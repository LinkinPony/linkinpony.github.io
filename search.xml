<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>[题解]CF1350C-Orac and LCM</title>
    <url>/2020/05/13/solution-CF1350C/</url>
    <content><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>​        给定集合${a_1,a_2,…,a_n}$,求$gcd({lcm({a_i,a_j})|i&lt;j})$  </p>
<p>​        $2 \leq n \leq 1e5 $ , $1 \leq a_i \leq 2e5$</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>​        考虑唯一分解定理:</p>
<p>​                $a = \prod^{n}_{1}p_i^{k_i}$ </p>
<p>​                $b = \prod^{n}_{1}p_i^{g_i}$</p>
<p>​        对于 $gcd$ 和 $lcm$ ,我们有:</p>
<p>​                $gcd(a,b) = \prod^{n}_{1}p_i^{min(k_i,g_i)}$</p>
<p>​                $lcm(a,b) = \prod^{n}_{1}p_i^{max(k_i,g_i)}$</p>
<p>​        观察易得,对于答案中的每个质因子$p_i$,它的指数$k_i$为${a_1,…,a_n}$中 $p_i$ <strong>第二小</strong> 的指数$k$</p>
<p>​        我们预处理出$i$的所有质因数$p[i]$,将$a_i$分解,用$d[i][j]$表示$a_j$的质因子$i$的指数,排序后扫一遍$d[i]$即可得到答案</p>
<p>​        具体来说</p>
<script type="math/tex; mode=display">
ans *= \left\{
\begin{array}{lcl}
i^{d[i][0]}&& {d[i].size() == n-1} \\
i^{d[i][1]} && {d[i].size()  \geq n-1 }\\
1 && otherwise
\end{array}
\right.</script><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> raw[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="function">ll <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">	ll tans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(d == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	ll a = Pow(x,d/<span class="number">2</span>);</span><br><span class="line">	tans = a*a;</span><br><span class="line">	<span class="keyword">if</span>(d%<span class="number">2</span>)tans = tans*x; </span><br><span class="line">	<span class="keyword">return</span> tans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> n_prime[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;p[maxn],d[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;maxn;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!n_prime[i])&#123;</span><br><span class="line">			p[i].push_back(i); </span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = i*<span class="number">2</span>;j &lt; maxn;j += i)&#123;</span><br><span class="line">				n_prime[j] = <span class="number">1</span>;</span><br><span class="line">				p[j].push_back(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	n_prime[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	prime();</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)<span class="built_in">cin</span> &gt;&gt; raw[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> u = raw[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x:p[u])&#123;</span><br><span class="line">			<span class="keyword">int</span> yay = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(u%x == <span class="number">0</span>)&#123;</span><br><span class="line">				yay++;</span><br><span class="line">				u /= x;</span><br><span class="line">			&#125;</span><br><span class="line">			d[x].push_back(yay);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; maxn;i++)&#123;</span><br><span class="line">		sort(d[i].begin(),d[i].end());</span><br><span class="line">		<span class="keyword">if</span>(d[i].size() == n<span class="number">-1</span>)&#123;</span><br><span class="line">			ans *= Pow(i,d[i][<span class="number">0</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(d[i].size() &gt; n<span class="number">-1</span>)ans *= Pow(i,d[i][<span class="number">1</span>]); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>math-misc</title>
    <url>/2020/05/11/math-misc/</url>
    <content><![CDATA[<ul>
<li>本篇仅记录一些杂乱的知识点留作日后整理,更多是作Markdown和$L_{A}T^{E}X$的练习用</li>
</ul>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>[模板]计算几何</title>
    <url>/2020/05/09/template-geometry/</url>
    <content><![CDATA[<p><del>不存在的</del></p>
<h1 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h1><h2 id="起手式-待补充"><a href="#起手式-待补充" class="headerlink" title="起手式(待补充):"></a>起手式(待补充):</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> ld;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.14159265358979</span>; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">	ld x,y;</span><br><span class="line">	Point(ld x = <span class="number">0</span>,ld y = <span class="number">0</span>):x(x),y(y)&#123;&#125;</span><br><span class="line">	Point <span class="keyword">operator</span> + (Point B)&#123;<span class="keyword">return</span> Point(x+B.x,y+B.y);&#125;</span><br><span class="line">	Point <span class="keyword">operator</span> - (Point B)&#123;<span class="keyword">return</span> Point(x-B.x,y-B.y);&#125;</span><br><span class="line">	Point <span class="keyword">operator</span> * (ld w)&#123;<span class="keyword">return</span> Point(x*w,y*w);&#125;</span><br><span class="line">	Point <span class="keyword">operator</span> / (ld w)&#123;<span class="keyword">return</span> Point(x/w,y/w);&#125;</span><br><span class="line">	<span class="function">Point <span class="title">Rotate_90_clock</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> Point(y,-x);&#125;<span class="comment">//顺时针旋转90°</span></span><br><span class="line">	<span class="function">ld <span class="title">len2</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> x*x + y*y;&#125;<span class="comment">//长度的平方</span></span><br><span class="line">	<span class="function">ld <span class="title">len</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>(<span class="built_in">sqrt</span>(x*x + y*y));&#125;</span><br><span class="line">&#125;point[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span>&#123;</span></span><br><span class="line">	Point O;</span><br><span class="line">	ld R;</span><br><span class="line">	Circle(Point O = Point(<span class="number">0</span>,<span class="number">0</span>),ld R = <span class="number">0</span>):O(O),R(R)&#123;&#125;</span><br><span class="line">	<span class="function">ld <span class="title">R2</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> R*R;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"><span class="function">ld <span class="title">Dot</span><span class="params">(Vector A,Vector B)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> A.x*B.x + A.y*B.y;</span><br><span class="line">&#125;<span class="comment">//点积</span></span><br><span class="line"><span class="function">ld <span class="title">Cross</span><span class="params">(Vector A,Vector B)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> A.x*B.y - A.y*B.x;</span><br><span class="line">&#125;<span class="comment">//二维叉积</span></span><br><span class="line"><span class="function">Point <span class="title">Line_inter</span><span class="params">(Point P0,Point V0,Point P1,Point V1)</span></span>&#123;</span><br><span class="line">	ld t = Cross(P1 - P0,V1)/Cross(V0,V1);</span><br><span class="line">	<span class="keyword">return</span> P0 + V0 * t;</span><br><span class="line">&#125;<span class="comment">//返回两向量交点.P和V分别为向量起点终点*</span></span><br><span class="line"><span class="function">Circle <span class="title">p2circle</span><span class="params">(Point A,Point B)</span></span>&#123;</span><br><span class="line">	Circle tans = Circle((A+B)/<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	tans.R = (tans.O - A).len();</span><br><span class="line">	<span class="keyword">return</span> tans;</span><br><span class="line">&#125;<span class="comment">//两点的外接圆</span></span><br><span class="line"><span class="function">Circle <span class="title">p2circle</span><span class="params">(Point A,Point B,Point C)</span></span>&#123;</span><br><span class="line">	Circle tans = Circle(Line_inter((A+B)/<span class="number">2</span>,(B - A).Rotate_90_clock(),(A+C)/<span class="number">2</span>,(C - A).Rotate_90_clock()),<span class="number">0</span>);</span><br><span class="line">	tans.R = (tans.O - A).len();</span><br><span class="line">	<span class="keyword">return</span> tans;</span><br><span class="line">&#125;<span class="comment">//三点共圆</span></span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">to_rad</span><span class="params">(<span class="keyword">double</span> deg)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> deg*(PI/<span class="number">180</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Vector <span class="title">Rotate</span><span class="params">(Vector A,<span class="keyword">double</span> rad)</span></span>&#123;<span class="comment">//逆时针 </span></span><br><span class="line">	<span class="keyword">return</span> Vector(A.x*<span class="built_in">cos</span>(rad) - A.y*<span class="built_in">sin</span>(rad),A.x*<span class="built_in">sin</span>(rad) + A.y*<span class="built_in">cos</span>(rad));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="凸包"><a href="#凸包" class="headerlink" title="凸包:"></a>凸包:</h2><p>输入顶点个数,返回凸包上点的个数.raw为原顶点数组,hull为凸包顶点数组</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ConvexHull</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	sort(raw+<span class="number">1</span>,raw+n+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> idx = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(idx &gt; <span class="number">2</span> <span class="keyword">and</span> Cross(hull[idx<span class="number">-1</span>] - hull[idx<span class="number">-2</span>],raw[i] - hull[idx<span class="number">-2</span>]) &lt;= <span class="number">0</span>)idx--;</span><br><span class="line">		hull[idx++] = raw[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> k = idx;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>;i &gt;= <span class="number">1</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">while</span>(idx &gt; k <span class="keyword">and</span> Cross(hull[idx<span class="number">-1</span>] - hull[idx<span class="number">-2</span>],raw[i] - hull[idx<span class="number">-2</span>]) &lt;= <span class="number">0</span>)idx--;</span><br><span class="line">		hull[idx++] = raw[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> idx<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多边形面积"><a href="#多边形面积" class="headerlink" title="多边形面积:"></a>多边形面积:</h2><p>_Point为多边形点集,n为顶点数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">PolyArea</span><span class="params">(Point * _Point,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> area = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; n;i++)&#123;</span><br><span class="line">		area += Cross(_Point[i] - _Point[<span class="number">1</span>],_Point[i+<span class="number">1</span>] - _Point[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> area/<span class="number">2</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最小圆覆盖"><a href="#最小圆覆盖" class="headerlink" title="最小圆覆盖"></a>最小圆覆盖</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> ld;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">	ld x,y;</span><br><span class="line">	Point(ld x = <span class="number">0</span>,ld y = <span class="number">0</span>):x(x),y(y)&#123;&#125;</span><br><span class="line">	Point <span class="keyword">operator</span> + (Point B)&#123;<span class="keyword">return</span> Point(x+B.x,y+B.y);&#125;</span><br><span class="line">	Point <span class="keyword">operator</span> - (Point B)&#123;<span class="keyword">return</span> Point(x-B.x,y-B.y);&#125;</span><br><span class="line">	Point <span class="keyword">operator</span> * (ld w)&#123;<span class="keyword">return</span> Point(x*w,y*w);&#125;</span><br><span class="line">	Point <span class="keyword">operator</span> / (ld w)&#123;<span class="keyword">return</span> Point(x/w,y/w);&#125;</span><br><span class="line">	<span class="function">Point <span class="title">Rotate_90_clock</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> Point(y,-x);&#125;<span class="comment">//顺时针旋转90°</span></span><br><span class="line">	<span class="function">ld <span class="title">len2</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> x*x + y*y;&#125;<span class="comment">//长度的平方</span></span><br><span class="line">	<span class="function">ld <span class="title">len</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>(<span class="built_in">sqrt</span>(x*x + y*y));&#125;</span><br><span class="line">&#125;point[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span>&#123;</span></span><br><span class="line">	Point O;</span><br><span class="line">	ld R;</span><br><span class="line">	Circle(Point O = Point(<span class="number">0</span>,<span class="number">0</span>),ld R = <span class="number">0</span>):O(O),R(R)&#123;&#125;</span><br><span class="line">	<span class="function">ld <span class="title">R2</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> R*R;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"><span class="function">ld <span class="title">Dot</span><span class="params">(Vector A,Vector B)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> A.x*B.x + A.y*B.y;</span><br><span class="line">&#125;<span class="comment">//点积</span></span><br><span class="line"><span class="function">ld <span class="title">Cross</span><span class="params">(Vector A,Vector B)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> A.x*B.y - A.y*B.x;</span><br><span class="line">&#125;<span class="comment">//二维叉积</span></span><br><span class="line"><span class="function">Point <span class="title">Line_inter</span><span class="params">(Point P0,Point V0,Point P1,Point V1)</span></span>&#123;</span><br><span class="line">	ld t = Cross(P1 - P0,V1)/Cross(V0,V1);</span><br><span class="line">	<span class="keyword">return</span> P0 + V0 * t;</span><br><span class="line">&#125;<span class="comment">//返回两向量交点.P和V分别为向量起点终点*</span></span><br><span class="line"><span class="function">Circle <span class="title">p2circle</span><span class="params">(Point A,Point B)</span></span>&#123;</span><br><span class="line">	Circle tans = Circle((A+B)/<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	tans.R = (tans.O - A).len();</span><br><span class="line">	<span class="keyword">return</span> tans;</span><br><span class="line">&#125;<span class="comment">//两点的外接圆</span></span><br><span class="line"><span class="function">Circle <span class="title">p2circle</span><span class="params">(Point A,Point B,Point C)</span></span>&#123;</span><br><span class="line">	Circle tans = Circle(Line_inter((A+B)/<span class="number">2</span>,(B - A).Rotate_90_clock(),(A+C)/<span class="number">2</span>,(C - A).Rotate_90_clock()),<span class="number">0</span>);</span><br><span class="line">	tans.R = (tans.O - A).len();</span><br><span class="line">	<span class="keyword">return</span> tans;</span><br><span class="line">&#125;<span class="comment">//三点共圆</span></span><br><span class="line"><span class="function">Circle <span class="title">Min_Cir_Cover</span><span class="params">(Point * point,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	random_shuffle(point+<span class="number">1</span>,point+n+<span class="number">1</span>);</span><br><span class="line">	Circle res;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>((point[i] - res.O).len2() &gt; res.R2())&#123;</span><br><span class="line">			res = Circle(point[i],<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; i;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>((point[j] - res.O).len2() &gt; res.R2())&#123;</span><br><span class="line">					res = p2circle(point[i],point[j]);</span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt; j;k++)&#123;</span><br><span class="line">						<span class="keyword">if</span>((point[k] - res.O).len2() &gt; res.R2())&#123;</span><br><span class="line">							res = p2circle(point[i],point[j],point[k]);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;<span class="comment">//最小圆覆盖,输入点集数组和点的数量,返回一个圆</span></span><br></pre></td></tr></table></figure>
<h1 id="三维"><a href="#三维" class="headerlink" title="三维"></a>三维</h1><h2 id="起手式"><a href="#起手式" class="headerlink" title="起手式:"></a>起手式:</h2><p>鸽子biss</p>
<h2 id="最小球覆盖"><a href="#最小球覆盖" class="headerlink" title="最小球覆盖"></a>最小球覆盖</h2><p>来自上交红书《ACM国际大学生程序设计竞赛-算法与实现》</p>
<p><strong>下标从0开始</strong></p>
<p>复杂度: $O(n)$</p>
<p>输入: </p>
<p>​    <code>npoint</code> 全局变量, 点的个数</p>
<p>​    <code>pt</code> 全局变量, 点的坐标</p>
<p>调用 <code>smallest_ball()</code></p>
<p>输出:</p>
<p>​    <code>res</code> 全局变量, 球心坐标</p>
<p>​    <code>radius</code> 全局变量, 球的半径</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">double</span> eps = <span class="number">1e-9</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tpoint</span>&#123;</span></span><br><span class="line">	<span class="keyword">double</span> x,y,z;</span><br><span class="line">	Tpoint(<span class="keyword">double</span> x = <span class="number">0</span>,<span class="keyword">double</span> y = <span class="number">0</span>,<span class="keyword">double</span> z = <span class="number">0</span>):x(x),y(y),z(z)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> npoint,nouter;</span><br><span class="line">Tpoint pt[maxn],outer[<span class="number">4</span>],res;</span><br><span class="line"><span class="keyword">double</span> radius,tmp;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">dist</span><span class="params">(Tpoint p1,Tpoint p2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> dx = p1.x - p2.x,dy = p1.y - p2.y,dz = p1.z - p2.z;</span><br><span class="line">	<span class="keyword">return</span> (dx*dx + dy*dy + dz*dz);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">dot</span><span class="params">(Tpoint p1,Tpoint p2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> p1.x*p2.x + p1.y*p2.y + p1.z*p2.z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ball</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Tpoint q[<span class="number">3</span>];<span class="keyword">double</span> m[<span class="number">3</span>][<span class="number">3</span>], sol[<span class="number">3</span>],L[<span class="number">3</span>],det;</span><br><span class="line">	res.x = res.y = res.z = radius = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">switch</span>(nouter)&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>: res = outer[<span class="number">0</span>];<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			res.x = (outer[<span class="number">0</span>].x+outer[<span class="number">1</span>].x)/<span class="number">2</span>;</span><br><span class="line">			res.y = (outer[<span class="number">0</span>].y+outer[<span class="number">1</span>].y)/<span class="number">2</span>;</span><br><span class="line">			res.z = (outer[<span class="number">0</span>].z+outer[<span class="number">1</span>].z)/<span class="number">2</span>;</span><br><span class="line">			radius = dist(res,outer[<span class="number">0</span>]);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">2</span>;i++)&#123;</span><br><span class="line">				q[i].x = outer[i+<span class="number">1</span>].x - outer[<span class="number">0</span>].x;</span><br><span class="line">				q[i].y = outer[i+<span class="number">1</span>].y - outer[<span class="number">0</span>].y;</span><br><span class="line">				q[i].z = outer[i+<span class="number">1</span>].z - outer[<span class="number">0</span>].z;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">2</span>;i++)</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">2</span>;j++)m[i][j] = dot(q[i],q[j])*<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">2</span>;i++)sol[i] = dot(q[i],q[i]);</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">fabs</span>(det = m[<span class="number">0</span>][<span class="number">0</span>]*m[<span class="number">1</span>][<span class="number">1</span>] - m[<span class="number">0</span>][<span class="number">1</span>]*m[<span class="number">1</span>][<span class="number">0</span>])&lt;eps)<span class="keyword">return</span>;</span><br><span class="line">			L[<span class="number">0</span>] = (sol[<span class="number">0</span>]*m[<span class="number">1</span>][<span class="number">1</span>] - sol[<span class="number">1</span>]*m[<span class="number">0</span>][<span class="number">1</span>])/det;</span><br><span class="line">			L[<span class="number">1</span>] = (sol[<span class="number">1</span>]*m[<span class="number">0</span>][<span class="number">0</span>] - sol[<span class="number">0</span>]*m[<span class="number">1</span>][<span class="number">0</span>])/det;</span><br><span class="line">			res.x = outer[<span class="number">0</span>].x + q[<span class="number">0</span>].x*L[<span class="number">0</span>] + q[<span class="number">1</span>].x*L[<span class="number">1</span>];</span><br><span class="line">			res.y = outer[<span class="number">0</span>].y + q[<span class="number">0</span>].y*L[<span class="number">0</span>] + q[<span class="number">1</span>].y*L[<span class="number">1</span>];</span><br><span class="line">			res.z = outer[<span class="number">0</span>].z + q[<span class="number">0</span>].z*L[<span class="number">0</span>] + q[<span class="number">1</span>].z*L[<span class="number">1</span>];</span><br><span class="line">			radius = dist(res,outer[<span class="number">0</span>]);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)&#123;</span><br><span class="line">				q[i].x = outer[i+<span class="number">1</span>].x - outer[<span class="number">0</span>].x;</span><br><span class="line">				q[i].y = outer[i+<span class="number">1</span>].y - outer[<span class="number">0</span>].y;</span><br><span class="line">				q[i].z = outer[i+<span class="number">1</span>].z - outer[<span class="number">0</span>].z;</span><br><span class="line">				sol[i] = dot(q[i],q[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++)m[i][j] = dot(q[i],q[j])*<span class="number">2</span>;</span><br><span class="line">			det = m[<span class="number">0</span>][<span class="number">0</span>] * m[<span class="number">1</span>][<span class="number">1</span>] * m[<span class="number">2</span>][<span class="number">2</span>]</span><br><span class="line">				+ m[<span class="number">0</span>][<span class="number">1</span>] * m[<span class="number">1</span>][<span class="number">2</span>] * m[<span class="number">2</span>][<span class="number">0</span>]</span><br><span class="line">				+ m[<span class="number">0</span>][<span class="number">2</span>] * m[<span class="number">2</span>][<span class="number">1</span>] * m[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">				- m[<span class="number">0</span>][<span class="number">2</span>] * m[<span class="number">1</span>][<span class="number">1</span>] * m[<span class="number">2</span>][<span class="number">0</span>]</span><br><span class="line">				- m[<span class="number">0</span>][<span class="number">1</span>] * m[<span class="number">1</span>][<span class="number">0</span>] * m[<span class="number">2</span>][<span class="number">2</span>]</span><br><span class="line">				- m[<span class="number">0</span>][<span class="number">0</span>] * m[<span class="number">1</span>][<span class="number">2</span>] * m[<span class="number">2</span>][<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">fabs</span>(det) &lt; eps)<span class="keyword">return</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++)&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)m[i][j] = sol[i];</span><br><span class="line">				L[j] = (m[<span class="number">0</span>][<span class="number">0</span>] * m[<span class="number">1</span>][<span class="number">1</span>] * m[<span class="number">2</span>][<span class="number">2</span>]</span><br><span class="line">					+ m[<span class="number">0</span>][<span class="number">1</span>] * m[<span class="number">1</span>][<span class="number">2</span>] * m[<span class="number">2</span>][<span class="number">0</span>]</span><br><span class="line">					+ m[<span class="number">0</span>][<span class="number">2</span>] * m[<span class="number">2</span>][<span class="number">1</span>] * m[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">					- m[<span class="number">0</span>][<span class="number">2</span>] * m[<span class="number">1</span>][<span class="number">1</span>] * m[<span class="number">2</span>][<span class="number">0</span>]</span><br><span class="line">					- m[<span class="number">0</span>][<span class="number">1</span>] * m[<span class="number">1</span>][<span class="number">0</span>] * m[<span class="number">2</span>][<span class="number">2</span>]</span><br><span class="line">					- m[<span class="number">0</span>][<span class="number">0</span>] * m[<span class="number">1</span>][<span class="number">2</span>] * m[<span class="number">2</span>][<span class="number">1</span>]</span><br><span class="line">					)/det;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)m[i][j] = dot(q[i],q[j])*<span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			res = outer[<span class="number">0</span>];</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)&#123;</span><br><span class="line">				res.x += q[i].x * L[i];</span><br><span class="line">				res.y += q[i].y * L[i];</span><br><span class="line">				res.z += q[i].z * L[i];</span><br><span class="line">			&#125;</span><br><span class="line">			radius = dist(res,outer[<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minball</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	ball();</span><br><span class="line">	<span class="keyword">if</span>(nouter &lt; <span class="number">4</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(dist(res,pt[i]) - radius &gt; eps)&#123;</span><br><span class="line">				outer[nouter] = pt[i];</span><br><span class="line">				++nouter;</span><br><span class="line">				minball(i);</span><br><span class="line">				--nouter;</span><br><span class="line">				<span class="keyword">if</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">					Tpoint Tt = pt[i];</span><br><span class="line">					memmove(&amp;pt[<span class="number">1</span>],&amp;pt[<span class="number">0</span>],<span class="keyword">sizeof</span>(Tpoint)*i);</span><br><span class="line">					pt[<span class="number">0</span>] = Tt;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">smallest_ball</span><span class="params">()</span></span>&#123;</span><br><span class="line">	radius = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; npoint;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(dist(res,pt[i]) - radius &gt; eps)&#123;</span><br><span class="line">			nouter = <span class="number">1</span>;</span><br><span class="line">			outer[<span class="number">0</span>] = pt[i];</span><br><span class="line">			minball(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>(radius);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; npoint;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; npoint;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x,y,z;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">		pt[i] = Tpoint(x,y,z);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%.10lf"</span>,smallest_ball());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>[模板]数学</title>
    <url>/2020/05/09/template-math/</url>
    <content><![CDATA[<p>212370440130137957</p>
<p>(↑这是一个很大的质数)</p>
<p>19260817</p>
<p>(↑这是一颗很大的子弹)</p>
<p><strong>判断同余时用</strong>$(a - b) \mod m== 0$</p>
<p>cout不使用科学计数法输出，设置精度:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span>.setf(ios::fixed,ios::floatfield);</span><br><span class="line"><span class="built_in">cout</span>.precision(<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><h2 id="大整数"><a href="#大整数" class="headerlink" title="大整数"></a>大整数</h2><p>(我也不知道从哪copy)的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bign</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> d[maxn], len;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clean</span><span class="params">()</span> </span>&#123; <span class="keyword">while</span>(len &gt; <span class="number">1</span> &amp;&amp; !d[len<span class="number">-1</span>]) len--; &#125;</span><br><span class="line"> </span><br><span class="line">    bign() 			&#123; <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d)); len = <span class="number">1</span>; &#125;</span><br><span class="line">    bign(<span class="keyword">int</span> num) 	&#123; *<span class="keyword">this</span> = num; &#125; </span><br><span class="line">	bign(<span class="keyword">char</span>* num) &#123; *<span class="keyword">this</span> = num; &#125;</span><br><span class="line">    bign <span class="keyword">operator</span> = (<span class="keyword">const</span> <span class="keyword">char</span>* num)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d)); len = <span class="built_in">strlen</span>(num);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) d[i] = num[len<span class="number">-1</span>-i] - <span class="string">'0'</span>;</span><br><span class="line">        clean();</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bign <span class="keyword">operator</span> = (<span class="keyword">int</span> num)&#123;</span><br><span class="line">        <span class="keyword">char</span> s[<span class="number">20</span>]; <span class="built_in">sprintf</span>(s, <span class="string">"%d"</span>, num);</span><br><span class="line">        *<span class="keyword">this</span> = s;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    bign <span class="keyword">operator</span> + (<span class="keyword">const</span> bign&amp; b)&#123;</span><br><span class="line">        bign c = *<span class="keyword">this</span>; <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; b.len; i++)&#123;</span><br><span class="line">        	c.d[i] += b.d[i];</span><br><span class="line">        	<span class="keyword">if</span> (c.d[i] &gt; <span class="number">9</span>) c.d[i]%=<span class="number">10</span>, c.d[i+<span class="number">1</span>]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (c.d[i] &gt; <span class="number">9</span>) c.d[i++]%=<span class="number">10</span>, c.d[i]++;</span><br><span class="line">		c.len = max(len, b.len);</span><br><span class="line">		<span class="keyword">if</span> (c.d[i] &amp;&amp; c.len &lt;= i) c.len = i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    bign <span class="keyword">operator</span> - (<span class="keyword">const</span> bign&amp; b)&#123;</span><br><span class="line">        bign c = *<span class="keyword">this</span>; <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; b.len; i++)&#123;</span><br><span class="line">        	c.d[i] -= b.d[i];</span><br><span class="line">        	<span class="keyword">if</span> (c.d[i] &lt; <span class="number">0</span>) c.d[i]+=<span class="number">10</span>, c.d[i+<span class="number">1</span>]--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (c.d[i] &lt; <span class="number">0</span>) c.d[i++]+=<span class="number">10</span>, c.d[i]--;</span><br><span class="line">		c.clean();</span><br><span class="line">		<span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    bign <span class="keyword">operator</span> * (<span class="keyword">const</span> bign&amp; b)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j; bign c; c.len = len + b.len; </span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; b.len; j++) <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++) </span><br><span class="line">			c.d[i+j] += d[i] * b.d[j];</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; c.len<span class="number">-1</span>; i++)</span><br><span class="line">            c.d[i+<span class="number">1</span>] += c.d[i]/<span class="number">10</span>, c.d[i] %= <span class="number">10</span>;</span><br><span class="line">        c.clean();</span><br><span class="line">		<span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    bign <span class="keyword">operator</span> / (<span class="keyword">const</span> bign&amp; b)&#123;</span><br><span class="line">    	<span class="keyword">int</span> i, j;</span><br><span class="line">		bign c = *<span class="keyword">this</span>, a = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">for</span> (i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    	&#123;</span><br><span class="line">    		a = a*<span class="number">10</span> + d[i];</span><br><span class="line">    		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) <span class="keyword">if</span> (a &lt; b*(j+<span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line">    		c.d[i] = j;</span><br><span class="line">    		a = a - b*j;</span><br><span class="line">    	&#125;</span><br><span class="line">    	c.clean();</span><br><span class="line">    	<span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    bign <span class="keyword">operator</span> % (<span class="keyword">const</span> bign&amp; b)&#123;</span><br><span class="line">    	<span class="keyword">int</span> i, j;</span><br><span class="line">		bign a = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">for</span> (i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    	&#123;</span><br><span class="line">    		a = a*<span class="number">10</span> + d[i];</span><br><span class="line">    		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) <span class="keyword">if</span> (a &lt; b*(j+<span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line">    		a = a - b*j;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">	bign <span class="keyword">operator</span> += (<span class="keyword">const</span> bign&amp; b)&#123;</span><br><span class="line">        *<span class="keyword">this</span> = *<span class="keyword">this</span> + b;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> bign&amp; b) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len != b.len) <span class="keyword">return</span> len &lt; b.len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span>(d[i] != b.d[i]) <span class="keyword">return</span> d[i] &lt; b.d[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt;(<span class="keyword">const</span> bign&amp; b) <span class="keyword">const</span>&#123;<span class="keyword">return</span> b &lt; *<span class="keyword">this</span>;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> bign&amp; b) <span class="keyword">const</span>&#123;<span class="keyword">return</span> !(b &lt; *<span class="keyword">this</span>);&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> bign&amp; b) <span class="keyword">const</span>&#123;<span class="keyword">return</span> !(*<span class="keyword">this</span> &lt; b);&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> bign&amp; b) <span class="keyword">const</span>&#123;<span class="keyword">return</span> b &lt; *<span class="keyword">this</span> || *<span class="keyword">this</span> &lt; b;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> bign&amp; b) <span class="keyword">const</span>&#123;<span class="keyword">return</span> !(b &lt; *<span class="keyword">this</span>) &amp;&amp; !(b &gt; *<span class="keyword">this</span>);&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> s[maxn]=&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) s[len<span class="number">-1</span>-i] = d[i]+<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">istream&amp; <span class="keyword">operator</span> &gt;&gt; (istream&amp; in, bign&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    in &gt;&gt; s;</span><br><span class="line">    x = s.c_str();</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; out, <span class="keyword">const</span> bign&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; x.str();</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用例:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">bign <span class="title">GCD</span><span class="params">(bign a,bign b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// cout&lt;&lt;"@@@ "&lt;&lt;a&lt;&lt;endl&lt;&lt;"### "&lt;&lt;b&lt;&lt;endl;;</span></span><br><span class="line">	bign k=<span class="number">0</span>,c;</span><br><span class="line">	<span class="keyword">while</span>(b&gt;k)</span><br><span class="line">	&#123;</span><br><span class="line">		c=a%b;</span><br><span class="line">		a=b;</span><br><span class="line">		b=c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">110</span>];</span><br><span class="line"><span class="built_in">vector</span> &lt;bign&gt; prime;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetPrime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">2</span>;;i+=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> j=<span class="number">2</span>;j&lt;i;j+=<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">if</span>(i%j==<span class="number">0</span>) flag=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(flag)</span><br><span class="line">		&#123;</span><br><span class="line">			bign k=i;</span><br><span class="line">			prime.push_back(k);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>((<span class="keyword">int</span>)prime.size()&gt;<span class="number">100</span>) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">	GetPrime();</span><br><span class="line">	<span class="keyword">while</span>(T--)</span><br><span class="line">	&#123;</span><br><span class="line">		bign n;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">		bign a=<span class="number">1</span>,b=<span class="number">1</span>,k=<span class="number">1</span>,sum=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> pos=<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(sum*prime[i]&lt;=n) sum=sum*prime[i],pos=i;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=pos;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			</span><br><span class="line">			b=b*prime[i];</span><br><span class="line">			a=a*(prime[i]+k);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// cout&lt;&lt;"@@@ "&lt;&lt;s&lt;&lt;endl;</span></span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		bign s=GCD(a,b);</span><br><span class="line">		b=b/s,a=a/s;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="string">"/"</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="随机数发生器"><a href="#随机数发生器" class="headerlink" title="随机数发生器"></a>随机数发生器</h2><p>注意不要用Windows下的$rand()$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mt19937 Rand(seed);</span><br><span class="line">Rand();&#x2F;&#x2F;返回一个随机数</span><br></pre></td></tr></table></figure>
<h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>计算$x^d \mod p$</p>
<p>注意$a^b % p = ((a % p)^b) % p$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">Pow</span><span class="params">(ll x,ll d)</span></span>&#123;</span><br><span class="line">	ll tans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(d == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>%p;</span><br><span class="line">	ll a = Pow(x,d/<span class="number">2</span>);</span><br><span class="line">	tans = a*a%p;</span><br><span class="line">	<span class="keyword">if</span>(d%<span class="number">2</span>)tans = tans*x%p; </span><br><span class="line">	<span class="keyword">return</span> tans%p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a,LL b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        LL tmp=b;</span><br><span class="line">        b=a%b;</span><br><span class="line">        a=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="GCD-amp-exGCD"><a href="#GCD-amp-exGCD" class="headerlink" title="GCD &amp; exGCD"></a>GCD &amp; exGCD</h2><p>x,y,d为全局变量.求x和y使得 $ax + by = d$ 且 $|x| + |y|$最小.</p>
<p>其中 $d = gcd(a,b)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b?gcd(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gcd</span><span class="params">(ll a,ll b,ll &amp; d,ll &amp; x,ll &amp; y)</span></span>&#123;</span><br><span class="line">	<span class="comment">//notice d = gcd(a,b)</span></span><br><span class="line">	<span class="keyword">if</span>(!b)d = a,x = <span class="number">1</span>,y = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		gcd(b,a%b,d,y,x);</span><br><span class="line">		y -= x*(a/b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h2><p>返回模p下a的逆.不存在则返回-1.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a,ll p)</span></span>&#123;</span><br><span class="line">	ll d,x,y;</span><br><span class="line">	gcd(a,p,d,x,y);</span><br><span class="line">	<span class="keyword">return</span> d == <span class="number">1</span>?(x+p)%p:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线性筛逆元"><a href="#线性筛逆元" class="headerlink" title="线性筛逆元:"></a>线性筛逆元:</h3><p>返回模p下1…n的逆.保存在invs里</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_inv</span><span class="params">()</span></span>&#123;</span><br><span class="line">	invs[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		invs[i] = (ll)(p - p/i)*invs[p%i]%p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="a-b不互质时"><a href="#a-b不互质时" class="headerlink" title="a,b不互质时"></a>a,b不互质时</h2><script type="math/tex; mode=display">
\frac{a}{b} \mod m = \frac{a \mod (mb)}{b}</script><p>证:</p>
<script type="math/tex; mode=display">
\begin{align}
&\frac{a}{b} = km + x (x < m)\\
\Rightarrow \space &a =kbm + bx\\
\Rightarrow \space &a \mod (bm) = bx\\
\Rightarrow \space &\frac{a \mod (bm)}{b} = x\\
\Rightarrow \space &\frac{a \mod (bm)}{b} = \frac{a}{b} \mod m
\end{align}</script><h2 id="中国剩余定理-CRT"><a href="#中国剩余定理-CRT" class="headerlink" title="中国剩余定理(CRT)"></a>中国剩余定理(CRT)</h2><p>求同余方程组</p>
<script type="math/tex; mode=display">
\begin{cases} x &\equiv a_1 \pmod {m_1} \\ x &\equiv a_2 \pmod {m_2} \\ &\vdots \\ x &\equiv a_k \pmod {m_k} \\ \end{cases}</script><p>在$[0,\prod_{i = 1}^nm_i])$中的解. 要求任意$m_i$两两互质</p>
<p>输入: <code>int n</code> 方程组个数, <code>ll a[] ll m[]</code>,方程组的参数和模数</p>
<p>复杂度:$O(nlogM)$, 其中$M$与$m_i$同阶</p>
<p>输出: 方程组在$[0,\prod_{i = 1}^nm_i])$中的解.</p>
<p>前置: 逆元</p>
<p>调用 <code>CRT(n,a,m)</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">CRT</span><span class="params">(<span class="keyword">int</span> n,ll * a,ll * m)</span></span>&#123;</span><br><span class="line">	ll M = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)M *= m[i];</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		ll mt = M/m[i];</span><br><span class="line">		ll ret = inv(mt,m[i]);</span><br><span class="line">		ans = (ans + a[i]*mt%M*ret%M)%M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (ans + M)%M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Eratosthenes筛"><a href="#Eratosthenes筛" class="headerlink" title="Eratosthenes筛"></a>Eratosthenes筛</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!n_prime[i])&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = i*<span class="number">2</span>;j &lt;= n;j += i)n_prime[j] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	n_prime[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h2><h3 id="线性筛素数以及-varphi"><a href="#线性筛素数以及-varphi" class="headerlink" title="线性筛素数以及$\varphi$"></a>线性筛素数以及$\varphi$</h3><p>(大多数线性筛都要筛素数)</p>
<p>phi[n]为$\varphi(n)$,prime里存的素数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> phi[maxn];</span><br><span class="line"><span class="keyword">bool</span> not_p[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;prime;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eular_sieve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	not_p[<span class="number">1</span>] = phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!not_p[i])&#123;</span><br><span class="line">			phi[i] = i<span class="number">-1</span>;</span><br><span class="line">			prime.push_back(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> p:prime)&#123;</span><br><span class="line">			<span class="keyword">if</span>((ll)p*i &gt;= n)<span class="keyword">break</span>;</span><br><span class="line">			not_p[p*i] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%p)phi[i*p] = phi[i]*(p<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				phi[i*p] = phi[i]*p;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线性筛-mu"><a href="#线性筛-mu" class="headerlink" title="线性筛$\mu$"></a>线性筛$\mu$</h3><script type="math/tex; mode=display">
\mu(n)= \begin{cases} 1&n=1\\ 0&n\text{ 含有平方因子}\\ (-1)^k&k\text{ 为 }n\text{ 的本质不同质因子个数}\\ \end{cases}</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> phi[maxn],mu[maxn];</span><br><span class="line"><span class="keyword">bool</span> not_p[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;prime;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve_mu</span><span class="params">()</span></span>&#123;</span><br><span class="line">	not_p[<span class="number">1</span>] = mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; maxn;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!not_p[i])&#123;</span><br><span class="line">			mu[i] = <span class="number">-1</span>;</span><br><span class="line">			prime.push_back(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> p:prime)&#123;</span><br><span class="line">			<span class="keyword">if</span>(ll(p)*i &gt;= maxn)<span class="keyword">break</span>;</span><br><span class="line">			not_p[p*i] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%p)mu[i*p] = -mu[i];</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				mu[i*p] = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="杜教筛"><a href="#杜教筛" class="headerlink" title="杜教筛"></a>杜教筛</h2><p>详细请见杜教筛笔记.</p>
<p>杜教筛快速筛$\varphi$和$\mu$的前缀和.$maxn = n^{\frac{2}{3}}$时复杂度为$O(n^{\frac{2}{3}})$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1664510</span>;</span><br><span class="line"><span class="keyword">bool</span> not_p[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;prime;</span><br><span class="line">ll mu[maxn],phi[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	phi[<span class="number">1</span>] = mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; maxn;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!not_p[i])&#123;</span><br><span class="line">			mu[i] = <span class="number">-1</span>;</span><br><span class="line">			phi[i] = i<span class="number">-1</span>;</span><br><span class="line">			prime.push_back(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> p:prime)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="number">1L</span>L*p*i &gt;= maxn)<span class="keyword">break</span>;</span><br><span class="line">			not_p[i*p] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%p)&#123;</span><br><span class="line">				phi[i*p] = phi[i]*(p<span class="number">-1</span>);</span><br><span class="line">				mu[i*p] = -mu[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				phi[i*p] = phi[i]*p;</span><br><span class="line">				mu[i*p] = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; maxn;i++)mu[i] += mu[i<span class="number">-1</span>],phi[i] += phi[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,ll&gt;Mu,Phi;</span><br><span class="line"><span class="function">ll <span class="title">du_mu</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x &lt; maxn)<span class="keyword">return</span> mu[x];</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(Mu[x])<span class="keyword">return</span> Mu[x];</span><br><span class="line">	ll tans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">2</span>,r = <span class="number">0</span>;l &lt;= x;l = r+<span class="number">1</span>)&#123;</span><br><span class="line">		r = x/(x/l);</span><br><span class="line">		tans -= <span class="number">1L</span>L*(r - l + <span class="number">1</span>)*du_mu(x/l);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Mu[x] = tans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">du_phi</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x &lt; maxn)<span class="keyword">return</span> phi[x];</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(Phi[x])<span class="keyword">return</span> Phi[x];</span><br><span class="line">	ll tans = <span class="number">1L</span>L*x*(x+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">2</span>,r = <span class="number">0</span>;l &lt;= x;l = r+<span class="number">1</span>)&#123;</span><br><span class="line">		r = x/(x/l);</span><br><span class="line">		tans -= <span class="number">1L</span>L*(r-l+<span class="number">1</span>)*du_phi(x/l);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Phi[x] = tans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="欧拉函数-φ-x"><a href="#欧拉函数-φ-x" class="headerlink" title="欧拉函数$φ(x)$"></a>欧拉函数$φ(x)$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">cal_phi</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m = (ll)<span class="built_in">sqrt</span>(x+<span class="number">0.5</span>);</span><br><span class="line">	ll tans = x;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= m;i++)<span class="keyword">if</span>(!(x%i))&#123;</span><br><span class="line">		tans = tans/i*(i<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">while</span>(!(x%i))x /= i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x &gt; <span class="number">1</span>)tans = tans / x * (x<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> tans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线性筛-φ-x"><a href="#线性筛-φ-x" class="headerlink" title="线性筛$φ(x)$"></a>线性筛$φ(x)$</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve_phi</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)<span class="keyword">if</span>(!phi[i])</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt;= n;j += i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!phi[j])phi[j] = j;</span><br><span class="line">			phi[j] = phi[j]/i * (i<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="有理数取模"><a href="#有理数取模" class="headerlink" title="有理数取模"></a>有理数取模</h2><p>求$a/b$ % $p$ （p为质数)</p>
<p>由费马小定理$b^{p-1} ≡ 1 \pmod p$ 可得 $b^{p-2} ≡ b^{-1} \pmod p$</p>
<p>故只需求$a*b^{p-2} \bmod p$</p>
<p>a,b过大则先膜一下</p>
<h2 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h2><p>若$a,p$互质,则有</p>
<p>$a^{φ(p)} ≡ 1 \pmod p$</p>
<h3 id="扩展欧拉定理-无需a-p互质"><a href="#扩展欧拉定理-无需a-p互质" class="headerlink" title="扩展欧拉定理(无需a,p互质)"></a>扩展欧拉定理(无需a,p互质)</h3><p>$b ≥ φ(p)$时:</p>
<p>$a^b ≡ a^{b \bmod φ(p) +φ(p)} \pmod p$</p>
<p>例题: 给出$w<em>1,w_2,..w_n$和$q$组询问$l \space r$. 求$w_l^{w</em>{l+1}^{…^{w_r}}} \pmod p$的值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CF906D </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line">ll raw[maxn],n,mod;</span><br><span class="line"><span class="built_in">map</span>&lt;ll,ll&gt;vis;</span><br><span class="line"><span class="function">ll <span class="title">phi</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m = (ll)<span class="built_in">sqrt</span>(x+<span class="number">0.5</span>);</span><br><span class="line">	ll tans = x;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= m;i++)<span class="keyword">if</span>(!(x%i))&#123;</span><br><span class="line">		tans = tans/i*(i<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">while</span>(!(x%i))x /= i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x &gt; <span class="number">1</span>)tans = tans / x * (x<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> tans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">upd</span><span class="params">(ll x,ll p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x&lt;p?x:x%p+p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">Pow</span><span class="params">(ll x,ll d,ll p)</span></span>&#123;</span><br><span class="line">	ll tans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(d == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	ll a = Pow(x,d/<span class="number">2</span>,p);</span><br><span class="line">	tans = upd(a*a,p);</span><br><span class="line">	<span class="keyword">if</span>(d%<span class="number">2</span>)tans = upd(tans*x,p); </span><br><span class="line">	<span class="keyword">return</span> upd(tans,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">cal</span><span class="params">(ll l,ll r,ll p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l == r <span class="keyword">or</span> p == <span class="number">1</span>)<span class="keyword">return</span> upd(raw[l],p);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> Pow(raw[l],cal(l+<span class="number">1</span>,r,vis[p]),p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; mod;</span><br><span class="line">	ll qwq = mod;</span><br><span class="line">	<span class="keyword">while</span>(qwq != <span class="number">1</span>)&#123;</span><br><span class="line">		vis[qwq] = phi(qwq);</span><br><span class="line">		qwq = vis[qwq];</span><br><span class="line">	&#125;</span><br><span class="line">	vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)<span class="built_in">cin</span> &gt;&gt; raw[i];</span><br><span class="line">	<span class="keyword">int</span> q;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">	<span class="keyword">while</span>(q--)&#123;</span><br><span class="line">		<span class="keyword">int</span> l,r;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; cal(l,r,mod)%mod &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="原根"><a href="#原根" class="headerlink" title="原根"></a>原根</h2><p><code>proot(p)</code> 返回素数p的原根</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;pri;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">g_test</span><span class="params">(ll g,ll p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(ll x:pri)&#123;</span><br><span class="line">		<span class="keyword">if</span>(Pow(g,(p<span class="number">-1</span>)/x,p) == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">proot</span><span class="params">(ll p)</span></span>&#123;</span><br><span class="line">	ll tmp = p<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(ll i = <span class="number">2</span>;i &lt;= tmp/i;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(tmp%i == <span class="number">0</span>)&#123;</span><br><span class="line">			pri.push_back(i);</span><br><span class="line">			<span class="keyword">while</span>(tmp%i == <span class="number">0</span>)tmp /= i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(tmp != <span class="number">1</span>)pri.push_back(tmp);</span><br><span class="line">	ll g = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(g_test(g,p))<span class="keyword">return</span> g;</span><br><span class="line">		g++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拉格朗日插值"><a href="#拉格朗日插值" class="headerlink" title="拉格朗日插值"></a>拉格朗日插值</h2><p>px,py为点坐标,p为模数,k是L(k)那个k<br>inv为逆元</p>
<p>返回L(k)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">lagrange</span><span class="params">(ll n,ll k)</span></span>&#123;</span><br><span class="line">	ll tans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		ll f = <span class="number">1</span>,g = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)<span class="keyword">if</span>(i != j)&#123;</span><br><span class="line">			f = f*(k - px[j]+p)%p;</span><br><span class="line">			g = g*(px[i] - px[j]+p)%p;</span><br><span class="line">		&#125;</span><br><span class="line">		ll lota = py[i]*f%p*inv(g,p)%p;</span><br><span class="line">		tans = (tans+lota)%p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tans; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线性求-sum-i-0-n-i-k"><a href="#线性求-sum-i-0-n-i-k" class="headerlink" title="线性求$\sum_{i = 0}^{n}i^k$"></a>线性求$\sum_{i = 0}^{n}i^k$</h3><p>(返回L(k)的值,多项式次数为n.按需更改yi的值,复杂度$O(n)$)</p>
<p>(注意求$\sum_{i = 0}^{n}i^k$需要调用line_lagrange(k+2,n) )</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">line_lagrange</span><span class="params">(ll n,ll k)</span></span>&#123;</span><br><span class="line">	ll tans = <span class="number">0</span>;</span><br><span class="line">	get_inv();</span><br><span class="line">	pre[<span class="number">0</span>] = suf[n+<span class="number">1</span>] = ifac[<span class="number">0</span>] =  <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		pre[i] = pre[i<span class="number">-1</span>]*(k-i)%mod;</span><br><span class="line">		ifac[i] = ifac[i<span class="number">-1</span>]*invs[i]%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n;i &gt;= <span class="number">0</span>;i--)suf[i] = suf[i+<span class="number">1</span>]*(k-i)%mod;</span><br><span class="line">	ll yi = <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		yi = (yi+pow_mod(i,n<span class="number">-2</span>))%mod;</span><br><span class="line">		ll a = pre[i<span class="number">-1</span>]*suf[i+<span class="number">1</span>]%mod*yi%mod*ifac[i<span class="number">-1</span>]%mod*ifac[n-i]%mod;</span><br><span class="line">		<span class="keyword">if</span>((n-i)%<span class="number">2</span>)a = mod-a; </span><br><span class="line">		tans = (tans+a+mod)%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="卢卡斯定理"><a href="#卢卡斯定理" class="headerlink" title="卢卡斯定理"></a>卢卡斯定理</h2><p>Lucas(n,m) = C(n%p,m%p)*Lucas(n/p,m/p)%p</p>
<p>p需为素数,fac[]为预处理的阶乘,时间复杂度大约是$O(p + mlogm)$(预处理需要$O(p)$)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n,ll m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(m &gt; n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> (fac[n]*Pow(fac[m],p<span class="number">-2</span>)%p*Pow(fac[n-m],p<span class="number">-2</span>)%p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">Lucas</span><span class="params">(ll n,ll m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!m)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> C(n%p,m%p)*Lucas(n/p,m/p)%p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="线性基"><a href="#线性基" class="headerlink" title="线性基"></a>线性基</h2><p>maxbit取值域位数</p>
<p>insert返回0则说明现有基可以表示x</p>
<p>qmax返回异或最大值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinerBasis</span>&#123;</span></span><br><span class="line">	ll base[maxbit+<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">bool</span> vis[maxbit+<span class="number">4</span>];</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = maxbit;~i;i--)&#123;</span><br><span class="line">			<span class="keyword">if</span>(x&amp;(<span class="number">1L</span>L&lt;&lt;i))&#123;</span><br><span class="line">				<span class="keyword">if</span>(!base[i])&#123;</span><br><span class="line">					base[i] = x;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> x ^= base[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">qmax</span><span class="params">()</span></span>&#123;</span><br><span class="line">		ll ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = maxbit;~i;i--)ans = max(ans,ans^base[i]);</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;yay;</span><br></pre></td></tr></table></figure>
<h1 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h1><h2 id="威佐夫游戏"><a href="#威佐夫游戏" class="headerlink" title="威佐夫游戏"></a>威佐夫游戏</h2><p>两人轮流取两堆筹码，其中取法有两种：取走一堆中任意个筹码，或从两堆中取走相同数目的筹码。取完所有筹码的一方获胜。</p>
<p>(1为先手胜)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(n1&gt;n2)  swap(n1,n2);</span><br><span class="line">temp&#x3D;floor((n2-n1)*(1+sqrt(5.0))&#x2F;2.0);</span><br><span class="line">if(temp&#x3D;&#x3D;n1) cout&lt;&lt;&quot;0&quot;&lt;&lt;endl;</span><br><span class="line">else cout&lt;&lt;&quot;1&quot;&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="定义-amp-快速幂"><a href="#定义-amp-快速幂" class="headerlink" title="定义&amp;快速幂"></a>定义&amp;快速幂</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,a,b) for(int i = a;i &lt;= b;i++)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Martix</span>&#123;</span></span><br><span class="line">	ll A[maxn][maxn];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">initer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)A[i][j] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)A[i][i] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Martix <span class="keyword">operator</span> * (<span class="keyword">const</span> Martix &amp; a)&#123;</span><br><span class="line">		Martix res;</span><br><span class="line">		<span class="built_in">memset</span>(res.A,<span class="number">0</span>,<span class="keyword">sizeof</span>(res.A));</span><br><span class="line">		FOR(k,<span class="number">1</span>,n)</span><br><span class="line">			FOR(i,<span class="number">1</span>,n)</span><br><span class="line">				FOR(j,<span class="number">1</span>,n)res.A[i][j] = (res.A[i][j] + (A[i][k]*a.A[k][j])%MOD)%MOD;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;martix,martixI;</span><br><span class="line"><span class="function">Martix <span class="title">martixPow</span><span class="params">(Martix x,ll p)</span></span>&#123;</span><br><span class="line">	Martix ans;</span><br><span class="line">	ans.initer();</span><br><span class="line">	<span class="keyword">while</span>(p)&#123;</span><br><span class="line">		<span class="keyword">if</span>(p%<span class="number">2</span>)ans = ans*x;</span><br><span class="line">		x = x*x;</span><br><span class="line">		p /= <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一些例题"><a href="#一些例题" class="headerlink" title="一些例题"></a>一些例题</h2><h3 id="加速递推式"><a href="#加速递推式" class="headerlink" title="加速递推式"></a>加速递推式</h3><p>以$Fibonacci$为例:</p>
<p>$f(1) = f(2) = 1,f(n) = f(n-1) + f(n-2),(n \geq 10^9)$,求$f(n)$</p>
<p>我们有这么一个矩阵:$A = [f(n-1),f(n-2)]$</p>
<p>构造一个矩阵$B$使得$A*B = [f(n),f(n-1)]$</p>
<p>这里容易看出:</p>
<script type="math/tex; mode=display">
B = \left\{ \begin{matrix}   1 & 1  \\   1 & 0   \end{matrix}  \right\}</script><p>我们使</p>
<script type="math/tex; mode=display">
A =  \left\{ \begin{matrix}   1 & 1  \\   0 & 0   \end{matrix}  \right\}</script><p>(即递推式的初始项),求$A = A*B^{n-1}$后,$f(n) = A[1][1]$</p>
<p>其它递推式同理.</p>
<h3 id="求包含严格k条边的方案数-最短路"><a href="#求包含严格k条边的方案数-最短路" class="headerlink" title="求包含严格k条边的方案数/最短路"></a>求包含严格k条边的方案数/最短路</h3><p>1.无权图求从$i$到$j$经过$k$条边的方案数:求邻接矩阵的$k$次幂即可</p>
<p>2.有向图求包含$k$条边的最短路:求邻接矩阵的$k$次幂,<strong>把普通矩阵乘法改为Floyd</strong></p>
<h1 id="0-1分数规划"><a href="#0-1分数规划" class="headerlink" title="0-1分数规划"></a>0-1分数规划</h1><p>给出数列${a_i},{b_i}$,求一组$w_i \in {0,1}$, 使得</p>
<script type="math/tex; mode=display">
\frac{\sum_{i = 1}^na_i \cdot w_i}{\sum_{i = 1}^nb_i \cdot w_i}</script><p>最大或最小</p>
<p>或给出$n$个物品,每个物品有两个权值$a_i$和$b_i$, 选择任意个物品使得$\frac{\sum a_i}{\sum b_i}$最大\最小</p>
<h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><script type="math/tex; mode=display">
\frac{\sum_{i = 1}^na_i \cdot w_i}{\sum_{i = 1}^nb_i \cdot w_i} \ge M \Leftrightarrow \sum_{i = 1}^n w_i \cdot (a_i - M\cdot b_i) \ge 0</script><p>因此只需判断$\sum_{i = 1}^n w_i \cdot (a_i - M\cdot b_i) $的最大值是否非负即可对$M$二分.</p>
<h2 id="Dinkelbach-算法-迭代法"><a href="#Dinkelbach-算法-迭代法" class="headerlink" title="Dinkelbach 算法(迭代法)"></a>Dinkelbach 算法(迭代法)</h2><p>将上一轮的答案作为输入进行迭代.注意此时答案应为$\frac{\sum<em>{i = 1}^na_i}{\sum</em>{i = 1}^nb_i}$, 而不是变形后的式子.</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="POJ2728-Desert-King"><a href="#POJ2728-Desert-King" class="headerlink" title="[POJ2728]Desert King"></a>[POJ2728]Desert King</h3><p> 给出$n \leq 10^3$个点的横纵坐标和高度, 两点间距离为欧几里得距离, 价值为高度之差绝对值. 所有点构成一个完全图. 求一棵生成树使得</p>
<p>距离/价值比最小.</p>
<h4 id="二分法-1"><a href="#二分法-1" class="headerlink" title="二分法"></a>二分法</h4><p>此题是有一定限制的0-1分数规划(所选的”物品”构成一棵生成树). 直接求边权为$w_i \cdot (a_i - M\cdot b_i)$的最小生成树, 判断是否有解即可二分.</p>
<p>由于是完全图, 采用不加优化的Prim求解.</p>
<p>复杂度大概是$O(n^2 \log((R - L)*2^{-eps}))$</p>
<p>由于二分法较慢, 本题需要猜一个答案上界(100)才能通过=-=</p>
<p>用时<code>2610ms</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//POJ2728</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> ld;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ld INF = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ld eps = <span class="number">1e-5</span>;</span><br><span class="line">ld G[maxn][maxn],dis[maxn];</span><br><span class="line"><span class="keyword">int</span> x[maxn],y[maxn],h[maxn],n;</span><br><span class="line">ld w[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function">ld <span class="title">Dis</span><span class="params">(<span class="keyword">int</span> idx1,<span class="keyword">int</span> idx2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>((x[idx1] - x[idx2])*(x[idx1] - x[idx2])+(y[idx1] - y[idx2])*(y[idx1] - y[idx2]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">prim</span><span class="params">(ld M)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)vis[i] = <span class="number">0</span>,dis[i] = INF;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)<span class="keyword">if</span>(!vis[j])&#123;</span><br><span class="line">			<span class="keyword">if</span>(!x <span class="keyword">or</span> dis[x] &gt; dis[j])x = j;</span><br><span class="line">		&#125;</span><br><span class="line">		vis[x] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)<span class="keyword">if</span>(!vis[j])&#123;</span><br><span class="line">			dis[j] = min(dis[j],w[j][x] - M*G[j][x]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ld tans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)tans += dis[i];</span><br><span class="line">	<span class="keyword">return</span> tans &gt;= <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n) == <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!n)<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x[i],&amp;y[i],&amp;h[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">				G[i][j] = Dis(i,j);</span><br><span class="line">				w[i][j] = <span class="built_in">abs</span>(h[i] - h[j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ld M = <span class="number">0</span>,L = <span class="number">0</span>,R = <span class="number">100</span>;</span><br><span class="line">		<span class="keyword">while</span>(R - L &gt;= eps)&#123;</span><br><span class="line">			M = (L+R)/<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>(prim(M))L = M;</span><br><span class="line">			<span class="keyword">else</span> R = M;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%.3f\n"</span>,L);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h4><p>求生成树时仍按边权$w<em>i \cdot (a_i - M\cdot b_i)$来计算. 但统计答案则计算$\frac{\sum</em>{i = 1}^na<em>i}{\sum</em>{i = 1}^nb_i}$</p>
<p>跑的飞快(<code>250ms</code>)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//POJ2728</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> ld;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ld INF = <span class="number">1e9</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ld eps = <span class="number">1e-5</span>;</span><br><span class="line">ld G[maxn][maxn],dis[maxn];</span><br><span class="line"><span class="keyword">int</span> x[maxn],y[maxn],h[maxn],to[maxn],n;</span><br><span class="line">ld w[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function">ld <span class="title">Dis</span><span class="params">(<span class="keyword">int</span> idx1,<span class="keyword">int</span> idx2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>((x[idx1] - x[idx2])*(x[idx1] - x[idx2])+(y[idx1] - y[idx2])*(y[idx1] - y[idx2]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ld <span class="title">prim</span><span class="params">(ld M)</span></span>&#123;</span><br><span class="line">	ld up = <span class="number">0</span>,down = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)vis[i] = <span class="number">0</span>,dis[i] = INF,to[i] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)<span class="keyword">if</span>(!vis[j])&#123;</span><br><span class="line">			<span class="keyword">if</span>(!x <span class="keyword">or</span> dis[x] &gt; dis[j])x = j;</span><br><span class="line">		&#125;</span><br><span class="line">		vis[x] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)<span class="keyword">if</span>(!vis[j])&#123;</span><br><span class="line">			<span class="keyword">if</span>(dis[j] &gt; w[x][j] - M*G[x][j])dis[j] = w[x][j] - M*G[x][j],to[j] = x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		up += w[i][to[i]];</span><br><span class="line">		down += G[i][to[i]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> up/down;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n) == <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!n)<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x[i],&amp;y[i],&amp;h[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">				G[i][j] = Dis(i,j);</span><br><span class="line">				w[i][j] = <span class="built_in">abs</span>(h[i] - h[j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ld ans = <span class="number">0</span>,lans = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">fabs</span>(lans - ans) &gt; eps)&#123;</span><br><span class="line">			lans = ans;</span><br><span class="line">			ans = prim(ans);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%.3f\n"</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h1><h2 id="FFT"><a href="#FFT" class="headerlink" title="FFT"></a>FFT</h2><p>复数类操作:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt;m;</span><br><span class="line">m.real();m.imag();<span class="comment">//获取实部虚部的值</span></span><br><span class="line">m.real(<span class="number">114</span>);m.imag(<span class="number">514</span>);<span class="comment">//为实部虚部赋值</span></span><br></pre></td></tr></table></figure>
<p>包括手写复数类, DFT与IDFT, 多项式乘法.</p>
<ul>
<li><p>复数类: $x$为实部, $y$为虚部</p>
</li>
<li><p><code>FFT(Comp * A,int siz,int type)</code></p>
<p>  A: 复数数组, 全局变量, 为待求解的多项式</p>
<p>  siz: 多项式长度. 需保证为2的次方</p>
<p>  type: 1为DFT, -1为IDFT</p>
</li>
<li><p><code>Poly mul(Poly A,Poly B)</code></p>
<p>  多项式乘法. 输入两个多项式$A,B$, 长度分别为$n,m$(也就是$n-1,m-1$阶). 返回一个长度$n - m + 1$的多项式, 为$A,B$的乘积.</p>
<p>  <code>Poly</code>为<code>vector&lt;int&gt;</code>.</p>
</li>
</ul>
<p><strong>!!!切记在点值表示法下相乘时, 两个IDFT的长度必须相同!!!</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Poly;</span><br><span class="line"><span class="keyword">const</span> ld PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">int</span> rev[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Comp</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Comp (<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>):x(x),y(y)&#123;&#125;</span><br><span class="line">    Comp <span class="keyword">operator</span> * (Comp B)&#123;</span><br><span class="line">   		<span class="keyword">return</span> Comp(x*B.x - y*B.y,x*B.y + y*B.x);</span><br><span class="line">	&#125;</span><br><span class="line">	Comp <span class="keyword">operator</span> + (Comp B)&#123;</span><br><span class="line">	    <span class="keyword">return</span> Comp(x + B.x,y + B.y);</span><br><span class="line">	&#125;</span><br><span class="line">	Comp <span class="keyword">operator</span> - (Comp B)&#123;</span><br><span class="line">	    <span class="keyword">return</span> Comp(x - B.x,y - B.y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Comp F1[maxn],F2[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Comp * A,<span class="keyword">int</span> siz,<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = siz;</span><br><span class="line">	<span class="keyword">int</span> S = log2(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)rev[i] = (rev[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (S - <span class="number">1</span>));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)<span class="keyword">if</span>(i &lt; rev[i])swap(A[i],A[rev[i]]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i *= <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="function">Comp <span class="title">Wn</span><span class="params">(<span class="built_in">cos</span>(PI/i),type*<span class="built_in">sin</span>(PI/i))</span></span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j += i*<span class="number">2</span>)&#123;</span><br><span class="line">			<span class="function">Comp <span class="title">W</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; i;k++)&#123;</span><br><span class="line">				Comp facx = A[j+k],facy = W*A[j+k+i];</span><br><span class="line">				A[j+k] = facx + facy;</span><br><span class="line">				A[j+k+i] = facx - facy;</span><br><span class="line">				W = W*Wn;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>(type == <span class="number">-1</span>)<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)A[i].x = (<span class="keyword">int</span>)((A[i].x/n + <span class="number">0.5</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Poly <span class="title">mul</span><span class="params">(Poly A,Poly B)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = A.size(),m = B.size();</span><br><span class="line">	<span class="keyword">int</span> siz = n + m - <span class="number">1</span>;</span><br><span class="line">	<span class="function">Poly <span class="title">C</span><span class="params">(siz)</span></span>;</span><br><span class="line">	<span class="keyword">if</span>(siz &lt; <span class="number">64</span>)&#123;<span class="comment">//小于等于64项直接暴力算</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++)C[i+j] = (C[i+j] + <span class="number">1L</span>L*A[i]*B[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> C;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> fsiz = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(fsiz &lt;= siz)fsiz *= <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; fsiz;i++)F1[i] = F2[i] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)F1[i] = A[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)F2[i] = B[i];</span><br><span class="line">	FFT(F1,fsiz,<span class="number">1</span>);</span><br><span class="line">	FFT(F2,fsiz,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; fsiz;i++)F1[i] = F1[i]*F2[i];</span><br><span class="line">	FFT(F1,fsiz,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; siz;i++)&#123;</span><br><span class="line">		C[i] = ((ll)F1[i].x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h3><script type="math/tex; mode=display">
C[i] = \sum_{j = 0}^iA[i]B[i-j]</script><p>卷积等同于多项式乘积</p>
<h2 id="NTT"><a href="#NTT" class="headerlink" title="NTT"></a>NTT</h2><p>从OI-wiki抄来的, 用法和上面的FFT一致. 记得自己手写一遍</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">6e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(d == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>%p;</span><br><span class="line">	<span class="keyword">int</span> a = Pow(x,d/<span class="number">2</span>);</span><br><span class="line">	tans = <span class="number">1l</span>l*a*a%p;</span><br><span class="line">	<span class="keyword">if</span>(d%<span class="number">2</span>)tans = <span class="number">1l</span>l*tans*x%p; </span><br><span class="line">	<span class="keyword">return</span> tans%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Poly;</span><br><span class="line"><span class="keyword">int</span> F1[maxn],F2[maxn];</span><br><span class="line"><span class="keyword">int</span> rev[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> * A,<span class="keyword">int</span> lim,<span class="keyword">int</span> opt)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i, j, k, m, gn, g, tmp;</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)rev[i] = (i &amp; <span class="number">1</span>)*(lim &gt;&gt; <span class="number">1</span>) + (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>);</span><br><span class="line"> 	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; lim; ++i)<span class="keyword">if</span> (rev[i] &lt; i) swap(A[i], A[rev[i]]);</span><br><span class="line"> 	<span class="keyword">for</span>(m = <span class="number">2</span>; m &lt;= lim; m &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">	    k = m &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	    gn = Pow(<span class="number">3</span>,(p - <span class="number">1</span>) / m);</span><br><span class="line">	    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; lim; i += m) &#123;</span><br><span class="line">	    	g = <span class="number">1</span>;</span><br><span class="line">	    	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; k; ++j, g = <span class="number">1l</span>l * g * gn % p) &#123;</span><br><span class="line">	    	    tmp = <span class="number">1l</span>l * A[i + j + k] * g % p;</span><br><span class="line">	    	    A[i + j + k] = (A[i + j] - tmp + p) % p;</span><br><span class="line">	     	 	A[i + j] = (A[i + j] + tmp) % p;</span><br><span class="line">	    	&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(opt == <span class="number">-1</span>)&#123;</span><br><span class="line">    	reverse(A+<span class="number">1</span>,A+lim);</span><br><span class="line">    	<span class="keyword">int</span> inv = Pow(lim,p<span class="number">-2</span>);</span><br><span class="line">    	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; lim; ++i) A[i] = <span class="number">1l</span>l * A[i] * inv % p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Poly <span class="title">mul</span><span class="params">(Poly A,Poly B)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = A.size(),m = B.size();</span><br><span class="line">	<span class="keyword">int</span> siz = n + m - <span class="number">1</span>;</span><br><span class="line">	<span class="function">Poly <span class="title">C</span><span class="params">(siz)</span></span>;</span><br><span class="line">	<span class="keyword">if</span>(siz &lt; <span class="number">64</span>)&#123;<span class="comment">//小于等于64项直接暴力算</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++)C[i+j] = (C[i+j] + <span class="number">1L</span>L*A[i]*B[j]%p)%p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> C;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> fsiz = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(fsiz &lt;= siz)fsiz *= <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; fsiz;i++)F1[i] = F2[i] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)F1[i] = A[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)F2[i] = B[i];</span><br><span class="line">	NTT(F1,fsiz,<span class="number">1</span>);</span><br><span class="line">	NTT(F2,fsiz,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; fsiz;i++)F1[i] = <span class="number">1l</span>l*F1[i]*F2[i]%p;</span><br><span class="line">	NTT(F1,fsiz,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; siz;i++)&#123;</span><br><span class="line">		C[i] = F1[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与FFT的区别在点值表示法相乘时, NTT需要取模. 另外注意原根需与模数对应</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (<span class="keyword">int</span>)A.size();i++)A[i] = <span class="number">1l</span>l*A[i]*B[i]%p;</span><br></pre></td></tr></table></figure>
<h1 id="组合数学"><a href="#组合数学" class="headerlink" title="组合数学"></a>组合数学</h1><h2 id="杂乱的结论"><a href="#杂乱的结论" class="headerlink" title="杂乱的结论"></a>杂乱的结论</h2><h3 id="长度为n-可选-1-m-的本质不同序列个数"><a href="#长度为n-可选-1-m-的本质不同序列个数" class="headerlink" title="长度为n, 可选[1,m]的本质不同序列个数"></a>长度为n, 可选[1,m]的本质不同序列个数</h3><p>(本质不同即将序列排序后两个序列不相同)</p>
<script type="math/tex; mode=display">
C_{n+m-1}^{m-1}</script><h1 id="杂项-1"><a href="#杂项-1" class="headerlink" title="杂项"></a>杂项</h1><h2 id="杂乱的知识点"><a href="#杂乱的知识点" class="headerlink" title="杂乱的知识点"></a>杂乱的知识点</h2><ul>
<li><script type="math/tex; mode=display">
  \lfloor \frac{a}{bc} \rfloor = \lfloor \frac{\lfloor \frac{a}{b} \rfloor}{c} \rfloor</script></li>
<li><script type="math/tex; mode=display">
  a +b = a\oplus b + 2\cdot a \&b</script></li>
</ul>
<h2 id="图兰定理"><a href="#图兰定理" class="headerlink" title="图兰定理"></a>图兰定理</h2><p>对于一个有 $n$个点的无向图，若其中不存在三个点的环，则边数不超过 $n^2/4$</p>
<h2 id="Pick定理"><a href="#Pick定理" class="headerlink" title="Pick定理"></a>Pick定理</h2><p>给定一个顶点均为整点(坐标为整数的点)的简单多边形,其面积$A$和内部格点数$I$,边上格点数$B$的关系是: $A = I+B/2 - 1$</p>
<h2 id="Cayley公式"><a href="#Cayley公式" class="headerlink" title="Cayley公式"></a>Cayley公式</h2><p>一个有$n$个节点的完全图有$n^{n-2}$种不同的生成树</p>
<h2 id="Polya定理1"><a href="#Polya定理1" class="headerlink" title="Polya定理1"></a>Polya定理1</h2><pre><code>-仅旋转,染色数和顶点数均为n.欧拉函数优化(抄自Lskkkno1的题解qwq)
</code></pre><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">polya</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	ll tans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i*i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n%i)<span class="keyword">continue</span>;</span><br><span class="line">		tans += (cal_phi(n/i)*pow_mod(n,i<span class="number">-1</span>))%MOD;</span><br><span class="line">		<span class="keyword">if</span>(i*i != n)tans += cal_phi(i)*pow_mod(n,n/i<span class="number">-1</span>)%MOD;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tans%MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
C_k^k +C_{k+1}^k +...+C_{n}^k（n > k)</script><h2 id="某些数列"><a href="#某些数列" class="headerlink" title="某些数列"></a>某些数列</h2><p>对于数列${1,2,2,3,3,3,4,4,4,4,…}$(数$i$出现了$i$)次, 有通项公式</p>
<script type="math/tex; mode=display">
a_n = \frac{1+2\sqrt{2n}}{2}</script><script type="math/tex; mode=display">
\sum_{i = 1}^\infin i \cdot \frac{1}{a^i}</script><p>海伦公式</p>
<p>$a,b,c$为三角形边长, $s = \frac{a+b+c}{2}$</p>
<p>三角形面积为$S = \sqrt{s(s-a)(s-b)(s-c)}$</p>
<h2 id="组合数奇偶性"><a href="#组合数奇偶性" class="headerlink" title="组合数奇偶性"></a>组合数奇偶性</h2><p>对于$C_n^k$, 如果$n\&amp;k == k$为奇数, 否则偶数.(按位and)</p>
<h2 id="生成2进制恰好包含k位的下一个数"><a href="#生成2进制恰好包含k位的下一个数" class="headerlink" title="生成2进制恰好包含k位的下一个数"></a>生成2进制恰好包含k位的下一个数</h2><p>若$x$里有$k$个1, 则<code>gen_next(x)</code>为包含$k$个1的下一位数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gen_next</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> b = x &amp; -x;</span><br><span class="line">	<span class="keyword">int</span> t = x + b;</span><br><span class="line">	<span class="keyword">int</span> c = t &amp; -t;</span><br><span class="line">	<span class="keyword">int</span> m = (c/b &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> t | m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="求区间-n-m-内不含平方因子的数"><a href="#求区间-n-m-内不含平方因子的数" class="headerlink" title="求区间[n,m]内不含平方因子的数"></a>求区间[n,m]内不含平方因子的数</h2><p>筛掉$p^2$即可. $p$是素数且$p \in [n,m]$</p>
<h2 id="等比数列"><a href="#等比数列" class="headerlink" title="等比数列"></a>等比数列</h2><p>$a$为首项, $q$为公比</p>
<h3 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h3><script type="math/tex; mode=display">
S_n = a \cdot \frac{1-q^n}{1-q} (q \ne 1)</script><h3 id="求积"><a href="#求积" class="headerlink" title="求积"></a>求积</h3><script type="math/tex; mode=display">
P_n = a^n \cdot q^{\frac{n(n-1)}{2}}</script><h2 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h2><p>对于集合$S = {a_i}，i = 1…n$</p>
<p>其全部子集中元素和的和为</p>
<p>$2^{n-1}\cdot \sum_{i = 1}^na_i$</p>
<p>其全部子集中元素积的和为</p>
<p>$\prod_{i = 1}^n(a_i + 1)$</p>
]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>[模板]数据结构</title>
    <url>/2020/05/09/template-data-structure/</url>
    <content><![CDATA[<h1 id="优化指令"><a href="#优化指令" class="headerlink" title="优化指令"></a>优化指令</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">"/stack:200000000"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"Ofast,unroll-loops"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC target(<span class="meta-string">"avx,avx2,sse,sse2"</span>)</span></span><br></pre></td></tr></table></figure>
<p>8e9的暴力, CF上跑了733ms…</p>
<p>适用于常数小的多重循环暴力, 建议热身赛的时候测试下能不能用</p>
<h1 id="RMQ问题"><a href="#RMQ问题" class="headerlink" title="RMQ问题"></a>RMQ问题</h1><h2 id="ST表"><a href="#ST表" class="headerlink" title="ST表"></a>ST表</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">STable</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> ST[<span class="number">50005</span>][<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">bool</span> ismax;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ST_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">memset</span>(ST,<span class="number">0</span>,<span class="keyword">sizeof</span>(ST));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)ST[i][<span class="number">0</span>] = inital[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j) &lt;= n;j++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i +(<span class="number">1</span>&lt;&lt;j) - <span class="number">1</span>&lt;= n;i++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(ismax)ST[i][j] = max(ST[i][j - <span class="number">1</span>],ST[i + (<span class="number">1</span>&lt;&lt;(j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">				<span class="keyword">else</span> ST[i][j] = min(ST[i][j - <span class="number">1</span>],ST[i + (<span class="number">1</span>&lt;&lt;(j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> k = log2(r-l+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(ismax)<span class="keyword">return</span> max(ST[l][k],ST[r - (<span class="number">1</span>&lt;&lt;k) + <span class="number">1</span>][k]);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> min(ST[l][k],ST[r - (<span class="number">1</span>&lt;&lt;k) + <span class="number">1</span>][k]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Fenwick树"><a href="#Fenwick树" class="headerlink" title="Fenwick树"></a>Fenwick树</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> BIT[<span class="number">5000005</span>],n,m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(index &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		tmp += BIT[index];</span><br><span class="line">		index -= lowbit(index);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(index &lt;= n)&#123;</span><br><span class="line">		BIT[index] += x;</span><br><span class="line">		index += lowbit(index); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求k小值"><a href="#求k小值" class="headerlink" title="求k小值:"></a>求k小值:</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tans = <span class="number">0</span>,tcnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = log2(n);i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">		tans += (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">		<span class="keyword">if</span>(tans &gt;= n <span class="keyword">or</span> tcnt + BIT[tans] &gt;= k)tans -= (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">		<span class="keyword">else</span> tcnt += BIT[tans];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tans+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>区间修改单点查询见<a href="https://www.luogu.org/problemnew/show/P3368" target="_blank" rel="noopener">P3368</a>(懒到爆炸</p>
<h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><h2 id="单点修改-区间查询-线性建树"><a href="#单点修改-区间查询-线性建树" class="headerlink" title="单点修改,区间查询,线性建树"></a>单点修改,区间查询,线性建树</h2><p>调用init(n)初始化.传入一个数组建树.</p>
<p>树根标号为0.</p>
<p><strong>下标从0开始</strong></p>
<p><strong>查询操作区间为[L,R).</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segtree</span>&#123;</span></span><br><span class="line">	<span class="comment">//root idx:0</span></span><br><span class="line">	<span class="comment">//[L,R)</span></span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;ll&gt;sumv;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(size &lt; n)size *= <span class="number">2</span>;</span><br><span class="line">		sumv.assign(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;ll&gt; &amp; in,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(lx &lt; (<span class="keyword">int</span>)in.size())sumv[x] = in[lx];</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		build(in,ls(x),lx,m);</span><br><span class="line">		build(in,rs(x),m,rx);</span><br><span class="line">		sumv[x] = sumv[ls(x)] + sumv[rs(x)];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;ll&gt; &amp; in)</span></span>&#123;</span><br><span class="line">		build(in,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)&#123;</span><br><span class="line">			sumv[x] = v;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(idx &lt; m)<span class="built_in">set</span>(idx,v,ls(x),lx,m);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">set</span>(idx,v,rs(x),m,rx);</span><br><span class="line">		sumv[x] = sumv[ls(x)] + sumv[rs(x)];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		<span class="built_in">set</span>(idx,v,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(lx &gt;= l <span class="keyword">and</span> rx &lt;= r)<span class="keyword">return</span> sumv[x];</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		ll s1 = sum(l,r,ls(x),lx,m);</span><br><span class="line">		ll s2 = sum(l,r,rs(x),m,rx);</span><br><span class="line">		<span class="keyword">return</span> s1+s2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> sum(l,r,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="区间内第一个大于等于x的值的下标"><a href="#区间内第一个大于等于x的值的下标" class="headerlink" title="区间内第一个大于等于x的值的下标"></a>区间内第一个大于等于x的值的下标</h3><p>$least(L,v)$返回$[L,n)$里第一个大于等于x的值的下标.如果题目求$[L,R]$的话特判一下下标和R的关系就行.</p>
<p>小于等于与之类似</p>
<p>再次提醒,这种写法的线段树下标从0开始</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">least</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(rx &lt;= l <span class="keyword">or</span> maxv[x] &lt; v)<span class="keyword">return</span> INF;</span><br><span class="line">	<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(maxv[x] &gt;= v)<span class="keyword">return</span> lx;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> INF;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> m = (lx + rx)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> a1 = least(l,v,ls(x),lx,m),a2 = INF;</span><br><span class="line">	<span class="keyword">if</span>(a1 == INF)a2 = least(l,v,rs(x),m,rx);</span><br><span class="line">	<span class="keyword">return</span> min(a1,a2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">least</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> least(l,v,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第k个1"><a href="#第k个1" class="headerlink" title="第k个1"></a>第k个1</h3><p>给出一个0-1数组,求第k个1的下标.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="comment">//return the idx of kth-one</span></span><br><span class="line">	<span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> k = x,l = <span class="number">0</span>,r = size;</span><br><span class="line">	<span class="keyword">while</span>(k)&#123;</span><br><span class="line">		<span class="keyword">if</span>(r - l == <span class="number">1</span>)<span class="keyword">return</span> l;</span><br><span class="line">		<span class="keyword">int</span> lw = sumv[ls(u)],rw = sumv[rs(u)];</span><br><span class="line">		<span class="keyword">int</span> m = (l+r)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(lw &gt;= k)&#123;</span><br><span class="line">			u = ls(u);</span><br><span class="line">			r = m;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			k -= lw;</span><br><span class="line">			u = rs(u);</span><br><span class="line">			l = m;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间合并操作"><a href="#区间合并操作" class="headerlink" title="区间合并操作"></a>区间合并操作</h3><p>例:求最大连续子段和.</p>
<p>记$seg_x$为区间$x$的最大连续子段和.$pre_x$为最大前缀和,$suf_x$为最大后缀和,$sum_x$为区间之和.</p>
<p>记$ls$为$x$的左儿子,$rs$为$x$的右儿子.</p>
<p>对于一个区间$x$,它的$seg$有三种可能:左子区间的$seg$,右子区间的$seg$,两个子区间的公共部分.因此我们有:</p>
<script type="math/tex; mode=display">
seg_x = \max(seg_{ls},seg_{rs},suf_{ls}+pre_{rs})</script><p>对于$pre$和$suf$我们有:</p>
<script type="math/tex; mode=display">
pre_x = max(pre_{ls},sum_{ls}+pre_{rs})\\
suf_x = max(suf_{rs},sum_{rs}+suf_{ls})</script><p> 其他区间信息的合并与此基本相同.(本题答案为$seg[0]$)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segtree</span>&#123;</span></span><br><span class="line">	<span class="comment">//root idx:0</span></span><br><span class="line">	<span class="comment">//[L,R)</span></span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;ll&gt;sumv,pre,suf,seg;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(size &lt; n)size *= <span class="number">2</span>;</span><br><span class="line">		sumv.assign(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">		pre.assign(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">		suf.assign(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">		seg.assign(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)&#123;</span><br><span class="line">			sumv[x] =  suf[x] = pre[x] = seg[x] = v;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(idx &lt; m)<span class="built_in">set</span>(idx,v,ls(x),lx,m);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">set</span>(idx,v,rs(x),m,rx);</span><br><span class="line">		sumv[x] = sumv[ls(x)] + sumv[rs(x)];</span><br><span class="line">		pre[x] = max(pre[ls(x)],sumv[ls(x)]+pre[rs(x)]);</span><br><span class="line">		suf[x] = max(suf[rs(x)],sumv[rs(x)]+suf[ls(x)]);</span><br><span class="line">		seg[x] = max(&#123;seg[ls(x)],seg[rs(x)],suf[ls(x)]+pre[rs(x)]&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		<span class="built_in">set</span>(idx,v,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="区间加-单点查询"><a href="#区间加-单点查询" class="headerlink" title="区间加 单点查询"></a>区间加 单点查询</h2><h3 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P-3-E </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4e6</span>+<span class="number">10</span>; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fenwick</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	ll BIT[maxn];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		size = n+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//		BIT.assign(n+1,0);</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x &amp; -x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">		ll tans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(d)&#123;</span><br><span class="line">			tans += BIT[d];</span><br><span class="line">			d -= lowbit(d); </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> tans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> d,ll v)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(d &lt;= size)&#123;</span><br><span class="line"><span class="comment">//			cout &lt;&lt; d &lt;&lt; endl;</span></span><br><span class="line">			BIT[d] += v;</span><br><span class="line">			d += lowbit(d);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		add(l,v);</span><br><span class="line">		add(r+<span class="number">1</span>,-v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	Fenwick fen;</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	fen.init(n);</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="keyword">int</span> opt,l,r,v;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; opt;</span><br><span class="line">		<span class="keyword">if</span>(opt == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; v;</span><br><span class="line">			l++;</span><br><span class="line"><span class="comment">//			r--;</span></span><br><span class="line">			fen.add(l,r,v);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; v;</span><br><span class="line">			v++;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; fen.sum(v)&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="懒标记"><a href="#懒标记" class="headerlink" title="懒标记"></a>懒标记</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segtree</span>&#123;</span><span class="comment">//lazy tag,sum</span></span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;ll&gt;addv;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(size &lt; n)size *= <span class="number">2</span>;</span><br><span class="line"><span class="comment">//		sumv.assign(size*2,0);</span></span><br><span class="line">		addv.assign(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; in,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)&#123;</span><br><span class="line">			addv[x] = in[lx];</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		build(in,ls(x),lx,m);</span><br><span class="line">		build(in,rs(x),rx,m);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; in)</span></span>&#123;</span><br><span class="line">		build(in,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(lx &gt;= r <span class="keyword">or</span> l &gt;= rx)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			addv[x] += v;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		add(l,r,v,ls(x),lx,m);</span><br><span class="line">		add(l,r,v,rs(x),m,rx);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		add(l,r,v,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)<span class="keyword">return</span> addv[x];</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(idx &lt; m)<span class="keyword">return</span> addv[x] + sum(idx,ls(x),lx,m);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> addv[x] + sum(idx,rs(x),m,rx);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> sum(idx,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="区间修改-区间查询"><a href="#区间修改-区间查询" class="headerlink" title="区间修改,区间查询"></a>区间修改,区间查询</h2><p>维护如下操作:</p>
<p>$A \space l \space r \space v$：对区间$[L,R]$进行操作$A(l,r,v)$</p>
<p>$B \space l \space r$: 查询$B(l,r)$的值</p>
<p>$A,B$两种操作需要满足结合律;$A$需要满足交换律(如果不满足则需要懒标记).$A$与$B$需满足分配律</p>
<p>形式化地,设$\otimes$为操作$A$,$\odot$为操作$B$,线段树维护的操作需要满足:</p>
<ol>
<li><p> <script type="math/tex">A \otimes B\otimes C = A \otimes (B \otimes C)\\
 A \odot B \odot C = A \odot (B \odot C)</script> { }</p>
</li>
<li><script type="math/tex; mode=display">
 A \otimes B = B \otimes A</script></li>
<li><script type="math/tex; mode=display">
 (A \otimes C) \odot (B \otimes C) = (A \odot B) \otimes C</script></li>
</ol>
<h3 id="区间加-区间最小值"><a href="#区间加-区间最小值" class="headerlink" title="区间加,区间最小值"></a>区间加,区间最小值</h3><p>这里以区间加, 区间最小值为例.修改时修改$apply,pushup$和计算函数结尾.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segtree</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> n,size = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;ll&gt;addv,minv;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(size &lt; n)size *= <span class="number">2</span>;</span><br><span class="line">		addv.assign(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">		minv.assign(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(ll x,ll v)</span></span>&#123;</span><br><span class="line">		addv[x] += v;</span><br><span class="line">		minv[x] += v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		minv[x] = min(minv[ls(x)],minv[rs(x)]) + addv[x];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			apply(x,v);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		add(l,r,v,ls(x),lx,m);</span><br><span class="line">		add(l,r,v,rs(x),m,rx);</span><br><span class="line">		pushup(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		add(l,r,v,<span class="number">0</span>,<span class="number">0</span>,size);	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">Min</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span> INF;</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			<span class="keyword">return</span> minv[x];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		ll m1 = Min(l,r,ls(x),lx,m);</span><br><span class="line">		ll m2 = Min(l,r,rs(x),m,rx);</span><br><span class="line">		<span class="keyword">return</span> min(m1,m2) + addv[x];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">Min</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Min(l,r,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="区间乘-区间求和"><a href="#区间乘-区间求和" class="headerlink" title="区间乘,区间求和"></a>区间乘,区间求和</h3><p>初始数组均为1.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segtree</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> n,size = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;ll&gt;sumv,mulv;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		sumv[x] = rx - lx;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		build(ls(x),lx,m);</span><br><span class="line">		build(rs(x),m,rx);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">		build(<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(size &lt; n)&#123;</span><br><span class="line">			size *= <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		sumv.assign(size*<span class="number">2</span>,<span class="number">0l</span>l);</span><br><span class="line">		mulv.assign(size*<span class="number">2</span>,<span class="number">1l</span>l);</span><br><span class="line">		build();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(<span class="keyword">int</span> x,ll v)</span></span>&#123;</span><br><span class="line">		mulv[x] = mulv[x]*v%mod;</span><br><span class="line">		sumv[x] = sumv[x]*v%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		sumv[x] = (sumv[ls(x)] + sumv[rs(x)])%mod*mulv[x]%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			apply(x,v);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		mul(l,r,v,ls(x),lx,m);</span><br><span class="line">		mul(l,r,v,rs(x),m,rx);</span><br><span class="line">		pushup(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		mul(l,r,v,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			<span class="keyword">return</span> sumv[x];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		ll s1 = sum(l,r,ls(x),lx,m);</span><br><span class="line">		ll s2 = sum(l,r,rs(x),m,rx);</span><br><span class="line">		<span class="keyword">return</span> (s1+s2)%mod*mulv[x]%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> sum(l,r,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="区间加-区间求和"><a href="#区间加-区间求和" class="headerlink" title="区间加,区间求和"></a>区间加,区间求和</h3><p>这个比较特殊,因为$(a + x) + (b + x)  = (a+b) + 2x$,所以维护修改操作时应乘上区间长度</p>
<p>同时注意区间长度的判断(sum函数最后一行)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segtree</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;ll&gt;addv,sumv;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(size &lt; n)size *= <span class="number">2</span>;</span><br><span class="line">		addv.assign(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">		sumv.assign(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(<span class="keyword">int</span> x,ll v,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">		addv[x] += v;</span><br><span class="line">		sumv[x] += v*len;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		sumv[x] = sumv[ls(x)] + sumv[rs(x)] + addv[x]*(rx-lx);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> lx,<span class="keyword">int</span> rx,<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll v)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(lx &gt;= r <span class="keyword">or</span> l &gt;= rx)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			apply(x,v,rx - lx);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		add(lx,m,ls(x),l,r,v);</span><br><span class="line">		add(m,rx,rs(x),l,r,v);</span><br><span class="line">		pushup(x,lx,rx);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		add(<span class="number">0</span>,size,<span class="number">0</span>,l,r,v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> lx,<span class="keyword">int</span> rx,<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)<span class="keyword">return</span> sumv[x];</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		ll s1 = sum(lx,m,ls(x),l,r);</span><br><span class="line">		ll s2 = sum(m,rx,rs(x),l,r);</span><br><span class="line">		<span class="keyword">return</span> (s1+s2)+addv[x]*(min(r,rx) - max(l,lx));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> sum(<span class="number">0</span>,size,<span class="number">0</span>,l,r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;seg;</span><br></pre></td></tr></table></figure>
<h4 id="维护等差数列-区间加等差数列-单点查询"><a href="#维护等差数列-区间加等差数列-单点查询" class="headerlink" title="维护等差数列(区间加等差数列,单点查询)"></a>维护等差数列(区间加等差数列,单点查询)</h4><p>​    由于$A<em>n = A</em>{n-1} + d$， 维护一个差分数列即可.</p>
<ul>
<li>$1 \space l \space r \space a \space d$： 将$[L,R]$加上首项$a$公差$d$的等差数列</li>
<li>$2\space x$: 查询位置$x$的值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    <span class="keyword">int</span> opt,l,r,a,d;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; opt &gt;&gt; l;</span><br><span class="line">    <span class="keyword">if</span>(opt == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; r &gt;&gt; a &gt;&gt; d;</span><br><span class="line">        seg.add(l,l,a);</span><br><span class="line">        seg.add(r+<span class="number">1</span>,r+<span class="number">1</span>,-a);</span><br><span class="line">        seg.add(l+<span class="number">1</span>,r,d);</span><br><span class="line">        seg.add(r+<span class="number">1</span>,r+<span class="number">1</span>,-(r-l)*d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; seg.sum(<span class="number">1</span>,l) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间加-区间大于x的第一个值"><a href="#区间加-区间大于x的第一个值" class="headerlink" title="区间加,区间大于x的第一个值"></a>区间加,区间大于x的第一个值</h3><p>在线段树上二分即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segtree</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;ll&gt;addv,maxv;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(size &lt; n)size *= <span class="number">2</span>;</span><br><span class="line">		addv.assign(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">		maxv.assign(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		maxv[x] = max(maxv[ls(x)],maxv[rs(x)]) + addv[x];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			addv[x] += v;</span><br><span class="line">			maxv[x] += v;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		add(l,r,v,ls(x),lx,m);</span><br><span class="line">		add(l,r,v,rs(x),m,rx);</span><br><span class="line">		pushup(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll v)</span></span>&#123;</span><br><span class="line">		add(l,r,v,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">least</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx,ll add)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rx &lt;= l <span class="keyword">or</span> maxv[x] + add &lt; v)<span class="keyword">return</span> INF;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(maxv[x] + add &gt;= v)<span class="keyword">return</span> lx;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">return</span> INF;</span><br><span class="line">		&#125;</span><br><span class="line">		add += addv[x];</span><br><span class="line">		<span class="keyword">int</span> m = (lx + rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> a1 = least(l,v,ls(x),lx,m,add),a2 = INF;</span><br><span class="line">		<span class="keyword">if</span>(a1 == INF)a2 = least(l,v,rs(x),m,rx,add);</span><br><span class="line">		<span class="keyword">return</span> min(a1,a2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">least</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> least(l,v,<span class="number">0</span>,<span class="number">0</span>,size,addv[<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="区间懒标记"><a href="#区间懒标记" class="headerlink" title="区间懒标记"></a>区间懒标记</h2><h3 id="区间赋值-区间最小值"><a href="#区间赋值-区间最小值" class="headerlink" title="区间赋值 区间最小值"></a>区间赋值 区间最小值</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e10</span>+<span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segtree</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> NO_OPT = <span class="number">1E9</span>+<span class="number">10</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;ll&gt;setv,minv;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(size &lt; n)size *= <span class="number">2</span>;</span><br><span class="line">		setv.assign(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">		minv.assign(size*<span class="number">2</span>,<span class="number">0</span>); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(ll &amp; a,ll b)</span></span>&#123;</span><br><span class="line">		a = (b == NO_OPT?a:b);	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(setv[x] == NO_OPT)<span class="keyword">return</span>;</span><br><span class="line">		apply(setv[ls(x)],setv[x]);</span><br><span class="line">		apply(minv[ls(x)],setv[x]);</span><br><span class="line">		apply(setv[rs(x)],setv[x]);</span><br><span class="line">		apply(minv[rs(x)],setv[x]);</span><br><span class="line">		setv[x] = NO_OPT; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		minv[x] = min(minv[ls(x)],minv[rs(x)]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx &gt; <span class="number">1</span>)pushdown(x);</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			apply(setv[x],v);</span><br><span class="line">			apply(minv[x],v);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		Set(l,r,v,ls(x),lx,m);</span><br><span class="line">		Set(l,r,v,rs(x),m,rx);</span><br><span class="line">		pushup(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll v)</span></span>&#123;</span><br><span class="line">		Set(l,r,v,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">Min</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx &gt; <span class="number">1</span>)pushdown(x);</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span> INF;</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)<span class="keyword">return</span> minv[x];</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		ll m1 = Min(l,r,ls(x),lx,m);</span><br><span class="line">		ll m2 = Min(l,r,rs(x),m,rx);</span><br><span class="line">		<span class="keyword">return</span> min(m1,m2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">Min</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Min(l,r,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="区间赋值-区间加"><a href="#区间赋值-区间加" class="headerlink" title="区间赋值  区间加"></a>区间赋值  区间加</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segtree</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;ll&gt;sumv,setv;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> NO_OPT = INF+<span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(size &lt; n)size *= <span class="number">2</span>;</span><br><span class="line">		sumv.assign(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">		setv.assign(size*<span class="number">2</span>,NO_OPT);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(ll &amp; a,ll b)</span></span>&#123;</span><br><span class="line">		a = (b == NO_OPT?a:b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> len = rx - lx;</span><br><span class="line">		<span class="keyword">if</span>(len == <span class="number">1</span> <span class="keyword">or</span> setv[x] == NO_OPT)<span class="keyword">return</span>;</span><br><span class="line">		len /= <span class="number">2</span>;</span><br><span class="line">		apply(setv[ls(x)],setv[x]);</span><br><span class="line">		apply(sumv[ls(x)],setv[x]*len);</span><br><span class="line">		apply(setv[rs(x)],setv[x]);</span><br><span class="line">		apply(sumv[rs(x)],setv[x]*len);</span><br><span class="line">		setv[x] = NO_OPT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		sumv[x] = sumv[ls(x)] + sumv[rs(x)];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">		pushdown(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			setv[x] = v;</span><br><span class="line">			sumv[x] = v*(rx - lx);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		Set(l,r,v,ls(x),lx,m);</span><br><span class="line">		Set(l,r,v,rs(x),m,rx);</span><br><span class="line">		pushup(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll v)</span></span>&#123;</span><br><span class="line">		Set(l,r,v,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		pushdown(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			<span class="keyword">return</span> sumv[x];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		ll s1 = sum(l,r,ls(x),lx,m);</span><br><span class="line">		ll s2 = sum(l,r,rs(x),m,rx);</span><br><span class="line">		<span class="keyword">return</span> s1+s2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> sum(l,r,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="区间赋值-最大连续子段和-区间合并"><a href="#区间赋值-最大连续子段和-区间合并" class="headerlink" title="区间赋值 最大连续子段和(区间合并)"></a>区间赋值 最大连续子段和(区间合并)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segtree</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;ll&gt;sumv,setv;</span><br><span class="line">	<span class="built_in">vector</span>&lt;ll&gt;prev,sufv,segv;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> NO_OPT = INF+<span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(size &lt; n)size *= <span class="number">2</span>;</span><br><span class="line">		sumv.assign(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">		setv.assign(size*<span class="number">2</span>,NO_OPT);</span><br><span class="line">		prev.assign(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">		sufv.assign(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">		segv.assign(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(ll &amp; a,ll b)</span></span>&#123;</span><br><span class="line">		a = (b == NO_OPT?a:b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> len = rx - lx;</span><br><span class="line">		<span class="keyword">if</span>(len == <span class="number">1</span> <span class="keyword">or</span> setv[x] == NO_OPT)<span class="keyword">return</span>;</span><br><span class="line">		len /= <span class="number">2</span>;</span><br><span class="line">		apply(setv[ls(x)],setv[x]);</span><br><span class="line">		apply(sumv[ls(x)],setv[x]*len);</span><br><span class="line">		apply(setv[rs(x)],setv[x]);</span><br><span class="line">		apply(sumv[rs(x)],setv[x]*len);</span><br><span class="line">		<span class="keyword">if</span>(setv[x] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			prev[ls(x)] = prev[rs(x)] = setv[x]*len;</span><br><span class="line">			sufv[ls(x)] = sufv[rs(x)] = setv[x]*len;</span><br><span class="line">			segv[ls(x)] = segv[rs(x)] = setv[x]*len;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			prev[ls(x)] = prev[rs(x)] = <span class="number">0</span>;</span><br><span class="line">			sufv[ls(x)] = sufv[rs(x)] = <span class="number">0</span>;</span><br><span class="line">			segv[ls(x)] = segv[rs(x)] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		setv[x] = NO_OPT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		sumv[x] = sumv[ls(x)] + sumv[rs(x)];</span><br><span class="line">		sufv[x] = max(sufv[rs(x)],sufv[ls(x)] + sumv[rs(x)]);</span><br><span class="line">		prev[x] = max(prev[ls(x)],prev[rs(x)] + sumv[ls(x)]);</span><br><span class="line">		segv[x] = max(&#123;segv[ls(x)],segv[rs(x)],prev[rs(x)] + sufv[ls(x)]&#125;); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">		pushdown(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			setv[x] = v;</span><br><span class="line">			sumv[x] = v*(rx - lx);</span><br><span class="line">			<span class="keyword">if</span>(v &gt; <span class="number">0</span>)&#123;</span><br><span class="line">				segv[x] = prev[x] = sufv[x] = v*(rx - lx);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				segv[x] = prev[x] = sufv[x] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		Set(l,r,v,ls(x),lx,m);</span><br><span class="line">		Set(l,r,v,rs(x),m,rx);</span><br><span class="line">		pushup(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll v)</span></span>&#123;</span><br><span class="line">		Set(l,r,v,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		pushdown(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			<span class="keyword">return</span> sumv[x];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		ll s1 = sum(l,r,ls(x),lx,m);</span><br><span class="line">		ll s2 = sum(l,r,rs(x),m,rx);</span><br><span class="line">		<span class="keyword">return</span> s1+s2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> sum(l,r,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="区间取反-第k个值"><a href="#区间取反-第k个值" class="headerlink" title="区间取反 第k个值"></a>区间取反 第k个值</h3><p>用sum来维护区间取反,每取反一次有$sum_x = len_x - sum_x$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segtree</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;ll&gt;sumv;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;inv,tag;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(size &lt; n)size *= <span class="number">2</span>;</span><br><span class="line">		sumv.assign(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">		inv.assign(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span> <span class="keyword">or</span> !inv[x])<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">int</span> len = (rx - lx)/<span class="number">2</span>;</span><br><span class="line">		sumv[ls(x)] = len - sumv[ls(x)];</span><br><span class="line">		sumv[rs(x)] = len - sumv[rs(x)];</span><br><span class="line">		inv[ls(x)] = !inv[ls(x)];</span><br><span class="line">		inv[rs(x)] = !inv[rs(x)];</span><br><span class="line">		inv[x] = !inv[x];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		sumv[x] = sumv[ls(x)] + sumv[rs(x)];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Inv</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">		pushdown(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			inv[x] = !inv[x];</span><br><span class="line">			sumv[x] = (rx - lx) - sumv[x];</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		Inv(l,r,ls(x),lx,m);</span><br><span class="line">		Inv(l,r,rs(x),m,rx);</span><br><span class="line">		pushup(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Inv</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		Inv(l,r,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		pushdown(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx)<span class="keyword">return</span> INF;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(sumv[x] &gt;= v)<span class="keyword">return</span> lx;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">return</span> INF;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(sumv[ls(x)] &gt; v)<span class="keyword">return</span> kth(l,v,ls(x),lx,m);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> kth(l,v - sumv[ls(x)],rs(x),m,rx); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> kth(l,v,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="区间加-区间赋值-区间求和"><a href="#区间加-区间赋值-区间求和" class="headerlink" title="区间加 区间赋值 区间求和"></a>区间加 区间赋值 区间求和</h2><p>此时set和add标记均要Pushdown.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segtree</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;ll&gt;setv,sumv,addv;</span><br><span class="line">	<span class="keyword">const</span> ll NO_OPT = LLONG_MAX; </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(size &lt; n)size *= <span class="number">2</span>;</span><br><span class="line">		setv.assign(size*<span class="number">2</span>,NO_OPT);</span><br><span class="line">		sumv.assign(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">		addv.assign(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">int</span> len = (rx - lx)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(setv[x] != NO_OPT)&#123;</span><br><span class="line">			addv[ls(x)] = addv[rs(x)] = <span class="number">0</span>;</span><br><span class="line">			setv[ls(x)] = setv[rs(x)] = setv[x];</span><br><span class="line">			sumv[ls(x)] = sumv[rs(x)] = setv[x]*len;</span><br><span class="line">			setv[x] = NO_OPT; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(addv[x])&#123;</span><br><span class="line">			addv[ls(x)] += addv[x];</span><br><span class="line">			addv[rs(x)] += addv[x];</span><br><span class="line">			sumv[ls(x)] += addv[x]*len;</span><br><span class="line">			sumv[rs(x)] += addv[x]*len;</span><br><span class="line">			addv[x] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">		sumv[x] = sumv[ls(x)] + sumv[rs(x)] + addv[x]*len;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">		pushdown(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			setv[x] = v;</span><br><span class="line">			addv[x] = <span class="number">0</span>;</span><br><span class="line">			sumv[x] = v*(rx - lx);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		Set(l,r,v,ls(x),lx,m);</span><br><span class="line">		Set(l,r,v,rs(x),m,rx);</span><br><span class="line">		pushup(x,rx - lx);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll v)</span></span>&#123;</span><br><span class="line">		Set(l,r,v,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">		pushdown(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			addv[x] += v;</span><br><span class="line">			sumv[x] += v*(rx - lx);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		add(l,r,v,ls(x),lx,m);</span><br><span class="line">		add(l,r,v,rs(x),m,rx);</span><br><span class="line">		pushup(x,rx - lx);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll v)</span></span>&#123;</span><br><span class="line">		add(l,r,v,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		pushdown(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			<span class="keyword">return</span> sumv[x];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		ll s1 = sum(l,r,ls(x),lx,m);</span><br><span class="line">		ll s2 = sum(l,r,rs(x),m,rx);</span><br><span class="line">		<span class="keyword">return</span> s1+s2+addv[x]*(min(r,rx) - max(l,lx));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> sum(l,r,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="一些例题"><a href="#一些例题" class="headerlink" title="一些例题"></a>一些例题</h2><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>区间赋值为0或1,求区间内1的子段个数</p>
<p>比如<code>0 1 0 1 1 0 0 1 1 1</code>答案为3</p>
<p>解法:</p>
<p>维护三个数组，$num[x]$表示$x$的线段个数</p>
<p>$left[x]$表示$x$的左端点是否为1,$right[]$同理.</p>
<p>小细节:pushup时当<code>right[ls(x)] == 1 and left[rs(x)] == 1</code>时,<code>num[x]--</code></p>
<h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p><a href="https://codeforces.com/edu/course/2/lesson/5/4/practice/contest/280801/problem/E" target="_blank" rel="noopener">IOI2014-Walls</a></p>
<p>长度为$n$的序列初始为空,维护两种操作:</p>
<ol>
<li>Add(L,R,v): 将$[L,R]$中小于$v$的值改变为$v$</li>
<li>Remove(L,R,v):将$[L,R]$中大于$v$的值改变为$v$</li>
</ol>
<p>给出$m$个操作,输出操作全部完成后的序列.</p>
<p>$1 \leq n \leq 2\cdot10^6,1 \leq m \leq 5\cdot10^5$</p>
<p>对每个节点维护$upv[]$和$lowv[]$,表示该节点值的上限和下限.查询时对每个点做一次单点查询,答案为$lowv[x]$.</p>
<h1 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h1><h2 id="Treap"><a href="#Treap" class="headerlink" title="Treap"></a>Treap</h2><hr>
<p>平衡树1-Treap</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> cnt,size,v,r;</span><br><span class="line">	Node * ch[<span class="number">2</span>];</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(x == v)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">return</span> x&lt;v?<span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Node()&#123;<span class="comment">//null,plz use newnode(x);</span></span><br><span class="line">		ch[<span class="number">0</span>] = ch[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">		cnt = size = v = r = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">()</span></span>&#123;</span><br><span class="line">		size = ch[<span class="number">0</span>]-&gt;size +ch[<span class="number">1</span>]-&gt;size + cnt;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;;</span><br><span class="line">Node * null = <span class="keyword">new</span> Node();</span><br><span class="line"><span class="function">Node * <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	Node * tmp = <span class="keyword">new</span> Node();</span><br><span class="line">	tmp-&gt;ch[<span class="number">0</span>] = tmp-&gt;ch[<span class="number">1</span>] = null;</span><br><span class="line">	tmp-&gt;v = x;</span><br><span class="line">	tmp-&gt;r = rand();</span><br><span class="line">	tmp-&gt;size = tmp-&gt;cnt = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node * <span class="title">find</span><span class="params">(Node * o,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(o != null)&#123;</span><br><span class="line">		<span class="keyword">int</span> d = o-&gt;cmp(x);</span><br><span class="line">		<span class="keyword">if</span>(d == <span class="number">-1</span>)<span class="keyword">return</span> o;</span><br><span class="line">		<span class="keyword">else</span> o = o-&gt;ch[d];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> null;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(Node *&amp; o,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">	Node * k = o-&gt;ch[d^<span class="number">1</span>];</span><br><span class="line">	o-&gt;ch[d^<span class="number">1</span>] = k-&gt;ch[d];</span><br><span class="line">	k-&gt;ch[d] = o;</span><br><span class="line">	o-&gt;maintain();k-&gt;maintain();</span><br><span class="line">	o = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node *&amp; o,<span class="keyword">int</span> x,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(o == null)o = newnode(x);</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> d = o-&gt;cmp(x);</span><br><span class="line">		<span class="keyword">if</span>(d == <span class="number">-1</span>)o-&gt;cnt+=c;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			insert(o-&gt;ch[d],x,c);</span><br><span class="line">			<span class="keyword">if</span>(o-&gt;ch[d]-&gt;r &gt; o-&gt;r)rotate(o,d^<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	o-&gt;maintain();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node *&amp; o,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(find(o,x) == null)<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> d = o-&gt;cmp(x);</span><br><span class="line">	<span class="keyword">if</span>(d == <span class="number">-1</span>)&#123;</span><br><span class="line">		Node * u = o;</span><br><span class="line">		<span class="keyword">if</span>(o-&gt;cnt &gt; <span class="number">1</span>)&#123;</span><br><span class="line">			o-&gt;cnt--;</span><br><span class="line">			o-&gt;size--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(o-&gt;ch[<span class="number">0</span>] != null <span class="keyword">and</span> o-&gt;ch[<span class="number">1</span>] != null)&#123;</span><br><span class="line">			<span class="keyword">int</span> d2 = o-&gt;ch[<span class="number">0</span>]-&gt;r &gt; o-&gt;ch[<span class="number">1</span>]-&gt;r ?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">			rotate(o,d2);</span><br><span class="line">			remove(o-&gt;ch[d2],x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(o-&gt;ch[<span class="number">0</span>] == null)o = o-&gt;ch[<span class="number">1</span>];<span class="keyword">else</span> o = o-&gt;ch[<span class="number">0</span>];</span><br><span class="line">			<span class="keyword">delete</span> u;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> remove(o-&gt;ch[d],x);</span><br><span class="line">	<span class="keyword">if</span>(o != null)o-&gt;maintain();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(Node * o,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="comment">//min</span></span><br><span class="line">	<span class="keyword">int</span> k1 = k;</span><br><span class="line">	<span class="keyword">while</span>(o != null)&#123;</span><br><span class="line">		<span class="keyword">int</span> s = o-&gt;ch[<span class="number">0</span>]-&gt;size;</span><br><span class="line">		<span class="keyword">if</span>(k1 &gt; s <span class="keyword">and</span> k1 &lt;= s + o-&gt;cnt)<span class="keyword">return</span> o-&gt;v;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(k1 &lt;= s) o = o-&gt;ch[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			k1 = k1 - s - o-&gt;cnt;</span><br><span class="line">			o = o-&gt;ch[<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Rank</span><span class="params">(Node * o,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans_ = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(find(o,x) == null)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(o != null)&#123;</span><br><span class="line">		<span class="keyword">if</span>(o-&gt;v == x)&#123;</span><br><span class="line">			ans_ += <span class="number">1</span> + o-&gt;ch[<span class="number">0</span>]-&gt;size;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(o-&gt;v &gt; x)o = o-&gt;ch[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			ans_ += o-&gt;ch[<span class="number">0</span>]-&gt;size + o-&gt;cnt;</span><br><span class="line">			o = o-&gt;ch[<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(Node * o,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans_ = -INF;</span><br><span class="line">	<span class="keyword">while</span>(o != null)&#123;</span><br><span class="line">		<span class="keyword">if</span>(ans_ &lt;= o-&gt;v <span class="keyword">and</span> o-&gt;v &lt; x)&#123;</span><br><span class="line">			ans_ = o-&gt;v;</span><br><span class="line">			o = o-&gt;ch[<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> o = o-&gt;ch[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">upper_bound</span><span class="params">(Node * o,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans_ = INF;</span><br><span class="line">	<span class="keyword">while</span>(o != null)&#123;</span><br><span class="line">		<span class="keyword">if</span>(x &lt; o-&gt;v <span class="keyword">and</span> o-&gt;v &lt; ans_)&#123;</span><br><span class="line">			ans_ = o-&gt;v;</span><br><span class="line">			o = o-&gt;ch[<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> o = o-&gt;ch[<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deltree</span><span class="params">(Node *&amp; o)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(o-&gt;ch[<span class="number">0</span>] != null)deltree(o-&gt;ch[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">if</span>(o-&gt;ch[<span class="number">1</span>] != null)deltree(o-&gt;ch[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">delete</span> o;</span><br><span class="line">	o = null;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(Node *&amp; src,Node *&amp; dest)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(src-&gt;ch[<span class="number">0</span>] != null)merge(src-&gt;ch[<span class="number">0</span>],dest);</span><br><span class="line">	<span class="keyword">if</span>(src-&gt;ch[<span class="number">1</span>] != null)merge(src-&gt;ch[<span class="number">1</span>],dest);</span><br><span class="line">	insert(dest,src-&gt;v,src-&gt;cnt);</span><br><span class="line">	<span class="keyword">delete</span> src;</span><br><span class="line">	src = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="读入"><a href="#读入" class="headerlink" title="读入"></a>读入</h2><h3 id="读入一行"><a href="#读入一行" class="headerlink" title="读入一行"></a>读入一行</h3><h4 id="getline"><a href="#getline" class="headerlink" title="getline"></a>getline</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line">getline(<span class="built_in">cin</span>,s);</span><br></pre></td></tr></table></figure>
<h3 id="sstream"><a href="#sstream" class="headerlink" title="sstream"></a>sstream</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">stringstream</span> ss;</span><br><span class="line"><span class="keyword">int</span> a, b, c;</span><br><span class="line">getline(<span class="built_in">cin</span>, s);</span><br><span class="line">ss.clear();</span><br><span class="line">ss.str(s);</span><br><span class="line">ss &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br></pre></td></tr></table></figure>
<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p>$Next[i]$表示自$i$结束(不包括$i$)的子串中前后缀相同的长度</p>
<p>例如：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">i</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
<th style="text-align:center">10</th>
<th style="text-align:center">11</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$s[i]$</td>
<td style="text-align:center">A</td>
<td style="text-align:center">B</td>
<td style="text-align:center">R</td>
<td style="text-align:center">A</td>
<td style="text-align:center">C</td>
<td style="text-align:center">A</td>
<td style="text-align:center">D</td>
<td style="text-align:center">A</td>
<td style="text-align:center">B</td>
<td style="text-align:center">R</td>
<td style="text-align:center">A</td>
<td style="text-align:center">\</td>
</tr>
<tr>
<td style="text-align:center">$Next[i]$</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
</tr>
</tbody>
</table>
</div>
<p>可以看出$[i - Next[i],i - 1]$这一段的前后缀是相同的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> Next[<span class="number">1000010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFail</span><span class="params">(<span class="built_in">string</span> P)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p_size = P.size();</span><br><span class="line">	Next[<span class="number">0</span>] = Next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; p_size;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> j = Next[i];</span><br><span class="line">		<span class="keyword">while</span>(j <span class="keyword">and</span> P[i] != P[j])j = Next[j];</span><br><span class="line">		Next[i+<span class="number">1</span>] = (P[j] == P[i]?j+<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KMP</span><span class="params">(<span class="built_in">string</span> T,<span class="built_in">string</span> P)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t_size = T.size(),p_size = P.size();</span><br><span class="line">	getFail(P);</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; t_size;i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(j <span class="keyword">and</span> P[j] != T[i])j = Next[j];</span><br><span class="line">		<span class="keyword">if</span>(P[j] == T[i])j++;</span><br><span class="line">		<span class="keyword">if</span>(j == p_size)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i - p_size + <span class="number">2</span>);</span><br><span class="line">			j = Next[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Manacher"><a href="#Manacher" class="headerlink" title="Manacher"></a>Manacher</h2><p>最长连续回文子串</p>
<p>$len[i] - 1$表示以i为中心的最长回文串一半的长度(不包括中心)</p>
<p>返回最长连续回文子串的长度</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Manacher</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> len[maxn];</span><br><span class="line">	<span class="built_in">string</span> raw = <span class="string">"~"</span>;</span><br><span class="line">	<span class="keyword">int</span> ic = <span class="number">0</span>,im = <span class="number">0</span>,ir = <span class="number">0</span>,ans = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="built_in">string</span> s = <span class="string">""</span>)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.size();i++)&#123;</span><br><span class="line">			raw += <span class="string">'|'</span>;</span><br><span class="line">			raw += s[i];</span><br><span class="line">		&#125;</span><br><span class="line">		raw += <span class="string">"|!"</span>;</span><br><span class="line"><span class="comment">//		cout &lt;&lt; raw &lt;&lt; endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> l = raw.size();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; l;i++)&#123;</span><br><span class="line">			len[i] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(i &lt; ir)&#123;</span><br><span class="line">				im = <span class="number">2</span>*ic-i;</span><br><span class="line">				len[i] = min(ir-i,len[im]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span>(raw[i-len[i]] == raw[i+len[i]])len[i]++;</span><br><span class="line">			<span class="keyword">if</span>(i + len[i] &gt; ir)ic = i,ir = i + len[i];</span><br><span class="line">			<span class="keyword">if</span>(len[i] &gt; len[ic])ic = i;</span><br><span class="line">			ans = max(len[i],ans);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">char</span> x:raw)<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		<span class="keyword">return</span> ans<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;yay;</span><br></pre></td></tr></table></figure>
<h2 id="字符串hash-滚动hash"><a href="#字符串hash-滚动hash" class="headerlink" title="字符串hash (滚动hash)"></a>字符串hash (滚动hash)</h2><p>​    $H[x]$为hash值,$xp[d]$为$x^d$,$x$为底数(随便取一个就行),$s$为字符串.用ull自然溢出来-1s</p>
<p>​    递推式:$H[i] = H[i-1] \cdot x + (s[i] - ‘a’)$</p>
<p>​    查询以$i$开始长度为$L$的字符串的hash:$Hash(i,L) = H[i + L - 1] - (H[i-1] \cdot xp[L]) $</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ull xp[maxn],H[maxn];</span><br><span class="line"><span class="comment">//预处理x的幂</span></span><br><span class="line">xp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; maxn;i++)xp[i] = xp[i<span class="number">-1</span>]*x; </span><br><span class="line"><span class="comment">//预处理hash</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)H[i] = H[i<span class="number">-1</span>]*x + s[i<span class="number">-1</span>] - <span class="string">'a'</span>;</span><br><span class="line"><span class="comment">//Hash(i,L)</span></span><br><span class="line"><span class="function">ull <span class="title">Hash</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> L)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> H[x+L<span class="number">-1</span>] - H[x<span class="number">-1</span>]*xp[L];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后缀数组"><a href="#后缀数组" class="headerlink" title="后缀数组"></a>后缀数组</h2><p><strong>一晚上速成的垃圾内容 需要细致的重构</strong></p>
<p>注意字符串下标均从0开始</p>
<p>$sa$为后缀数组, <code>sa[i]</code>表示将所有后缀排序后第$i$小的后缀的编号</p>
<p><code>sa</code>的示意图:(p为sa)</p>
<p><img src="C:\Users\frien\AppData\Roaming\Typora\typora-user-images\image-20201010184404464.png" alt="image-20201010184404464"></p>
<p>$lcp[i]$为$s[sa[i]…]$和$s[sa[i-1]…]$的最长公共前缀长度(等同于lrj蓝书上的$height$</p>
<p>$c$为等价类,迭代结束后$c$等同于$rank$,$c[i]$代表第$i$个后缀在$sa$中的下标</p>
<p>调用时通过$SA(string)$初始化,$cal()$计算sa,$getlcp$计算lcp.</p>
<p>$LCP(i,j)$返回后缀i和j的LCP.</p>
<p>顺便注意LCP和ST用的是数组而不是vector,纯粹是我懒得再初始化一遍了(你个sb,初始化用assign啊)=-=(测试了下开O2之后vector和普通数组速度相差无几)</p>
<p>这个写法的确长,但是我看来比lrj的好理解多了=-=md那个看着都头大,这个至少能自己一遍敲下来</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> a,b;</span><br><span class="line">	Node(<span class="keyword">int</span> a = <span class="number">0</span>,<span class="keyword">int</span> b = <span class="number">0</span>):a(a),b(b)&#123;&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp; x)&#123;</span><br><span class="line">		<span class="keyword">return</span> a == x.a?b &lt; x.b:a &lt; x.a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SA</span>&#123;</span></span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;sa,c;</span><br><span class="line">	<span class="keyword">int</span> lcp[maxn],ST[maxn][<span class="number">20</span>];</span><br><span class="line">	SA(<span class="built_in">string</span> s = <span class="string">""</span>):s(s)&#123;</span><br><span class="line">		s += <span class="string">'$'</span>;</span><br><span class="line">		n = s.size();</span><br><span class="line">		sa.assign(n,<span class="number">0</span>);</span><br><span class="line">		c.assign(n,<span class="number">0</span>); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">count_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; sa,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; c)</span></span>&#123;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;pos(n),cnt(n),sa_new(n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x:c)cnt[x]++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)pos[i] = pos[i<span class="number">-1</span>] + cnt[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x:sa)&#123;</span><br><span class="line">			<span class="keyword">int</span> d = c[x];</span><br><span class="line">			sa_new[pos[d]] = x;</span><br><span class="line">			pos[d]++;</span><br><span class="line">		&#125;</span><br><span class="line">		sa = sa_new;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//init</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">vector</span>&lt;Node&gt;A(n);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)A[i] = Node(s[i],i);</span><br><span class="line">			sort(A.begin(),A.end());</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)sa[i] = A[i].b;</span><br><span class="line">			c[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">				c[sa[i]] = c[sa[i<span class="number">-1</span>]] + (A[i].a != A[i<span class="number">-1</span>].a);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;k) &lt; n)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)sa[i] = (sa[i] - (<span class="number">1</span>&lt;&lt;k) + n)%n;</span><br><span class="line">			count_sort(sa,c);</span><br><span class="line">			<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;c_new(n);</span><br><span class="line">			c_new[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">				pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;now = &#123;c[sa[i]],c[(sa[i] + (<span class="number">1</span>&lt;&lt;k)) % n]&#125;;</span><br><span class="line">				pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;prev = &#123;c[sa[i<span class="number">-1</span>]],c[(sa[i<span class="number">-1</span>] + (<span class="number">1</span>&lt;&lt;k)) % n]&#125;;</span><br><span class="line">				c_new[sa[i]] = c_new[sa[i<span class="number">-1</span>]] + (now != prev);</span><br><span class="line">			&#125;</span><br><span class="line">			k++;</span><br><span class="line">			c = c_new;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ST_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)ST[i][<span class="number">0</span>] = lcp[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j) &lt;= n;j++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;j) <span class="number">-1</span> &lt;= n;i++)</span><br><span class="line">				ST[i][j] = min(ST[i][j - <span class="number">1</span>],ST[i + (<span class="number">1</span>&lt;&lt;(j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">LCP</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">		L = c[L],R = c[R];</span><br><span class="line">		<span class="keyword">if</span>(L &gt; R)swap(L,R);</span><br><span class="line">		L++;</span><br><span class="line">		<span class="keyword">int</span> k = log2(R - L + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> min(ST[L][k],ST[R - (<span class="number">1</span>&lt;&lt;k) + <span class="number">1</span>][k]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getlcp</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> j = sa[c[i] - <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">while</span>(s[i+k] == s[j+k])k++;</span><br><span class="line">			lcp[c[i]] = k;</span><br><span class="line">			<span class="keyword">if</span>(k)k--;</span><br><span class="line">		&#125;</span><br><span class="line">		ST_init();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)<span class="built_in">printf</span>(<span class="string">"%d "</span>,sa[i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)<span class="built_in">printf</span>(<span class="string">"%d "</span>,lcp[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="built_in">string</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> k = x.size();</span><br><span class="line">		<span class="keyword">int</span> L = <span class="number">0</span>,R = n,M;</span><br><span class="line">		<span class="keyword">while</span>(L &lt; R)&#123;</span><br><span class="line">			M = (L+R)/<span class="number">2</span>;</span><br><span class="line">			<span class="built_in">string</span> u = s.substr(sa[M],k);</span><br><span class="line">			<span class="keyword">if</span>(u &gt;= x)R = M;</span><br><span class="line">			<span class="keyword">else</span> L = M+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> L;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">upper_bound</span><span class="params">(<span class="built_in">string</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> k = x.size();</span><br><span class="line">		<span class="keyword">int</span> L = <span class="number">0</span>,R = n,M;</span><br><span class="line">		<span class="keyword">while</span>(L &lt; R)&#123;</span><br><span class="line">			M = (L+R)/<span class="number">2</span>;</span><br><span class="line">			<span class="built_in">string</span> u = s.substr(sa[M],k);</span><br><span class="line">			<span class="keyword">if</span>(u &lt;= x)L = M+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> R = M;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> L;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="built_in">string</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> upper_bound(x) - lower_bound(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>附上个不用vector的,留着给POJ这种0202年还不兹磁C++11的OJ用(注意下标依旧从0开始)</p>
<p><strong>如果T了的话把pair改成自己写的结构体.pair排序很慢</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sa[maxn],pos[maxn],cnt[maxn],sa_new[maxn],c[maxn],c_new[maxn];</span><br><span class="line">pair&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;A[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SA</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//init</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)A[i] = &#123;s[i],i&#125;;</span><br><span class="line">		sort(A,A+n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)sa[i] = A[i].second;</span><br><span class="line">		c[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">			c[sa[i]] = c[sa[i<span class="number">-1</span>]] + (A[i].first != A[i<span class="number">-1</span>].first);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;k) &lt; n)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)sa[i] = (sa[i] - (<span class="number">1</span>&lt;&lt;k) + n)%n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)cnt[i] = pos[i] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)cnt[c[i]]++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)pos[i] = pos[i<span class="number">-1</span>] + cnt[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)sa_new[pos[c[sa[i]]]++] = sa[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)sa[i] = sa_new[i];</span><br><span class="line">		c_new[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">			c_new[sa[i]] = c_new[sa[i<span class="number">-1</span>]] + (c[sa[i]] != c[sa[i<span class="number">-1</span>]] <span class="keyword">or</span> c[(sa[i] + (<span class="number">1</span>&lt;&lt;k)) % n] != c[(sa[i<span class="number">-1</span>] + (<span class="number">1</span>&lt;&lt;k)) % n]);</span><br><span class="line">		&#125;</span><br><span class="line">		k++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)c[i] = c_new[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="循环拼接"><a href="#循环拼接" class="headerlink" title="循环拼接"></a>循环拼接</h4><p>对字符串$s$的每个循环节进行排序</p>
<p>例如 <code>s = &quot;abacba&quot;</code></p>
<p>即为对<code>&quot;abacba&quot;,&quot;bacbaa&quot;,&quot;acbaab&quot;,&quot;cbaaba&quot;,&quot;baabac&quot;,&quot;aabacb&quot;</code>进行排序</p>
<p>解法:将字符串本身拼接在其后面, 求$s+s$的后缀数组即可.</p>
<h4 id="在线模式匹配"><a href="#在线模式匹配" class="headerlink" title="在线模式匹配"></a>在线模式匹配</h4><p>每个字符串均为某些字符串的后缀的前缀. 假设模式串为$t$, 长度为$|t|$, 那么我们只需根据后缀数组在文本串$s$中找到长度为$|k|$的后缀的前缀, 二分即可</p>
<p>每次查找复杂度:$O(|t|logn)$</p>
<p>文本串为$s$, 模式串为$t$.调用<code>check(t)</code>即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="built_in">string</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = x.size();</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>,R = n,M;</span><br><span class="line">    <span class="keyword">while</span>(L &lt;= R)&#123;</span><br><span class="line">        M = (L+R)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">string</span> u = s.substr(sa[M],k);</span><br><span class="line">        <span class="keyword">if</span>(u == x)<span class="keyword">return</span> sa[M];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(u &lt; x)L = M+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> R = M<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="统计字符串t在s中出现次数-可重叠"><a href="#统计字符串t在s中出现次数-可重叠" class="headerlink" title="统计字符串t在s中出现次数(可重叠)"></a>统计字符串t在s中出现次数(可重叠)</h4><p>思想同上.二分出上下界即可</p>
<p>代码见模板部分的<code>count()</code></p>
<h4 id="从字符串首尾取字符-使新串字典序最小"><a href="#从字符串首尾取字符-使新串字典序最小" class="headerlink" title="从字符串首尾取字符, 使新串字典序最小"></a>从字符串首尾取字符, 使新串字典序最小</h4><p>当首尾字符不等时,显然取最小的最优.</p>
<p>当首尾字符相等时,需要判断由$L$开始的子串和由$R$开始的反子串的字典序大小,并取其中小的那个.</p>
<p>暴力求最坏需要$O(n)$, 而后缀数组可以做到$O(1)$判断. 我们在$s$后加上一个$s$中未出现的字符,再将$s$反转之后的$s’$拼在其后.对新的$s|s’$求后缀数组. </p>
<p>由$L$开始的子串排名为$rank[L]$, 由$R$开始的反子串排名为$rank[N - 2 - R]$. ($N$为$s|s’$的长度. -2是因为我们在两个串中间拼接了一个特殊字符)</p>
<p>例题:[USACO07DEC]Best Cow Line G</p>
<p>输入一个整数$n$,接下来$n$行每行一个字符.</p>
<p>输出从字符串首尾取字符, 能得到的最小字典序的新串.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P2870</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SA</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;sa,c;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">count_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; sa,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; c)</span></span>&#123;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;pos(n),cnt(n),sa_new(n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x:c)cnt[x]++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)pos[i] = pos[i<span class="number">-1</span>] + cnt[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x:sa)&#123;</span><br><span class="line">			<span class="keyword">int</span> d = c[x];</span><br><span class="line">			sa_new[pos[d]] = x;</span><br><span class="line">			pos[d]++;</span><br><span class="line">		&#125;</span><br><span class="line">		sa = sa_new;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)sa.push_back(<span class="number">0</span>),c.push_back(<span class="number">0</span>);</span><br><span class="line">		<span class="comment">//init</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; &gt;A(n);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)A[i] = &#123;s[i],i&#125;;</span><br><span class="line">			sort(A.begin(),A.end());</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)sa[i] = A[i].second;</span><br><span class="line">			c[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">				c[sa[i]] = c[sa[i<span class="number">-1</span>]] + (A[i].first != A[i<span class="number">-1</span>].first);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;k) &lt; n)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)sa[i] = (sa[i] - (<span class="number">1</span>&lt;&lt;k) + n)%n;</span><br><span class="line">			count_sort(sa,c);</span><br><span class="line">			<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;c_new(n);</span><br><span class="line">			c_new[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">				pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;now = &#123;c[sa[i]],c[(sa[i] + (<span class="number">1</span>&lt;&lt;k)) % n]&#125;;</span><br><span class="line">				pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;prev = &#123;c[sa[i<span class="number">-1</span>]],c[(sa[i<span class="number">-1</span>] + (<span class="number">1</span>&lt;&lt;k)) % n]&#125;;</span><br><span class="line">				c_new[sa[i]] = c_new[sa[i<span class="number">-1</span>]] + (now != prev);</span><br><span class="line">			&#125;</span><br><span class="line">			k++;</span><br><span class="line">			c = c_new;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)<span class="built_in">printf</span>(<span class="string">"%d "</span>,sa[i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,N;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)<span class="built_in">cin</span> &gt;&gt; s[i];</span><br><span class="line">	s[n] = <span class="string">'|'</span>;</span><br><span class="line">	<span class="keyword">int</span> idx = n+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)s[idx++] = s[i];</span><br><span class="line">	N = <span class="number">2</span>*(n+<span class="number">1</span>);</span><br><span class="line">	SA yay;</span><br><span class="line">	yay.n = N;</span><br><span class="line">	yay.cal();</span><br><span class="line">	<span class="keyword">int</span> L = <span class="number">0</span>,R = n<span class="number">-1</span>,cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(L &lt;= R)&#123;</span><br><span class="line">		<span class="keyword">if</span>(yay.c[L] &lt; yay.c[N - <span class="number">2</span> - R])<span class="built_in">cout</span> &lt;&lt; s[L++];</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; s[R--];</span><br><span class="line">		cnt++;</span><br><span class="line">		<span class="keyword">if</span>(cnt%<span class="number">80</span> == <span class="number">0</span>)<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LCP的应用"><a href="#LCP的应用" class="headerlink" title="LCP的应用"></a>LCP的应用</h3><h4 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h4><p>给出两个字符串$s,t$, 求它们的最长公共连续子串.</p>
<p>我们在$s$和$t$之间拼接一个未出现的特殊字符, 然后求LCP.将后缀分为两类:从$s$开始的后缀和从$t$开始的.显然答案为$\max{LCP[i]},i与i-1为不同类$</p>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P-5-B </span></span><br><span class="line"><span class="comment">//SA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SA</span>&#123;</span></span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;sa,c;</span><br><span class="line">	<span class="keyword">int</span> lcp[maxn],ST[maxn][<span class="number">20</span>];</span><br><span class="line">	SA(<span class="built_in">string</span> s = <span class="string">""</span>):s(s)&#123;</span><br><span class="line">		s += <span class="string">'$'</span>;</span><br><span class="line">		n = s.size();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)sa.push_back(<span class="number">0</span>),c.push_back(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">count_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; sa,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; c)</span></span>&#123;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;pos(n),cnt(n),sa_new(n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x:c)cnt[x]++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)pos[i] = pos[i<span class="number">-1</span>] + cnt[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x:sa)&#123;</span><br><span class="line">			<span class="keyword">int</span> d = c[x];</span><br><span class="line">			sa_new[pos[d]] = x;</span><br><span class="line">			pos[d]++;</span><br><span class="line">		&#125;</span><br><span class="line">		sa = sa_new;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//init</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; &gt;A(n);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)A[i] = &#123;s[i],i&#125;;</span><br><span class="line">			sort(A.begin(),A.end());</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)sa[i] = A[i].second;</span><br><span class="line">			c[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">				c[sa[i]] = c[sa[i<span class="number">-1</span>]] + (A[i].first != A[i<span class="number">-1</span>].first);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;k) &lt; n)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)sa[i] = (sa[i] - (<span class="number">1</span>&lt;&lt;k) + n)%n;</span><br><span class="line">			count_sort(sa,c);</span><br><span class="line">			<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;c_new(n);</span><br><span class="line">			c_new[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">				pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;now = &#123;c[sa[i]],c[(sa[i] + (<span class="number">1</span>&lt;&lt;k)) % n]&#125;;</span><br><span class="line">				pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;prev = &#123;c[sa[i<span class="number">-1</span>]],c[(sa[i<span class="number">-1</span>] + (<span class="number">1</span>&lt;&lt;k)) % n]&#125;;</span><br><span class="line">				c_new[sa[i]] = c_new[sa[i<span class="number">-1</span>]] + (now != prev);</span><br><span class="line">			&#125;</span><br><span class="line">			k++;</span><br><span class="line">			c = c_new;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ST_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)ST[i][<span class="number">0</span>] = lcp[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j) &lt;= n;j++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;j) <span class="number">-1</span> &lt;= n;i++)</span><br><span class="line">				ST[i][j] = min(ST[i][j - <span class="number">1</span>],ST[i + (<span class="number">1</span>&lt;&lt;(j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">LCP</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">		L = c[L],R = c[R];</span><br><span class="line">		<span class="keyword">if</span>(L &gt; R)swap(L,R);</span><br><span class="line">		L++;</span><br><span class="line">		<span class="keyword">int</span> k = log2(R - L + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> min(ST[L][k],ST[R - (<span class="number">1</span>&lt;&lt;k) + <span class="number">1</span>][k]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getlcp</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> j = sa[c[i] - <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">while</span>(s[i+k] == s[j+k])k++;</span><br><span class="line">			lcp[c[i]] = k;</span><br><span class="line">			<span class="keyword">if</span>(k)k--;</span><br><span class="line">		&#125;</span><br><span class="line">		ST_init();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> idx = <span class="number">0</span>,len = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> now = n - <span class="number">1</span> - sa[i],pre = n - <span class="number">1</span> - sa[i<span class="number">-1</span>];</span><br><span class="line">			<span class="keyword">if</span>((pre &gt; b <span class="keyword">and</span> now &lt;= b) <span class="keyword">or</span> (pre &lt;= b <span class="keyword">and</span> now &gt; b))&#123;</span><br><span class="line">				<span class="keyword">if</span>(len &lt; lcp[i])&#123;</span><br><span class="line">					idx = sa[i];len = lcp[i];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; s.substr(idx,len);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="built_in">string</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> k = x.size();</span><br><span class="line">		<span class="keyword">int</span> L = <span class="number">0</span>,R = n,M;</span><br><span class="line">		<span class="keyword">while</span>(L &lt; R)&#123;</span><br><span class="line">			M = (L+R)/<span class="number">2</span>;</span><br><span class="line">			<span class="built_in">string</span> u = s.substr(sa[M],k);</span><br><span class="line">			<span class="keyword">if</span>(u &gt;= x)R = M;</span><br><span class="line">			<span class="keyword">else</span> L = M+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> L;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">upper_bound</span><span class="params">(<span class="built_in">string</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> k = x.size();</span><br><span class="line">		<span class="keyword">int</span> L = <span class="number">0</span>,R = n,M;</span><br><span class="line">		<span class="keyword">while</span>(L &lt; R)&#123;</span><br><span class="line">			M = (L+R)/<span class="number">2</span>;</span><br><span class="line">			<span class="built_in">string</span> u = s.substr(sa[M],k);</span><br><span class="line">			<span class="keyword">if</span>(u &lt;= x)L = M+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> R = M;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> L;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="built_in">string</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> upper_bound(x) - lower_bound(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> s,t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; s &gt;&gt; t;</span><br><span class="line">	a = s.size(),b = t.size();</span><br><span class="line">	s = s+<span class="string">'#'</span>+t;</span><br><span class="line">	<span class="function">SA <span class="title">yay</span><span class="params">(s)</span></span>;</span><br><span class="line">	yay.cal();</span><br><span class="line">	yay.getlcp();</span><br><span class="line">	yay.output();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="两子串最长公共前缀"><a href="#两子串最长公共前缀" class="headerlink" title="两子串最长公共前缀"></a>两子串最长公共前缀</h4><script type="math/tex; mode=display">
LCP(sa[i],sa[j]) = min\{lcp[i+1],...,lcp[j]\}</script><p>于是就转化成了RMQ问题.</p>
<p>具体代码见模板中的<code>LCP()</code></p>
<h4 id="比较一个字符中两子串的关系"><a href="#比较一个字符中两子串的关系" class="headerlink" title="比较一个字符中两子串的关系"></a>比较一个字符中两子串的关系</h4><p>设需要比较$A = s[a…b]$和$B = s[c…d]$的关系.</p>
<p>若$lcp(a,c) \ge \min(|A|,|B|)$,则$A &lt; B$等价于$|A| &lt; |B|$</p>
<p>否则, $A &lt; B$等价于$rank[a] &lt; rank[b]$</p>
<h4 id="不同子串的数目"><a href="#不同子串的数目" class="headerlink" title="不同子串的数目"></a>不同子串的数目</h4><script type="math/tex; mode=display">
\frac{n(n+1)}{2} - \sum_{i = 1}^n lcp[i]</script><p>怎么推的忘了</p>
<h4 id="出现至少k次的子串的最大长度"><a href="#出现至少k次的子串的最大长度" class="headerlink" title="出现至少k次的子串的最大长度"></a>出现至少k次的子串的最大长度</h4><p>首先$lcp[i]$表示$sa[i]$和$sa[i-1]$的最大公共长度</p>
<p>那么相邻的$k-1$个$lcp$的最小值就是该子串出现$k$次的最大公共长度.</p>
<p>所以我们求出相邻$k-1$个$lcp$的最小值, 再求这些最小值的最大值就是答案</p>
<p>可以用单调队列或者单调栈在$O(n)$时间内解决.</p>
<p>例题: [USACO06DEC]Milk Patterns G</p>
<p>输入第一行为$n,k$ $n$为字符串长度,$k$为出现至少$k$次</p>
<p>下面的$n$行每行一个数字.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P2852 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,s[maxn];</span><br><span class="line"><span class="keyword">int</span> sa[maxn],pos[maxn],cnt[maxn],sa_new[maxn],c[maxn],c_new[maxn],lcp[maxn];</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;A[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SA</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)A[i] = &#123;s[i],i&#125;;</span><br><span class="line">	sort(A,A+n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)sa[i] = A[i].second;</span><br><span class="line">	c[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">		c[sa[i]] = c[sa[i<span class="number">-1</span>]] + (A[i].first != A[i<span class="number">-1</span>].first);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;k) &lt; n)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)sa[i] = (sa[i] - (<span class="number">1</span>&lt;&lt;k) + n)%n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)cnt[i] = pos[i] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)cnt[c[i]]++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)pos[i] = pos[i<span class="number">-1</span>] + cnt[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)sa_new[pos[c[sa[i]]]++] = sa[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)sa[i] = sa_new[i];</span><br><span class="line">		c_new[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">			c_new[sa[i]] = c_new[sa[i<span class="number">-1</span>]] + (c[sa[i]] != c[sa[i<span class="number">-1</span>]] <span class="keyword">or</span> c[(sa[i] + (<span class="number">1</span>&lt;&lt;k)) % n] != c[(sa[i<span class="number">-1</span>] + (<span class="number">1</span>&lt;&lt;k)) % n]);</span><br><span class="line">		&#125;</span><br><span class="line">		k++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)c[i] = c_new[i];</span><br><span class="line">	&#125;</span><br><span class="line">	k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> j = sa[c[i] - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">while</span>(s[i+k] == s[j+k])k++;</span><br><span class="line">		lcp[c[i]] = k;</span><br><span class="line">		<span class="keyword">if</span>(k)k--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> w,idx;</span><br><span class="line">	Node(<span class="keyword">int</span> w = <span class="number">0</span>,<span class="keyword">int</span> idx = <span class="number">0</span>):w(w),idx(idx)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">deque</span>&lt;Node&gt;qmin;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> K;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;K);</span><br><span class="line">	K--;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;s[i]);</span><br><span class="line">	s[n] = <span class="number">-1</span>;</span><br><span class="line">	n++;</span><br><span class="line">	SA();</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">		Node u = Node(lcp[i],i);</span><br><span class="line">		<span class="keyword">while</span>(qmin.size() <span class="keyword">and</span> qmin.back().w &gt; u.w)qmin.pop_back();</span><br><span class="line">		qmin.push_back(u);</span><br><span class="line">		<span class="keyword">while</span>(qmin.size() <span class="keyword">and</span> qmin.front().idx &lt; i - K + <span class="number">1</span>)qmin.pop_front();</span><br><span class="line">		<span class="keyword">if</span>(i &gt;= K)ans = max(ans,qmin.front().w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><p>待补充.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> siz = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> nxt[maxn][<span class="number">30</span>];</span><br><span class="line">	<span class="keyword">int</span> vis[maxn];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">		siz = <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">memset</span>(nxt,<span class="number">0</span>,<span class="keyword">sizeof</span>(nxt));</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x:s)&#123;</span><br><span class="line">			<span class="keyword">int</span> c = x - <span class="string">'0'</span>;</span><br><span class="line">			<span class="keyword">if</span>(!nxt[u][c])&#123;</span><br><span class="line">				nxt[u][c] = siz++;</span><br><span class="line">			&#125;</span><br><span class="line">			u = nxt[u][c];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x:s)&#123;</span><br><span class="line">			<span class="keyword">int</span> c = x - <span class="string">'0'</span>;</span><br><span class="line">			<span class="keyword">if</span>(!nxt[u][c])&#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"WRONG\n"</span>;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			u = nxt[u][c];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(vis[u])<span class="built_in">cout</span> &lt;&lt; <span class="string">"REPEAT\n"</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"OK\n"</span>;</span><br><span class="line">			vis[u] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;trie;</span><br></pre></td></tr></table></figure>
<h1 id="暴力就完事了"><a href="#暴力就完事了" class="headerlink" title="暴力就完事了"></a>暴力就完事了</h1><h2 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h2><p>因为分块细节很多,这里只放几道例题.</p>
<h3 id="区间加法-单点查询"><a href="#区间加法-单点查询" class="headerlink" title="区间加法,单点查询"></a>区间加法,单点查询</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//LOJ6277 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZ = <span class="number">256</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt;block[maxn];</span><br><span class="line"><span class="keyword">int</span> bnt[maxn];</span><br><span class="line">ll add[maxn],raw[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(bnt[L] == bnt[R])&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = L;i &lt;= R;i++)raw[i] += w;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = L;i &lt;= bnt[L]*SIZ;i++)raw[i] += w;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = (bnt[R]<span class="number">-1</span>)*SIZ+<span class="number">1</span>;i &lt;= R;i++)raw[i] += w;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = bnt[L]+<span class="number">1</span>;i &lt; bnt[R];i++)add[i] += w;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> raw[x] + add[(x<span class="number">-1</span>)/SIZ+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; maxn;i++)bnt[i] = (i<span class="number">-1</span>)/SIZ+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)<span class="built_in">cin</span> &gt;&gt; raw[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> o,l,r,w;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; o &gt;&gt; l &gt;&gt; r &gt;&gt; w;</span><br><span class="line">		<span class="keyword">if</span>(o)<span class="built_in">cout</span> &lt;&lt; query(r) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> update(l,r,w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态逆序对"><a href="#动态逆序对" class="headerlink" title="动态逆序对"></a>动态逆序对</h3><p>现在给出 1到n 的一个排列，按照某种顺序依次删除 m 个元素，你的任务是在每次删除一个元素<strong>之前</strong>统计整个序列的逆序对数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P3157 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZ = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> bnt[maxn],raw[maxn],A[maxn];</span><br><span class="line"><span class="keyword">int</span> BIT[maxn],n,m,maxb;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;Block[maxn];</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b&amp;-b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(index &lt;= n)&#123;</span><br><span class="line">		BIT[index] += d;</span><br><span class="line">		index += lowbit(index);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t_ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(index)&#123;</span><br><span class="line">		t_ans += BIT[index];</span><br><span class="line">		index -= lowbit(index);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t_ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;raw[i]);</span><br><span class="line">		bnt[i] = (i<span class="number">-1</span>)/SIZ+<span class="number">1</span>;</span><br><span class="line">		A[raw[i]] = i;</span><br><span class="line">		Block[bnt[i]].push_back(raw[i]);</span><br><span class="line">		ans += (i<span class="number">-1</span>-sum(raw[i]));</span><br><span class="line">		add(raw[i],<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	maxb = (n<span class="number">-1</span>)/SIZ+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= maxb;i++)sort(Block[i].begin(),Block[i].end());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> b = (A[x]<span class="number">-1</span>)/SIZ+<span class="number">1</span>,k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; b;i++)k += (Block[i].size() - (lower_bound(Block[i].begin(),Block[i].end(),x) - Block[i].begin()));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = b+<span class="number">1</span>;i &lt;= maxb;i++)k += lower_bound(Block[i].begin(),Block[i].end(),x) - Block[i].begin();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = (b<span class="number">-1</span>)*SIZ+<span class="number">1</span>;i &lt; A[x];i++)<span class="keyword">if</span>(raw[i] <span class="keyword">and</span> raw[i] &gt; x)k++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = A[x];i &lt;= b*SIZ;i++)<span class="keyword">if</span>(raw[i] <span class="keyword">and</span> raw[i] &lt; x)k++;</span><br><span class="line">	<span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> b = (A[x]<span class="number">-1</span>)/SIZ+<span class="number">1</span>;</span><br><span class="line">	raw[A[x]] = <span class="number">0</span>;</span><br><span class="line">	A[x] = <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> it = Block[b].begin();it != Block[b].end();it++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(*it == x)&#123;</span><br><span class="line">			Block[b].erase(it);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	init();</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="keyword">int</span> x;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">		ans -= query(x);</span><br><span class="line">		del(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h2><h3 id="基础莫队-小B的询问-Luogu-P2709"><a href="#基础莫队-小B的询问-Luogu-P2709" class="headerlink" title="基础莫队(小B的询问,Luogu P2709)"></a>基础莫队(小B的询问,Luogu P2709)</h3><p>求$\sum<em>{i = 1}^kc</em>{i}^2$</p>
<p>$c_i$为$i$在$[L,R]$的出现次数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P2709</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZ = <span class="number">512</span>;</span><br><span class="line">ll cnt[maxn],res[maxn],raw[maxn],ans;</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> L,R,idx;</span><br><span class="line">	Node(<span class="keyword">int</span> L = <span class="number">0</span>,<span class="keyword">int</span> R = <span class="number">0</span>,<span class="keyword">int</span> idx = <span class="number">0</span>):L(L),R(R),idx(idx)&#123;&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp; x)<span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>((L<span class="number">-1</span>)/SIZ != (x.L<span class="number">-1</span>)/SIZ)<span class="keyword">return</span> (L<span class="number">-1</span>) &lt; (x.L<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> R &lt; x.R;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;query[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> v = raw[pos];</span><br><span class="line">	<span class="keyword">if</span>(x == <span class="number">1</span>)ans += cnt[v]*<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> ans += <span class="number">1</span> - cnt[v]*<span class="number">2</span>;</span><br><span class="line">	cnt[v] += x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)<span class="built_in">cin</span> &gt;&gt; raw[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> L,R;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; L &gt;&gt; R;</span><br><span class="line">		query[i] = Node(L,R,i);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(query+<span class="number">1</span>,query+m+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">1</span>,r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(l &gt; query[i].L)update(--l,<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">while</span>(r &lt; query[i].R)update(++r,<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">while</span>(l &lt; query[i].L)update(l++,<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">while</span>(r &gt; query[i].R)update(r--,<span class="number">-1</span>);</span><br><span class="line">		res[query[i].idx] = ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)<span class="built_in">cout</span> &lt;&lt; res[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>奇偶排序优化:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp; x)<span class="keyword">const</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>((l<span class="number">-1</span>)/SIZ != (x.l<span class="number">-1</span>)/SIZ)<span class="keyword">return</span> l &lt; x.l;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(((l<span class="number">-1</span>)/SIZ+<span class="number">1</span>)%<span class="number">2</span>)<span class="keyword">return</span> r &lt; x.r;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> r &gt; x.r; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="带修莫队"><a href="#带修莫队" class="headerlink" title="带修莫队"></a>带修莫队</h3><p>分块大小取$n^{\frac{2}{3}}$</p>
<p>例题:P1903 [国家集训队]数颜色 / 维护队列</p>
<p>1、 Q L R代表询问你从第L支画笔到第R支画笔中共有几种不同颜色的画笔。</p>
<p>2、 R P Col 把第P支画笔替换为颜色Col。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P1903-Mo </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZ = <span class="number">2607</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> raw[maxn],cnt[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> l,r,idx,t,ans;</span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Query &amp; x) <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>((l<span class="number">-1</span>)/SIZ != (x.l<span class="number">-1</span>)/SIZ)<span class="keyword">return</span> l &lt; x.l;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>((r<span class="number">-1</span>)/SIZ != (x.r<span class="number">-1</span>)/SIZ)&#123;</span><br><span class="line">			<span class="keyword">if</span>(((l<span class="number">-1</span>)/SIZ)%<span class="number">2</span>)<span class="keyword">return</span> r &lt; x.r;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">return</span> r &gt; x.r;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> t &lt; x.t;	</span><br><span class="line">	&#125;</span><br><span class="line">	Query(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> idx,<span class="keyword">int</span> t):l(l),r(r),idx(idx),t(t)&#123;&#125;</span><br><span class="line">	Query(<span class="keyword">int</span> idx = <span class="number">0</span>,<span class="keyword">int</span> v = <span class="number">0</span>):idx(idx),v(v)&#123;&#125;</span><br><span class="line">&#125;query[maxn],op[maxn];</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!cnt[x])ans++;</span><br><span class="line">	cnt[x]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">1</span> == cnt[x])ans--;</span><br><span class="line">	cnt[x]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> tim,<span class="keyword">int</span> qidx)</span></span>&#123;</span><br><span class="line">	<span class="comment">//opt :1,re 0,add</span></span><br><span class="line">	<span class="keyword">int</span> l = query[qidx].l,r = query[qidx].r,x = op[tim].idx;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= x <span class="keyword">and</span> x &lt;= r)&#123;</span><br><span class="line">		del(raw[x]);</span><br><span class="line">		add(op[tim].v);</span><br><span class="line">	&#125;</span><br><span class="line">	swap(raw[x],op[tim].v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;raw[i]);</span><br><span class="line">	<span class="keyword">int</span> ocnt = <span class="number">0</span>,qcnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">		<span class="built_in">string</span> opt;</span><br><span class="line">		<span class="keyword">int</span> l,r;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; opt;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line">		<span class="keyword">if</span>(opt == <span class="string">"Q"</span>)&#123;</span><br><span class="line">			qcnt++;</span><br><span class="line">			query[qcnt] = Query(l,r,qcnt,ocnt);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> op[++ocnt] = Query(l,r);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(query+<span class="number">1</span>,query+qcnt+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">1</span>,r = <span class="number">0</span>,now = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= qcnt;i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(l &lt; query[i].l)del(raw[l++]);</span><br><span class="line">		<span class="keyword">while</span>(l &gt; query[i].l)add(raw[--l]);</span><br><span class="line">		<span class="keyword">while</span>(r &gt; query[i].r)del(raw[r--]);</span><br><span class="line">		<span class="keyword">while</span>(r &lt; query[i].r)add(raw[++r]);</span><br><span class="line">		<span class="keyword">while</span>(now &lt; query[i].t)change(++now,i);</span><br><span class="line">		<span class="keyword">while</span>(now &gt; query[i].t)change(now--,i);</span><br><span class="line">		query[i].ans = ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span> cmp = [](Query a,Query b) -&gt; <span class="keyword">bool</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a.idx &lt; b.idx;</span><br><span class="line">	&#125;;</span><br><span class="line">	sort(query+<span class="number">1</span>,query+qcnt+<span class="number">1</span>,cmp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= qcnt;i++)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query[i].ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>路径压缩,无按秩合并<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int father[maxn];</span><br><span class="line">void init()&#123;</span><br><span class="line">	for(int i &#x3D; 1;i &lt;&#x3D; n;i++)father[i] &#x3D; i;</span><br><span class="line">&#125;</span><br><span class="line">int findset(int e)&#123;</span><br><span class="line">	return father[e] &#x3D;&#x3D; e?e:father[e] &#x3D; findset(father[e]);</span><br><span class="line">&#125;</span><br><span class="line">inline void un(int x,int y)&#123;</span><br><span class="line">	father[findset(x)] &#x3D; findset(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>路径压缩, 按秩合并</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> fa[maxn],siz[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findset</span><span class="params">(<span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> fa[e] == e?e:fa[e] = findset(fa[e]); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">un</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	a = findset(a),b = findset(b);</span><br><span class="line">	<span class="keyword">if</span>(siz[a] &gt; siz[b])swap(a,b);</span><br><span class="line">	siz[b] += a;</span><br><span class="line">	<span class="comment">// fa[a] = fa[b];</span></span><br><span class="line">	fa[a] = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> findset(a) == findset(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> fa[maxn],siz[maxn],maxv[maxn],minv[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findset</span><span class="params">(<span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> fa[e] == e?e:fa[e] = findset(fa[e]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> findset(a) == findset(b);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">un</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(check(a,b))<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> &amp; v = fa[findset(a)],u = findset(b);</span><br><span class="line">	siz[u] += siz[v];</span><br><span class="line">	maxv[u] = max(maxv[u],maxv[v]);</span><br><span class="line">	minv[u] = min(minv[u],minv[v]);</span><br><span class="line">	v = u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int lower_bound(int &amp; A,int x)&#123;</span><br><span class="line">	int L &#x3D; 0,R &#x3D; n,M;</span><br><span class="line">	while(L &lt; R)&#123;</span><br><span class="line">		M &#x3D; (L+R)&#x2F;2;</span><br><span class="line">		if(A[M] &gt;&#x3D; x)R &#x3D; M;</span><br><span class="line">		else L &#x3D; M+1;</span><br><span class="line">	&#125;</span><br><span class="line">	return L;</span><br><span class="line">&#125;</span><br><span class="line">int upper_bound(int &amp; A,int x)&#123;</span><br><span class="line">	int L &#x3D; 0,R &#x3D; n,M;</span><br><span class="line">	while(L &lt; R)&#123;</span><br><span class="line">		M &#x3D; (L+R)&#x2F;2;</span><br><span class="line">		if(A[M] &lt;&#x3D; x)L &#x3D; M+1;&#x2F;&#x2F;区别在此</span><br><span class="line">		else R &#x3D; M;</span><br><span class="line">	&#125;</span><br><span class="line">	return L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><p>保证双端队列里的值单调即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">	Node u = Node(raw[i],i);</span><br><span class="line">	<span class="keyword">while</span>(qmin.size() <span class="keyword">and</span> qmin.back().w &gt; u.w)qmin.pop_back();</span><br><span class="line">	qmin.push_back(u);</span><br><span class="line">	<span class="keyword">while</span>(qmin.size() <span class="keyword">and</span> qmin.front().idx &lt; i - k + <span class="number">1</span>)qmin.pop_front();</span><br><span class="line">	<span class="keyword">if</span>(i &gt;= k)<span class="built_in">cout</span> &lt;&lt; qmin.front().w &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>[模板]图论</title>
    <url>/2020/05/09/template-graph-theory/</url>
    <content><![CDATA[<h2 id="建图"><a href="#建图" class="headerlink" title="建图"></a>建图</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = maxn*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn],pa[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> f,t,next;</span><br><span class="line">	Edge(<span class="keyword">int</span> f = <span class="number">0</span>,<span class="keyword">int</span> t = <span class="number">0</span>,<span class="keyword">int</span> next = <span class="number">0</span>):f(f),t(t),next(next)&#123;&#125;	</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="keyword">int</span> tcnt,cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	edge[cnt] = Edge(f,t,head[f]);</span><br><span class="line">	head[f] = cnt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h1><h2 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)dis[i] = INF;</span><br><span class="line">    q.push(s);</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        vis[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];i;i = edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dis[v] &gt; dis[u] + edge[i].w)&#123;</span><br><span class="line">                dis[v] = dis[u] + edge[i].w;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">                    vis[v] = <span class="number">1</span>;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> pair &lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; node;</span><br><span class="line">	priority_queue&lt;node,<span class="built_in">vector</span>&lt;node&gt;,greater&lt;node&gt; &gt;q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;=n;i++)dis[i] = INF;</span><br><span class="line">	dis[s] = <span class="number">0</span>;</span><br><span class="line">	q.push(make_pair(dis[s],s));</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		node tmp = q.top();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">int</span> u = tmp.second;</span><br><span class="line">		<span class="keyword">if</span>(vis[u])<span class="keyword">continue</span>;</span><br><span class="line">		vis[u] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">			<span class="keyword">if</span>(dis[v] &gt; dis[u] + edge[i].w)&#123;</span><br><span class="line">				dis[v] = dis[u] + edge[i].w;</span><br><span class="line">				<span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">					q.push(make_pair(dis[v],v));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h1><h2 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h2><h3 id="Edmonds-Karp"><a href="#Edmonds-Karp" class="headerlink" title="Edmonds-Karp"></a>Edmonds-Karp</h3><p>(慎用)<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn],parent[maxn],approve[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> from,to,next,w,cap,flow;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="keyword">int</span> n,m,start,to,cnt,ans;<span class="comment">//cnt = 0 so we can calculate "backedge" easily</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">int</span> cap,<span class="keyword">int</span> flow)</span></span>&#123;</span><br><span class="line">	edge[cnt].cap = cap;</span><br><span class="line">	edge[cnt].flow = flow;</span><br><span class="line">	edge[cnt].to = to;</span><br><span class="line">	edge[cnt].from = from;</span><br><span class="line">	edge[cnt].next = head[from];</span><br><span class="line">	head[from] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">	<span class="built_in">memset</span>(approve,<span class="number">0</span>,<span class="keyword">sizeof</span>(approve)); </span><br><span class="line">	q.push(s);</span><br><span class="line">	approve[s] = INF;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		<span class="keyword">int</span> u = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">			<span class="keyword">if</span>(!approve[v] <span class="keyword">and</span> edge[i].cap &gt; edge[i].flow)&#123;</span><br><span class="line">				parent[v] = i;</span><br><span class="line">				approve[v] = min(approve[u],edge[i].cap - edge[i].flow);</span><br><span class="line">				q.push(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(approve[t])<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> approve[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EK</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">int</span> delta = BFS(s,t);</span><br><span class="line">		<span class="keyword">if</span>(!delta)<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> u = t;u != s;u = edge[parent[u]].from)&#123;</span><br><span class="line">			<span class="keyword">int</span> curp = parent[u];</span><br><span class="line">			edge[curp].flow += delta;</span><br><span class="line">			edge[curp^<span class="number">1</span>].flow -= delta;</span><br><span class="line">		&#125;</span><br><span class="line">		flow += delta;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Dinic"><a href="#Dinic" class="headerlink" title="Dinic"></a>Dinic</h3><p>记得加上容量为0的反向弧=-=</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">addedge(f,t,w,<span class="number">0</span>);</span><br><span class="line">addedge(t,f,<span class="number">0</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> from,to,next,w,cap,flow;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="keyword">int</span> head[maxn],deep[maxn],vis[maxn],cur[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m,start,to,cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">int</span> cap,<span class="keyword">int</span> flow)</span></span>&#123;</span><br><span class="line">	edge[cnt].from = from;</span><br><span class="line">	edge[cnt].to = to;</span><br><span class="line">	edge[cnt].cap = cap;</span><br><span class="line">	edge[cnt].flow = flow;</span><br><span class="line">	edge[cnt].next = head[from];</span><br><span class="line">	head[from] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)cur[i] = head[i];</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">	q.push(s);</span><br><span class="line">	vis[s] = <span class="number">1</span>;</span><br><span class="line">	deep[s] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		<span class="keyword">int</span> u = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">			<span class="keyword">if</span>(!vis[v] <span class="keyword">and</span> edge[i].cap &gt; edge[i].flow)&#123;</span><br><span class="line">				vis[v] = <span class="number">1</span>;</span><br><span class="line">				deep[v] = deep[u] + <span class="number">1</span>;</span><br><span class="line">				q.push(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> t,<span class="keyword">int</span> approve)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(u == t <span class="keyword">or</span> approve == <span class="number">0</span>)<span class="keyword">return</span> approve;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>,delta = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = cur[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		cur[u] = i;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(deep[u] + <span class="number">1</span> == deep[v] <span class="keyword">and</span> (delta = DFS(v,t,min(approve,edge[i].cap - edge[i].flow))) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			edge[i].flow += delta;</span><br><span class="line">			edge[i^<span class="number">1</span>].flow -= delta;</span><br><span class="line">			flow += delta;approve -= delta;</span><br><span class="line">			<span class="keyword">if</span>(!approve)<span class="keyword">break</span>; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(BFS(s,t))&#123;</span><br><span class="line">		flow += DFS(s,t,INF);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最小费用最大流"><a href="#最小费用最大流" class="headerlink" title="最小费用最大流"></a>最小费用最大流</h2><p>全局变量flow为最大流,cost为最小费用</p>
<p>记得反向边容量为0费用为负=-=<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn],parent[maxn],approve[maxn],dis[maxn],vis[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> from,to,next,w,cap,flow,cost;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="keyword">int</span> n,m,start,to,cnt,ans,flow,cost;<span class="comment">//cnt = 0 so we can calculate "backedge" easily</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">int</span> cap,<span class="keyword">int</span> flow,<span class="keyword">int</span> cost)</span></span>&#123;</span><br><span class="line">	edge[cnt].cap = cap;</span><br><span class="line">	edge[cnt].cost = cost;</span><br><span class="line">	edge[cnt].flow = flow;</span><br><span class="line">	edge[cnt].to = to;</span><br><span class="line">	edge[cnt].from = from;</span><br><span class="line">	edge[cnt].next = head[from];</span><br><span class="line">	head[from] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)dis[i] = INF;</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">	<span class="built_in">memset</span>(approve,<span class="number">0</span>,<span class="keyword">sizeof</span>(approve)); </span><br><span class="line">	q.push(s);</span><br><span class="line">	approve[s] = INF;</span><br><span class="line">	dis[s] = <span class="number">0</span>;</span><br><span class="line">	vis[s] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		<span class="keyword">int</span> u = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		vis[u] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">			<span class="keyword">if</span>(dis[v] &gt; dis[u] + edge[i].cost <span class="keyword">and</span> edge[i].cap &gt; edge[i].flow)&#123;</span><br><span class="line">				parent[v] = i;</span><br><span class="line">				approve[v] = min(approve[u],edge[i].cap - edge[i].flow);</span><br><span class="line">				dis[v] = dis[u] + edge[i].cost;</span><br><span class="line">				<span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">					vis[v] = <span class="number">1</span>;</span><br><span class="line">					q.push(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		if(approve[t])break;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> approve[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EK</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line"><span class="comment">//	int flow = 0;</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">int</span> delta = spfa(s,t);</span><br><span class="line">		<span class="keyword">if</span>(!delta)<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> u = t;u != s;u = edge[parent[u]].from)&#123;</span><br><span class="line">			<span class="keyword">int</span> curp = parent[u];</span><br><span class="line">			edge[curp].flow += delta;</span><br><span class="line">			edge[curp^<span class="number">1</span>].flow -= delta;</span><br><span class="line">		&#125;</span><br><span class="line">		flow += delta;</span><br><span class="line">		cost += dis[t]*delta;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="二分图匹配"><a href="#二分图匹配" class="headerlink" title="二分图匹配"></a>二分图匹配</h1><h2 id="二分图最大匹配"><a href="#二分图最大匹配" class="headerlink" title="二分图最大匹配"></a>二分图最大匹配</h2><h3 id="网络流做法"><a href="#网络流做法" class="headerlink" title="网络流做法"></a>网络流做法</h3><p>建立超级源$S$和超级汇$T$, 从$S$向每个左端点连边, 每个右端点向$T$连边, 端点之间按给出的图连边, 边权均为1.</p>
<p>$S$到$T$的最大流就是最大匹配</p>
<h3 id="KM"><a href="#KM" class="headerlink" title="KM"></a>KM</h3><p>复杂度$O(nm)$</p>
<p><code>match[v]</code>为$v$的匹配点.</p>
<p>a为左端点点的个数, b为右端点点的个数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">KM</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">		<span class="keyword">if</span>(vis[v])<span class="keyword">continue</span>;</span><br><span class="line">		vis[v] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(!match[v] <span class="keyword">or</span> KM(match[v]))&#123;</span><br><span class="line">			match[v] = u;</span><br><span class="line">			match[u] = v;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">int</span> match_cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= a;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= a+b;j++)vis[j] = <span class="number">0</span>;</span><br><span class="line">		match_cnt += KM(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; match_cnt;</span><br></pre></td></tr></table></figure>
<h3 id="二分图最大点独立集"><a href="#二分图最大点独立集" class="headerlink" title="二分图最大点独立集"></a>二分图最大点独立集</h3><p>个数为顶点数-最大匹配数</p>
<h1 id="连通性与环"><a href="#连通性与环" class="headerlink" title="连通性与环"></a>连通性与环</h1><h2 id="割点"><a href="#割点" class="headerlink" title="割点"></a>割点</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dfn[u])<span class="keyword">return</span>;</span><br><span class="line">	dfn[u] = low[u] = dfsclock++;</span><br><span class="line">	<span class="keyword">int</span> child = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">			Tarjan(v,fa);</span><br><span class="line">			low[u] = min(low[v],low[u]);</span><br><span class="line">			<span class="keyword">if</span>(u == fa)child++;</span><br><span class="line">			<span class="keyword">if</span>(low[v] &gt;= dfn[u] <span class="keyword">and</span> u != fa)iscut[u] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		low[u] = min(low[u],dfn[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(fa == u <span class="keyword">and</span> child &gt; <span class="number">1</span>)iscut[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SCC-强连通分量"><a href="#SCC-强连通分量" class="headerlink" title="SCC/强连通分量"></a>SCC/强连通分量</h2><h3 id="Kosaraju"><a href="#Kosaraju" class="headerlink" title="Kosaraju"></a>Kosaraju</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> next,to,w;</span><br><span class="line"> &#125;edge[maxn],edgeT[maxn],edgeD[maxn];</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">     edge[cnt].to = to;</span><br><span class="line">     edge[cnt].next = head[from];</span><br><span class="line">     head[from] = cnt++;</span><br><span class="line">     edgeT[cntT].to = from;</span><br><span class="line">     edgeT[cntT].next = headT[to];</span><br><span class="line">     headT[to] = cntT++;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">     edgeD[cntD].to = to;</span><br><span class="line">     edgeD[cntD].w = w;</span><br><span class="line">     edgeD[cntD].next = headD[from];</span><br><span class="line">     headD[from] = cntD++;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">DFS1</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(vis[s])<span class="keyword">return</span>;</span><br><span class="line">	vis[s] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[s];~i;i = edge[i].next)DFS1(edge[i].to);</span><br><span class="line">	r_topo.push_back(s);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS2</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(sccno[s])<span class="keyword">return</span>;</span><br><span class="line">	sccno[s] = scccnt;</span><br><span class="line">	sccmin[scccnt] = min(sccmin[scccnt],pointw[s]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = headT[s];~i;i = edgeT[i].next)DFS2(edgeT[i].to);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findscc</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &amp;lt;= n;i++)DFS1(i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!sccno[r_topo[i]])&#123;</span><br><span class="line">			scccnt++;</span><br><span class="line">			DFS2(r_topo[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildmap</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">1</span>;u &amp;lt;= n;u++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">			<span class="keyword">if</span>(sccno[u] != sccno[v])&#123;</span><br><span class="line">				<span class="keyword">if</span>(!dup[pair&amp;lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(sccno[u],sccno[v])])&#123;</span><br><span class="line">					addedge(sccno[u],sccno[v],<span class="number">1</span>);</span><br><span class="line">					dup[pair&amp;lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(sccno[u],sccno[v])] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="桥"><a href="#桥" class="headerlink" title="桥"></a>桥</h2><p>一种比较好理解的求桥的方法 <strong>(注意无法用来求割顶</strong></p>
<p>$dp[u]$表示跨过$u$的反向边的数量.如果$dp[u] == 0$则$<fa,u>$为桥($fa$是$u$的父亲)</p>
<p>调用时需初始化$dep[root] = 1$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cal_bri</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	dp[u] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">		<span class="keyword">if</span>(v == fa)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(!dep[v])&#123;</span><br><span class="line">			dep[v] = dep[u]+<span class="number">1</span>;</span><br><span class="line">			Cal_bri(v,u);</span><br><span class="line">			dp[u] += dp[v];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(dep[v] &gt; dep[u])dp[u]--;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(dep[v] &lt; dep[u])&#123;</span><br><span class="line">				dp[u]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!dp[u] <span class="keyword">and</span> dep[u] &gt; <span class="number">1</span>)ok = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="仙人掌"><a href="#仙人掌" class="headerlink" title="仙人掌"></a>仙人掌</h2><p>(接上文)点仙人掌中求环并缩点</p>
<p>$backcnt$为全局变量,初始化为$n+1$(点的个数+1)</p>
<p>$phash[u]$返回环的标号,从$n+1$开始.若不在环内则$phash[u] == u$</p>
<p>调用时初始化$dep[root] = 1$,注意缩点后需要重新寻找根节点(缩点代码未给出)</p>
<p>原理参见<a href="https://codeforces.com/blog/entry/68138" target="_blank" rel="noopener">https://codeforces.com/blog/entry/68138</a> 这个东西应该找简单环都可以用(?<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cal_bri</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	dp[u] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">bool</span> ok = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = rhead[u];~i;i = redge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = redge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(v == fa)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(!dep[v])&#123;</span><br><span class="line">			dep[v] = dep[u]+<span class="number">1</span>;</span><br><span class="line">			Cal_bri(v,u);</span><br><span class="line">			dp[u] += dp[v];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(dep[v] &gt; dep[u])dp[u]--;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(dep[v] &lt; dep[u])&#123;</span><br><span class="line">				in[v]++;</span><br><span class="line">				dp[u]++;</span><br><span class="line">				ok = <span class="number">1</span>;</span><br><span class="line">				redge[i].cnt = ++backcnt;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ok)phash[u] = backcnt;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		phash[u] = u;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = rhead[u];~i;i = redge[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = redge[i].to;</span><br><span class="line">			<span class="keyword">if</span>(v == fa)<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(phash[v] != v <span class="keyword">and</span> !in[v])&#123;</span><br><span class="line">				phash[u] = phash[v];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="BFS求最小环"><a href="#BFS求最小环" class="headerlink" title="BFS求最小环"></a>BFS求最小环</h2><p>见代码=-=可以画个BFS树或者手模感悟一下</p>
<p>记得得枚举1…n的所有起点,所以复杂度是$O(n^2)$<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">	dis[s] = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;q;</span><br><span class="line">	q.push(make_pair(s,<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		<span class="keyword">auto</span> now = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">int</span> u = now.first,fa = now.second;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">			<span class="keyword">if</span>(v == fa)<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(dis[v] == <span class="number">-1</span>)&#123;</span><br><span class="line">				dis[v] = dis[u]+<span class="number">1</span>;</span><br><span class="line">				q.push(make_pair(v,u));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				ans = min(ans,dis[v]+dis[u]+<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Floyd求最小环"><a href="#Floyd求最小环" class="headerlink" title="Floyd求最小环"></a>Floyd求最小环</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> val[maxn + <span class="number">1</span>][maxn + <span class="number">1</span>];  <span class="comment">// 原图的邻接矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">floyd</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> dis[maxn + <span class="number">1</span>][maxn + <span class="number">1</span>];  <span class="comment">// 最短路矩阵</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) dis[i][j] = val[i][j];  <span class="comment">// 初始化最短路矩阵</span></span><br><span class="line">  <span class="keyword">int</span> ans = inf;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">        ans = <span class="built_in">std</span>::min(ans, dis[i][j] + val[i][k] + val[k][j]);  <span class="comment">// 更新答案</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        dis[i][j] = <span class="built_in">std</span>::min(</span><br><span class="line">            dis[i][j], dis[i][k] + dis[k][j]);  <span class="comment">// 正常的 floyd 更新最短路矩阵</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-SAT"><a href="#2-SAT" class="headerlink" title="2-SAT"></a>2-SAT</h1><p>参数a,x,b,y代表$x_a$为x或$x_b$为y x,y是bool<br>是的我知道这个变量起的很弱智<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P4782</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">4E6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> from,to,next;</span><br><span class="line">&#125;edge[maxm],edgeT[maxm];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;r_topo;</span><br><span class="line"><span class="keyword">int</span> scc_no[maxn],scc_cnt;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span>,cntT = <span class="number">1</span>,head[maxn],headT[maxn],n,m,q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	edge[cnt].from = f;</span><br><span class="line">	edge[cnt].to = t;</span><br><span class="line">	edge[cnt].next = head[f];</span><br><span class="line">	head[f] = cnt++;</span><br><span class="line">	edgeT[cntT].from = t;</span><br><span class="line">	edgeT[cntT].to = f;</span><br><span class="line">	edgeT[cntT].next = headT[t];</span><br><span class="line">	headT[t] = cntT++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS1</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(vis[u])<span class="keyword">return</span>;</span><br><span class="line">	vis[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		DFS1(edge[i].to);</span><br><span class="line">	&#125;</span><br><span class="line">	r_topo.push_back(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS2</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(scc_no[u])<span class="keyword">return</span>;</span><br><span class="line">	scc_no[u] = scc_cnt;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = headT[u];~i;i = edgeT[i].next)DFS2(edgeT[i].to);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findscc</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">2</span>*n;i++)DFS1(i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>*n<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!scc_no[r_topo[i]])&#123;</span><br><span class="line">			scc_cnt++;</span><br><span class="line">			DFS2(r_topo[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("P4782.in","r",stdin);</span></span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">	<span class="built_in">memset</span>(headT,<span class="number">-1</span>,<span class="keyword">sizeof</span>(headT));</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> a,b,x,y;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;a,&amp;x,&amp;b,&amp;y);</span><br><span class="line">		addedge(a+n*(x&amp;<span class="number">1</span>),b+n*(y^<span class="number">1</span>));</span><br><span class="line">		addedge(b+n*(y&amp;<span class="number">1</span>),a+n*(x^<span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	findscc();</span><br><span class="line">	<span class="keyword">bool</span> ok = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)<span class="keyword">if</span>(scc_no[i] == scc_no[i+n])&#123;</span><br><span class="line">		ok = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!ok)<span class="built_in">printf</span>(<span class="string">"IMPOSSIBLE"</span>);</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"POSSIBLE\n"</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)<span class="built_in">printf</span>(<span class="string">"%d "</span>,scc_no[i] &gt; scc_no[i+n]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="弦图"><a href="#弦图" class="headerlink" title="弦图"></a>弦图</h1><h2 id="完美消除序列"><a href="#完美消除序列" class="headerlink" title="完美消除序列"></a>完美消除序列</h2><p>此处完美消除序列的定义为: 令 $n=|V|$，完美消除序列 $v<em>1,v_2,\ldots ,v_n$ 为 $1,2,\ldots ,n$ 的一个排列，满足 $v_i$ 在 ${v_i,v</em>{i+1},\ldots ,v_n}$ 的导出子图中为单纯点. </p>
<p>注意该定义可能与部分论文顺序相反.</p>
<h3 id="最大势算法-MCS"><a href="#最大势算法-MCS" class="headerlink" title="最大势算法(MCS)"></a>最大势算法(MCS)</h3><h4 id="优先队列做法"><a href="#优先队列做法" class="headerlink" title="优先队列做法"></a>优先队列做法</h4><p>复杂度: $O((n+m)\log n)$</p>
<p>输入: $n$, 点数</p>
<p>$head[],edge[],cnt$, 无向图(全局变量)</p>
<p>使用的全局变量:$vis[]$</p>
<p>输出: <code>vector&lt;int&gt;</code>, 长度为$n$的完美消除序列.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">MCS</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;res;</span><br><span class="line">	priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;pq;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		label[i] = vis[i] = <span class="number">0</span>;</span><br><span class="line">		pq.push(&#123;<span class="number">0</span>,i&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> step = <span class="number">1</span>;step &lt;= n;step++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(pq.size())&#123;</span><br><span class="line">			<span class="keyword">int</span> u = pq.top().second;</span><br><span class="line">			pq.pop();</span><br><span class="line">			<span class="keyword">if</span>(!vis[u])&#123;</span><br><span class="line">				res.push_back(u);</span><br><span class="line">				vis[u] = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">					<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">					<span class="keyword">if</span>(vis[v])<span class="keyword">continue</span>;</span><br><span class="line">					label[v]++;</span><br><span class="line">					pq.push(&#123;label[v],v&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	reverse(res.begin(),res.end());</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="链表做法"><a href="#链表做法" class="headerlink" title="链表做法"></a>链表做法</h4><p>复杂度$O(n+m)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">MCS</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> best = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;res;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; &gt;link(n+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		label[i] = vis[i] = <span class="number">0</span>;</span><br><span class="line">		link[<span class="number">0</span>].push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> step = <span class="number">1</span>;step &lt;= n;step++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(best &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!link[best].size())&#123;</span><br><span class="line">				best--;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> u = link[best].front();</span><br><span class="line">			link[best].pop_front();</span><br><span class="line">			<span class="keyword">if</span>(!vis[u])&#123;</span><br><span class="line">				vis[u] = <span class="number">1</span>;</span><br><span class="line">				res.push_back(u);</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">					<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">					<span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">						label[v]++;</span><br><span class="line">						link[label[v]].push_back(v);</span><br><span class="line">						<span class="keyword">if</span>(label[v] &gt; best)best = label[v];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	reverse(res.begin(),res.end());</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="弦图最大独立集-最小团覆盖"><a href="#弦图最大独立集-最小团覆盖" class="headerlink" title="弦图最大独立集/最小团覆盖"></a>弦图最大独立集/最小团覆盖</h2><p>最大独立集: 从前往后遍历完美消除序列, 每次选取不在独立集且与独立集无邻边的点加入独立集中.</p>
<p>最小团覆盖: 设最大独立集为 ${v_1,v_2,\ldots ,v_t}$, 则团的集合${$  ${v_1+N(v_1)},{v_2+N(v_2)},… ,{v_t+N(v_t)}$ $}$为图的最小团覆盖. 时间复杂度均为 $O(n+m)$</p>
<h2 id="弦图的色数-弦图的团数"><a href="#弦图的色数-弦图的团数" class="headerlink" title="弦图的色数/弦图的团数"></a>弦图的色数/弦图的团数</h2><p>一种构造方法：按完美消除序列从后往前依次给每个点染色，给每个点染上可以染的最小颜色。时间复杂度 $O(m+n)$。</p>
<p>正确性证明：设以上方法使用了 $t$ 种颜色，则 $t\ge \chi(G)$。由于团上每个点都是不同的颜色，所以 $t=\omega(G)$，由 <strong>Lemma 1</strong>，$t=\omega(G)\le \chi(G)$。综上，可得 $t=\chi(G)=\omega(G)$。</p>
<p>无需染色方案，只需求出弦图的色数/团数时，可以取 $|{x}+N(x)|$ 的最大值得到。</p>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="最近公共祖先-LCA"><a href="#最近公共祖先-LCA" class="headerlink" title="最近公共祖先(LCA)"></a>最近公共祖先(LCA)</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> p[maxn][<span class="number">35</span>],dep[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(u == fa)<span class="keyword">return</span>;</span><br><span class="line">	dep[u] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">	p[u][<span class="number">0</span>] = fa;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;(<span class="number">1</span>&lt;&lt;i) &lt;= dep[u];i++)p[u][i] = p[p[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)<span class="keyword">if</span>(fa != edge[i].to)pre(edge[i].to,u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dep[a] &gt; dep[b])swap(a,b);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">30</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(dep[a] &lt;= dep[b] - (<span class="number">1</span>&lt;&lt;i))b = p[b][i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(a == b)<span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">30</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(p[a][i] == p[b][i])<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			a = p[a][i];b = p[b][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重心"><a href="#重心" class="headerlink" title="重心"></a>重心</h2><p>$w[u]$为删去$u$后剩余连通分量的最大值</p>
<p>$rt$为树的重心</p>
<p>树最多有两个相邻的重心</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cent</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	siz[u] = <span class="number">1</span>;</span><br><span class="line">	w[u] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(v != fa)&#123;</span><br><span class="line">			cent(v,u);</span><br><span class="line">			siz[u] += siz[v];</span><br><span class="line">			w[u] = max(w[u],siz[v]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	w[u] = max(w[u],n - siz[u]);</span><br><span class="line">	<span class="keyword">if</span>(!rt <span class="keyword">or</span> w[u] &lt; w[rt])rt = u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="点分治"><a href="#点分治" class="headerlink" title="点分治"></a>点分治</h2><p>具体看lyd的书.这里只放几道例题</p>
<h3 id="例题1-Tree"><a href="#例题1-Tree" class="headerlink" title="例题1-Tree"></a>例题1-Tree</h3><p>求树上间距小于等于$k$的点对个数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P4178</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn],vis[maxn],cnt;</span><br><span class="line"><span class="keyword">int</span> dis[maxn],bal[maxn],siz[maxn];<span class="comment">//权值,平衡因子,子树大小</span></span><br><span class="line"><span class="keyword">int</span> mapp[maxn],par[maxn],occur[maxn],tot;<span class="comment">//树上点的映射,该点属于根的哪颗子树,出现次数,待处理的总数</span></span><br><span class="line"><span class="keyword">int</span> root,n,k,ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> f,t,w,next;</span><br><span class="line">	Edge(<span class="keyword">int</span> f = <span class="number">0</span>,<span class="keyword">int</span> t = <span class="number">0</span>,<span class="keyword">int</span> w = <span class="number">0</span>,<span class="keyword">int</span> next = <span class="number">0</span>):f(f),t(t),w(w),next(next)&#123;&#125;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">	edge[cnt] = Edge(f,t,w,head[f]);</span><br><span class="line">	head[f] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> dis[a] &lt; dis[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_root</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa,<span class="keyword">int</span> rawsiz)</span></span>&#123;</span><br><span class="line">	siz[u] = <span class="number">1</span>,bal[u] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">		<span class="keyword">if</span>(vis[v] <span class="keyword">or</span> v == fa)<span class="keyword">continue</span>;</span><br><span class="line">		get_root(v,u,rawsiz);</span><br><span class="line">		siz[u] += siz[v];</span><br><span class="line">		bal[u] = max(bal[u],siz[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	bal[u] = max(bal[u],rawsiz - siz[u]);</span><br><span class="line">	<span class="keyword">if</span>(!root <span class="keyword">or</span> bal[root] &gt; bal[u])root = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_dis</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa,<span class="keyword">int</span> w,<span class="keyword">int</span> parent)</span></span>&#123;</span><br><span class="line">	mapp[++tot] = u;</span><br><span class="line">	dis[u] = w,par[u] = parent;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">		<span class="keyword">if</span>(vis[v] <span class="keyword">or</span> v == fa)<span class="keyword">continue</span>;</span><br><span class="line">		get_dis(v,u,w + edge[i].w,parent);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cal</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	tot = <span class="number">0</span>;</span><br><span class="line">	mapp[++tot] = u;</span><br><span class="line">	dis[u] = <span class="number">0</span>,par[u] = u;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">		<span class="keyword">if</span>(vis[v])<span class="keyword">continue</span>;</span><br><span class="line">		get_dis(v,u,edge[i].w,v);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(mapp+<span class="number">1</span>,mapp+tot+<span class="number">1</span>,cmp);</span><br><span class="line">	<span class="comment">// cout &lt;&lt; tot &lt;&lt; endl;</span></span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">1</span>,r = tot;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= tot;i++)occur[par[mapp[i]]]++;</span><br><span class="line">	<span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">		<span class="keyword">if</span>(dis[mapp[l]] + dis[mapp[r]] &gt; k)occur[par[mapp[r--]]]--;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			ans += (r - l + <span class="number">1</span> - occur[par[mapp[l]]]);</span><br><span class="line">			occur[par[mapp[l++]]]--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Divide</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	vis[u] = <span class="number">1</span>;</span><br><span class="line">	dis[u] = <span class="number">0</span>;</span><br><span class="line">	Cal(u);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">		<span class="keyword">if</span>(vis[v])<span class="keyword">continue</span>;</span><br><span class="line">		root = <span class="number">0</span>;</span><br><span class="line">		get_root(v,<span class="number">-1</span>,siz[v]);</span><br><span class="line">		Divide(root);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> f,t,w;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; f &gt;&gt; t &gt;&gt; w;</span><br><span class="line">		addedge(f,t,w);</span><br><span class="line">		addedge(t,f,w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">	get_root(<span class="number">1</span>,<span class="number">-1</span>,n);</span><br><span class="line">	Divide(root);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例题2-IOI2011-Race"><a href="#例题2-IOI2011-Race" class="headerlink" title="例题2-[IOI2011]Race"></a>例题2-[IOI2011]Race</h3><p>给出一棵树,求路径和为k的最短路径长度(边数)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P4149</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = maxn*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1E9</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn],vis[maxn],dis[maxn],dep[maxn];</span><br><span class="line"><span class="keyword">int</span> bal[maxn],siz[maxn],par[maxn];</span><br><span class="line"><span class="keyword">int</span> mapp[maxn],mindis[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt,ans,root,n,k,tot;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> f,t,w,next;</span><br><span class="line">	Edge(<span class="keyword">int</span> f = <span class="number">0</span>,<span class="keyword">int</span> t = <span class="number">0</span>,<span class="keyword">int</span> w = <span class="number">0</span>,<span class="keyword">int</span> next = <span class="number">0</span>):f(f),t(t),w(w),next(next)&#123;&#125;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">	edge[cnt] = Edge(f,t,w,head[f]);</span><br><span class="line">	head[f] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> dis[a] &lt; dis[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_root</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa,<span class="keyword">int</span> rawsiz)</span></span>&#123;</span><br><span class="line">	siz[u] = <span class="number">1</span>,bal[u] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">		<span class="keyword">if</span>(vis[v] <span class="keyword">or</span> v == fa)<span class="keyword">continue</span>;</span><br><span class="line">		get_root(v,u,rawsiz);</span><br><span class="line">		siz[u] += siz[v];</span><br><span class="line">		bal[u] = max(bal[u],siz[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	bal[u] = max(bal[u],rawsiz - siz[u]);</span><br><span class="line">	<span class="keyword">if</span>(!root <span class="keyword">or</span> bal[root] &gt; bal[u])root = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_dis</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa,<span class="keyword">int</span> parent)</span></span>&#123;</span><br><span class="line">	par[u] = parent;</span><br><span class="line">	mapp[++tot] = u;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">		<span class="keyword">if</span>(vis[v] <span class="keyword">or</span> fa == v)<span class="keyword">continue</span>;</span><br><span class="line">		dis[v] = dis[u] + edge[i].w;</span><br><span class="line">		dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">		get_dis(v,u,parent);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cal</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	tot = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> pretot = <span class="number">0</span>;</span><br><span class="line">	dep[u] = dis[u] = <span class="number">0</span>,par[u] = u;</span><br><span class="line">	mindis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	mapp[++tot] = u;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">		<span class="keyword">if</span>(vis[v])<span class="keyword">continue</span>;</span><br><span class="line">		pretot = tot;</span><br><span class="line">		dis[v] = edge[i].w;</span><br><span class="line">		dep[v] = <span class="number">1</span>;</span><br><span class="line">		get_dis(v,u,v);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = pretot+<span class="number">1</span>;j &lt;= tot;j++)&#123;</span><br><span class="line">			<span class="keyword">int</span> x = mapp[j];</span><br><span class="line">			<span class="keyword">if</span>(k - dis[x] &gt;= <span class="number">0</span>)ans = min(ans,mindis[k - dis[x]] + dep[x]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = pretot+<span class="number">1</span>;j &lt;= tot;j++)&#123;</span><br><span class="line">			<span class="keyword">int</span> x = mapp[j];</span><br><span class="line">			<span class="keyword">if</span>(dis[x] &lt; maxn)mindis[dis[x]] = min(mindis[dis[x]],dep[x]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= tot;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> j = mapp[i];</span><br><span class="line">		<span class="keyword">if</span>(dis[j] &lt; maxn)mindis[dis[j]] = INF;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Divide</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	vis[u] = <span class="number">1</span>;</span><br><span class="line">	dis[u] = <span class="number">0</span>;</span><br><span class="line">	dep[u] = <span class="number">0</span>;</span><br><span class="line">	Cal(u);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">		<span class="keyword">if</span>(vis[v])<span class="keyword">continue</span>;</span><br><span class="line">		root = <span class="number">0</span>;</span><br><span class="line">		get_root(v,<span class="number">-1</span>,siz[v]);</span><br><span class="line">		Divide(root);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// freopen("P4149_1.in","r",stdin);</span></span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; maxn;i++)mindis[i] = INF;</span><br><span class="line">	ans = INF;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> f,t,w;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; f &gt;&gt; t &gt;&gt; w;</span><br><span class="line">		f++;t++;</span><br><span class="line">		addedge(f,t,w);</span><br><span class="line">		addedge(t,f,w);</span><br><span class="line">	&#125;</span><br><span class="line">	get_root(<span class="number">1</span>,<span class="number">-1</span>,n);</span><br><span class="line">	Divide(root);</span><br><span class="line">	<span class="keyword">if</span>(ans == INF)ans = <span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解] CF906D-Power Tower</title>
    <url>/2020/05/13/solution-CF906D/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给定序列$w_1,w_2,…,w_n$和$q$组询问,对于每组询问,求<img src="../images/CF906D_1.png" alt="img1"></p>
<p>当然,需要对这个值膜$m$ </p>
<p>(hexo渲染多重幂有问题,只好放原题图片了)</p>
<p>$1 \leq n \leq 1e5$, $1 \leq m \leq 1e9$, $1 \leq q \leq 1e5$</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>考虑扩展欧拉定理:</p>
<script type="math/tex; mode=display">
a^b = \left\{
\begin{array}{lcl}
a^b && {b < φ(p)} \\
a^{b \bmod φ(p) + φ(p) } && {b \geq φ(p)}\\
\end{array}
\right.</script><p>由于$p \geq 2$时$φ(p)$为偶数,故$p = φ(p)$的下降速度是log级别的,换句话说经过最多$log(p)$次迭代之后$p$便会变为1.由于$x \bmod 1 == 0$,我们在$l == r$或者$p == 1$时便可跳出递归,单组询问的复杂度为$O(logp)$,可以接受</p>
<p>在具体实现时,应预处理出$p,φ(p),φ(φ(p)),…,1$来减少时间开销,同时修改快速幂来适应扩欧定理(upd函数),细节见代码</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CF906D </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line">ll raw[maxn],n,mod;</span><br><span class="line"><span class="built_in">map</span>&lt;ll,ll&gt;vis;</span><br><span class="line"><span class="function">ll <span class="title">phi</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m = (ll)<span class="built_in">sqrt</span>(x+<span class="number">0.5</span>);</span><br><span class="line">	ll tans = x;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= m;i++)<span class="keyword">if</span>(!(x%i))&#123;</span><br><span class="line">		tans = tans/i*(i<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">while</span>(!(x%i))x /= i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x &gt; <span class="number">1</span>)tans = tans / x * (x<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> tans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">upd</span><span class="params">(ll x,ll p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x&lt;p?x:x%p+p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">Pow</span><span class="params">(ll x,ll d,ll p)</span></span>&#123;</span><br><span class="line">	ll tans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(d == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	ll a = Pow(x,d/<span class="number">2</span>,p);</span><br><span class="line">	tans = upd(a*a,p);</span><br><span class="line">	<span class="keyword">if</span>(d%<span class="number">2</span>)tans = upd(tans*x,p); </span><br><span class="line">	<span class="keyword">return</span> upd(tans,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">cal</span><span class="params">(ll l,ll r,ll p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l == r <span class="keyword">or</span> p == <span class="number">1</span>)<span class="keyword">return</span> upd(raw[l],p);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> Pow(raw[l],cal(l+<span class="number">1</span>,r,vis[p]),p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; mod;</span><br><span class="line">	ll qwq = mod;</span><br><span class="line">	<span class="keyword">while</span>(qwq != <span class="number">1</span>)&#123;</span><br><span class="line">		vis[qwq] = phi(qwq);</span><br><span class="line">		qwq = vis[qwq];</span><br><span class="line">	&#125;</span><br><span class="line">	vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)<span class="built_in">cin</span> &gt;&gt; raw[i];</span><br><span class="line">	<span class="keyword">int</span> q;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">	<span class="keyword">while</span>(q--)&#123;</span><br><span class="line">		<span class="keyword">int</span> l,r;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; cal(l,r,mod)%mod &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
f(n) = O(g(n)) 
\\ \Rightarrow f(n) \leq c_f \cdot g(n) \\ 
\Rightarrow \frac{1}{f(n)} \geq \frac{1}{c_f\cdot g(n)}\\
\Rightarrow \frac{1}{g(n)} \leq c_f\cdot \frac{1}{f(n)} 对于n >= n_f\\
故有 \frac{1}{g(n)} = O(\frac{1}{f(n)})</script>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>Mobius-Transformation</title>
    <url>/2020/05/13/Mobius-Transformation/</url>
    <content><![CDATA[<p>这个菜鸡现在还什么都不会&gt;_&gt;慢慢更新吧</p>
<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="整除分块"><a href="#整除分块" class="headerlink" title="整除分块"></a>整除分块</h2><p>设$f(x) = \lfloor \frac{k}{x} \rfloor$</p>
<p>$f(x)$分布呈块状,对于任意一个$i$,有最大的$j = \lfloor \frac{k}{\lfloor \frac{k}{i} \rfloor} \rfloor$,使得$f(i) == f(i+1) == … = f(j)$</p>
<p>对于类似$\sum_{i = 1}^{n}\lfloor \frac{k}{i} \rfloor$的式子,可分块在$O(\sqrt{n})$时间内计算完毕</p>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>;l &lt;= n;l = r+<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(k/l)r = min(n,k/(k/l));</span><br><span class="line">		<span class="keyword">else</span> r = n;</span><br><span class="line">		ans += (r-l+<span class="number">1</span>)*(k/l);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="狄利克雷-Dirichlet-卷积"><a href="#狄利克雷-Dirichlet-卷积" class="headerlink" title="狄利克雷(Dirichlet)卷积"></a>狄利克雷(Dirichlet)卷积</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>设$f,g$为两个数论函数,其狄利克雷卷积$f*g$为:</p>
<script type="math/tex; mode=display">
f \ast g(n) = \sum_{d|n}f(d)g(\frac{n}{d})</script><h3 id="常用式子"><a href="#常用式子" class="headerlink" title="常用式子"></a>常用式子</h3><script type="math/tex; mode=display">
\begin{aligned}

\varepsilon=\mu \ast 1&\iff\varepsilon(n)=\sum_{d\mid n}\mu(d)\\
d=1 \ast 1&\iff d(n)=\sum_{d\mid n}1\\
\sigma=\text{id} \ast 1&\iff\sigma(n)=\sum_{d\mid n}d\\
\varphi=\mu \ast \text{id}&\iff\varphi(n)=\sum_{d\mid n}d\cdot\mu(\frac{n}{d}) \\


\end{aligned}</script><h2 id="常用结论"><a href="#常用结论" class="headerlink" title="常用结论"></a>常用结论</h2><script type="math/tex; mode=display">
\sum_{d|n}^n\varphi(d) = n</script><script type="math/tex; mode=display">
[\gcd(i,j) == 1] = \epsilon(\gcd(i,j) = \sum_{d|\gcd(i,j)}\mu(d)</script><h1 id="套路题"><a href="#套路题" class="headerlink" title="套路题"></a>套路题</h1><h2 id="sum-i-1-ngcd-i-n"><a href="#sum-i-1-ngcd-i-n" class="headerlink" title="$\sum_{i=1}^ngcd(i,n)$"></a>$\sum_{i=1}^ngcd(i,n)$</h2><script type="math/tex; mode=display">
\begin{align}
&\sum_{i=1}^n\gcd(i,n)\\
&=\sum_{d|n}d\sum_{i=1}^n[\gcd(i,n)==d]\\
&=\sum_{d|n}d\sum_{i=1}^{\frac{n}{d}}[\gcd(i,n)==1]\\
&=\sum_{d|n}d\cdotφ(\frac{n}{d})
\end{align}</script><h2 id="sum-i-1-n-sum-j-1-n-gcd-i-j"><a href="#sum-i-1-n-sum-j-1-n-gcd-i-j" class="headerlink" title="$\sum{i = 1}^n\sum{j=1}^n\gcd(i,j)$"></a>$\sum<em>{i = 1}^n\sum</em>{j=1}^n\gcd(i,j)$</h2><script type="math/tex; mode=display">
\begin{align}
&\sum_{i = 1}^n\sum_{j=1}^n\gcd(i,j)\\
&= \sum_{d=1}^nd\sum_{i=1}^n\sum_{j=1}^n[gcd(i,j) == d]\\
&=\sum_{d=1}^nd\sum_{i=1}^{\frac{n}{d}}\sum_{j=1}^{\frac{n}{d}}[gcd(i,j)==1]\\
&=\sum_{d=1}^nd(2\cdot\sum_{i=1}^{\frac{n}{d}}\varphi(i) - 1)
\end{align}</script><p>关于最后一步,我们设$f(x) = \sum<em>{i=1}^{n}\sum</em>{j=1}^{n}[gcd(i,j)==1]$</p>
<p>手画一下,容易看出$f(x) = 2\cdot\sum_{i=1}^n\varphi(i) - 1$</p>
<p>另一种做法:</p>
<p>我们知道$\varphi$有这么一个性质,$\sum_{d|n}^{n}\varphi(d) = n$</p>
<p>也就是$\sum_{d|\gcd(i,j)}^{n}\varphi(d) = \gcd(i,j)$</p>
<p>那么:</p>
<script type="math/tex; mode=display">
\begin{align}
&\sum_{i = 1}^n\sum_{j = 1}^n\gcd(i,j)\\
&=\sum_{i=1}^n\sum_{j=1}^n\sum_{d|\gcd(i,j)}\varphi(d)\\
&=\sum_{d = 1}^n\varphi(d)\sum_{i=1}^n[d|i]\sum_{j=1}^n[d|j]\\
&=\sum_{d = 1}^n\varphi(d)\cdot\lfloor\frac{n}{d}\rfloor\lfloor\frac{m}{d}\rfloor
\end{align}</script><p>少处理个前缀和=-=而且我感觉这个做法更好理解</p>
<p>例题:洛谷P2398</p>
<h2 id="sum-i-1-n-sum-j-i-1-n-gcd-i-j"><a href="#sum-i-1-n-sum-j-i-1-n-gcd-i-j" class="headerlink" title="$\sum{i = 1}^{n}\sum{j=i+1}^{n}\gcd(i,j)$"></a>$\sum<em>{i = 1}^{n}\sum</em>{j=i+1}^{n}\gcd(i,j)$</h2><p>和上面那个基本一样</p>
<script type="math/tex; mode=display">
\begin{align}
&\sum_{i = 1}^n\sum_{j=i+1}^n\gcd(i,j)\\
&= \sum_{d=1}^nd\sum_{i=1}^n\sum_{j=i+1}^n[gcd(i,j) == d]\\
&=\sum_{d=1}^nd\sum_{i=1}^{\frac{n}{d}}\sum_{j=i+1}^{\frac{n}{d}}[gcd(i,j)==1]\\
&=\sum_{d=1}^nd(\sum_{i=1}^{\frac{n}{d}}\varphi(i) - 1)
\end{align}</script><p>(最后一步的化简和上一题大同小异,手画一下就有了)</p>
<h2 id="sum-i-1-n-sum-i-1-m-gcd-i-j-1"><a href="#sum-i-1-n-sum-i-1-m-gcd-i-j-1" class="headerlink" title="$\sum{i=1}^{n}\sum{i=1}^{m}[\gcd(i,j) == 1]$"></a>$\sum<em>{i=1}^{n}\sum</em>{i=1}^{m}[\gcd(i,j) == 1]$</h2><p>前置知识:</p>
<script type="math/tex; mode=display">
\epsilon(n)=\sum_{d|n}\mu(d)= \begin{cases} 1&n=1\\ 
0&otherwise 
\end{cases}</script><p>开始愉快地推式子:</p>
<script type="math/tex; mode=display">
\begin{align}
&\sum_{i=1}^{n}\sum_{i=1}^{m}[\gcd(i,j) == 1] \\
&=\sum_{i=1}^{n}\sum_{i=1}^{m}\epsilon(\gcd(i,j))\\
&=\sum_{i=1}^{n}\sum_{i=1}^{m}\sum_{d|gcd(i,j)}\mu(d)\\
&=\sum_{d = 1}^{\min(n,m)}\mu(d)\sum_{i = 1}^n[d|i]\sum_{j = 1}^{m}[d|j]\\
&=\sum_{d=1}^{\min(n,m)}\mu(d)\lfloor \frac{n}{d}\rfloor \lfloor \frac{m}{d} \rfloor
\end{align}</script><p>同理,我们有:</p>
<script type="math/tex; mode=display">
\sum_{i = 1}^n\sum_{j = 1}^n\sum_{k = 1}^n [\gcd(i,j,k) == 1] = \sum_{d = 1}^n \mu(d)(\lfloor \frac{n}{d}\rfloor)^3</script>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>笔记</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]CF1325E-Ehab&#39;s REAL Number Theory Problem</title>
    <url>/2020/05/15/solution-CF1325E/</url>
    <content><![CDATA[<p>一道有意思的<del>毒瘤</del>题</p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>​    给出数列${a_1,a_2,…,a_n}$,其中每个$a_i$最多只有7个因子.求乘积为完全平方数的最短子序列</p>
<p>​    $1 \leq n \leq 1e5$,$1 \leq a_i \leq 1e6$</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>​    首先条件里”最多只有7个因子”是很有意思的一个提示,它实际上是指每个数<strong>最多只有2个素因子</strong></p>
<p>证明:</p>
<p>​        我们考虑因子个数定理:</p>
<p>​        以$d(N)$表示$N$的因子个数,且$N = Σ<em>{i=1}^{n}p</em>{i}^{k_i}$</p>
<p>​        则有$d(N) = \prod_{i = 1}^{n}(k_i+1)$ </p>
<p>​        容易看出当$N$有3个素因子时,$d(N) \geq 8$.故N最多只有两个素因子.</p>
<p>​    如此可以分解每个$a_i$为$a_i = p^{k_1}q^{k_2}$的形式.因为我们需要求完全平方数,$k_1,k_2$可以直接模2.之后有如下三种情况:</p>
<ol>
<li>$a_i = 1$</li>
<li>$a_i = 1*p_i$</li>
<li>$a_i = p_i*q_i$<br>我们要做的就是保证子序列里每个$p_i,q_i$的指数为偶数,同时使这个序列最短.</li>
</ol>
<hr>
<p>​    如何高效求解这个问题?上面的因子分解得到了$p,q$两个因子,让人联想到图的连边.不妨如此建模:将因子作为点,向$a_i$的两个因子$p_i,q_i$连一条无向无权边,则问题转化为求这个图里的最小环.(因为一个简单环里每个点的度数都为2,满足每个因子的指数都为偶数这一要求).</p>
<p>​    对于无向无权图图求最小环我们可以简单地对每个点做BFS.对于一条未访问的边$u,v$ ,如果$v$已访问过,那么该图存在一个长度为$dis[u]+dis[v]+1$的环(请自己画图验证).但是这样复杂度为$O(n^2)$</p>
<p>​    考虑这个图的特殊性质:任意正整数$N$最多只有一个大于$\sqrt{N}$的素因子,换句话说这个图里每条边都至少有一个点标号小于$\sqrt{max{a_i}}$.只需枚举这些点即可.</p>
<p>​    总复杂度:$O(\sqrt{max{a_i}}n)$</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CF1325E</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> f,t,next;</span><br><span class="line">	Edge(<span class="keyword">int</span> f = <span class="number">0</span>,<span class="keyword">int</span> t = <span class="number">0</span>,<span class="keyword">int</span> next = <span class="number">0</span>):f(f),t(t),next(next)&#123;&#125;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt,head[maxn],dis[maxn],ans = <span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	edge[cnt] = Edge(f,t,head[f]);</span><br><span class="line">	head[f] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	addedge(f,t);</span><br><span class="line">	addedge(t,f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> visp[maxn],vis[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;P,d[maxn];</span><br><span class="line"><span class="keyword">int</span> n,raw[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	visp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; maxn;i++)<span class="keyword">if</span>(!visp[i])&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i*<span class="number">2</span>;j &lt; maxn;j+=i)visp[j] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; maxn;i++)<span class="keyword">if</span>(!visp[i])&#123;</span><br><span class="line">		P.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; raw[i];</span><br><span class="line">		<span class="keyword">int</span> cur = raw[i];</span><br><span class="line">		<span class="keyword">if</span>(!visp[cur])&#123;</span><br><span class="line">			d[i].push_back(cur);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>;j*j &lt;= raw[i];j++)&#123;</span><br><span class="line">			<span class="keyword">int</span> cnt2 = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(cur%j == <span class="number">0</span>)&#123;</span><br><span class="line">				cur /= j;cnt2++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(cnt2%<span class="number">2</span>)d[i].push_back(j);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(cur &gt; <span class="number">1</span>)d[i].push_back(cur);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!d[i].size())&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(d[i].size() == <span class="number">1</span>)&#123;</span><br><span class="line">			add(<span class="number">1</span>,d[i][<span class="number">0</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> add(d[i][<span class="number">0</span>],d[i][<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">	dis[s] = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;q;</span><br><span class="line">	q.push(make_pair(s,<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		<span class="keyword">auto</span> now = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">int</span> u = now.first,fa = now.second;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">			<span class="keyword">if</span>(v == fa)<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(dis[v] == <span class="number">-1</span>)&#123;</span><br><span class="line">				dis[v] = dis[u]+<span class="number">1</span>;</span><br><span class="line">				q.push(make_pair(v,u));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				ans = min(ans,dis[v]+dis[u]+<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">	init();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">1010</span>;i++)BFS(i);</span><br><span class="line">	<span class="keyword">if</span>(ans == <span class="number">1e9</span>)ans = <span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$2^{2n-1}+2^{2n-2}-2^n$</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]CF1355C-Count Triangles</title>
    <url>/2020/05/16/solution-CF1355C/</url>
    <content><![CDATA[<p>写这个不是因为这题多难或者有意思,纯粹是纪念一下自己有多傻逼=-=</p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给出$A,B,C,D$求满足$A \leq x \leq B \leq y \leq C \leq z \leq D$,的$x,y,z$能组成的三角形个数</p>
<p>$1 \leq A \leq B \leq C \leq D \leq 5e5$</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>很显然只要满足$z &lt; x+y$且$C \leq z \leq D$就行=-=</p>
<p>那么枚举$x$,把$[x+B,x+C]$加1(用前缀和维护一下就行),再枚举$z$统计满足$z &lt; x+y$的个数就行=-=</p>
<p>复杂度$O(C)$</p>
<p><strong>就这玩意都做不出来,我是傻逼</strong></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ll a,b,c,d,ans = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = a;i &lt;= b;i++)pre[i+b]++,pre[i+c+<span class="number">1</span>]--;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; maxn;i++)pre[i] += pre[i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; maxn;i++)ans += pre[i]*max(<span class="number">0l</span>l,min(d,(ll)(i<span class="number">-1</span>)) - c + <span class="number">1</span>); </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>我是sb</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]UVA11107 Life Forms</title>
    <url>/2020/06/08/solution-Uva11107/</url>
    <content><![CDATA[<h4 id="题面"><a href="#题面" class="headerlink" title="题面:"></a>题面:</h4><p><a href="https://vjudge.net/problem/UVA-11107" target="_blank" rel="noopener">https://vjudge.net/problem/UVA-11107</a></p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>​    这里给出一种字符串Hash+二分的做法.</p>
<p>​    对每个字符串分别进行Hash,再二分最长子串的长度$L$.在判断$L$是否合法时,只需求出每个字符串中长度为$L$的<strong>不重复</strong>子串,再统计全部字符串中所有子串的个数.如果有子串出现次数大于等于$\frac{n}{2}+1$,那么$L$合法.</p>
<p>​    实现上,使用map进行统计($cnt$)和判重($vis$).对每个字符串$s$,计算以$[1…|s| - L+1]$为起点,长度为$L$的子串的hash值$h_i$,去重后添加到$cnt$里.在添加过程中如果有$cnt[h_i] \geq \frac{n}{2}+1$那么$L$合法,同时将该段子串添加到答案中.输出时对答案去重输出即可,同时注意UVA的毒瘤格式要求=-=</p>
<p>​    这个做法时间效率很低(在不作优化的情况下跑了3.72s),但是比较好想和好写</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//UVA11107</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span>+<span class="number">10</span>,maxs = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> ull x = <span class="number">13331</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ull xp[maxn],H[maxn][maxs];</span><br><span class="line"><span class="built_in">string</span> raw[maxs];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;ans;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> L)</span></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> ok = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">map</span>&lt;ull,<span class="keyword">int</span>&gt;cnt;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= n;k++)&#123;</span><br><span class="line">		<span class="built_in">map</span>&lt;ull,<span class="keyword">bool</span>&gt;vis;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i+L<span class="number">-1</span> &lt;= raw[k].size();i++)&#123;</span><br><span class="line">			ull u = H[i+L<span class="number">-1</span>][k] - H[i<span class="number">-1</span>][k]*xp[L];</span><br><span class="line">			<span class="keyword">if</span>(!vis[u])&#123;</span><br><span class="line">				vis[u] = <span class="number">1</span>;</span><br><span class="line">				cnt[u]++;</span><br><span class="line">				<span class="keyword">if</span>(cnt[u] &gt;= n/<span class="number">2</span>+<span class="number">1</span>)ok = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> L)</span></span>&#123;</span><br><span class="line">	<span class="built_in">map</span>&lt;ull,<span class="keyword">int</span>&gt;cnt;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= n;k++)&#123;</span><br><span class="line">		<span class="built_in">map</span>&lt;ull,<span class="keyword">bool</span>&gt;vis;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i+L<span class="number">-1</span> &lt;= raw[k].size();i++)&#123;</span><br><span class="line">			ull u = H[i+L<span class="number">-1</span>][k] - H[i<span class="number">-1</span>][k]*xp[L];</span><br><span class="line">			<span class="keyword">if</span>(!vis[u])&#123;</span><br><span class="line">				vis[u] = <span class="number">1</span>;</span><br><span class="line">				cnt[u]++;</span><br><span class="line">				<span class="keyword">if</span>(cnt[u] &gt;= n/<span class="number">2</span>+<span class="number">1</span>)&#123;</span><br><span class="line">					<span class="built_in">string</span> yay = <span class="string">""</span>;</span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt;= i+L<span class="number">-1</span>;j++)yay += raw[k][j<span class="number">-1</span>];</span><br><span class="line">					ans.push_back(yay);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	xp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; maxn;i++)xp[i] = xp[i<span class="number">-1</span>]*x;</span><br><span class="line">	<span class="keyword">bool</span> wtf = <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n) == <span class="number">1</span> <span class="keyword">and</span> n)&#123;</span><br><span class="line">		<span class="keyword">if</span>(wtf)<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		wtf = <span class="number">1</span>;</span><br><span class="line">		ans.clear();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">			<span class="built_in">string</span> u;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; u;</span><br><span class="line">			raw[i] = u;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= u.size();j++)H[j][i] = H[j<span class="number">-1</span>][i]*x + u[j<span class="number">-1</span>] - <span class="string">'a'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> L = <span class="number">1</span>,R = maxn,M,len = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(L &lt;= R)&#123;</span><br><span class="line">			M = (L+R)/<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>(check(M))&#123;</span><br><span class="line">				len = M;</span><br><span class="line">				L = M+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> R = M<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		solve(len);</span><br><span class="line">		sort(ans.begin(),ans.end());</span><br><span class="line">		<span class="keyword">if</span>(ans.size() <span class="keyword">and</span> len)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; ans.size();i++)<span class="keyword">if</span>(!i <span class="keyword">or</span> ans[i] != ans[i<span class="number">-1</span>])<span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"?\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>Hash</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]CF1364-D Ehab&#39;s Last Corollary</title>
    <url>/2020/06/14/solution-CF1364D/</url>
    <content><![CDATA[<p>很妙的一题</p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给出$n$个节点$m$条边的无向连通图和参数$k$,求:</p>
<ul>
<li>严格$\lceil \frac{k}{2} \rceil$大小的点独立集</li>
<li>或大小$ \leq k$的简单环</li>
</ul>
<p>$3 \leq k \leq n \leq 10^5,n-1 \leq m \leq 2 \cdot 10^5$</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h5 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h5><p>​    我们求出一个原图的DFS树,当某个节点$u$存在反向边时,找出终点$v$深度最深的反向边.容易看出这个反向边在一个简单环中,且这个简单环不会被其他边分割.如果这个环的大小$\leq k$,直接输出即可,否则我们取不相邻的$\lceil \frac{k}{2} \rceil$个点,它们形成一个点独立集.</p>
<p>​    如果原图无环(或者说是一棵树),那么我们很容易就能求出大小$\lceil \frac{k}{2} \rceil$的点独立集.</p>
<h5 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h5><p>​    我们求出任意一个环,然后枚举所有的边$1…m$.如果某条边把这个环分割开(即起点终点都在环上),那么保留这个环的任意一半,继续该过程.最后我们会得到一个不被其他边分割的简单环.之后的处理同解法1.</p>
<p>​    如果原图是一棵树,同解法1.</p>
<p>​    (比赛时我用的就是这种做法,但是写T了=-=个人觉得这是最难想也最难写的做法,鬼知道我当时在干什么)</p>
<h5 id="解法3"><a href="#解法3" class="headerlink" title="解法3"></a>解法3</h5><p>​    (来自Um_nik的代码)<a href="https://codeforces.com/contest/1364/submission/83636767" target="_blank" rel="noopener">https://codeforces.com/contest/1364/submission/83636767</a></p>
<p>​    %%%%%</p>
<p>​    根据原题,无论我们求点独立集还是简单环,都需要最多$k$个点,那么我们简单粗暴地把所有编号$ &gt; k$的点删掉,再在剩下的图(<strong>注意新图可能不连通</strong>)中寻找环.如果我们找到任意一个环,直接输出即可,因为这个环的大小肯定$\leq k$.如果没有环(新图是一个森林),那也能很容易地找到$\lceil \frac{k}{2} \rceil$大小的点独立集.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//D</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> from,to,next,cnt;</span><br><span class="line">	Edge(<span class="keyword">int</span> from = <span class="number">0</span>,<span class="keyword">int</span> to = <span class="number">0</span>,<span class="keyword">int</span> next = <span class="number">0</span>):from(from),to(to),next(next)&#123;&#125;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn],cnt,d,dep[maxn],p[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn],col[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	edge[cnt] = Edge(f,t,head[f]);</span><br><span class="line">	head[f] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(vis[u])<span class="keyword">return</span>;</span><br><span class="line">	vis[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(vis[v] <span class="keyword">and</span> dep[v] &gt; dep[u])&#123;</span><br><span class="line">			<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;cir = &#123;&#125;;</span><br><span class="line">			<span class="keyword">int</span> cur = v;</span><br><span class="line">			<span class="keyword">while</span>(cur != u)&#123;</span><br><span class="line">				cir.push_back(cur);</span><br><span class="line">				cur = p[cur];</span><br><span class="line">			&#125;</span><br><span class="line">			cir.push_back(u);</span><br><span class="line">			<span class="keyword">int</span> s = cir.size();</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> yay:cir)<span class="built_in">cout</span> &lt;&lt; yay &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">			p[v] = u;</span><br><span class="line">			dep[v] = dep[u]+<span class="number">1</span>;</span><br><span class="line">			col[v] = !col[u];</span><br><span class="line">			DFS(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">	d = <span class="built_in">ceil</span>((<span class="keyword">double</span>)k/<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> f1,t1;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; f1&gt;&gt; t1;</span><br><span class="line">		<span class="keyword">if</span>(f1 &gt; k <span class="keyword">or</span> t1 &gt; k)<span class="keyword">continue</span>;</span><br><span class="line">		addedge(f1,t1);</span><br><span class="line">		addedge(t1,f1);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> cnt1 = <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)DFS(i);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;ans = &#123;&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)<span class="keyword">if</span>(col[i])cnt1++;</span><br><span class="line">	<span class="keyword">int</span> qwq = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(cnt1 &gt;= d)qwq = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)<span class="keyword">if</span>(col[i] == qwq)&#123;</span><br><span class="line">		<span class="keyword">if</span>((<span class="keyword">int</span>)ans.size() == d)<span class="keyword">break</span>;</span><br><span class="line">		ans.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> x:ans)<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]洛谷P2257-YY的GCD</title>
    <url>/2020/06/17/solution-P2257/</url>
    <content><![CDATA[<p><em>*本文思路部分来自于这篇题解</em>:<a href="https://www.luogu.com.cn/blog/qlwpc/" target="_blank" rel="noopener">凄魉</a> <a href="https://www.luogu.com.cn/blog/qlwpc/solution-p2257" target="_blank" rel="noopener">题解 P2257 【YY的GCD】</a></p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>多组数据,求</p>
<script type="math/tex; mode=display">
\sum_{i = 1}^n\sum_{j = 1}^m [\gcd(i,j) == k],k \in prime</script><p>$T = 10^4,1 \leq n,m \leq 10^7$</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><p>首先我们在求</p>
<script type="math/tex; mode=display">
\sum_{i = 1}^n\sum_{j = 1}^m [\gcd(i,j) == 1]</script><p>时有这么一种做法,利用了莫比乌斯函数$\mu$的性质:</p>
<script type="math/tex; mode=display">
\sum_{d|n}\mu(d) = [n = 1]</script><hr>
<script type="math/tex; mode=display">
\begin{align}
&\sum_{i=1}^{n}\sum_{i=1}^{m}[\gcd(i,j) == 1] \\
&=\sum_{i=1}^{n}\sum_{i=1}^{m}\epsilon(\gcd(i,j))\\
&=\sum_{i=1}^{n}\sum_{i=1}^{m}\sum_{d|gcd(i,j)}\mu(d)\\
&=\sum_{d = 1}^{\min(n,m)}\mu(d)\sum_{i = 1}^n[d|i]\sum_{j = 1}^{m}[d|j]\\
&=\sum_{d=1}^{\min(n,m)}\mu(d)\lfloor \frac{n}{d}\rfloor \lfloor \frac{m}{d} \rfloor
\end{align}</script><p>那么我们只要构造一个数论函数$f$,使得</p>
<script type="math/tex; mode=display">
\sum_{d|n}f(d) = [n \in prime]</script><p>答案就变为了</p>
<script type="math/tex; mode=display">
\sum_{d=1}^{\min(n,m)}f(d)\lfloor \frac{n}{d}\rfloor \lfloor \frac{m}{d} \rfloor</script><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>形式化地,设数论函数$g$,构造$f$使得$\sum_{d|n}f(d) = g(n)$</p>
<ol>
<li>对于$k \in [1,n]$,使$f(k) = g(k)$</li>
<li>$f(n) = f(n) - \sum_{d|n,d \neq n}f(d)$</li>
</ol>
<p>如此,我们有:</p>
<script type="math/tex; mode=display">
\sum_{d|n}f(d) = \sum_{d|n,d \neq n}f(d) + f(n) = g(n)</script><p>第二步可以采用类似埃氏筛的方法,复杂度$O(n\ln n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; maxn;i++)f[i] = g[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; maxn;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = i+i;j &lt; maxn;j += i)f[j] -= f[i];</span><br></pre></td></tr></table></figure>
<p>对于本题,我们设$g(n) = [n \in prine]$即可,可以在$O(n)$时间内筛出$g$.</p>
<p>总复杂度:$O(n + n\ln n + T \sqrt{\min(n,m)})$</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P2257</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"><span class="keyword">bool</span> not_p[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;prime;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	not_p[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; maxn;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!not_p[i])&#123;</span><br><span class="line">			f[i] = <span class="number">1</span>;</span><br><span class="line">			prime.push_back(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> p:prime)&#123;</span><br><span class="line">			<span class="keyword">if</span>(ll(p)*i &gt;= maxn)<span class="keyword">break</span>;</span><br><span class="line">			not_p[p*i] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%p == <span class="number">0</span>)<span class="keyword">break</span>; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; maxn;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i+i;j &lt; maxn;j += i)f[j] -= f[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; maxn;i++)f[i] += f[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">cal</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	ll tans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>,r = <span class="number">0</span>;l &lt;= min(x,y);l = r+<span class="number">1</span>)&#123;</span><br><span class="line">		r = min(x/(x/l),y/(y/l));</span><br><span class="line">		tans += <span class="number">1L</span>L*(f[r] - f[l<span class="number">-1</span>])*(x/l)*(y/l);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	sieve();</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>); </span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="keyword">int</span> n,m;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; cal(n,m) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS.不是我不喜欢用行间公式,是hexo渲染行间LaTex总出奇怪的bug,凑合着看吧=-=</p>
<h1 id="另一种做法"><a href="#另一种做法" class="headerlink" title="另一种做法"></a>另一种做法</h1><p>以下均有$k \in prime$</p>
<script type="math/tex; mode=display">
\begin{align}
&\sum_{k = 1}^n\sum_{i = 1}^n\sum_{j = 1}^n[\gcd(i,j) == k]\\
&=\sum_{k = 1}^n\sum_{i = 1}^{\frac{n}{k}}\sum_{j = 1}^{\frac{m}{k}}[\gcd(i,j) == 1]\\
&=\sum_{k = 1}^n\sum_{i = 1}^{\frac{n}{k}}\sum_{j = 1}^{\frac{m}{k}}\sum_{d|\gcd(i,j)}\varphi(d)\\
&=\sum_{k = 1}^n\sum_{d = 1}^{\frac{n}{k}}\varphi(d)\cdot \lfloor\frac{n}{kd}\rfloor\lfloor\frac{m}{kd}\rfloor\\
&设T = kd,枚举T\\
&=\sum_{k = 1}^n\sum_{d=1}^{\frac{n}{k}}\varphi(d)\lfloor\frac{n}{T}\rfloor\lfloor\frac{m}{T}\rfloor\\
&=\sum_{T = 1}^n\lfloor\frac{n}{T}\rfloor\lfloor\frac{m}{T}\rfloor\sum_{k|T}\mu(\frac{T}{k})
\end{align}</script><p>可以看出$f(T) = \sum_{k|T}\mu(\frac{T}{k})$可以预处理</p>
<p>复杂度:不会</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> p:prime)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;<span class="number">1l</span>l*j*p &lt; maxn;j++)f[j*p] += mu[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>code:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;P2257_2 </span><br><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn &#x3D; 1e7+10;</span><br><span class="line">bool not_p[maxn];</span><br><span class="line">int mu[maxn];</span><br><span class="line">ll f[maxn];</span><br><span class="line">vector&lt;int&gt;prime;</span><br><span class="line">void sieve_mu()&#123;</span><br><span class="line">	mu[1] &#x3D; not_p[1] &#x3D; 1;</span><br><span class="line">	for(int i &#x3D; 2;i &lt; maxn;i++)&#123;</span><br><span class="line">		if(!not_p[i])&#123;</span><br><span class="line">			prime.push_back(i);</span><br><span class="line">			mu[i] &#x3D; -1;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int p:prime)&#123;</span><br><span class="line">			if(1ll*p*i &gt;&#x3D; maxn)break;</span><br><span class="line">			not_p[i*p] &#x3D; 1;</span><br><span class="line">			if(i%p)mu[i*p] &#x3D; -mu[i];</span><br><span class="line">			else&#123;</span><br><span class="line">				mu[i*p] &#x3D; 0;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int p:prime)&#123;</span><br><span class="line">		for(int j &#x3D; 1;1ll*j*p &lt; maxn;j++)f[j*p] +&#x3D; mu[j];</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i &#x3D; 1;i &lt; maxn;i++)f[i] +&#x3D; f[i-1];</span><br><span class="line">&#125;</span><br><span class="line">ll cal(int n,int m)&#123;</span><br><span class="line">	ll tans &#x3D; 0;</span><br><span class="line">	for(int l &#x3D; 1,r &#x3D; 0;l &lt;&#x3D; min(n,m);l &#x3D; r+1)&#123;</span><br><span class="line">		r &#x3D; min(n&#x2F;(n&#x2F;l),m&#x2F;(m&#x2F;l));</span><br><span class="line">		tans +&#x3D; (f[r] - f[l-1])*(n&#x2F;l)*(m&#x2F;l);</span><br><span class="line">	&#125;</span><br><span class="line">	return tans;</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">	sieve_mu();</span><br><span class="line">	int t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		int n,m;</span><br><span class="line">		cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		cout &lt;&lt; cal(n,m) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>莫比乌斯反演</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>[笔记]杜教筛</title>
    <url>/2020/06/18/note-du-sieve/</url>
    <content><![CDATA[<p><strong>dlstxdy!</strong></p>
<p>杜教筛用于快速求数论函数的前缀和.当预处理了小于$n^\frac{2}{3}$的前缀和时,杜教筛的时间复杂度为$O(n^\frac{2}{3})$</p>
<h1 id="形式化定义"><a href="#形式化定义" class="headerlink" title="形式化定义"></a>形式化定义</h1><p>给出数论函数$f$,快速求$S(n) = \sum_{i = 1}^nf(i)$</p>
<h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>引理:</p>
<script type="math/tex; mode=display">
\sum_{i = 1}^n f \ast g (i) = \sum_{i = 1}^ng(i) \cdot S(\lfloor \frac{n}{i} \rfloor)</script><p>证明:</p>
<script type="math/tex; mode=display">
\begin{align}

&\sum_{i = 1}^n f \ast g (i) \\
&= \sum_{i = 1}^n \sum_{d|n}f(d)\cdot g(\frac{n}{d})\\
&= \sum_{d = 1}^ng(d)\sum_{i*d = 1,d|i}^{i*d <= n}f(\frac{i}{d})\\
&= \sum_{d = 1}^ng(d)\sum_{i = 1}^{\lfloor \frac{n}{d} \rfloor}f(i)\\
&= \sum_{d = 1}^ng(d)\cdot S(\lfloor \frac{n}{d} \rfloor)

\end{align}</script><p>观察上式,我们能得到:</p>
<script type="math/tex; mode=display">
\begin{align}
&g(1) \cdot S(n) \\
&= \sum_{i = 1}^ng(i) \cdot S(\lfloor \frac{n}{i} \rfloor) -\sum_{i = 2}^ng(i) \cdot S(\lfloor \frac{n}{i} \rfloor)\\
&= \sum_{i = 1}^n f \ast g(i) - \sum_{i = 2}^ng(i) \cdot S(\lfloor \frac{n}{i} \rfloor)\\ 
\end{align}</script><p>这个式子的后半部分可以用数论分块递归去求,如果我们构造的$g$能快速求出$\sum_{i = 1}^nf\ast g(i)$,我们就能快速求出$g(1)\cdot S(n)$.</p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="筛-mu"><a href="#筛-mu" class="headerlink" title="筛$\mu$"></a>筛$\mu$</h2><p>我们知道$\mu \ast 1 = \epsilon$</p>
<p>因而有:</p>
<script type="math/tex; mode=display">
\begin{align}
&1\cdot S(n) = S(n)\\
&= \sum_{i = 1}^n\mu \ast 1(i) - \sum_{i = 2}^n 1 \cdot S(\lfloor \frac{n}{i}\rfloor)\\
&= \sum_{i = 1}^n \epsilon - \sum_{i = 2}^n S(\lfloor \frac{n}{i}\rfloor)\\
&= 1 - \sum_{i = 2}^n S(\lfloor \frac{n}{i}\rfloor)\\
\end{align}</script><p>简单地把$\mu \ast 1 = \epsilon$带进上面的结论就行了.</p>
<p>代码:</p>
<p>(Mu为map,记忆化求过的μ.求之前先线性筛一遍小于maxn的μ.下面求φ同理)</p>
<p>注意$g = 1$,减的时候别漏了($r-l+1$)=-=</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ll du_mu(int x)&#123;</span><br><span class="line">	if(x &lt; maxn)return mu[x];</span><br><span class="line">	else if(Mu[x])return Mu[x];</span><br><span class="line">	ll tans &#x3D; 1;</span><br><span class="line">	for(int l &#x3D; 2,r &#x3D; 0;l &lt;&#x3D; x;l &#x3D; r+1)&#123;</span><br><span class="line">		r &#x3D; x&#x2F;(x&#x2F;l);</span><br><span class="line">		tans -&#x3D; 1LL*(r - l + 1)*du_mu(x&#x2F;l);</span><br><span class="line">	&#125;</span><br><span class="line">	return Mu[x] &#x3D; tans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="筛-varphi"><a href="#筛-varphi" class="headerlink" title="筛$\varphi$"></a>筛$\varphi$</h2><p>和μ大同小异.我们有$\varphi \ast 1 = id$,其中$id(n) = n$</p>
<script type="math/tex; mode=display">
\begin{align}
&1\cdot S(n) = S(n)\\
&= \sum_{i = 1}^n\varphi \ast 1(i) - \sum_{i = 2}^n 1 \cdot S(\lfloor \frac{n}{i}\rfloor)\\
&= \sum_{i = 1}^n id(i) - \sum_{i = 2}^n S(\lfloor \frac{n}{i}\rfloor)\\
&= \frac{n*(n+1)}{2} - \sum_{i = 2}^n S(\lfloor \frac{n}{i}\rfloor)\\
\end{align}</script><p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">du_phi</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x &lt; maxn)<span class="keyword">return</span> phi[x];</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(Phi[x])<span class="keyword">return</span> Phi[x];</span><br><span class="line">	ll tans = <span class="number">1L</span>L*x*(x+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">2</span>,r = <span class="number">0</span>;l &lt;= x;l = r+<span class="number">1</span>)&#123;</span><br><span class="line">		r = x/(x/l);</span><br><span class="line">		tans -= <span class="number">1L</span>L*(r-l+<span class="number">1</span>)*du_phi(x/l);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Phi[x] = tans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>笔记</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title>solution-HDU4746</title>
    <url>/2020/06/22/solution-HDU4746/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>[题解]IOI2014-Wall</title>
    <url>/2020/09/12/solution-Wall/</url>
    <content><![CDATA[<h2 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h2><p><a href="https://codeforces.com/edu/course/2/lesson/5/4/practice/contest/280801/problem/E" target="_blank" rel="noopener">https://codeforces.com/edu/course/2/lesson/5/4/practice/contest/280801/problem/E</a></p>
<p>或:</p>
<p><a href="https://www.luogu.com.cn/problem/P4560" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P4560</a></p>
<p>长度为$n$的序列初始为空,维护两种操作:</p>
<ol>
<li>Add(L,R,v): 将$[L,R]$中小于$v$的值改变为$v$</li>
<li>Remove(L,R,v):将$[L,R]$中大于$v$的值改变为$v$</li>
</ol>
<p>给出$m$个操作,输出操作全部完成后的序列.</p>
<p>$1 \leq n \leq 2\cdot10^6,1 \leq m \leq 5\cdot10^5$</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对每个节点维护$upv[]$和$lowv[]$,表示该节点值的上限和下限.查询时对每个点做一次单点查询,答案为$lowv[x]$.</p>
<p>下放节点时$upv$和$lowv$的关系比较显然,细节请见代码.</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P-4-E </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NO_OPT = INT_MAX;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segtree</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;upv,lowv;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(size &lt; n)size *= <span class="number">2</span>;</span><br><span class="line">		upv.assign(size*<span class="number">2</span>,NO_OPT);</span><br><span class="line">		lowv.assign(size*<span class="number">2</span>,NO_OPT);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(upv[x] != NO_OPT)&#123;</span><br><span class="line">			upv[ls(x)] = min(upv[x],upv[ls(x)]);</span><br><span class="line">			upv[rs(x)] = min(upv[x],upv[rs(x)]);</span><br><span class="line">			<span class="keyword">if</span>(lowv[ls(x)] != NO_OPT <span class="keyword">and</span> lowv[ls(x)] &gt; upv[x])lowv[ls(x)] = upv[x];</span><br><span class="line">			<span class="keyword">if</span>(lowv[rs(x)] != NO_OPT <span class="keyword">and</span> lowv[rs(x)] &gt; upv[x])lowv[rs(x)] = upv[x];</span><br><span class="line">			upv[x] = NO_OPT;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(lowv[x] != NO_OPT)&#123;</span><br><span class="line">			<span class="keyword">if</span>(lowv[ls(x)] != NO_OPT)lowv[ls(x)] = max(lowv[ls(x)],lowv[x]);</span><br><span class="line">			<span class="keyword">else</span> lowv[ls(x)] = lowv[x];</span><br><span class="line">			<span class="keyword">if</span>(lowv[rs(x)] != NO_OPT)lowv[rs(x)] = max(lowv[rs(x)],lowv[x]);</span><br><span class="line">			<span class="keyword">else</span> lowv[rs(x)] = lowv[x];</span><br><span class="line">			<span class="keyword">if</span>(upv[ls(x)] != NO_OPT <span class="keyword">and</span> upv[ls(x)] &lt; lowv[x])upv[ls(x)] = lowv[x];</span><br><span class="line">			<span class="keyword">if</span>(upv[rs(x)] != NO_OPT <span class="keyword">and</span> upv[rs(x)] &lt; lowv[x])upv[rs(x)] = lowv[x];</span><br><span class="line">			lowv[x] = NO_OPT;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">		pushdown(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			upv[x] = min(upv[x],v);</span><br><span class="line">			<span class="keyword">if</span>(lowv[x] != NO_OPT <span class="keyword">and</span> lowv[x] &gt; v)lowv[x] = v;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		up(l,r,v,ls(x),lx,m);</span><br><span class="line">		up(l,r,v,rs(x),m,rx);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		up(l,r,v,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">low</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">		pushdown(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			<span class="keyword">if</span>(lowv[x] == NO_OPT <span class="keyword">or</span> lowv[x] &lt; v)lowv[x] = v;</span><br><span class="line">			<span class="keyword">if</span>(upv[x] != NO_OPT <span class="keyword">and</span> upv[x] &gt; v)upv[x] = v;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		low(l,r,v,ls(x),lx,m);</span><br><span class="line">		low(l,r,v,rs(x),m,rx);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">low</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		low(l,r,v,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(idx &gt;= rx)<span class="keyword">return</span> NO_OPT;</span><br><span class="line">		pushdown(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)<span class="keyword">return</span> lowv[x];</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(idx &lt; m)<span class="keyword">return</span> get(idx,ls(x),lx,m);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> get(idx,rs(x),m,rx);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> get(idx,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	segtree seg;</span><br><span class="line">	seg.init(n+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="keyword">int</span> opt,l,r,v;</span><br><span class="line">		r++;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; opt &gt;&gt; l &gt;&gt; r &gt;&gt; v;</span><br><span class="line">		r++;</span><br><span class="line">		<span class="keyword">if</span>(opt == <span class="number">1</span>)seg.low(l,r,v);</span><br><span class="line">		<span class="keyword">else</span> seg.up(l,r,v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> ans = seg.get(i);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; (ans == NO_OPT?<span class="number">0</span>:ans) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]CCPC网络赛2019 B - array</title>
    <url>/2020/09/19/solution-HDU6703/</url>
    <content><![CDATA[<h1 id="CCPC网络赛2019-B-array"><a href="#CCPC网络赛2019-B-array" class="headerlink" title="[CCPC网络赛2019] B - array"></a>[CCPC网络赛2019] B - array</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一个数列${a_i}$,维护两种操作:</p>
<ul>
<li><code>1 pos</code> : 把$a_{pos}$加上$10^7$</li>
<li><code>2 r k</code>: 找到一个不小于$k$且不等于$a_1,…,a_r$的最小值$x$</li>
</ul>
<p>共有$m$组询问,强制在线.</p>
<p>$1 \leq n,m \leq 10^5$,$1 \leq a_i \leq n$. 保证$1 \leq pos,r,k\leq n$</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>建一棵权值线段树,每个点存储该数原来的位置.维护$Set$操作和$minv$.</p>
<p>对于操作1,由限制易得等同于删除$a_{pos}$.</p>
<p>对于操作2,我们搜索权值线段树里$[k,n]$中大于$r$的第一个最小值,若不存在则答案为$n+1$.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HDU6703 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segtree</span>&#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> NO_OPT = INT_MAX;</span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;setv,maxv;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(size &lt; n)size *= <span class="number">2</span>;</span><br><span class="line">		setv.assign(size*<span class="number">2</span>,NO_OPT);</span><br><span class="line">		maxv.assign(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(NO_OPT != setv[x])&#123;</span><br><span class="line">			setv[ls(x)] = setv[rs(x)] = setv[x];</span><br><span class="line">			maxv[ls(x)] = maxv[rs(x)] = setv[x];</span><br><span class="line">			setv[x] = NO_OPT;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		maxv[x] = max(maxv[ls(x)],maxv[rs(x)]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">		pushdown(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			setv[x] = v;</span><br><span class="line">			maxv[x] = v;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		Set(l,r,v,ls(x),lx,m);</span><br><span class="line">		Set(l,r,v,rs(x),m,rx);</span><br><span class="line">		pushup(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		r++;</span><br><span class="line">		Set(l,r,v,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		pushdown(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> maxv[x] &lt; v)<span class="keyword">return</span> NO_OPT;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(setv[x] != NO_OPT)&#123;</span><br><span class="line">				maxv[x] = setv[x];</span><br><span class="line">				setv[x] = NO_OPT;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(maxv[x] &gt;= v)<span class="keyword">return</span> lx;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">return</span> NO_OPT;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> idx1 = kth(l,v,ls(x),lx,m),idx2 = NO_OPT;</span><br><span class="line">		<span class="keyword">if</span>(idx1 == NO_OPT)idx2 = kth(l,v,rs(x),m,rx);</span><br><span class="line">		<span class="keyword">return</span> min(idx1,idx2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> kth(l,v,<span class="number">0</span>,<span class="number">0</span>,size); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="keyword">int</span> lstans = <span class="number">0</span>;</span><br><span class="line">		segtree seg;</span><br><span class="line">		<span class="keyword">int</span> n,m;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;raw(n+<span class="number">10</span>);</span><br><span class="line">		seg.init(<span class="number">1e5</span>+<span class="number">10</span>);</span><br><span class="line">		seg.Set(<span class="number">0</span>,<span class="number">0</span>,INF);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; raw[i];</span><br><span class="line">			seg.Set(raw[i],raw[i],i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">			<span class="keyword">int</span> opt,l,r;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; opt &gt;&gt; l;</span><br><span class="line">			l ^= lstans;</span><br><span class="line">			<span class="keyword">if</span>(opt == <span class="number">1</span>)&#123;</span><br><span class="line">				seg.Set(raw[l],raw[l],INF);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="built_in">cin</span> &gt;&gt; r;</span><br><span class="line">				r ^= lstans;</span><br><span class="line">				lstans = seg.kth(r,l+<span class="number">1</span>);</span><br><span class="line">				<span class="keyword">if</span>(lstans == INT_MAX)lstans = n+<span class="number">1</span>;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; lstans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>CCPC</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>权值线段树</tag>
        <tag>CCPC</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]CF1385E</title>
    <url>/2020/10/08/solution-CF1385E/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给出一张图, 图中有的边已确定方向(且不可更改), 另一些边尚未确定方向. 给所有未确定方向的边指定一个方向, 使得新的图不存在环. 如果无解输出<code>NO</code></p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>一张图的拓扑排序是一个DAG. 我们首先仅考虑原图的有向边, 如果其中存在环那么无解. 否则求原图的拓扑序, 按拓扑序指派边的方向即可.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">10</span>; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> f,t,next;</span><br><span class="line">	Edge(<span class="keyword">int</span> f = <span class="number">0</span>,<span class="keyword">int</span> t = <span class="number">0</span>,<span class="keyword">int</span> next = <span class="number">0</span>):f(f),t(t),next(next)&#123;&#125;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="keyword">int</span> cnt,head[maxm],vis[maxm],dep[maxn],in[maxn],dict[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	edge[cnt] = Edge(f,t,head[f]);</span><br><span class="line">	head[f] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> ok = <span class="number">1</span>;</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;Node[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> qwq = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)<span class="keyword">if</span>(!in[i])&#123;</span><br><span class="line">		q.push(i);</span><br><span class="line">		vis[i] = <span class="number">1</span>;</span><br><span class="line">		dep[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(q.empty())ok = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		<span class="keyword">int</span> u = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		dep[u] = ++qwq;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">			<span class="keyword">if</span>(--in[v])&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			q.push(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(qwq != n)ok = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		ok = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> n,m;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">			head[i] = <span class="number">-1</span>;</span><br><span class="line">			dep[i] = dict[i] = in[i] = vis[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> opt,f,t;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; opt &gt;&gt; f &gt;&gt; t;</span><br><span class="line">			Node[i] = &#123;f,t&#125;;</span><br><span class="line">			<span class="keyword">if</span>(opt)&#123;</span><br><span class="line">				addedge(f,t);</span><br><span class="line">				in[t]++;</span><br><span class="line">				dict[i] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		BFS(n);</span><br><span class="line">		<span class="keyword">if</span>(!ok)&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"NO\n"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"YES\n"</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">				<span class="keyword">int</span> &amp; f = Node[i].first,&amp; t = Node[i].second;</span><br><span class="line">				<span class="keyword">if</span>(dep[f] &gt; dep[t])<span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="string">" "</span> &lt;&lt; f &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; f &lt;&lt; <span class="string">" "</span> &lt;&lt; t &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]CF1417E</title>
    <url>/2020/10/14/solution-CF1417E/</url>
    <content><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一个长为$n$的数组${a_i}$, 用$x$异或数组中的每一个元素, 使得在新数组逆序对最少的情况下$x$最小.求满足题意的逆序对数和$x$</p>
<p>$1 \le n \le 3 \cdot 10^5$</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>异或让我们考虑0-1Trie.</p>
<p>对于每一个数, 按照从高位到低位的顺序插入Trie, 并对其经过的每个节点维护该数字的下标. 具体来说,<code>idx[u]</code>记录了经过节点$u$的数字的下标. 由于我们按下标递增的顺序插入元素, 该数组是有序的.</p>
<p>有了<code>idx[]</code>，再结合一个显然的事实: 两个数的大小只取决于其最高位, 我们就可高效计算每一位所影响的逆序对(0-1Trie中,左子树代表的值小于右子树).</p>
<p>具体做法: 从高位开始自上而下遍历整棵0-1Trie. 设当前节点为$u$, 当$u$的两个子节点均存在时, 修改该位才能对逆序对数目产生影响. 利用前面维护的下标, 我们可以在线性时间内计算该位对逆序对数目的贡献.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ptr = <span class="number">0</span>;<span class="comment">//右子树idx[]的游标</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x:idx[l])&#123;<span class="comment">//遍历左子树的下标</span></span><br><span class="line">		<span class="keyword">while</span>(ptr &lt; idx[r].size() <span class="keyword">and</span> idx[r][ptr] &lt; x)ptr++;<span class="comment">//左子树当前下标贡献的逆序对个数</span></span><br><span class="line">			inv += ptr;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用$sum[][]$来记录该结果.$sum[i][0]$表示不修改第$i$位所贡献的逆序对, $sum[i][1]$表示修改该位贡献的逆序对.容易看出修改该位后, 原本的逆序对变成了顺序对, 反之亦然.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sum[dep][<span class="number">0</span>] += inv;</span><br><span class="line">sum[dep][<span class="number">1</span>] += (ll)idx[l].size()*idx[r].size() - inv;</span><br></pre></td></tr></table></figure>
<p>有了sum数组,答案便很容易统计:$inv += \min(sum[i][0],sum[i][1])$. 而当$sum[i][1] &lt; sum[i][0]$时, $x$的第$i$位为1.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//E</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">6e6</span>+<span class="number">10</span>;</span><br><span class="line">ll sum[<span class="number">100</span>][<span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> nxt[maxn][<span class="number">2</span>];</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;idx[maxn*<span class="number">2</span>];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">memset</span>(nxt,<span class="number">0</span>,<span class="keyword">sizeof</span>(nxt));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">29</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">			<span class="keyword">bool</span> c = ((<span class="number">1l</span>l&lt;&lt;i)&amp;x);</span><br><span class="line">			<span class="keyword">if</span>(!nxt[u][c])nxt[u][c] = size++;</span><br><span class="line">			u = nxt[u][c];</span><br><span class="line">			idx[u].push_back(pos);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> l = nxt[pos][<span class="number">0</span>],r = nxt[pos][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(l)DFS(l,dep<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">if</span>(r)DFS(r,dep<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">if</span>(!l <span class="keyword">or</span> !r)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">int</span> ptr = <span class="number">0</span>,inv = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x:idx[l])&#123;</span><br><span class="line">			<span class="keyword">while</span>(ptr &lt; idx[r].size() <span class="keyword">and</span> idx[r][ptr] &lt; x)ptr++;</span><br><span class="line">			inv += ptr;</span><br><span class="line">		&#125;</span><br><span class="line">		sum[dep][<span class="number">0</span>] += inv;</span><br><span class="line">		sum[dep][<span class="number">1</span>] += (ll)idx[l].size()*idx[r].size() - inv;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;trie;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	trie.clear();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">		trie.insert(x,i);</span><br><span class="line">	&#125;</span><br><span class="line">	trie.DFS(<span class="number">0</span>,<span class="number">29</span>);</span><br><span class="line">	ll X = <span class="number">0</span>,inv = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">29</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">		inv += min(sum[i][<span class="number">0</span>],sum[i][<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">if</span>(sum[i][<span class="number">1</span>] &lt; sum[i][<span class="number">0</span>])X += (<span class="number">1l</span>l &lt;&lt; i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; inv &lt;&lt; <span class="string">" "</span> &lt;&lt; X;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]CF1433G-Reducing Delivery Cost</title>
    <url>/2020/10/22/solution-CF1433G/</url>
    <content><![CDATA[<h1 id="CF1433G-Reducing-Delivery-Cost"><a href="#CF1433G-Reducing-Delivery-Cost" class="headerlink" title="[CF1433G]Reducing Delivery Cost"></a>[CF1433G]Reducing Delivery Cost</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一张无向带权图$G$和$k$个点对, 你可以将最多一条边的权值变为0, 求$k$个点对之间最短路之和的最小值</p>
<p>图中存在重边和自环.</p>
<p>$1 \leq n \leq 1000, 1 \leq m \leq \frac{n(n-1)}{2},1 \leq k \leq 1000$</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>套路题, 一开始想麻烦了.</p>
<p>设$D[i][j]$为$(i,j)$间的最短路. 对于每条边$(f,t)$有两种情况:</p>
<ol>
<li>无论该边权值是否为零, 都不在点对$(x,y)$的最短路上. 删掉该边后答案仍为$D[x][y]$.</li>
<li>删掉该边前/后该边位于点对$(x,y)$的最短路上. 删掉该边后答案为$\min(D[x][f]+D[t][y],D[x][t]+D[f][y])$</li>
</ol>
<p>我们跑$n$遍Dijkstra预处理出任意点对最短路,再对于每条边枚举$k$个点对即可求出答案.总复杂度$O(nm\log n + km)$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">#define endl &#39;\n&#39;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int INF &#x3D; 1e9+10;</span><br><span class="line">const int maxn &#x3D; 1e3+10;</span><br><span class="line">const int maxm &#x3D; maxn*maxn;</span><br><span class="line">typedef pair&lt;int,int&gt; Node;</span><br><span class="line">int head[maxn],vis[maxn],dis[maxn];</span><br><span class="line">int D[maxn][maxn]; </span><br><span class="line">int viscnt[maxm];</span><br><span class="line">struct Edge&#123;</span><br><span class="line">	int f,t,w,next;</span><br><span class="line">	Edge(int f &#x3D; 0,int t &#x3D; 0,int w &#x3D; 0,int next &#x3D; 0):f(f),t(t),w(w),next(next)&#123;&#125;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line">int cnt &#x3D; 0,n,m;</span><br><span class="line">void addedge(int f,int t,int w)&#123;</span><br><span class="line">	edge[cnt] &#x3D; Edge(f,t,w,head[f]);</span><br><span class="line">	head[f] &#x3D; cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void dijkstra(int s)&#123;</span><br><span class="line">	for(int i &#x3D; 0;i &lt;&#x3D; n;i++)&#123;</span><br><span class="line">		dis[i] &#x3D; INF;</span><br><span class="line">		vis[i] &#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line">	dis[s] &#x3D; 0;</span><br><span class="line">	priority_queue&lt;Node,vector&lt;Node&gt;,greater&lt;Node&gt; &gt;pq;</span><br><span class="line">	pq.push(&#123;dis[s],s&#125;);</span><br><span class="line">	while(!pq.empty())&#123;</span><br><span class="line">		int u &#x3D; pq.top().second;</span><br><span class="line">		pq.pop();</span><br><span class="line">		if(vis[u])continue;</span><br><span class="line">		vis[u] &#x3D; 1;</span><br><span class="line">		for(int i &#x3D; head[u];~i;i &#x3D; edge[i].next)&#123;</span><br><span class="line">			int v &#x3D; edge[i].t,w &#x3D; edge[i].w;</span><br><span class="line">			if(dis[v] &gt; dis[u] + w)&#123;</span><br><span class="line">				dis[v] &#x3D; dis[u] + w;</span><br><span class="line">				if(!vis[v])&#123;</span><br><span class="line">					pq.push(&#123;dis[v],v&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">	ios::sync_with_stdio(0);</span><br><span class="line">	cin.tie(0);</span><br><span class="line">	memset(head,-1,sizeof(head));</span><br><span class="line">	memset(D,0x3f3f3f3f,sizeof(D));</span><br><span class="line">	int k;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">	for(int i &#x3D; 1;i &lt;&#x3D; m;i++)&#123;</span><br><span class="line">		int f,t,w;</span><br><span class="line">		cin &gt;&gt; f &gt;&gt; t &gt;&gt; w;</span><br><span class="line">		addedge(f,t,w);</span><br><span class="line">		addedge(t,f,w);</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i &#x3D; 1;i &lt;&#x3D; n;i++)&#123;</span><br><span class="line">		dijkstra(i);</span><br><span class="line">		for(int j &#x3D; 1;j &lt;&#x3D; n;j++)D[i][j] &#x3D; D[j][i] &#x3D; dis[j];</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;Node&gt;path; </span><br><span class="line">	for(int i &#x3D; 1;i &lt;&#x3D; k;i++)&#123;</span><br><span class="line">		int x,y;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		path.push_back(&#123;x,y&#125;);</span><br><span class="line">	&#125; </span><br><span class="line">	ll ans &#x3D; LLONG_MAX;</span><br><span class="line">	for(int i &#x3D; 0;i &lt; cnt;i++)&#123;</span><br><span class="line">		int f &#x3D; edge[i].f,t &#x3D; edge[i].t;</span><br><span class="line">		ll tans &#x3D; 0;</span><br><span class="line">		for(int j &#x3D; 0;j &lt; k;j++)&#123;</span><br><span class="line">			int x &#x3D; path[j].first,y &#x3D; path[j].second;</span><br><span class="line">			tans +&#x3D; min(&#123;D[x][y],D[x][f]+D[t][y],D[x][t]+D[f][y]&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		ans &#x3D; min(ans,tans);	</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]Gym102798-C Rencontre (CCPC2020威海站)</title>
    <url>/2020/11/18/solution-Gym102798-C/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给出一棵$n$个点的带权无根树, 给出三个点的集合. 在每个集合任取一点, 在树上寻找新的一个点使得该点到三点的路径和最短. 求路径和期望</p>
<p>$ 1 \le n \le 2\cdot10^5,1 \le w \le 1000$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先考虑这样一个问题: 给出树上三点$a,b,c$, 求这三点汇聚到一点$v$的最短路径(设为$f(a,b,c)$)</p>
<script type="math/tex; mode=display">
f(a,b,c) = \min\{v\in V |dis(a,v) + dis(b,v) + dis(c,v)\}</script><p><img src="C:\Users\frien\AppData\Roaming\Typora\typora-user-images\image-20201119121551047.png" alt="image-20201119121551047" style="zoom: 33%;" /></p>
<p>如上图所示, $a,b,c$为$3,4,5$. 观察易得汇合点$v$为$2$, 即$a,b,c$的LCA中深度最深的那个.  此时$a,b\space a,c \space b,c$间的每条边都恰好经过一次, 即:</p>
<script type="math/tex; mode=display">
f(a,b,c) = \frac{1}{2}(dis(a,b) + dis(a,c) + dis(b,c))</script><p>由期望的性质$E(X + Y) = E(X) + E(Y)$, 我们可以分别计算两个集合$j,k$中各点的距离和. 通过一遍DFS来计算子树$u$中属于集合$i$的节点个数$num[u][i]$, 再对每条边分别统计贡献$g$. 设$cnt_i$为集合$i$的大小.</p>
<script type="math/tex; mode=display">
g(e_i,j,k) = ((cnt_i - num[u][j])*num[u][k] + (cnt_k - num[u][k])*cnt_j)*e_i.w</script><p>答案即为</p>
<script type="math/tex; mode=display">
\sum_{j = 1}^3 \sum_{k = j+1}^3\frac{\sum_{i = 1}^{n-1}g(e_i,j,k)}{2\cdot cnt_j \cdot cnt_k}</script><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> ld;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn],cnt,use[maxn][<span class="number">4</span>],num[maxn][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll sum[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> f,t,w,next;</span><br><span class="line">	Edge(<span class="keyword">int</span> f = <span class="number">0</span>,<span class="keyword">int</span> t = <span class="number">0</span>,<span class="keyword">int</span> w = <span class="number">0</span>,<span class="keyword">int</span> next = <span class="number">0</span>):f(f),t(t),w(w),next(next)&#123;&#125;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">	edge[cnt] = Edge(f,t,w,head[f]);</span><br><span class="line">	head[f] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">3</span>;i++)<span class="keyword">if</span>(use[u][i])num[u][i] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].t,w = edge[i].w;</span><br><span class="line">		<span class="keyword">if</span>(v == fa)<span class="keyword">continue</span>;</span><br><span class="line">		DFS(v,u);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">3</span>;j++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k = j+<span class="number">1</span>;k &lt;= <span class="number">3</span>;k++)&#123;</span><br><span class="line">				sum[j][k] += (num[<span class="number">0</span>][j] - num[v][j])*num[v][k]*w;</span><br><span class="line">				sum[j][k] += (num[<span class="number">0</span>][k] - num[v][k])*num[v][j]*w;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">3</span>;j++)num[u][j] += num[v][j];</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>.setf(ios::fixed,ios::floatfield);</span><br><span class="line">	<span class="built_in">cout</span>.precision(<span class="number">10</span>);</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> f,t,w;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; f &gt;&gt; t &gt;&gt; w;</span><br><span class="line">		addedge(f,t,w);</span><br><span class="line">		addedge(t,f,w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">3</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> m;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">		num[<span class="number">0</span>][i] = m;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++)&#123;</span><br><span class="line">			<span class="keyword">int</span> x;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">			use[x][i] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	DFS(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">	ld ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">3</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt;= <span class="number">3</span>;j++)ans += (<span class="keyword">double</span>)sum[i][j]/num[<span class="number">0</span>][i]/num[<span class="number">0</span>][j]/<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS: 当时我这题题意转述的时候锅了, 导致队友直接一个点分治敲上去, 敲完才发现不对劲=-= 不然这题是有可能做出来的</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>CCPC</tag>
        <tag>树形DP</tag>
        <tag>Regional</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]CF1451E2-Bitwise Queries (Hard Version)</title>
    <url>/2020/11/26/solution-CF1451E2/</url>
    <content><![CDATA[<p>小清新构造题</p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>交互题.</p>
<p>有一个长度为$n$的数列${a_i}$, 满足$a_i \in [0,n-1], n \in [4,2^{16}], n = 2^k$</p>
<p>你可以进行最多$n+1$次询问, 询问分三种:</p>
<p><code>AND i j</code>      返回$a_i \&amp; a_j$的值</p>
<p><code>OR i j</code>        返回$a_i | a_j$的值</p>
<p><code>XOR i j</code>      返回$a_i \oplus a_j$的值</p>
<p>均需满足$1 \leq i,j \leq n$且$i \ne j$</p>
<p>当确定答案后, 你需要输出<code>!</code>然后在同一行内输出这个数组.</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先一个显而易见的结论: 询问$a_1$与$a_2…a_n$的异或(共$n-1$次询问), 再在两次询问内求出$a_1$的值就能还原整个数组. 问题转化为如何求出$a_1$,</p>
<p>因为数列长度为$n$值域为$[0,n-1]$, 由鸽巢原理可得:</p>
<ol>
<li><p>数列中至少有两个数字相同</p>
<p> 分为两种情况:</p>
<ol>
<li><p>$a_1$与其他至少一个数字相同. </p>
<p> 表现为至少一个异或询问$a_1 \oplus a_i$的答案为$0$. 一次<code>AND 1 i</code>询问即可求出$a_1$的值.</p>
</li>
<li><p>$a_i$与$a_j$相同($i,j \ne 1$). </p>
<p> 此时至少两个异或询问的答案相等($a_1 \oplus a_i = a_1 \oplus a_j$), 即$a_i = a_j$. 通过一次<code>AND i j</code>可求出$a_i$的值, 再由$a_1 \oplus a_i \oplus a_i = a_1$求出$a_1$</p>
</li>
</ol>
</li>
<li><p>数列中全部数字均不相同.</p>
<p>由于$n = 2^k$且$n \ge 4$, $k$位二进制的每一种情况均会出现, 故必存在$a_1 \oplus a_i = 1$. 显然$a_1$与$a_i$只有最后一位不同. 这时一次<code>AND 1 i</code>可获得$a_1$除了最后一位外的信息. 同理存在$a_1 \oplus a_j = 2$, <code>AND 1 j</code>可获得$a_1$最后一位的信息. 两者综合起来即可求出$a_1$</p>
</li>
</ol>
<p>以上无论何种情况, 询问次数都不超过$n+1$</p>
<p>时间复杂度$O(n\log n)$ (因为有一次不必要的排序来去重)</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//E</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="comment">// #define endl '\n'</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> Xor[maxn],ans[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> w,idx;</span><br><span class="line">	Node(<span class="keyword">int</span> w = <span class="number">0</span>,<span class="keyword">int</span> idx = <span class="number">0</span>):w(w),idx(idx)&#123;&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp; x) <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> w &lt; x.w;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;node[maxn];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"XOR 1 "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">int</span> x;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">		Xor[i] = x;</span><br><span class="line">		node[i] = Node(x,i);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(node+<span class="number">2</span>,node+n+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt;= n;i++)<span class="keyword">if</span>(node[i].w == node[i<span class="number">-1</span>].w)idx = i;</span><br><span class="line">	<span class="keyword">if</span>(!node[<span class="number">2</span>].w)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"AND 1 "</span> &lt;&lt; node[<span class="number">2</span>].idx &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">int</span> x;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">		ans[<span class="number">1</span>] = x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(idx)&#123;</span><br><span class="line">		<span class="keyword">int</span> l = node[idx].idx,r = node[idx<span class="number">-1</span>].idx;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"AND "</span> &lt;&lt; l &lt;&lt; <span class="string">" "</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">int</span> x;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">		ans[<span class="number">1</span>] = Xor[l]^x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> bit_0 = <span class="number">0</span>,bit_1 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(Xor[i] == <span class="number">1</span>)&#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"AND 1 "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">int</span> x;</span><br><span class="line">				<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">				bit_0 = x;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(Xor[i] == <span class="number">2</span>)&#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"AND 1 "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">int</span> x;</span><br><span class="line">				<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">				bit_1 = x;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(bit_0 &amp; <span class="number">1</span>)bit_0--;</span><br><span class="line">		<span class="keyword">if</span>(bit_1 &amp; <span class="number">1</span>)bit_0++;</span><br><span class="line">		ans[<span class="number">1</span>] = bit_0;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)ans[i] = Xor[i]^ans[<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"! "</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)<span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>构造</tag>
        <tag>交互</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]-CF1454E</title>
    <url>/2020/11/25/solution-CF1454E/</url>
    <content><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一棵基环树, 求树上简单路径条数</p>
<p>$3 \leq n \leq 2 \cdot 10^5$</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>将基环树看作一个环, 环上连接着一些树, 设第$i$棵树有$cnt_i$个节点.</p>
<p>路径分为两种情况:</p>
<ol>
<li>在树内. 有$\frac{cnt_i \cdot (cnt_i - 1)}{2}$条</li>
<li>由树内到树外, 有$cnt_i \cdot (n - cnt_i)$条(这里只计算了一半, 但当计算完全部子树后答案是完整的)</li>
</ol>
<p>通过一遍$DFS$求出环, 再通过一次$DFS$求出每个子树大小, 答案为</p>
<script type="math/tex; mode=display">
\sum_{i \in subtree}\frac{cnt_i\cdot(cnt_i-1)}{2} + cnt_{i}\cdot(n - cnt_i)</script><p>复杂度$O(n)$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//E</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = maxn*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn],pa[maxn];</span><br><span class="line"><span class="keyword">bool</span> loop[maxn],vis[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> f,t,next;</span><br><span class="line">	Edge(<span class="keyword">int</span> f = <span class="number">0</span>,<span class="keyword">int</span> t = <span class="number">0</span>,<span class="keyword">int</span> next = <span class="number">0</span>):f(f),t(t),next(next)&#123;&#125;	</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="keyword">int</span> tcnt,cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	edge[cnt] = Edge(f,t,head[f]);</span><br><span class="line">	head[f] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> ok = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ok)<span class="keyword">return</span>;</span><br><span class="line">	vis[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">		<span class="keyword">if</span>(v == fa <span class="keyword">or</span> ok)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(vis[v])&#123;</span><br><span class="line">			<span class="keyword">while</span>(u != v)&#123;</span><br><span class="line">				loop[u] = <span class="number">1</span>;</span><br><span class="line">				u = pa[u];</span><br><span class="line">				ok = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			loop[v] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pa[v] = u;</span><br><span class="line">		pre(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	tcnt++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">		<span class="keyword">if</span>(v == fa <span class="keyword">or</span> loop[v])<span class="keyword">continue</span>;</span><br><span class="line">		DFS(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		tcnt = <span class="number">0</span>;</span><br><span class="line">		ok = <span class="number">0</span>;</span><br><span class="line">		cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">vector</span>&lt;ll&gt;res;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)head[i] = <span class="number">-1</span>,loop[i] = <span class="number">0</span>,pa[i] = vis[i] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> f,t;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; f &gt;&gt; t;</span><br><span class="line">			addedge(f,t);</span><br><span class="line">			addedge(t,f);</span><br><span class="line">		&#125;</span><br><span class="line">		pre(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(loop[i])&#123;</span><br><span class="line">				tcnt = <span class="number">0</span>;</span><br><span class="line">				DFS(i,<span class="number">-1</span>);</span><br><span class="line">				res.push_back(tcnt);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ll ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(ll x:res)ans += x*(x<span class="number">-1</span>)/<span class="number">2</span> + x*(n-x);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>基环树</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]CF1200 E-Compress Words</title>
    <url>/2020/12/03/solution-CF1200E/</url>
    <content><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出$n$个字符串, 将字符串按顺序拼接. 拼接时删除后面字符串的前缀与前面字符串的后缀中的最长相同部分.</p>
<p>例如<code>sample</code>与<code>please</code>拼接成为<code>samplease</code></p>
<p>$1 \leq n \leq 10^5$, $\sum|s_i| \leq 10^6$</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>设将$u$和$v$拼接在一起, 用KMP求出$s = v|u$(|是任意分隔符)的失配数组$next[]$.由于失配数组代表前后缀的最长长度, $next[|s|]$即为$v$的前缀与$u$的后缀相同部分的最长长度.</p>
<p>注意到这个最长长度不会超过$|v|$, 因此我们只需把$u$的最后$|v|$个字符接到分隔符后. 时间复杂度$O(\sum|s_i|)$</p>
<p>赛时十分傻逼地忘了用分隔符把$u,v$分隔开, 疯狂WA到怀疑人生…顺便吐槽一句这个数据真的弱</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我  是  傻  逼</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="keyword">int</span> Next[<span class="number">4000010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFail</span><span class="params">(<span class="built_in">string</span> &amp; P)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= (<span class="keyword">int</span>)P.size();i++)Next[i] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> p_size = P.size();</span><br><span class="line">	Next[<span class="number">0</span>] = Next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; p_size;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> j = Next[i];</span><br><span class="line">		<span class="keyword">while</span>(j <span class="keyword">and</span> P[i] != P[j])j = Next[j];</span><br><span class="line">		Next[i+<span class="number">1</span>] = (P[j] == P[i]?j+<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">process</span><span class="params">(<span class="built_in">string</span> &amp; u,<span class="built_in">string</span> &amp; v)</span></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> x = v;</span><br><span class="line">	x += <span class="string">'|'</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = max(<span class="number">0</span>,(<span class="keyword">int</span>)(u.size() - v.size()));i &lt; (<span class="keyword">int</span>)u.size();i++)x += u[i];</span><br><span class="line">	getFail(x);</span><br><span class="line">	<span class="built_in">string</span> tans = <span class="string">""</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = Next[x.size()];i &lt; (<span class="keyword">int</span>)v.size();i++)tans += v[i];</span><br><span class="line">	<span class="keyword">return</span> tans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="built_in">string</span> ans = <span class="string">""</span>;</span><br><span class="line">	<span class="built_in">string</span> u,v;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; u;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; u;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">	ans = u + process(u,v);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; v;</span><br><span class="line">		ans += process(ans,v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]CF1473E-Minimum Path</title>
    <url>/2021/01/16/solution-CF1473E/</url>
    <content><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一个$n$个点, $m$条边, 不含自环, 重边的带权无向图, 定义一条路径$<v_1,v_2,...v_k>$的权值为</p>
<script type="math/tex; mode=display">
\sum_{i = 1}^k w_{v_i} - \max_{i = 1}^k\{w_{v_i}\} + \min_{i = 1}^k\{w_{v_i}\}</script><p>求从点1到其他所有点路径的最小权值</p>
<p>$2 \leq n \leq 2e5,1 \leq m \leq 2e5,1 \leq w \leq 1e9$</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>原问题要求在权值中减去边权最大值, 加上边权最小值. 我们考虑<strong>将问题约束放宽</strong>: 可以减去和加上任意一条边的边权. </p>
<p>可以发现, 在最短路径中, 减去的必定是边权最大值, 而加上的必定是边权最小值(可用反证法证明), 即放宽后的问题与原问题等价.</p>
<p>求解该问题可以用分层图最短路. 由于必须加上和减去一条边的边权, 故求解最短路径时可能有以下三种情况:</p>
<ol>
<li>先减去边X(图A), 再加上边Y(图B)</li>
<li>先加上边X(图C), 再减去边Y(图D) </li>
<li><p>加上和减去同一条边X (图S, 相当于原图最短路)</p>
<p><img src="https://i.loli.net/2021/01/16/tdNH1ugTGCOhiA2.png" alt="pic1.png"></p>
</li>
</ol>
<p>建图时每层原图为无向边，连接两层图之间的边为有向边, 具体细节见代码. 从1开始跑Dijkstra, 图S, B , D的最小值即为答案.</p>
<p>时间复杂度: $O(m\log n)$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll,<span class="keyword">int</span>&gt; node;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = N*<span class="number">6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = maxn*<span class="number">6</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e17</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn],cnt;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line">ll dis[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> f,t;</span><br><span class="line">	ll w;</span><br><span class="line">	<span class="keyword">int</span> next;</span><br><span class="line">	Edge(<span class="keyword">int</span> f = <span class="number">0</span>,<span class="keyword">int</span> t = <span class="number">0</span>,ll w = <span class="number">0</span>,<span class="keyword">int</span> next = <span class="number">0</span>):f(f),t(t),w(w),next(next)&#123;&#125;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t,ll w)</span></span>&#123;</span><br><span class="line">	edge[cnt] = Edge(f,t,w,head[f]);</span><br><span class="line">	head[f] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; maxn;i++)dis[i] = INF;</span><br><span class="line">	dis[s] = <span class="number">0</span>;</span><br><span class="line">	priority_queue&lt;node,<span class="built_in">vector</span>&lt;node&gt;,greater&lt;node&gt; &gt;pq;</span><br><span class="line">	pq.push(&#123;<span class="number">0</span>,s&#125;);</span><br><span class="line">	<span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">		<span class="keyword">int</span> u = pq.top().second;</span><br><span class="line">		pq.pop();</span><br><span class="line">		<span class="keyword">if</span>(vis[u])<span class="keyword">continue</span>;</span><br><span class="line">		vis[u] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">			ll w = edge[i].w;</span><br><span class="line">			<span class="keyword">if</span>(dis[v] &gt; dis[u] + w)&#123;</span><br><span class="line">				dis[v] = dis[u] + w;</span><br><span class="line">				<span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">					pq.push(&#123;dis[v],v&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">	addedge(f,t,w);</span><br><span class="line">	addedge(t,f,w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> f,t,w;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; f &gt;&gt; t &gt;&gt; w;</span><br><span class="line">		<span class="comment">//+0:ori</span></span><br><span class="line">		<span class="comment">//+N:sub first</span></span><br><span class="line">		<span class="comment">//+2*N:sub -&gt; add</span></span><br><span class="line">		<span class="comment">//+3*N:add first</span></span><br><span class="line">		<span class="comment">//+4*N:add -&gt; sub</span></span><br><span class="line">		add(f,t,w);</span><br><span class="line">		add(f+N,t+N,w);</span><br><span class="line">		add(f+<span class="number">2</span>*N,t+<span class="number">2</span>*N,w);</span><br><span class="line">		add(f+<span class="number">3</span>*N,t+<span class="number">3</span>*N,w);</span><br><span class="line">		add(f+<span class="number">4</span>*N,t+<span class="number">4</span>*N,w);</span><br><span class="line">		addedge(f,t+N,<span class="number">0</span>);<span class="comment">//sub</span></span><br><span class="line">		addedge(t,f+N,<span class="number">0</span>);</span><br><span class="line">		addedge(f+N,t+<span class="number">2</span>*N,<span class="number">2</span>*w);<span class="comment">//add</span></span><br><span class="line">		addedge(t+N,f+<span class="number">2</span>*N,<span class="number">2</span>*w);</span><br><span class="line">		addedge(f,t+<span class="number">3</span>*N,<span class="number">2</span>*w);<span class="comment">//add</span></span><br><span class="line">		addedge(t,f+<span class="number">3</span>*N,<span class="number">2</span>*w);</span><br><span class="line">		addedge(f+<span class="number">3</span>*N,t+<span class="number">4</span>*N,<span class="number">0</span>);<span class="comment">//sub</span></span><br><span class="line">		addedge(t+<span class="number">3</span>*N,f+<span class="number">4</span>*N,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	dijkstra(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; min(&#123;dis[i+<span class="number">2</span>*N],dis[i+<span class="number">4</span>*N],dis[i]&#125;) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA</title>
    <url>/2020/12/11/JAVA/</url>
    <content><![CDATA[<h2 id="大整数"><a href="#大整数" class="headerlink" title="大整数"></a>大整数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">比较大小: a.compareTo(b): 小于返回-<span class="number">1</span>,等于返回<span class="number">0</span>,大于返回<span class="number">1</span></span><br><span class="line"><span class="keyword">int</span>/<span class="keyword">long</span>转换: BigIntger a = BigInteger.valueOf(<span class="number">114514</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来自https://blog.csdn.net/dlx_handsome/article/details/102529307</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.math.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//随便打的两个数,不过用生成随机大整数不是更香嘛</span></span><br><span class="line">    	BigInteger number1=<span class="keyword">new</span> BigInteger(<span class="string">"347238462384523623645237465237415234165234615246742354"</span>);</span><br><span class="line">    	BigInteger number2=<span class="keyword">new</span> BigInteger(<span class="string">"42673547263541874637462394142837645"</span>);</span><br><span class="line">    	<span class="comment">//返回一个BigInteger，其值为该BigInteger的绝对值。</span></span><br><span class="line">    	System.out.println(<span class="string">"abs():"</span>+number1.abs().toString());</span><br><span class="line">    	<span class="comment">//返回值为BigInteger (this / val)。</span></span><br><span class="line">    	System.out.println(<span class="string">"divide():"</span>+number1.divide(number2));</span><br><span class="line">    	<span class="comment">//返回值为的BigInteger (this % val)。</span></span><br><span class="line">    	System.out.println(<span class="string">"remainder():"</span>+number1.remainder(number2));</span><br><span class="line">    	<span class="comment">//返回值为的BigInteger (this + val)。</span></span><br><span class="line">    	System.out.println(<span class="string">"add():"</span>+number1.add(number2).toString());</span><br><span class="line">    	<span class="comment">//返回值为的BigInteger (this &lt;&lt; n)。</span></span><br><span class="line">    	System.out.println(<span class="string">"shiftLeft():"</span>+number1.shiftLeft(<span class="number">1</span>));</span><br><span class="line">    	<span class="comment">//返回值为的BigInteger (this &gt;&gt; n)。</span></span><br><span class="line">    	System.out.println(<span class="string">"shiftRight():"</span>+number1.shiftRight(<span class="number">1</span>));</span><br><span class="line">    	<span class="comment">//返回此BigInteger的signum函数 返回-1,0,1作为BigInteger的符号</span></span><br><span class="line">    	System.out.println(<span class="string">"signum():"</span>+number1.signum());</span><br><span class="line">    	<span class="comment">//返回此BigInteger的整数平方根。</span></span><br><span class="line">    	System.out.println(<span class="string">"sqrt():"</span>+number1.sqrt());</span><br><span class="line">    	<span class="comment">//返回值为的BigInteger (this &amp; val)。</span></span><br><span class="line">    	System.out.println(<span class="string">"and():"</span>+number1.and(number2));</span><br><span class="line">    	<span class="comment">//返回值为的BigInteger (this &amp; ~val)。</span></span><br><span class="line">    	System.out.println(<span class="string">"andNot():"</span>+number1.andNot(number2));</span><br><span class="line">    	<span class="comment">//返回此BigInteger的二进制补码表示形式中不同于其符号位的位数.</span></span><br><span class="line">    	<span class="comment">//此方法在此BigInteger，从它的符号位不同的补码表示返回的比特数</span></span><br><span class="line">    	System.out.println(<span class="string">"bitCount():"</span>+number1.bitCount());</span><br><span class="line">    	<span class="comment">//	返回此BigInteger的最小2补码表示形式中的位数，不包括符号位。</span></span><br><span class="line">    	System.out.println(<span class="string">"bitLength():"</span>+number1.bitLength());</span><br><span class="line">    	<span class="comment">//将其转换BigInteger为byte，以检查是否丢失了信息。如果超出了,会丢出一个ArithmeticException异常</span></span><br><span class="line">    	<span class="comment">//System.out.println("byteValueExact():"+number1.byteValueExact());</span></span><br><span class="line">    	<span class="comment">//返回一个BigInteger，其值等于该BigInteger，并且清除了指定的位。</span></span><br><span class="line">    	System.out.println(<span class="string">"clearBit:"</span>+number2.clearBit(<span class="number">0</span>));</span><br><span class="line">    	<span class="comment">//将此BigInteger与指定的BigInteger进行比较。</span></span><br><span class="line">    	System.out.println(<span class="string">"compareTo():"</span>+number1.compareTo(number2));</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//返回两个BigIntegers组成的数组，其中包含(this / val) 后跟(this % val)。</span></span><br><span class="line">    	System.out.println(<span class="string">"divideAndRemainder():"</span>+Arrays.toString(number1.divideAndRemainder(number2)));</span><br><span class="line">    	<span class="comment">//将此BigInteger转换为double。</span></span><br><span class="line">    	System.out.println(<span class="string">"doubleValue():"</span>+number1.doubleValue());</span><br><span class="line">    	<span class="comment">//将此BigInteger转换为float。</span></span><br><span class="line">    	System.out.println(<span class="string">"floatValue():"</span>+number1.floatValue());</span><br><span class="line"><span class="comment">//    	返回此BigInteger和的最大值val。</span></span><br><span class="line">    	System.out.println(<span class="string">"max():"</span>+number1.max(number2));</span><br><span class="line">    	<span class="comment">//返回此BigInteger和的最小值val。</span></span><br><span class="line">    	System.out.println(<span class="string">"min():"</span>+number1.min(number2));</span><br><span class="line">    	<span class="comment">//返回值为的BigInteger (this mod m)。</span></span><br><span class="line">    	System.out.println(<span class="string">"mod():"</span>+number1.mod(number2));</span><br><span class="line">    	<span class="comment">//返回值为(this-1 的BigInteger mod m)。</span></span><br><span class="line">    	System.out.println(<span class="string">"modInverse():"</span>+number1.modInverse(number2));</span><br><span class="line">    	<span class="comment">//返回值为的BigInteger 。(thisexponent mod m)</span></span><br><span class="line">    	System.out.println(<span class="string">"modPow():"</span>+number1.modPow(BigInteger.valueOf(<span class="number">1</span>), number2));</span><br><span class="line">    	<span class="comment">//返回值为的BigInteger (this * val)。</span></span><br><span class="line">    	System.out.println(<span class="string">"multiply():"</span>+number1.multiply(number2));</span><br><span class="line">    	<span class="comment">//返回值为的BigInteger (-this)。 </span></span><br><span class="line">    	System.out.println(<span class="string">"negate():"</span>+number1.negate());</span><br><span class="line">    	<span class="comment">//将此BigInteger与指定的Object比较是否相等。</span></span><br><span class="line">    	System.out.println(<span class="string">"equals()就不说了,大家都明白...."</span>);</span><br><span class="line">    	<span class="comment">//返回一个BigInteger，其值等于该BigInteger的指定位被翻转。</span></span><br><span class="line">    	System.out.println(<span class="string">"flipBit():"</span>+number1.flipBit(<span class="number">1</span>));  	</span><br><span class="line">    	<span class="comment">//返回一个BigInteger，其值是abs(this)和的最大公约数 abs(val)。</span></span><br><span class="line">    	System.out.println(<span class="string">"gcd():"</span>+number1.gcd(number2));</span><br><span class="line">    	<span class="comment">//返回此BigInteger中最右边（最低位）的一位的索引（最右边一位的右边的零位数）。</span></span><br><span class="line">    	System.out.println(<span class="string">"getLowestSetBit():"</span>+number1.getLowestSetBit());</span><br><span class="line">    	<span class="comment">//返回此BigInteger的哈希码。</span></span><br><span class="line">    	System.out.println(<span class="string">"hashCode():"</span>+number1.hashCode());</span><br><span class="line">    	<span class="comment">//将此BigInteger转换为int。</span></span><br><span class="line">    	System.out.println(<span class="string">"intValue():"</span>+number1.intValue());</span><br><span class="line">    	<span class="comment">//	将此转换BigInteger为int，以检查是否丢失了信息。</span></span><br><span class="line">    	<span class="comment">//System.out.println("intValueExact():"+number1.intValueExact());</span></span><br><span class="line">    	<span class="comment">//true如果此BigInteger可能是质数，false则返回， 如果它绝对是复合的。</span></span><br><span class="line">    	System.out.println(<span class="string">"isProbablePrime():"</span>+number1.isProbablePrime(<span class="number">10</span>));</span><br><span class="line">    	<span class="comment">//将此BigInteger转换为long。</span></span><br><span class="line">    	System.out.println(<span class="string">"longValue():"</span>+number1.longValue());</span><br><span class="line">    	<span class="comment">//将其转换BigInteger为long，以检查是否丢失了信息。</span></span><br><span class="line">    	<span class="comment">//System.out.println("longValueExact()"+number1.longValueExact());</span></span><br><span class="line">    	<span class="comment">//将其转换BigInteger为short，以检查是否丢失了信息。</span></span><br><span class="line">    	<span class="comment">//System.out.println("shortValueExact"+number1.shortValueExact());</span></span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//返回大于此BigInteger可能是质数的第一个整数。</span></span><br><span class="line">    	System.out.println(<span class="string">"nextProbablePrime():"</span>+number1.nextProbablePrime());</span><br><span class="line">    	<span class="comment">//返回值为的BigInteger (~this)。</span></span><br><span class="line">    	System.out.println(<span class="string">"not():"</span>+number1.not());</span><br><span class="line">    	<span class="comment">//返回值为的BigInteger (this | val)。</span></span><br><span class="line">    	System.out.println(<span class="string">"or():"</span>+number1.or(number2));</span><br><span class="line">    	<span class="comment">//返回值为的BigInteger 。(thisexponent)</span></span><br><span class="line">    	System.out.println(<span class="string">"pow():"</span>+number1.pow(<span class="number">2</span>));</span><br><span class="line">    	<span class="comment">//返回带有指定bitLength的正BigInteger（可能是素数）。</span></span><br><span class="line">    	System.out.println(<span class="string">"probablePrime():"</span>+number1.probablePrime(<span class="number">10</span>, <span class="keyword">new</span> Random(<span class="number">10</span>)));</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    	<span class="comment">//返回一个BigInteger，其值与此指定位设置的BigInteger等效。</span></span><br><span class="line">    	System.out.println(<span class="string">"setBit():"</span>+number1.setBit(<span class="number">5</span>));</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//分别返回包含整数平方根两个BigInteger的平方根 s的this和它的其余部分this - s*s。</span></span><br><span class="line">    	BigInteger[] arr1=number1.sqrtAndRemainder();</span><br><span class="line">    	System.out.println(arr1[<span class="number">0</span>]+<span class="string">" "</span>+arr1[<span class="number">1</span>]);</span><br><span class="line">    	<span class="comment">//返回值为的BigInteger (this - val)。    	</span></span><br><span class="line">    	System.out.println(<span class="string">"subtract():"</span>+number1.subtract(number2));</span><br><span class="line">    	<span class="comment">//	true仅当设置了指定位时返回。</span></span><br><span class="line">    	System.out.println(<span class="string">"testBit():"</span>+number1.testBit(<span class="number">1</span>));</span><br><span class="line">    	<span class="comment">//	返回一个字节数组，其中包含此BigInteger的二进制补码表示形式</span></span><br><span class="line">    	System.out.println(<span class="string">"toByteArray():"</span>+Arrays.toString(number1.toByteArray()));</span><br><span class="line">    	<span class="comment">//返回此BigInteger的十进制String表示形式。</span></span><br><span class="line">    	System.out.println(<span class="string">"toString()不多说了...."</span>);</span><br><span class="line">    	<span class="comment">//以给定的基数返回此BigInteger的String表示形式。</span></span><br><span class="line">    	<span class="comment">//返回此BigInteger在给定的基数的字符串表示形式。如果基数是从Character.MIN_RADIX到Character.MAX_RADIX包容的范围内，它会默认为10(因为Integer.toString的情况下)。注释链接：</span></span><br><span class="line">    	https:<span class="comment">//www.yiibai.com/java/math/biginteger_tostring_radix.html</span></span><br><span class="line">		<span class="comment">//说白了就是修改进制...</span></span><br><span class="line">    	System.out.println(<span class="string">"toString(int radix):"</span>+number1.toString(<span class="number">10</span>));</span><br><span class="line">    	<span class="comment">//返回一个BigInteger，其值等于指定的long。</span></span><br><span class="line">    	System.out.println(<span class="string">"valueOf():"</span>+BigInteger.valueOf(<span class="number">8</span>));</span><br><span class="line">    	<span class="comment">//返回值为的BigInteger (this ^ val)</span></span><br><span class="line">    	System.out.println(<span class="string">"xor(BigInteger val):"</span>+number1.xor(number2));</span><br><span class="line">    	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用例(国王游戏)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.math.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span> &lt;<span class="title">Node</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> BigInteger a,b,w;</span><br><span class="line">    Node(<span class="keyword">long</span> A,<span class="keyword">long</span> B)&#123;</span><br><span class="line">        a = BigInteger.valueOf(A);</span><br><span class="line">        b = BigInteger.valueOf(B);</span><br><span class="line">        w = a.multiply(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node X)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w.compareTo(X.w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> maxn = (<span class="keyword">int</span>)<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        Node [] node = <span class="keyword">new</span> Node[maxn];</span><br><span class="line">        <span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">long</span> a,b;</span><br><span class="line">            a = sc.nextLong();b = sc.nextLong();</span><br><span class="line">            node[i] = <span class="keyword">new</span> Node(a,b);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(node,<span class="number">1</span>,n+<span class="number">1</span>);</span><br><span class="line">        BigInteger ans = <span class="keyword">new</span> BigInteger(<span class="string">"-1"</span>);</span><br><span class="line">        BigInteger pre = node[<span class="number">0</span>].a;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            ans = ans.max(pre.divide(node[i].b));</span><br><span class="line">            pre = pre.multiply(node[i].a);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\frac{1}{2} \cdot (-4)^n + \frac{1}{4}\cdot16^n</script>]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>template-DP</title>
    <url>/2021/01/14/template-DP/</url>
    <content><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h2><h3 id="nlogn做法"><a href="#nlogn做法" class="headerlink" title="nlogn做法"></a>nlogn做法</h3><h4 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h4><p>$f[i]$表示长度为$i$的最长上升子序列中, 最小的末尾数值. $siz$为最长上升子序列长度.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">f[<span class="number">1</span>] = raw[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> siz = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[siz] &lt; raw[i])f[++siz] = raw[i];</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = lower_bound(f+<span class="number">1</span>,f+siz+<span class="number">1</span>,raw[i]) - f;</span><br><span class="line">        f[idx] = min(f[idx],raw[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="状压dp"><a href="#状压dp" class="headerlink" title="状压dp"></a>状压dp</h1><h2 id="TSP问题"><a href="#TSP问题" class="headerlink" title="TSP问题"></a>TSP问题</h2><p>(变体):给出一个带权完全无向图, 求恰好经过每一点的最短简单路径</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> f[<span class="number">1</span>&lt;&lt;<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0x3f3f3f3f</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k;i++)f[<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>)][i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> S = <span class="number">1</span>;S &lt; (<span class="number">1</span>&lt;&lt;k);S++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k;i++)<span class="keyword">if</span>(S&amp;(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>)))&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= k;j++)<span class="keyword">if</span>(j != i <span class="keyword">and</span> S&amp;(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>)))&#123;</span><br><span class="line">            f[S][i] = min(f[S][i],f[S ^ (<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>))][j] + dis[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll ans = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k;i++)ans = min(ans,f[(<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span>][i]);</span><br></pre></td></tr></table></figure>
<p>t</p>
]]></content>
  </entry>
  <entry>
    <title>[题解]ICPC2017-2018-Daejeon-E How Many to Be Happy?</title>
    <url>/2021/03/28/solution-ICPC2017-2018-Daejeon-E/</url>
    <content><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一个带权无向图$(1 \leq n \le 100, 1 \le m \le 500)$, 设的最小生成树为$G$.</p>
<p>对于每条边$e$, 设$G’$为必须包含$e$的最小生成树. 定义$H(e)$为存在于$G$但不存在于$G’$的边的数目.</p>
<p>求$\sum_{i = 1}^mH(e_i)$ </p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>考虑转化原问题.</p>
<p>对于某条边$e$, 设权值比它小的边的集合为$E’$. 显然只有$E’$才会影响到$e$是否在最小生成树中. 而要确保$e$被添加到最小生成树中, $E’$组成的图中$e$的两端必须不连通. 至此问题转化为最小割, 求$m$次最小割即可求解.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = maxn*maxn*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>+<span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> from,to,next,w,cap,flow;</span><br><span class="line">	Edge(<span class="keyword">int</span> from = <span class="number">0</span>,<span class="keyword">int</span> to = <span class="number">0</span>,<span class="keyword">int</span> w = <span class="number">0</span>):from(from),to(to),w(w)&#123;&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge &amp; X)<span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> w &lt; X.w;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;edge[maxm],edge2[maxm];</span><br><span class="line"><span class="keyword">int</span> head[maxn],deep[maxn],vis[maxn],cur[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m,cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">int</span> cap,<span class="keyword">int</span> flow)</span></span>&#123;</span><br><span class="line">	edge[cnt].from = from;</span><br><span class="line">	edge[cnt].to = to;</span><br><span class="line">	edge[cnt].cap = cap;</span><br><span class="line">	edge[cnt].flow = flow;</span><br><span class="line">	edge[cnt].next = head[from];</span><br><span class="line">	head[from] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)cur[i] = head[i];</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">	q.push(s);</span><br><span class="line">	vis[s] = <span class="number">1</span>;</span><br><span class="line">	deep[s] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		<span class="keyword">int</span> u = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">			<span class="keyword">if</span>(!vis[v] <span class="keyword">and</span> edge[i].cap &gt; edge[i].flow)&#123;</span><br><span class="line">				vis[v] = <span class="number">1</span>;</span><br><span class="line">				deep[v] = deep[u] + <span class="number">1</span>;</span><br><span class="line">				q.push(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> t,<span class="keyword">int</span> approve)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(u == t <span class="keyword">or</span> approve == <span class="number">0</span>)<span class="keyword">return</span> approve;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>,delta = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = cur[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		cur[u] = i;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(deep[u] + <span class="number">1</span> == deep[v] <span class="keyword">and</span> (delta = DFS(v,t,min(approve,edge[i].cap - edge[i].flow))) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			edge[i].flow += delta;</span><br><span class="line">			edge[i^<span class="number">1</span>].flow -= delta;</span><br><span class="line">			flow += delta;approve -= delta;</span><br><span class="line">			<span class="keyword">if</span>(!approve)<span class="keyword">break</span>; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(BFS(s,t))&#123;</span><br><span class="line">		flow += DFS(s,t,INF);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> f,t,w;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; f &gt;&gt; t &gt;&gt; w;</span><br><span class="line">		edge2[i] = Edge(f,t,w);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(edge2+<span class="number">1</span>,edge2+m+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">		cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)head[j] = <span class="number">-1</span>,deep[j] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> s = edge2[i].from,t = edge2[i].to;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; i;j++)<span class="keyword">if</span>(edge2[j].w &lt; edge2[i].w)&#123;</span><br><span class="line">			<span class="keyword">int</span> f = edge2[j].from,t = edge2[j].to;</span><br><span class="line">			addedge(f,t,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">			addedge(t,f,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">			addedge(t,f,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">			addedge(f,t,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		ans += Dinic(s,t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>网络流</tag>
        <tag>ICPC</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]-CF954I Yet Another String Matching Problem</title>
    <url>/2021/03/31/solution-CF954I/</url>
    <content><![CDATA[<p><del>孩子的第一道卷积题</del></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>假设两个相等长度的字符串$u,v$. 每次可以进行一次操作将$u,v$中某种字符同时全部变为另一种字符, 设$F(u,v)$为使得$u,v$相等的最小操作次数.</p>
<p>现在给出两个字符串$s,t$, 且保证$|s| \geq |t|$. 求对于$s$的全部长度为$|t|$的子串$s’$, $F(s’,t)$的值各为多少.</p>
<p>保证$\sum = {\text{a,b,c,d,e,f}}$, $1 \leq |t| \leq |s| \leq 1.25\cdot 10^5$</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先求解$F(u,v)$. 我们建一张图, 图中节点为字母$a…f$. 对所有的$i = 1…|u|$, 连边$(u[i],v[i])$. 显然答案最小值为该图任意生成树边的数目, 可以简单地用并查集求解. 暴力求解复杂度为$O(|s|^2)$.</p>
<p>考虑优化. 设$n = |s|,m = |t|.$ 设$f[c][d][idx]$为$s[idx- m + 1…idx]$中字符$c$与$t$中字符$d$下标(从0开始)一一对应的数目. 例如$s = \text{bbcdefa}, t = \text{ddcb}$. 则$f[‘b’][‘d’][3] = 2$.</p>
<p>求出$f[c][d][idx]$后, 对于每个$f[c][d][idx] &gt; 0$, 从$c$向$d$连一条边, 再按$F(u,v)$的方法求解, 便能求出每个$idx$的答案.</p>
<p>下面是FFT处理这类字符串匹配问题的套路做法:</p>
<p>假设我们需要求$f[c][d]$. 设多项式$g,h$. 令$g(i) = [s[i] == c],h(i) = [t[j] == d]$. 此后将$h$<strong>翻转</strong>, 我们发现$g$与$h$的卷积:</p>
<script type="math/tex; mode=display">
(g \ast h)[i] = \sum_{j = 0}^i g[j]\cdot h[i-j]</script><p>恰好是我们想要的$f[c][d][]$.</p>
<p>枚举每个$c,d \in \sum$, 便能高效求解问题. 时间复杂度$|\sum|^2n\log n$</p>
<p>优化: 容易发现$g$和$h$各只有$6$种, 因此我们只需做$12$次(而非$36$次)DFT. 并且$c == d$的情况显然对答案没有贡献, 无需考虑.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">complex</span>&lt;ld&gt; cld;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;cld&gt; Poly;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">6e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ld PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">int</span> rev[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Poly &amp; A,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	A.clear();</span><br><span class="line">	A.shrink_to_fit();</span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(size &lt;= n)size *= <span class="number">2</span>;</span><br><span class="line">	A.assign(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT_init</span><span class="params">(Poly A)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = A.size();</span><br><span class="line">	<span class="keyword">int</span> S = log2(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)rev[i] = (rev[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (S - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Poly &amp; A,<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = A.size();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)<span class="keyword">if</span>(i &lt; rev[i])swap(A[i],A[rev[i]]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i *= <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="function">cld <span class="title">Wn</span><span class="params">(<span class="built_in">cos</span>(PI/i),type*<span class="built_in">sin</span>(PI/i))</span></span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j += i*<span class="number">2</span>)&#123;</span><br><span class="line">			<span class="function">cld <span class="title">W</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; i;k++)&#123;</span><br><span class="line">				cld facx = A[j+k],facy = W*A[j+k+i];</span><br><span class="line">				A[j+k] = facx + facy;</span><br><span class="line">				A[j+k+i] = facx - facy;</span><br><span class="line">				W *= Wn;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(type == <span class="number">-1</span>)<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (<span class="keyword">int</span>)A.size();i++)A[i].real((<span class="keyword">int</span>)(A[i].real()/A.size() + <span class="number">0.5</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;f[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">Poly DFTA[<span class="number">10</span>],DFTB[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> father[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)father[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findset</span><span class="params">(<span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> father[e] == e?e:father[e] = findset(father[e]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">un</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	father[findset(x)] = findset(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> findset(u) == findset(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">	init();</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="string">'a'</span>;i &lt;= <span class="string">'f'</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="string">'a'</span>;j &lt;= <span class="string">'f'</span>;j++)<span class="keyword">if</span>(i != j)&#123;</span><br><span class="line">			<span class="keyword">int</span> u = i - <span class="string">'a'</span>,v = j - <span class="string">'a'</span>;</span><br><span class="line">			<span class="keyword">if</span>(f[u][v][idx] &lt;= <span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(!check(u,v))cnt++;</span><br><span class="line">			un(u,v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">string</span> s,t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; s &gt;&gt; t;</span><br><span class="line">	Poly A,B;</span><br><span class="line">	n = s.size(),m = t.size();</span><br><span class="line">	init(A,n);</span><br><span class="line">	FFT_init(A);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">'a'</span>;c &lt;= <span class="string">'f'</span>;c++)&#123;</span><br><span class="line">		init(DFTA[c - <span class="string">'a'</span>],n);</span><br><span class="line">		init(DFTB[c - <span class="string">'a'</span>],n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)<span class="keyword">if</span>(s[i] == c)DFTA[c - <span class="string">'a'</span>][i] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++)<span class="keyword">if</span>(t[j] == c)DFTB[c - <span class="string">'a'</span>][m - j - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		FFT(DFTA[c - <span class="string">'a'</span>],<span class="number">1</span>);</span><br><span class="line">		FFT(DFTB[c - <span class="string">'a'</span>],<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">'a'</span>;c &lt;= <span class="string">'f'</span>;c++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">char</span> d = <span class="string">'a'</span>;d &lt;= <span class="string">'f'</span>;d++)<span class="keyword">if</span>(c != d)&#123;</span><br><span class="line">			A = DFTA[c - <span class="string">'a'</span>],B = DFTB[d - <span class="string">'a'</span>];</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (<span class="keyword">int</span>)A.size();i++)A[i] *= B[i];</span><br><span class="line">			FFT(A,<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (<span class="keyword">int</span>)A.size();i++)f[c - <span class="string">'a'</span>][d - <span class="string">'a'</span>].push_back((<span class="keyword">int</span>)A[i].real());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = m<span class="number">-1</span>;i &lt; n;i++)<span class="built_in">cout</span> &lt;&lt; cal(i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title>[笔记]多项式</title>
    <url>/2021/03/28/polynomial/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>[题解]CF1334G-Substring Search</title>
    <url>/2021/04/02/solution-CF1334G/</url>
    <content><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>设$p$为从$\sum$到$\sum$的双射($\sum = {a,b,…,z})$. 给出两个字符串$s,t$(<strong>由于个人习惯,此处s,t的含义和原题相反</strong>)且满足$(1 \leq |t| \leq |s| \leq 2 \cdot10^5)$. 求对于$s$的每个长度为$|t|$的子串$s’$, $s’$与$t$是否匹配. 输出一个长为$|s| - |t| + 1$的01串, 其中第$i$位为1表示$s[i…i+|t| - 1]$与$t$匹配.</p>
<p>匹配在此题定义为: 设两个长度相等的串$s’,t$, 对全部$i = 0…|t|-1$, 有$s’[i] == t[i]$ 或$s’[i] == p(t[i])$</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先我们设匹配函数</p>
<script type="math/tex; mode=display">
F(x) = \sum_{i = x,j = i - x}^{|t| + x - 1}(s[i] - t[j])^2(s[i] - f(t[j]))^2</script><p>容易看出, 当且仅当$F(x) == 0$时, $s[x…x+|t| - 1]$与$t$匹配. 将和式内部展开后化简, 可以发现展开后每一项都可化为 $\sum_{i,j = 1}^na_ib_j$的形式. 我们用经典套路把$t$反转后, 便可化为卷积形式用FFT求解.</p>
<p>但是这个式子好像要做七次DFT和IDFT, 太麻烦. 我们尝试乱搞一下:</p>
<script type="math/tex; mode=display">
G(x) = \sum_{i = x,j = i-x}^{|t| + x - 1}(s[i] - t[j])(s[i] - f(t[j]))</script><p>展开后有:</p>
<script type="math/tex; mode=display">
G(x) = \sum_{i = x}^{|t| + x - 1}s[i]^2 - \sum_{i = x,j = i-x}^{|t| + x - 1}s[i]\cdot f(t[j]) - \sum_{i = x,j = i-x}^{|t| + x - 1}s[i]\cdot t[j] + \sum_{j = 0}^{|t| - 1} t[j] \cdot f(t[j])</script><p>首项和末项用前缀和处理, 剩下两项可以分别进行一次卷积求出.</p>
<p>把平方去掉后由于存在负数项, 因而某些不能被匹配的位置也可能有$G(x) = 0$. 我们将<code>a-z</code>随机赋上一个权值后再进行计算, 便能大大减少冲突的概率. (我不知道这种做法实际上是否正确, <strong>更不能保证不会被卡</strong>, 但这种做法足够通过此题). 由于FFT在计算时会损失精度, 我们使用NTT进行求解.</p>
<p>时间复杂度$|s|\log |s|$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">6e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(d == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>%p;</span><br><span class="line">	<span class="keyword">int</span> a = Pow(x,d/<span class="number">2</span>);</span><br><span class="line">	tans = <span class="number">1l</span>l*a*a%p;</span><br><span class="line">	<span class="keyword">if</span>(d%<span class="number">2</span>)tans = <span class="number">1l</span>l*tans*x%p; </span><br><span class="line">	<span class="keyword">return</span> tans%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> rev[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; x,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(size &lt;= n)size *= <span class="number">2</span>;</span><br><span class="line">	x.assign(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT_init</span><span class="params">(<span class="keyword">int</span> lim)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i) rev[i] = (i &amp; <span class="number">1</span>) * (lim &gt;&gt; <span class="number">1</span>) + (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; A, <span class="keyword">int</span> opt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> lim = A.size();</span><br><span class="line"> 	<span class="keyword">int</span> i, j, k, m, gn, g, tmp;</span><br><span class="line"> 	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; lim; ++i)<span class="keyword">if</span> (rev[i] &lt; i) swap(A[i], A[rev[i]]);</span><br><span class="line"> 	<span class="keyword">for</span>(m = <span class="number">2</span>; m &lt;= lim; m &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">	    k = m &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	    gn = Pow(<span class="number">3</span>,(p - <span class="number">1</span>) / m);</span><br><span class="line">	    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; lim; i += m) &#123;</span><br><span class="line">	    	g = <span class="number">1</span>;</span><br><span class="line">	    	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; k; ++j, g = <span class="number">1l</span>l * g * gn % p) &#123;</span><br><span class="line">	    	    tmp = <span class="number">1l</span>l * A[i + j + k] * g % p;</span><br><span class="line">	    	    A[i + j + k] = (A[i + j] - tmp + p) % p;</span><br><span class="line">	     	 	A[i + j] = (A[i + j] + tmp) % p;</span><br><span class="line">	    	&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(opt == <span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="keyword">auto</span> it = A.begin();it++;</span><br><span class="line">    	reverse(it,A.end());</span><br><span class="line">    	<span class="keyword">int</span> inv = Pow(lim,p<span class="number">-2</span>);</span><br><span class="line">    	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; lim; ++i) A[i] = <span class="number">1l</span>l * A[i] * inv % p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Poly;</span><br><span class="line">Poly A,B;</span><br><span class="line"><span class="keyword">int</span> per[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> w[maxn][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> rnd[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> ans[maxn];</span><br><span class="line"><span class="function">mt19937 <span class="title">Rand</span><span class="params">(<span class="number">19260817</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">string</span> s,t;</span><br><span class="line">	srand(time(<span class="literal">NULL</span>));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++)<span class="built_in">cin</span> &gt;&gt; per[i],per[i]--,rnd[i] = Rand()%p;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t &gt;&gt; s;</span><br><span class="line">	<span class="keyword">int</span> n = s.size(),m = t.size();</span><br><span class="line">	Poly A,B;</span><br><span class="line">	init(A,s.size());</span><br><span class="line">	init(B,s.size());</span><br><span class="line">	NTT_init(A.size());</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)w[i][<span class="number">0</span>] = (<span class="number">1l</span>l*rnd[s[i] - <span class="string">'a'</span>]*rnd[s[i] - <span class="string">'a'</span>]%p + (i?w[i<span class="number">-1</span>][<span class="number">0</span>]:<span class="number">0</span>))%p;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)w[i][<span class="number">3</span>] = (<span class="number">1l</span>l*rnd[t[i] - <span class="string">'a'</span>]*rnd[per[t[i] - <span class="string">'a'</span>]]%p + (i?w[i<span class="number">-1</span>][<span class="number">3</span>]:<span class="number">0</span>))%p;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)A[i] = rnd[s[i] - <span class="string">'a'</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)B[m - i - <span class="number">1</span>] = rnd[t[i] - <span class="string">'a'</span>];</span><br><span class="line">	NTT(A,<span class="number">1</span>);</span><br><span class="line">	NTT(B,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (<span class="keyword">int</span>)A.size();i++)A[i] = (<span class="number">1l</span>l*A[i]*B[i])%p;</span><br><span class="line">	NTT(A,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (<span class="keyword">int</span>)A.size();i++)w[i][<span class="number">1</span>] = A[i];</span><br><span class="line">	init(A,s.size());</span><br><span class="line">	init(B,s.size());</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)A[i] = rnd[s[i] - <span class="string">'a'</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)B[m - i - <span class="number">1</span>] = rnd[per[t[i] - <span class="string">'a'</span>]];</span><br><span class="line">	NTT(A,<span class="number">1</span>);</span><br><span class="line">	NTT(B,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (<span class="keyword">int</span>)A.size();i++)A[i] = (<span class="number">1l</span>l*A[i]*B[i])%p;</span><br><span class="line">	NTT(A,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (<span class="keyword">int</span>)A.size();i++)w[i][<span class="number">2</span>] = A[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = m<span class="number">-1</span>;i &lt; n;i++)&#123;</span><br><span class="line">		ll A = (w[i][<span class="number">0</span>] - (i - m &gt;= <span class="number">0</span>?w[i-m][<span class="number">0</span>]:<span class="number">0</span>) + p)%p,D = w[m<span class="number">-1</span>][<span class="number">3</span>]%p;</span><br><span class="line">		ll B = w[i][<span class="number">1</span>],C = w[i][<span class="number">2</span>];</span><br><span class="line">		<span class="keyword">if</span>((((A -  B + p)%p - C + p) % p + D)%p == <span class="number">0</span>)<span class="built_in">cout</span> &lt;&lt; <span class="string">"1"</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"0"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>FFT</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title>历史遗迹</title>
    <url>/2021/04/03/history-qwq/</url>
    <content><![CDATA[<p>这里存一些被淘汰掉的板子之类的东西</p>
<h1 id="2021-04-03"><a href="#2021-04-03" class="headerlink" title="2021-04-03"></a>2021-04-03</h1><h2 id="FFT"><a href="#FFT" class="headerlink" title="FFT"></a>FFT</h2><p>复数类操作:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt;m;</span><br><span class="line">m.real();m.imag();<span class="comment">//获取实部虚部的值</span></span><br><span class="line">m.real(<span class="number">114</span>);m.imag(<span class="number">514</span>);<span class="comment">//为实部虚部赋值</span></span><br></pre></td></tr></table></figure>
<p>需要继续理解迭代算法.现在这就是个板子</p>
<p>被卡常时记得别用<code>long double</code></p>
<p>调用<code>FFT(A,1)</code>将$A$变为$A$的$DFT$,调用<code>FFT(A,-1)</code>求$DFT^{-1}$.</p>
<p>$A$是复数数组,其实部初始是多项式系数.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">complex</span>&lt;ld&gt; cld;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;cld&gt; Poly;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">8E6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ld PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">int</span> rev[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Poly &amp; A,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(size &lt;= n)size *= <span class="number">2</span>;</span><br><span class="line">	A.assign(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT_init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> S = log2(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)rev[i] = (rev[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (S - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Poly &amp; A,<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = A.size();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)<span class="keyword">if</span>(i &lt; rev[i])swap(A[i],A[rev[i]]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i *= <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="function">cld <span class="title">Wn</span><span class="params">(<span class="built_in">cos</span>(PI/i),type*<span class="built_in">sin</span>(PI/i))</span></span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j += i*<span class="number">2</span>)&#123;</span><br><span class="line">			<span class="function">cld <span class="title">W</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; i;k++)&#123;</span><br><span class="line">				cld facx = A[j+k],facy = W*A[j+k+i];</span><br><span class="line">				A[j+k] = facx + facy;</span><br><span class="line">				A[j+k+i] = facx - facy;</span><br><span class="line">				W *= Wn;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>(type == <span class="number">-1</span>)<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (<span class="keyword">int</span>)A.size();i++)A[i].real((<span class="keyword">int</span>)(A[i].real()/A.size() + <span class="number">0.5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h2><script type="math/tex; mode=display">
C[i] = \sum_{j = 0}^iA[i]B[i-j]</script><p>卷积等同于多项式乘积</p>
<p>输入两个多项式$A,B$的系数,求出其乘积:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">int</span> d = n+m;</span><br><span class="line">	Poly A,B;</span><br><span class="line">	init(A,max(n,m));</span><br><span class="line">	init(B,max(n,m));</span><br><span class="line">	FFT_init(A.size());</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)<span class="built_in">cin</span> &gt;&gt; A[i]; </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= m;i++)<span class="built_in">cin</span> &gt;&gt; B[i];</span><br><span class="line">	FFT(A,<span class="number">1</span>);</span><br><span class="line">	FFT(B,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (<span class="keyword">int</span>)A.size();i++)A[i] *= B[i];</span><br><span class="line">	FFT(A,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= d;i++)<span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>)(A[i].real()/A.size() + <span class="number">0.5</span>)&lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>手写复数类:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y ;</span><br><span class="line">    node (<span class="keyword">double</span> xx = <span class="number">0</span>, <span class="keyword">double</span> yy = <span class="number">0</span>)&#123;</span><br><span class="line">        x = xx, y = yy ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">node <span class="keyword">operator</span> * (node J, node Q)&#123;</span><br><span class="line">    <span class="keyword">return</span> node(J.x * Q.x - J.y * Q.y , J.x * Q.y + J.y * Q.x);</span><br><span class="line">&#125;</span><br><span class="line">node <span class="keyword">operator</span> + (node J, node Q)&#123;</span><br><span class="line">    <span class="keyword">return</span> node(J.x + Q.x , J.y + Q.y);</span><br><span class="line">&#125;</span><br><span class="line">node <span class="keyword">operator</span> - (node J, node Q)&#123;</span><br><span class="line">    <span class="keyword">return</span> node(J.x - Q.x , J.y - Q.y );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="NTT"><a href="#NTT" class="headerlink" title="NTT"></a>NTT</h2><p>从OI-wiki抄来的, 用法和上面的FFT一致. 记得自己手写一遍</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Poly;</span><br><span class="line"><span class="keyword">int</span> rev[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; x,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(size &lt;= n)size *= <span class="number">2</span>;</span><br><span class="line">	x.assign(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT_init</span><span class="params">(<span class="keyword">int</span> lim)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i) rev[i] = (i &amp; <span class="number">1</span>) * (lim &gt;&gt; <span class="number">1</span>) + (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; A, <span class="keyword">int</span> opt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> lim = A.size();</span><br><span class="line"> 	<span class="keyword">int</span> i, j, k, m, gn, g, tmp;</span><br><span class="line"> 	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; lim; ++i)<span class="keyword">if</span> (rev[i] &lt; i) swap(A[i], A[rev[i]]);</span><br><span class="line"> 	<span class="keyword">for</span>(m = <span class="number">2</span>; m &lt;= lim; m &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">	    k = m &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	    gn = Pow(<span class="number">3</span>,(p - <span class="number">1</span>) / m);<span class="comment">//998244353的原根是3</span></span><br><span class="line">	    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; lim; i += m) &#123;</span><br><span class="line">	    	g = <span class="number">1</span>;</span><br><span class="line">	    	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; k; ++j, g = <span class="number">1l</span>l * g * gn % p) &#123;</span><br><span class="line">	    	    tmp = <span class="number">1l</span>l * A[i + j + k] * g % p;</span><br><span class="line">	    	    A[i + j + k] = (A[i + j] - tmp + p) % p;</span><br><span class="line">	     	 	A[i + j] = (A[i + j] + tmp) % p;</span><br><span class="line">	    	&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(opt == <span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="keyword">auto</span> it = A.begin();it++;</span><br><span class="line">    	reverse(it,A.end());</span><br><span class="line">    	<span class="keyword">int</span> inv = Pow(lim,p<span class="number">-2</span>);</span><br><span class="line">    	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; lim; ++i) A[i] = <span class="number">1l</span>l * A[i] * inv % p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与FFT的区别在点值表示法相乘时, NTT需要取模. 另外注意原根需与模数对应</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (<span class="keyword">int</span>)A.size();i++)A[i] = <span class="number">1l</span>l*A[i]*B[i]%p;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>shitmountain</category>
      </categories>
      <tags>
        <tag>屎山</tag>
      </tags>
  </entry>
</search>
