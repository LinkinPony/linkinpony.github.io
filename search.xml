<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>历史遗迹</title>
    <url>/2021/04/03/history-qwq/</url>
    <content><![CDATA[<p>这里存一些被淘汰掉的板子之类的东西</p>
<h1 id="section">2021-04-03</h1>
<h2 id="fft">FFT</h2>
<p>复数类操作:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">complex&lt;<span class="keyword">double</span>&gt;m;</span><br><span class="line">m.<span class="built_in">real</span>();m.<span class="built_in">imag</span>();<span class="comment">//获取实部虚部的值</span></span><br><span class="line">m.<span class="built_in">real</span>(<span class="number">114</span>);m.<span class="built_in">imag</span>(<span class="number">514</span>);<span class="comment">//为实部虚部赋值</span></span><br></pre></td></tr></table></figure>
<p>需要继续理解迭代算法.现在这就是个板子</p>
<p>被卡常时记得别用<code>long double</code></p>
<p>调用<code>FFT(A,1)</code>将<span class="math inline">\(A\)</span>变为<span class="math inline">\(A\)</span>的<span class="math inline">\(DFT\)</span>,调用<code>FFT(A,-1)</code>求<span class="math inline">\(DFT^{-1}\)</span>.</p>
<p><span class="math inline">\(A\)</span>是复数数组,其实部初始是多项式系数.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> complex&lt;ld&gt; cld;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;cld&gt; Poly;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">8E6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ld PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">int</span> rev[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Poly &amp; A,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(size &lt;= n)size *= <span class="number">2</span>;</span><br><span class="line">	A.<span class="built_in">assign</span>(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT_init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> S = <span class="built_in">log2</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)rev[i] = (rev[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (S - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Poly &amp; A,<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)<span class="keyword">if</span>(i &lt; rev[i])<span class="built_in">swap</span>(A[i],A[rev[i]]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i *= <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="function">cld <span class="title">Wn</span><span class="params">(cos(PI/i),type*sin(PI/i))</span></span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j += i*<span class="number">2</span>)&#123;</span><br><span class="line">			<span class="function">cld <span class="title">W</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; i;k++)&#123;</span><br><span class="line">				cld facx = A[j+k],facy = W*A[j+k+i];</span><br><span class="line">				A[j+k] = facx + facy;</span><br><span class="line">				A[j+k+i] = facx - facy;</span><br><span class="line">				W *= Wn;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>(type == <span class="number">-1</span>)<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (<span class="keyword">int</span>)A.<span class="built_in">size</span>();i++)A[i].<span class="built_in">real</span>((<span class="keyword">int</span>)(A[i].<span class="built_in">real</span>()/A.<span class="built_in">size</span>() + <span class="number">0.5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="卷积">卷积</h2>
<p><span class="math display">\[
C[i] = \sum_{j = 0}^iA[j]B[i-j]
\]</span></p>
<p>卷积等同于多项式乘积</p>
<p>输入两个多项式<span class="math inline">\(A,B\)</span>的系数,求出其乘积:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">int</span> d = n+m;</span><br><span class="line">	Poly A,B;</span><br><span class="line">	<span class="built_in">init</span>(A,<span class="built_in">max</span>(n,m));</span><br><span class="line">	<span class="built_in">init</span>(B,<span class="built_in">max</span>(n,m));</span><br><span class="line">	<span class="built_in">FFT_init</span>(A.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)cin &gt;&gt; A[i]; </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= m;i++)cin &gt;&gt; B[i];</span><br><span class="line">	<span class="built_in">FFT</span>(A,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">FFT</span>(B,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (<span class="keyword">int</span>)A.<span class="built_in">size</span>();i++)A[i] *= B[i];</span><br><span class="line">	<span class="built_in">FFT</span>(A,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= d;i++)cout &lt;&lt; (<span class="keyword">int</span>)(A[i].<span class="built_in">real</span>()/A.<span class="built_in">size</span>() + <span class="number">0.5</span>)&lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>手写复数类:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y ;</span><br><span class="line">    <span class="built_in">node</span> (<span class="keyword">double</span> xx = <span class="number">0</span>, <span class="keyword">double</span> yy = <span class="number">0</span>)&#123;</span><br><span class="line">        x = xx, y = yy ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">node <span class="keyword">operator</span> * (node J, node Q)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">node</span>(J.x * Q.x - J.y * Q.y , J.x * Q.y + J.y * Q.x);</span><br><span class="line">&#125;</span><br><span class="line">node <span class="keyword">operator</span> + (node J, node Q)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">node</span>(J.x + Q.x , J.y + Q.y);</span><br><span class="line">&#125;</span><br><span class="line">node <span class="keyword">operator</span> - (node J, node Q)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">node</span>(J.x - Q.x , J.y - Q.y );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ntt">NTT</h2>
<p>从OI-wiki抄来的, 用法和上面的FFT一致. 记得自己手写一遍</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="keyword">int</span>&gt; Poly;</span><br><span class="line"><span class="keyword">int</span> rev[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp; x,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(size &lt;= n)size *= <span class="number">2</span>;</span><br><span class="line">	x.<span class="built_in">assign</span>(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT_init</span><span class="params">(<span class="keyword">int</span> lim)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i) rev[i] = (i &amp; <span class="number">1</span>) * (lim &gt;&gt; <span class="number">1</span>) + (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp; A, <span class="keyword">int</span> opt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> lim = A.<span class="built_in">size</span>();</span><br><span class="line"> 	<span class="keyword">int</span> i, j, k, m, gn, g, tmp;</span><br><span class="line"> 	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; lim; ++i)<span class="keyword">if</span> (rev[i] &lt; i) <span class="built_in">swap</span>(A[i], A[rev[i]]);</span><br><span class="line"> 	<span class="keyword">for</span>(m = <span class="number">2</span>; m &lt;= lim; m &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">	    k = m &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	    gn = <span class="built_in">Pow</span>(<span class="number">3</span>,(p - <span class="number">1</span>) / m);<span class="comment">//998244353的原根是3</span></span><br><span class="line">	    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; lim; i += m) &#123;</span><br><span class="line">	    	g = <span class="number">1</span>;</span><br><span class="line">	    	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; k; ++j, g = <span class="number">1ll</span> * g * gn % p) &#123;</span><br><span class="line">	    	    tmp = <span class="number">1ll</span> * A[i + j + k] * g % p;</span><br><span class="line">	    	    A[i + j + k] = (A[i + j] - tmp + p) % p;</span><br><span class="line">	     	 	A[i + j] = (A[i + j] + tmp) % p;</span><br><span class="line">	    	&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(opt == <span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="keyword">auto</span> it = A.<span class="built_in">begin</span>();it++;</span><br><span class="line">    	<span class="built_in">reverse</span>(it,A.<span class="built_in">end</span>());</span><br><span class="line">    	<span class="keyword">int</span> inv = <span class="built_in">Pow</span>(lim,p<span class="number">-2</span>);</span><br><span class="line">    	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; lim; ++i) A[i] = <span class="number">1ll</span> * A[i] * inv % p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与FFT的区别在点值表示法相乘时, NTT需要取模. 另外注意原根需与模数对应</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (<span class="keyword">int</span>)A.<span class="built_in">size</span>();i++)A[i] = <span class="number">1ll</span>*A[i]*B[i]%p;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>shitmountain</category>
      </categories>
      <tags>
        <tag>屎山</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA</title>
    <url>/2020/12/11/JAVA/</url>
    <content><![CDATA[<h2 id="大整数">大整数</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">比较大小: a.compareTo(b): 小于返回-<span class="number">1</span>,等于返回<span class="number">0</span>,大于返回<span class="number">1</span></span><br><span class="line"><span class="keyword">int</span>/<span class="keyword">long</span>转换: BigIntger a = BigInteger.valueOf(<span class="number">114514</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来自https://blog.csdn.net/dlx_handsome/article/details/102529307</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.math.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//随便打的两个数,不过用生成随机大整数不是更香嘛</span></span><br><span class="line">    	BigInteger number1=<span class="keyword">new</span> BigInteger(<span class="string">&quot;347238462384523623645237465237415234165234615246742354&quot;</span>);</span><br><span class="line">    	BigInteger number2=<span class="keyword">new</span> BigInteger(<span class="string">&quot;42673547263541874637462394142837645&quot;</span>);</span><br><span class="line">    	<span class="comment">//返回一个BigInteger，其值为该BigInteger的绝对值。</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;abs():&quot;</span>+number1.abs().toString());</span><br><span class="line">    	<span class="comment">//返回值为BigInteger (this / val)。</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;divide():&quot;</span>+number1.divide(number2));</span><br><span class="line">    	<span class="comment">//返回值为的BigInteger (this % val)。</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;remainder():&quot;</span>+number1.remainder(number2));</span><br><span class="line">    	<span class="comment">//返回值为的BigInteger (this + val)。</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;add():&quot;</span>+number1.add(number2).toString());</span><br><span class="line">    	<span class="comment">//返回值为的BigInteger (this &lt;&lt; n)。</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;shiftLeft():&quot;</span>+number1.shiftLeft(<span class="number">1</span>));</span><br><span class="line">    	<span class="comment">//返回值为的BigInteger (this &gt;&gt; n)。</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;shiftRight():&quot;</span>+number1.shiftRight(<span class="number">1</span>));</span><br><span class="line">    	<span class="comment">//返回此BigInteger的signum函数 返回-1,0,1作为BigInteger的符号</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;signum():&quot;</span>+number1.signum());</span><br><span class="line">    	<span class="comment">//返回此BigInteger的整数平方根。</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;sqrt():&quot;</span>+number1.sqrt());</span><br><span class="line">    	<span class="comment">//返回值为的BigInteger (this &amp; val)。</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;and():&quot;</span>+number1.and(number2));</span><br><span class="line">    	<span class="comment">//返回值为的BigInteger (this &amp; ~val)。</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;andNot():&quot;</span>+number1.andNot(number2));</span><br><span class="line">    	<span class="comment">//返回此BigInteger的二进制补码表示形式中不同于其符号位的位数.</span></span><br><span class="line">    	<span class="comment">//此方法在此BigInteger，从它的符号位不同的补码表示返回的比特数</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;bitCount():&quot;</span>+number1.bitCount());</span><br><span class="line">    	<span class="comment">//	返回此BigInteger的最小2补码表示形式中的位数，不包括符号位。</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;bitLength():&quot;</span>+number1.bitLength());</span><br><span class="line">    	<span class="comment">//将其转换BigInteger为byte，以检查是否丢失了信息。如果超出了,会丢出一个ArithmeticException异常</span></span><br><span class="line">    	<span class="comment">//System.out.println(&quot;byteValueExact():&quot;+number1.byteValueExact());</span></span><br><span class="line">    	<span class="comment">//返回一个BigInteger，其值等于该BigInteger，并且清除了指定的位。</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;clearBit:&quot;</span>+number2.clearBit(<span class="number">0</span>));</span><br><span class="line">    	<span class="comment">//将此BigInteger与指定的BigInteger进行比较。</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;compareTo():&quot;</span>+number1.compareTo(number2));</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//返回两个BigIntegers组成的数组，其中包含(this / val) 后跟(this % val)。</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;divideAndRemainder():&quot;</span>+Arrays.toString(number1.divideAndRemainder(number2)));</span><br><span class="line">    	<span class="comment">//将此BigInteger转换为double。</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;doubleValue():&quot;</span>+number1.doubleValue());</span><br><span class="line">    	<span class="comment">//将此BigInteger转换为float。</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;floatValue():&quot;</span>+number1.floatValue());</span><br><span class="line"><span class="comment">//    	返回此BigInteger和的最大值val。</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;max():&quot;</span>+number1.max(number2));</span><br><span class="line">    	<span class="comment">//返回此BigInteger和的最小值val。</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;min():&quot;</span>+number1.min(number2));</span><br><span class="line">    	<span class="comment">//返回值为的BigInteger (this mod m)。</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;mod():&quot;</span>+number1.mod(number2));</span><br><span class="line">    	<span class="comment">//返回值为(this-1 的BigInteger mod m)。</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;modInverse():&quot;</span>+number1.modInverse(number2));</span><br><span class="line">    	<span class="comment">//返回值为的BigInteger 。(thisexponent mod m)</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;modPow():&quot;</span>+number1.modPow(BigInteger.valueOf(<span class="number">1</span>), number2));</span><br><span class="line">    	<span class="comment">//返回值为的BigInteger (this * val)。</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;multiply():&quot;</span>+number1.multiply(number2));</span><br><span class="line">    	<span class="comment">//返回值为的BigInteger (-this)。 </span></span><br><span class="line">    	System.out.println(<span class="string">&quot;negate():&quot;</span>+number1.negate());</span><br><span class="line">    	<span class="comment">//将此BigInteger与指定的Object比较是否相等。</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;equals()就不说了,大家都明白....&quot;</span>);</span><br><span class="line">    	<span class="comment">//返回一个BigInteger，其值等于该BigInteger的指定位被翻转。</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;flipBit():&quot;</span>+number1.flipBit(<span class="number">1</span>));  	</span><br><span class="line">    	<span class="comment">//返回一个BigInteger，其值是abs(this)和的最大公约数 abs(val)。</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;gcd():&quot;</span>+number1.gcd(number2));</span><br><span class="line">    	<span class="comment">//返回此BigInteger中最右边（最低位）的一位的索引（最右边一位的右边的零位数）。</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;getLowestSetBit():&quot;</span>+number1.getLowestSetBit());</span><br><span class="line">    	<span class="comment">//返回此BigInteger的哈希码。</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;hashCode():&quot;</span>+number1.hashCode());</span><br><span class="line">    	<span class="comment">//将此BigInteger转换为int。</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;intValue():&quot;</span>+number1.intValue());</span><br><span class="line">    	<span class="comment">//	将此转换BigInteger为int，以检查是否丢失了信息。</span></span><br><span class="line">    	<span class="comment">//System.out.println(&quot;intValueExact():&quot;+number1.intValueExact());</span></span><br><span class="line">    	<span class="comment">//true如果此BigInteger可能是质数，false则返回， 如果它绝对是复合的。</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;isProbablePrime():&quot;</span>+number1.isProbablePrime(<span class="number">10</span>));</span><br><span class="line">    	<span class="comment">//将此BigInteger转换为long。</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;longValue():&quot;</span>+number1.longValue());</span><br><span class="line">    	<span class="comment">//将其转换BigInteger为long，以检查是否丢失了信息。</span></span><br><span class="line">    	<span class="comment">//System.out.println(&quot;longValueExact()&quot;+number1.longValueExact());</span></span><br><span class="line">    	<span class="comment">//将其转换BigInteger为short，以检查是否丢失了信息。</span></span><br><span class="line">    	<span class="comment">//System.out.println(&quot;shortValueExact&quot;+number1.shortValueExact());</span></span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//返回大于此BigInteger可能是质数的第一个整数。</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;nextProbablePrime():&quot;</span>+number1.nextProbablePrime());</span><br><span class="line">    	<span class="comment">//返回值为的BigInteger (~this)。</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;not():&quot;</span>+number1.not());</span><br><span class="line">    	<span class="comment">//返回值为的BigInteger (this | val)。</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;or():&quot;</span>+number1.or(number2));</span><br><span class="line">    	<span class="comment">//返回值为的BigInteger 。(thisexponent)</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;pow():&quot;</span>+number1.pow(<span class="number">2</span>));</span><br><span class="line">    	<span class="comment">//返回带有指定bitLength的正BigInteger（可能是素数）。</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;probablePrime():&quot;</span>+number1.probablePrime(<span class="number">10</span>, <span class="keyword">new</span> Random(<span class="number">10</span>)));</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    	<span class="comment">//返回一个BigInteger，其值与此指定位设置的BigInteger等效。</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;setBit():&quot;</span>+number1.setBit(<span class="number">5</span>));</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//分别返回包含整数平方根两个BigInteger的平方根 s的this和它的其余部分this - s*s。</span></span><br><span class="line">    	BigInteger[] arr1=number1.sqrtAndRemainder();</span><br><span class="line">    	System.out.println(arr1[<span class="number">0</span>]+<span class="string">&quot; &quot;</span>+arr1[<span class="number">1</span>]);</span><br><span class="line">    	<span class="comment">//返回值为的BigInteger (this - val)。    	</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;subtract():&quot;</span>+number1.subtract(number2));</span><br><span class="line">    	<span class="comment">//	true仅当设置了指定位时返回。</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;testBit():&quot;</span>+number1.testBit(<span class="number">1</span>));</span><br><span class="line">    	<span class="comment">//	返回一个字节数组，其中包含此BigInteger的二进制补码表示形式</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;toByteArray():&quot;</span>+Arrays.toString(number1.toByteArray()));</span><br><span class="line">    	<span class="comment">//返回此BigInteger的十进制String表示形式。</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;toString()不多说了....&quot;</span>);</span><br><span class="line">    	<span class="comment">//以给定的基数返回此BigInteger的String表示形式。</span></span><br><span class="line">    	<span class="comment">//返回此BigInteger在给定的基数的字符串表示形式。如果基数是从Character.MIN_RADIX到Character.MAX_RADIX包容的范围内，它会默认为10(因为Integer.toString的情况下)。注释链接：</span></span><br><span class="line">    	https:<span class="comment">//www.yiibai.com/java/math/biginteger_tostring_radix.html</span></span><br><span class="line">		<span class="comment">//说白了就是修改进制...</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;toString(int radix):&quot;</span>+number1.toString(<span class="number">10</span>));</span><br><span class="line">    	<span class="comment">//返回一个BigInteger，其值等于指定的long。</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;valueOf():&quot;</span>+BigInteger.valueOf(<span class="number">8</span>));</span><br><span class="line">    	<span class="comment">//返回值为的BigInteger (this ^ val)</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;xor(BigInteger val):&quot;</span>+number1.xor(number2));</span><br><span class="line">    	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用例(国王游戏)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.math.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span> &lt;<span class="title">Node</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> BigInteger a,b,w;</span><br><span class="line">    Node(<span class="keyword">long</span> A,<span class="keyword">long</span> B)&#123;</span><br><span class="line">        a = BigInteger.valueOf(A);</span><br><span class="line">        b = BigInteger.valueOf(B);</span><br><span class="line">        w = a.multiply(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node X)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w.compareTo(X.w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> maxn = (<span class="keyword">int</span>)<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        Node [] node = <span class="keyword">new</span> Node[maxn];</span><br><span class="line">        <span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">long</span> a,b;</span><br><span class="line">            a = sc.nextLong();b = sc.nextLong();</span><br><span class="line">            node[i] = <span class="keyword">new</span> Node(a,b);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(node,<span class="number">1</span>,n+<span class="number">1</span>);</span><br><span class="line">        BigInteger ans = <span class="keyword">new</span> BigInteger(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        BigInteger pre = node[<span class="number">0</span>].a;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            ans = ans.max(pre.divide(node[i].b));</span><br><span class="line">            pre = pre.multiply(node[i].a);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\frac{1}{2} \cdot (-4)^n + \frac{1}{4}\cdot16^n
\]</span></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>Mobius-Transformation</title>
    <url>/2020/05/13/Mobius-Transformation/</url>
    <content><![CDATA[<p>这个菜鸡现在还什么都不会&gt;_&gt;慢慢更新吧</p>
<h1 id="前置知识">前置知识</h1>
<h2 id="整除分块">整除分块</h2>
<p>设<span class="math inline">\(f(x) = \lfloor \frac{k}{x} \rfloor\)</span></p>
<p><span class="math inline">\(f(x)\)</span>分布呈块状,对于任意一个<span class="math inline">\(i\)</span>,有最大的<span class="math inline">\(j = \lfloor \frac{k}{\lfloor \frac{k}{i} \rfloor} \rfloor\)</span>,使得<span class="math inline">\(f(i) == f(i+1) == ... = f(j)\)</span></p>
<p>对于类似<span class="math inline">\(\sum_{i = 1}^{n}\lfloor \frac{k}{i} \rfloor\)</span>的式子,可分块在<span class="math inline">\(O(\sqrt{n})\)</span>时间内计算完毕</p>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>;l &lt;= n;l = r+<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(k/l)r = <span class="built_in">min</span>(n,k/(k/l));</span><br><span class="line">		<span class="keyword">else</span> r = n;</span><br><span class="line">		ans += (r-l+<span class="number">1</span>)*(k/l);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="狄利克雷dirichlet卷积">狄利克雷(Dirichlet)卷积</h2>
<h3 id="定义">定义</h3>
<p>设<span class="math inline">\(f,g\)</span>为两个数论函数,其狄利克雷卷积<span class="math inline">\(f*g\)</span>为: <span class="math display">\[
f \ast g(n) = \sum_{d|n}f(d)g(\frac{n}{d})
\]</span></p>
<h3 id="常用式子">常用式子</h3>
$$
<span class="math display">\[\begin{aligned}

\varepsilon=\mu \ast 1&amp;\iff\varepsilon(n)=\sum_{d\mid n}\mu(d)\\
d=1 \ast 1&amp;\iff d(n)=\sum_{d\mid n}1\\
\sigma=\text{id} \ast 1&amp;\iff\sigma(n)=\sum_{d\mid n}d\\
\varphi=\mu \ast \text{id}&amp;\iff\varphi(n)=\sum_{d\mid n}d\cdot\mu(\frac{n}{d}) \\


\end{aligned}\]</span>
<p>$$</p>
<h2 id="常用结论">常用结论</h2>
<p><span class="math display">\[
\sum_{d|n}^n\varphi(d) = n
\]</span></p>
<p><span class="math display">\[
[\gcd(i,j) == 1] = \epsilon(\gcd(i,j) = \sum_{d|\gcd(i,j)}\mu(d)
\]</span></p>
<h1 id="套路题">套路题</h1>
<h2 id="sum_i1ngcdin"><span class="math inline">\(\sum_{i=1}^ngcd(i,n)\)</span></h2>
<p><span class="math display">\[
\begin{align}
&amp;\sum_{i=1}^n\gcd(i,n)\\
&amp;=\sum_{d|n}d\sum_{i=1}^n[\gcd(i,n)==d]\\
&amp;=\sum_{d|n}d\sum_{i=1}^{\frac{n}{d}}[\gcd(i,n)==1]\\
&amp;=\sum_{d|n}d\cdotφ(\frac{n}{d})
\end{align}
\]</span></p>
<h2 id="sum_i-1nsum_j1ngcdij"><span class="math inline">\(\sum_{i = 1}^n\sum_{j=1}^n\gcd(i,j)\)</span></h2>
<p><span class="math display">\[
\begin{align}
&amp;\sum_{i = 1}^n\sum_{j=1}^n\gcd(i,j)\\
&amp;= \sum_{d=1}^nd\sum_{i=1}^n\sum_{j=1}^n[gcd(i,j) == d]\\
&amp;=\sum_{d=1}^nd\sum_{i=1}^{\frac{n}{d}}\sum_{j=1}^{\frac{n}{d}}[gcd(i,j)==1]\\
&amp;=\sum_{d=1}^nd(2\cdot\sum_{i=1}^{\frac{n}{d}}\varphi(i) - 1)
\end{align}
\]</span></p>
<p>关于最后一步,我们设<span class="math inline">\(f(x) = \sum_{i=1}^{n}\sum_{j=1}^{n}[gcd(i,j)==1]\)</span></p>
<p>手画一下,容易看出<span class="math inline">\(f(x) = 2\cdot\sum_{i=1}^n\varphi(i) - 1\)</span></p>
<p>另一种做法:</p>
<p>我们知道<span class="math inline">\(\varphi\)</span>有这么一个性质,<span class="math inline">\(\sum_{d|n}^{n}\varphi(d) = n\)</span></p>
<p>也就是<span class="math inline">\(\sum_{d|\gcd(i,j)}^{n}\varphi(d) = \gcd(i,j)\)</span></p>
<p>那么: <span class="math display">\[
\begin{align}
&amp;\sum_{i = 1}^n\sum_{j = 1}^n\gcd(i,j)\\
&amp;=\sum_{i=1}^n\sum_{j=1}^n\sum_{d|\gcd(i,j)}\varphi(d)\\
&amp;=\sum_{d = 1}^n\varphi(d)\sum_{i=1}^n[d|i]\sum_{j=1}^n[d|j]\\
&amp;=\sum_{d = 1}^n\varphi(d)\cdot\lfloor\frac{n}{d}\rfloor\lfloor\frac{m}{d}\rfloor
\end{align}
\]</span> 少处理个前缀和=-=而且我感觉这个做法更好理解</p>
<p>例题:洛谷P2398</p>
<h2 id="sum_i-1nsum_ji1ngcdij"><span class="math inline">\(\sum_{i = 1}^{n}\sum_{j=i+1}^{n}\gcd(i,j)\)</span></h2>
<p>和上面那个基本一样 <span class="math display">\[
\begin{align}
&amp;\sum_{i = 1}^n\sum_{j=i+1}^n\gcd(i,j)\\
&amp;= \sum_{d=1}^nd\sum_{i=1}^n\sum_{j=i+1}^n[gcd(i,j) == d]\\
&amp;=\sum_{d=1}^nd\sum_{i=1}^{\frac{n}{d}}\sum_{j=i+1}^{\frac{n}{d}}[gcd(i,j)==1]\\
&amp;=\sum_{d=1}^nd(\sum_{i=1}^{\frac{n}{d}}\varphi(i) - 1)
\end{align}
\]</span> (最后一步的化简和上一题大同小异,手画一下就有了)</p>
<h2 id="sum_i1nsum_i1mgcdij-1"><span class="math inline">\(\sum_{i=1}^{n}\sum_{i=1}^{m}[\gcd(i,j) == 1]\)</span></h2>
<p>前置知识: <span class="math display">\[
\epsilon(n)=\sum_{d|n}\mu(d)= \begin{cases} 1&amp;n=1\\ 
0&amp;otherwise 
\end{cases}
\]</span></p>
<p>开始愉快地推式子: <span class="math display">\[
\begin{align}
&amp;\sum_{i=1}^{n}\sum_{i=1}^{m}[\gcd(i,j) == 1] \\
&amp;=\sum_{i=1}^{n}\sum_{i=1}^{m}\epsilon(\gcd(i,j))\\
&amp;=\sum_{i=1}^{n}\sum_{i=1}^{m}\sum_{d|gcd(i,j)}\mu(d)\\
&amp;=\sum_{d = 1}^{\min(n,m)}\mu(d)\sum_{i = 1}^n[d|i]\sum_{j = 1}^{m}[d|j]\\
&amp;=\sum_{d=1}^{\min(n,m)}\mu(d)\lfloor \frac{n}{d}\rfloor \lfloor \frac{m}{d} \rfloor
\end{align}
\]</span> 同理,我们有: <span class="math display">\[
\sum_{i = 1}^n\sum_{j = 1}^n\sum_{k = 1}^n [\gcd(i,j,k) == 1] = \sum_{d = 1}^n \mu(d)(\lfloor \frac{n}{d}\rfloor)^3
\]</span></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>笔记</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>math-misc</title>
    <url>/2020/05/11/math-misc/</url>
    <content><![CDATA[<ul>
<li>本篇仅记录一些杂乱的知识点留作日后整理,更多是作Markdown和<span class="math inline">\(L_{A}T^{E}X\)</span>的练习用</li>
</ul>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>[笔记]杜教筛</title>
    <url>/2020/06/18/note-du-sieve/</url>
    <content><![CDATA[<p><strong>dlstxdy!</strong></p>
<p>杜教筛用于快速求数论函数的前缀和.当预处理了小于<span class="math inline">\(n^\frac{2}{3}\)</span>的前缀和时,杜教筛的时间复杂度为<span class="math inline">\(O(n^\frac{2}{3})\)</span></p>
<h1 id="形式化定义">形式化定义</h1>
<p>给出数论函数<span class="math inline">\(f\)</span>,快速求<span class="math inline">\(S(n) = \sum_{i = 1}^nf(i)\)</span></p>
<h1 id="解法">解法</h1>
<p>引理: <span class="math display">\[
\sum_{i = 1}^n f \ast g (i) = \sum_{i = 1}^ng(i) \cdot S(\lfloor \frac{n}{i} \rfloor)
\]</span> 证明: $$ <span class="math display">\[\begin{align}

&amp;\sum_{i = 1}^n f \ast g (i) \\
&amp;= \sum_{i = 1}^n \sum_{d|n}f(d)\cdot g(\frac{n}{d})\\
&amp;= \sum_{d = 1}^ng(d)\sum_{i*d = 1,d|i}^{i*d &lt;= n}f(\frac{i}{d})\\
&amp;= \sum_{d = 1}^ng(d)\sum_{i = 1}^{\lfloor \frac{n}{d} \rfloor}f(i)\\
&amp;= \sum_{d = 1}^ng(d)\cdot S(\lfloor \frac{n}{d} \rfloor)

\end{align}\]</span> <span class="math display">\[
观察上式,我们能得到:
\]</span> <span class="math display">\[\begin{align}
&amp;g(1) \cdot S(n) \\
&amp;= \sum_{i = 1}^ng(i) \cdot S(\lfloor \frac{n}{i} \rfloor) -\sum_{i = 2}^ng(i) \cdot S(\lfloor \frac{n}{i} \rfloor)\\
&amp;= \sum_{i = 1}^n f \ast g(i) - \sum_{i = 2}^ng(i) \cdot S(\lfloor \frac{n}{i} \rfloor)\\ 
\end{align}\]</span> $$ 这个式子的后半部分可以用数论分块递归去求,如果我们构造的<span class="math inline">\(g\)</span>能快速求出<span class="math inline">\(\sum_{i = 1}^nf\ast g(i)\)</span>,我们就能快速求出<span class="math inline">\(g(1)\cdot S(n)\)</span>.</p>
<h1 id="例子">例子</h1>
<h2 id="筛mu">筛<span class="math inline">\(\mu\)</span></h2>
<p>我们知道<span class="math inline">\(\mu \ast 1 = \epsilon\)</span></p>
<p>因而有: <span class="math display">\[
\begin{align}
&amp;1\cdot S(n) = S(n)\\
&amp;= \sum_{i = 1}^n\mu \ast 1(i) - \sum_{i = 2}^n 1 \cdot S(\lfloor \frac{n}{i}\rfloor)\\
&amp;= \sum_{i = 1}^n \epsilon - \sum_{i = 2}^n S(\lfloor \frac{n}{i}\rfloor)\\
&amp;= 1 - \sum_{i = 2}^n S(\lfloor \frac{n}{i}\rfloor)\\
\end{align}
\]</span> 简单地把<span class="math inline">\(\mu \ast 1 = \epsilon\)</span>带进上面的结论就行了.</p>
<p>代码:</p>
<p>(Mu为map,记忆化求过的μ.求之前先线性筛一遍小于maxn的μ.下面求φ同理)</p>
<p>注意<span class="math inline">\(g = 1\)</span>,减的时候别漏了(<span class="math inline">\(r-l+1\)</span>)=-=</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ll du_mu(int x)&#123;</span><br><span class="line">	if(x &lt; maxn)return mu[x];</span><br><span class="line">	else if(Mu[x])return Mu[x];</span><br><span class="line">	ll tans = 1;</span><br><span class="line">	for(int l = 2,r = 0;l &lt;= x;l = r+1)&#123;</span><br><span class="line">		r = x/(x/l);</span><br><span class="line">		tans -= 1LL*(r - l + 1)*du_mu(x/l);</span><br><span class="line">	&#125;</span><br><span class="line">	return Mu[x] = tans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="筛varphi">筛<span class="math inline">\(\varphi\)</span></h2>
<p>和μ大同小异.我们有<span class="math inline">\(\varphi \ast 1 = id\)</span>,其中<span class="math inline">\(id(n) = n\)</span> <span class="math display">\[
\begin{align}
&amp;1\cdot S(n) = S(n)\\
&amp;= \sum_{i = 1}^n\varphi \ast 1(i) - \sum_{i = 2}^n 1 \cdot S(\lfloor \frac{n}{i}\rfloor)\\
&amp;= \sum_{i = 1}^n id(i) - \sum_{i = 2}^n S(\lfloor \frac{n}{i}\rfloor)\\
&amp;= \frac{n*(n+1)}{2} - \sum_{i = 2}^n S(\lfloor \frac{n}{i}\rfloor)\\
\end{align}
\]</span> 代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">du_phi</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x &lt; maxn)<span class="keyword">return</span> phi[x];</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(Phi[x])<span class="keyword">return</span> Phi[x];</span><br><span class="line">	ll tans = <span class="number">1LL</span>*x*(x+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">2</span>,r = <span class="number">0</span>;l &lt;= x;l = r+<span class="number">1</span>)&#123;</span><br><span class="line">		r = x/(x/l);</span><br><span class="line">		tans -= <span class="number">1LL</span>*(r-l+<span class="number">1</span>)*<span class="built_in">du_phi</span>(x/l);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Phi[x] = tans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>笔记</tag>
        <tag>数学</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]CF1200 E-Compress Words</title>
    <url>/2020/12/03/solution-CF1200E/</url>
    <content><![CDATA[<h2 id="题意">题意</h2>
<p>给出<span class="math inline">\(n\)</span>个字符串, 将字符串按顺序拼接. 拼接时删除后面字符串的前缀与前面字符串的后缀中的最长相同部分.</p>
<p>例如<code>sample</code>与<code>please</code>拼接成为<code>samplease</code></p>
<p><span class="math inline">\(1 \leq n \leq 10^5\)</span>, <span class="math inline">\(\sum|s_i| \leq 10^6\)</span></p>
<h2 id="题解">题解</h2>
<p>设将<span class="math inline">\(u\)</span>和<span class="math inline">\(v\)</span>拼接在一起, 用KMP求出<span class="math inline">\(s = v|u\)</span>(|是任意分隔符)的失配数组<span class="math inline">\(next[]\)</span>.由于失配数组代表前后缀的最长长度, <span class="math inline">\(next[|s|]\)</span>即为<span class="math inline">\(v\)</span>的前缀与<span class="math inline">\(u\)</span>的后缀相同部分的最长长度.</p>
<p>注意到这个最长长度不会超过<span class="math inline">\(|v|\)</span>, 因此我们只需把<span class="math inline">\(u\)</span>的最后<span class="math inline">\(|v|\)</span>个字符接到分隔符后. 时间复杂度<span class="math inline">\(O(\sum|s_i|)\)</span></p>
<p>赛时十分傻逼地忘了用分隔符把<span class="math inline">\(u,v\)</span>分隔开, 疯狂WA到怀疑人生...顺便吐槽一句这个数据真的弱</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我  是  傻  逼</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">int</span> Next[<span class="number">4000010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFail</span><span class="params">(string &amp; P)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= (<span class="keyword">int</span>)P.<span class="built_in">size</span>();i++)Next[i] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> p_size = P.<span class="built_in">size</span>();</span><br><span class="line">	Next[<span class="number">0</span>] = Next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; p_size;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> j = Next[i];</span><br><span class="line">		<span class="keyword">while</span>(j <span class="keyword">and</span> P[i] != P[j])j = Next[j];</span><br><span class="line">		Next[i+<span class="number">1</span>] = (P[j] == P[i]?j+<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">process</span><span class="params">(string &amp; u,string &amp; v)</span></span>&#123;</span><br><span class="line">	string x = v;</span><br><span class="line">	x += <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="built_in">max</span>(<span class="number">0</span>,(<span class="keyword">int</span>)(u.<span class="built_in">size</span>() - v.<span class="built_in">size</span>()));i &lt; (<span class="keyword">int</span>)u.<span class="built_in">size</span>();i++)x += u[i];</span><br><span class="line">	<span class="built_in">getFail</span>(x);</span><br><span class="line">	string tans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = Next[x.<span class="built_in">size</span>()];i &lt; (<span class="keyword">int</span>)v.<span class="built_in">size</span>();i++)tans += v[i];</span><br><span class="line">	<span class="keyword">return</span> tans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	string u,v;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">		cin &gt;&gt; u;</span><br><span class="line">		cout &lt;&lt; u;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">	ans = u + <span class="built_in">process</span>(u,v);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		cin &gt;&gt; v;</span><br><span class="line">		ans += <span class="built_in">process</span>(ans,v);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>KMP</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>[笔记]多项式</title>
    <url>/2021/03/28/polynomial/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>[题解]CF1325E-Ehab&#39;s REAL Number Theory Problem</title>
    <url>/2020/05/15/solution-CF1325E/</url>
    <content><![CDATA[<p>一道有意思的<del>毒瘤</del>题</p>
<h1 id="题意">题意</h1>
<p>​ 给出数列<span class="math inline">\(\{a_1,a_2,...,a_n\}\)</span>,其中每个<span class="math inline">\(a_i\)</span>最多只有7个因子.求乘积为完全平方数的最短子序列</p>
<p>​ <span class="math inline">\(1 \leq n \leq 1e5\)</span>,<span class="math inline">\(1 \leq a_i \leq 1e6\)</span></p>
<h1 id="思路">思路</h1>
<p>​ 首先条件里"最多只有7个因子"是很有意思的一个提示,它实际上是指每个数<strong>最多只有2个素因子</strong></p>
<p>证明:</p>
<p>​ 我们考虑因子个数定理:</p>
<p>​ 以<span class="math inline">\(d(N)\)</span>表示<span class="math inline">\(N\)</span>的因子个数,且<span class="math inline">\(N = Σ_{i=1}^{n}p_{i}^{k_i}\)</span></p>
<p>​ 则有<span class="math inline">\(d(N) = \prod_{i = 1}^{n}(k_i+1)\)</span></p>
<p>​ 容易看出当<span class="math inline">\(N\)</span>有3个素因子时,<span class="math inline">\(d(N) \geq 8\)</span>.故N最多只有两个素因子.</p>
<p>​ 如此可以分解每个<span class="math inline">\(a_i\)</span>为<span class="math inline">\(a_i = p^{k_1}q^{k_2}\)</span>的形式.因为我们需要求完全平方数,<span class="math inline">\(k_1,k_2\)</span>可以直接模2.之后有如下三种情况:</p>
<ol type="1">
<li><span class="math inline">\(a_i = 1\)</span></li>
<li><span class="math inline">\(a_i = 1*p_i\)</span></li>
<li><span class="math inline">\(a_i = p_i*q_i\)</span> 我们要做的就是保证子序列里每个<span class="math inline">\(p_i,q_i\)</span>的指数为偶数,同时使这个序列最短.</li>
</ol>
<hr />
<p>​ 如何高效求解这个问题?上面的因子分解得到了<span class="math inline">\(p,q\)</span>两个因子,让人联想到图的连边.不妨如此建模:将因子作为点,向<span class="math inline">\(a_i\)</span>的两个因子<span class="math inline">\(p_i,q_i\)</span>连一条无向无权边,则问题转化为求这个图里的最小环.(因为一个简单环里每个点的度数都为2,满足每个因子的指数都为偶数这一要求).</p>
<p>​ 对于无向无权图图求最小环我们可以简单地对每个点做BFS.对于一条未访问的边<span class="math inline">\(u,v\)</span> ,如果<span class="math inline">\(v\)</span>已访问过,那么该图存在一个长度为<span class="math inline">\(dis[u]+dis[v]+1\)</span>的环(请自己画图验证).但是这样复杂度为<span class="math inline">\(O(n^2)\)</span></p>
<p>​ 考虑这个图的特殊性质:任意正整数<span class="math inline">\(N\)</span>最多只有一个大于<span class="math inline">\(\sqrt{N}\)</span>的素因子,换句话说这个图里每条边都至少有一个点标号小于<span class="math inline">\(\sqrt{max\{a_i\}}\)</span>.只需枚举这些点即可.</p>
<p>​ 总复杂度:<span class="math inline">\(O(\sqrt{max{a_i}}n)\)</span></p>
<h1 id="代码">代码</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CF1325E</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> f,t,next;</span><br><span class="line">	<span class="built_in">Edge</span>(<span class="keyword">int</span> f = <span class="number">0</span>,<span class="keyword">int</span> t = <span class="number">0</span>,<span class="keyword">int</span> next = <span class="number">0</span>):<span class="built_in">f</span>(f),<span class="built_in">t</span>(t),<span class="built_in">next</span>(next)&#123;&#125;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt,head[maxn],dis[maxn],ans = <span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	edge[cnt] = <span class="built_in">Edge</span>(f,t,head[f]);</span><br><span class="line">	head[f] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="built_in">addedge</span>(f,t);</span><br><span class="line">	<span class="built_in">addedge</span>(t,f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> visp[maxn],vis[maxn];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;P,d[maxn];</span><br><span class="line"><span class="keyword">int</span> n,raw[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	visp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; maxn;i++)<span class="keyword">if</span>(!visp[i])&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i*<span class="number">2</span>;j &lt; maxn;j+=i)visp[j] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; maxn;i++)<span class="keyword">if</span>(!visp[i])&#123;</span><br><span class="line">		P.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		cin &gt;&gt; raw[i];</span><br><span class="line">		<span class="keyword">int</span> cur = raw[i];</span><br><span class="line">		<span class="keyword">if</span>(!visp[cur])&#123;</span><br><span class="line">			d[i].<span class="built_in">push_back</span>(cur);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>;j*j &lt;= raw[i];j++)&#123;</span><br><span class="line">			<span class="keyword">int</span> cnt2 = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(cur%j == <span class="number">0</span>)&#123;</span><br><span class="line">				cur /= j;cnt2++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(cnt2%<span class="number">2</span>)d[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(cur &gt; <span class="number">1</span>)d[i].<span class="built_in">push_back</span>(cur);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!d[i].<span class="built_in">size</span>())&#123;</span><br><span class="line">			cout &lt;&lt; <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(d[i].<span class="built_in">size</span>() == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">add</span>(<span class="number">1</span>,d[i][<span class="number">0</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">add</span>(d[i][<span class="number">0</span>],d[i][<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">	dis[s] = <span class="number">0</span>;</span><br><span class="line">	queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;q;</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(s,<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="keyword">auto</span> now = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">int</span> u = now.first,fa = now.second;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">			<span class="keyword">if</span>(v == fa)<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(dis[v] == <span class="number">-1</span>)&#123;</span><br><span class="line">				dis[v] = dis[u]+<span class="number">1</span>;</span><br><span class="line">				q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(v,u));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				ans = <span class="built_in">min</span>(ans,dis[v]+dis[u]+<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">1010</span>;i++)<span class="built_in">BFS</span>(i);</span><br><span class="line">	<span class="keyword">if</span>(ans == <span class="number">1e9</span>)ans = <span class="number">-1</span>;</span><br><span class="line">	cout &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><span class="math inline">\(2^{2n-1}+2^{2n-2}-2^n\)</span></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>题解</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]CF1334G-Substring Search</title>
    <url>/2021/04/02/solution-CF1334G/</url>
    <content><![CDATA[<h2 id="题意">题意</h2>
<p>设<span class="math inline">\(p\)</span>为从<span class="math inline">\(\sum\)</span>到<span class="math inline">\(\sum\)</span>的双射(<span class="math inline">\(\sum = \{a,b,...,z\})\)</span>. 给出两个字符串<span class="math inline">\(s,t\)</span>(<strong>由于个人习惯,此处s,t的含义和原题相反</strong>)且满足<span class="math inline">\((1 \leq |t| \leq |s| \leq 2 \cdot10^5)\)</span>. 求对于<span class="math inline">\(s\)</span>的每个长度为<span class="math inline">\(|t|\)</span>的子串<span class="math inline">\(s&#39;\)</span>, <span class="math inline">\(s&#39;\)</span>与<span class="math inline">\(t\)</span>是否匹配. 输出一个长为<span class="math inline">\(|s| - |t| + 1\)</span>的01串, 其中第<span class="math inline">\(i\)</span>位为1表示<span class="math inline">\(s[i...i+|t| - 1]\)</span>与<span class="math inline">\(t\)</span>匹配.</p>
<p>匹配在此题定义为: 设两个长度相等的串<span class="math inline">\(s&#39;,t\)</span>, 对全部<span class="math inline">\(i = 0...|t|-1\)</span>, 有<span class="math inline">\(s&#39;[i] == t[i]\)</span> 或<span class="math inline">\(s&#39;[i] == p(t[i])\)</span></p>
<h2 id="题解">题解</h2>
<p>首先我们设匹配函数 <span class="math display">\[
F(x) = \sum_{i = x,j = i - x}^{|t| + x - 1}(s[i] - t[j])^2(s[i] - f(t[j]))^2
\]</span> 容易看出, 当且仅当<span class="math inline">\(F(x) == 0\)</span>时, <span class="math inline">\(s[x...x+|t| - 1]\)</span>与<span class="math inline">\(t\)</span>匹配. 将和式内部展开后化简, 可以发现展开后每一项都可化为 <span class="math inline">\(\sum_{i,j = 1}^na_ib_j\)</span>的形式. 我们用经典套路把<span class="math inline">\(t\)</span>反转后, 便可化为卷积形式用FFT求解.</p>
<p>但是这个式子好像要做七次DFT和IDFT, 太麻烦. 我们尝试乱搞一下: <span class="math display">\[
G(x) = \sum_{i = x,j = i-x}^{|t| + x - 1}(s[i] - t[j])(s[i] - f(t[j]))
\]</span> 展开后有: <span class="math display">\[
G(x) = \sum_{i = x}^{|t| + x - 1}s[i]^2 - \sum_{i = x,j = i-x}^{|t| + x - 1}s[i]\cdot f(t[j]) - \sum_{i = x,j = i-x}^{|t| + x - 1}s[i]\cdot t[j] + \sum_{j = 0}^{|t| - 1} t[j] \cdot f(t[j])
\]</span></p>
<p>首项和末项用前缀和处理, 剩下两项可以分别进行一次卷积求出.</p>
<p>把平方去掉后由于存在负数项, 因而某些不能被匹配的位置也可能有<span class="math inline">\(G(x) = 0\)</span>. 我们将<code>a-z</code>随机赋上一个权值后再进行计算, 便能大大减少冲突的概率. (我不知道这种做法实际上是否正确, <strong>更不能保证不会被卡</strong>, 但这种做法足够通过此题). 由于FFT在计算时会损失精度, 我们使用NTT进行求解.</p>
<p>时间复杂度<span class="math inline">\(|s|\log |s|\)</span></p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">6e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(d == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>%p;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="built_in">Pow</span>(x,d/<span class="number">2</span>);</span><br><span class="line">	tans = <span class="number">1ll</span>*a*a%p;</span><br><span class="line">	<span class="keyword">if</span>(d%<span class="number">2</span>)tans = <span class="number">1ll</span>*tans*x%p; </span><br><span class="line">	<span class="keyword">return</span> tans%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> rev[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp; x,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(size &lt;= n)size *= <span class="number">2</span>;</span><br><span class="line">	x.<span class="built_in">assign</span>(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT_init</span><span class="params">(<span class="keyword">int</span> lim)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i) rev[i] = (i &amp; <span class="number">1</span>) * (lim &gt;&gt; <span class="number">1</span>) + (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp; A, <span class="keyword">int</span> opt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> lim = A.<span class="built_in">size</span>();</span><br><span class="line"> 	<span class="keyword">int</span> i, j, k, m, gn, g, tmp;</span><br><span class="line"> 	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; lim; ++i)<span class="keyword">if</span> (rev[i] &lt; i) <span class="built_in">swap</span>(A[i], A[rev[i]]);</span><br><span class="line"> 	<span class="keyword">for</span>(m = <span class="number">2</span>; m &lt;= lim; m &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">	    k = m &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	    gn = <span class="built_in">Pow</span>(<span class="number">3</span>,(p - <span class="number">1</span>) / m);</span><br><span class="line">	    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; lim; i += m) &#123;</span><br><span class="line">	    	g = <span class="number">1</span>;</span><br><span class="line">	    	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; k; ++j, g = <span class="number">1ll</span> * g * gn % p) &#123;</span><br><span class="line">	    	    tmp = <span class="number">1ll</span> * A[i + j + k] * g % p;</span><br><span class="line">	    	    A[i + j + k] = (A[i + j] - tmp + p) % p;</span><br><span class="line">	     	 	A[i + j] = (A[i + j] + tmp) % p;</span><br><span class="line">	    	&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(opt == <span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="keyword">auto</span> it = A.<span class="built_in">begin</span>();it++;</span><br><span class="line">    	<span class="built_in">reverse</span>(it,A.<span class="built_in">end</span>());</span><br><span class="line">    	<span class="keyword">int</span> inv = <span class="built_in">Pow</span>(lim,p<span class="number">-2</span>);</span><br><span class="line">    	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; lim; ++i) A[i] = <span class="number">1ll</span> * A[i] * inv % p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="keyword">int</span>&gt; Poly;</span><br><span class="line">Poly A,B;</span><br><span class="line"><span class="keyword">int</span> per[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> w[maxn][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> rnd[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> ans[maxn];</span><br><span class="line"><span class="function">mt19937 <span class="title">Rand</span><span class="params">(<span class="number">19260817</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	string s,t;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++)cin &gt;&gt; per[i],per[i]--,rnd[i] = <span class="built_in">Rand</span>()%p;</span><br><span class="line">	cin &gt;&gt; t &gt;&gt; s;</span><br><span class="line">	<span class="keyword">int</span> n = s.<span class="built_in">size</span>(),m = t.<span class="built_in">size</span>();</span><br><span class="line">	Poly A,B;</span><br><span class="line">	<span class="built_in">init</span>(A,s.<span class="built_in">size</span>());</span><br><span class="line">	<span class="built_in">init</span>(B,s.<span class="built_in">size</span>());</span><br><span class="line">	<span class="built_in">NTT_init</span>(A.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)w[i][<span class="number">0</span>] = (<span class="number">1ll</span>*rnd[s[i] - <span class="string">&#x27;a&#x27;</span>]*rnd[s[i] - <span class="string">&#x27;a&#x27;</span>]%p + (i?w[i<span class="number">-1</span>][<span class="number">0</span>]:<span class="number">0</span>))%p;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)w[i][<span class="number">3</span>] = (<span class="number">1ll</span>*rnd[t[i] - <span class="string">&#x27;a&#x27;</span>]*rnd[per[t[i] - <span class="string">&#x27;a&#x27;</span>]]%p + (i?w[i<span class="number">-1</span>][<span class="number">3</span>]:<span class="number">0</span>))%p;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)A[i] = rnd[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)B[m - i - <span class="number">1</span>] = rnd[t[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">	<span class="built_in">NTT</span>(A,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">NTT</span>(B,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (<span class="keyword">int</span>)A.<span class="built_in">size</span>();i++)A[i] = (<span class="number">1ll</span>*A[i]*B[i])%p;</span><br><span class="line">	<span class="built_in">NTT</span>(A,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (<span class="keyword">int</span>)A.<span class="built_in">size</span>();i++)w[i][<span class="number">1</span>] = A[i];</span><br><span class="line">	<span class="built_in">init</span>(A,s.<span class="built_in">size</span>());</span><br><span class="line">	<span class="built_in">init</span>(B,s.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)A[i] = rnd[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)B[m - i - <span class="number">1</span>] = rnd[per[t[i] - <span class="string">&#x27;a&#x27;</span>]];</span><br><span class="line">	<span class="built_in">NTT</span>(A,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">NTT</span>(B,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (<span class="keyword">int</span>)A.<span class="built_in">size</span>();i++)A[i] = (<span class="number">1ll</span>*A[i]*B[i])%p;</span><br><span class="line">	<span class="built_in">NTT</span>(A,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (<span class="keyword">int</span>)A.<span class="built_in">size</span>();i++)w[i][<span class="number">2</span>] = A[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = m<span class="number">-1</span>;i &lt; n;i++)&#123;</span><br><span class="line">		ll A = (w[i][<span class="number">0</span>] - (i - m &gt;= <span class="number">0</span>?w[i-m][<span class="number">0</span>]:<span class="number">0</span>) + p)%p,D = w[m<span class="number">-1</span>][<span class="number">3</span>]%p;</span><br><span class="line">		ll B = w[i][<span class="number">1</span>],C = w[i][<span class="number">2</span>];</span><br><span class="line">		<span class="keyword">if</span>((((A -  B + p)%p - C + p) % p + D)%p == <span class="number">0</span>)cout &lt;&lt; <span class="string">&quot;1&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;0&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>题解</tag>
        <tag>NTT</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]CF1364-D Ehab&#39;s Last Corollary</title>
    <url>/2020/06/14/solution-CF1364D/</url>
    <content><![CDATA[<p>很妙的一题</p>
<h1 id="题意">题意</h1>
<p>给出<span class="math inline">\(n\)</span>个节点<span class="math inline">\(m\)</span>条边的无向连通图和参数<span class="math inline">\(k\)</span>,求:</p>
<ul>
<li>严格<span class="math inline">\(\lceil \frac{k}{2} \rceil\)</span>大小的点独立集</li>
<li>或大小$ k$的简单环</li>
</ul>
<p><span class="math inline">\(3 \leq k \leq n \leq 10^5,n-1 \leq m \leq 2 \cdot 10^5\)</span></p>
<h1 id="思路">思路</h1>
<h5 id="解法1">解法1</h5>
<p>​ 我们求出一个原图的DFS树,当某个节点<span class="math inline">\(u\)</span>存在反向边时,找出终点<span class="math inline">\(v\)</span>深度最深的反向边.容易看出这个反向边在一个简单环中,且这个简单环不会被其他边分割.如果这个环的大小<span class="math inline">\(\leq k\)</span>,直接输出即可,否则我们取不相邻的<span class="math inline">\(\lceil \frac{k}{2} \rceil\)</span>个点,它们形成一个点独立集.</p>
<p>​ 如果原图无环(或者说是一棵树),那么我们很容易就能求出大小<span class="math inline">\(\lceil \frac{k}{2} \rceil\)</span>的点独立集.</p>
<h5 id="解法2">解法2</h5>
<p>​ 我们求出任意一个环,然后枚举所有的边<span class="math inline">\(1...m\)</span>.如果某条边把这个环分割开(即起点终点都在环上),那么保留这个环的任意一半,继续该过程.最后我们会得到一个不被其他边分割的简单环.之后的处理同解法1.</p>
<p>​ 如果原图是一棵树,同解法1.</p>
<p>​ (比赛时我用的就是这种做法,但是写T了=-=个人觉得这是最难想也最难写的做法,鬼知道我当时在干什么)</p>
<h5 id="解法3">解法3</h5>
<p>​ (来自Um_nik的代码)https://codeforces.com/contest/1364/submission/83636767</p>
<p>​ %%%%%</p>
<p>​ 根据原题,无论我们求点独立集还是简单环,都需要最多<span class="math inline">\(k\)</span>个点,那么我们简单粗暴地把所有编号$ &gt; k<span class="math inline">\(的点删掉,再在剩下的图(**注意新图可能不连通**)中寻找环.如果我们找到任意一个环,直接输出即可,因为这个环的大小肯定\)</span>k<span class="math inline">\(.如果没有环(新图是一个森林),那也能很容易地找到\)</span> $大小的点独立集.</p>
<h1 id="代码">代码</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//D</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> from,to,next,cnt;</span><br><span class="line">	<span class="built_in">Edge</span>(<span class="keyword">int</span> from = <span class="number">0</span>,<span class="keyword">int</span> to = <span class="number">0</span>,<span class="keyword">int</span> next = <span class="number">0</span>):<span class="built_in">from</span>(from),<span class="built_in">to</span>(to),<span class="built_in">next</span>(next)&#123;&#125;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn],cnt,d,dep[maxn],p[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn],col[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	edge[cnt] = <span class="built_in">Edge</span>(f,t,head[f]);</span><br><span class="line">	head[f] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(vis[u])<span class="keyword">return</span>;</span><br><span class="line">	vis[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(vis[v] <span class="keyword">and</span> dep[v] &gt; dep[u])&#123;</span><br><span class="line">			vector&lt;<span class="keyword">int</span>&gt;cir = &#123;&#125;;</span><br><span class="line">			<span class="keyword">int</span> cur = v;</span><br><span class="line">			<span class="keyword">while</span>(cur != u)&#123;</span><br><span class="line">				cir.<span class="built_in">push_back</span>(cur);</span><br><span class="line">				cur = p[cur];</span><br><span class="line">			&#125;</span><br><span class="line">			cir.<span class="built_in">push_back</span>(u);</span><br><span class="line">			<span class="keyword">int</span> s = cir.<span class="built_in">size</span>();</span><br><span class="line">			cout &lt;&lt; <span class="number">2</span> &lt;&lt; endl &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> yay:cir)cout &lt;&lt; yay &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">			p[v] = u;</span><br><span class="line">			dep[v] = dep[u]+<span class="number">1</span>;</span><br><span class="line">			col[v] = !col[u];</span><br><span class="line">			<span class="built_in">DFS</span>(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">	d = <span class="built_in">ceil</span>((<span class="keyword">double</span>)k/<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> f1,t1;</span><br><span class="line">		cin &gt;&gt; f1&gt;&gt; t1;</span><br><span class="line">		<span class="keyword">if</span>(f1 &gt; k <span class="keyword">or</span> t1 &gt; k)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">addedge</span>(f1,t1);</span><br><span class="line">		<span class="built_in">addedge</span>(t1,f1);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> cnt1 = <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)<span class="built_in">DFS</span>(i);</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;ans = &#123;&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)<span class="keyword">if</span>(col[i])cnt1++;</span><br><span class="line">	<span class="keyword">int</span> qwq = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(cnt1 &gt;= d)qwq = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)<span class="keyword">if</span>(col[i] == qwq)&#123;</span><br><span class="line">		<span class="keyword">if</span>((<span class="keyword">int</span>)ans.<span class="built_in">size</span>() == d)<span class="keyword">break</span>;</span><br><span class="line">		ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> x:ans)cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]CF1350C-Orac and LCM</title>
    <url>/2020/05/13/solution-CF1350C/</url>
    <content><![CDATA[<h1 id="题目大意">题目大意</h1>
<p>​ 给定集合<span class="math inline">\(\{a_1,a_2,...,a_n\}\)</span>,求<span class="math inline">\(gcd(\{lcm(\{a_i,a_j\})|i&lt;j\})\)</span></p>
<p>​ $2 n 1e5 $ , <span class="math inline">\(1 \leq a_i \leq 2e5\)</span></p>
<h1 id="思路">思路</h1>
<p>​ 考虑唯一分解定理:</p>
<p>​ <span class="math inline">\(a = \prod^{n}_{1}p_i^{k_i}\)</span></p>
<p>​ <span class="math inline">\(b = \prod^{n}_{1}p_i^{g_i}\)</span></p>
<p>​ 对于 <span class="math inline">\(gcd\)</span> 和 <span class="math inline">\(lcm\)</span> ,我们有:</p>
<p>​ <span class="math inline">\(gcd(a,b) = \prod^{n}_{1}p_i^{min(k_i,g_i)}\)</span></p>
<p>​ <span class="math inline">\(lcm(a,b) = \prod^{n}_{1}p_i^{max(k_i,g_i)}\)</span></p>
<p>​ 观察易得,对于答案中的每个质因子<span class="math inline">\(p_i\)</span>,它的指数<span class="math inline">\(k_i\)</span>为<span class="math inline">\(\{a_1,...,a_n\}\)</span>中 <span class="math inline">\(p_i\)</span> <strong>第二小</strong> 的指数<span class="math inline">\(k\)</span></p>
<p>​ 我们预处理出<span class="math inline">\(i\)</span>的所有质因数<span class="math inline">\(p[i]\)</span>,将<span class="math inline">\(a_i\)</span>分解,用<span class="math inline">\(d[i][j]\)</span>表示<span class="math inline">\(a_j\)</span>的质因子<span class="math inline">\(i\)</span>的指数,排序后扫一遍<span class="math inline">\(d[i]\)</span>即可得到答案</p>
<p>​ 具体来说 <span class="math display">\[
ans *= \left\{
\begin{array}{lcl}
i^{d[i][0]}&amp;&amp; {d[i].size() == n-1} \\
i^{d[i][1]} &amp;&amp; {d[i].size()  \geq n-1 }\\
1 &amp;&amp; otherwise
\end{array}
\right.
\]</span></p>
<h1 id="代码">代码</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> raw[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="function">ll <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">	ll tans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(d == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	ll a = <span class="built_in">Pow</span>(x,d/<span class="number">2</span>);</span><br><span class="line">	tans = a*a;</span><br><span class="line">	<span class="keyword">if</span>(d%<span class="number">2</span>)tans = tans*x; </span><br><span class="line">	<span class="keyword">return</span> tans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> n_prime[maxn];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;p[maxn],d[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;maxn;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!n_prime[i])&#123;</span><br><span class="line">			p[i].<span class="built_in">push_back</span>(i); </span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = i*<span class="number">2</span>;j &lt; maxn;j += i)&#123;</span><br><span class="line">				n_prime[j] = <span class="number">1</span>;</span><br><span class="line">				p[j].<span class="built_in">push_back</span>(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	n_prime[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">prime</span>();</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)cin &gt;&gt; raw[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> u = raw[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x:p[u])&#123;</span><br><span class="line">			<span class="keyword">int</span> yay = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(u%x == <span class="number">0</span>)&#123;</span><br><span class="line">				yay++;</span><br><span class="line">				u /= x;</span><br><span class="line">			&#125;</span><br><span class="line">			d[x].<span class="built_in">push_back</span>(yay);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; maxn;i++)&#123;</span><br><span class="line">		<span class="built_in">sort</span>(d[i].<span class="built_in">begin</span>(),d[i].<span class="built_in">end</span>());</span><br><span class="line">		<span class="keyword">if</span>(d[i].<span class="built_in">size</span>() == n<span class="number">-1</span>)&#123;</span><br><span class="line">			ans *= <span class="built_in">Pow</span>(i,d[i][<span class="number">0</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(d[i].<span class="built_in">size</span>() &gt; n<span class="number">-1</span>)ans *= <span class="built_in">Pow</span>(i,d[i][<span class="number">1</span>]); </span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]CF1385E</title>
    <url>/2020/10/08/solution-CF1385E/</url>
    <content><![CDATA[<h1 id="题意">题意</h1>
<p>给出一张图, 图中有的边已确定方向(且不可更改), 另一些边尚未确定方向. 给所有未确定方向的边指定一个方向, 使得新的图不存在环. 如果无解输出<code>NO</code></p>
<h1 id="分析">分析</h1>
<p>一张图的拓扑排序是一个DAG. 我们首先仅考虑原图的有向边, 如果其中存在环那么无解. 否则求原图的拓扑序, 按拓扑序指派边的方向即可.</p>
<h1 id="代码">代码</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">10</span>; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> f,t,next;</span><br><span class="line">	<span class="built_in">Edge</span>(<span class="keyword">int</span> f = <span class="number">0</span>,<span class="keyword">int</span> t = <span class="number">0</span>,<span class="keyword">int</span> next = <span class="number">0</span>):<span class="built_in">f</span>(f),<span class="built_in">t</span>(t),<span class="built_in">next</span>(next)&#123;&#125;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="keyword">int</span> cnt,head[maxm],vis[maxm],dep[maxn],in[maxn],dict[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	edge[cnt] = <span class="built_in">Edge</span>(f,t,head[f]);</span><br><span class="line">	head[f] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> ok = <span class="number">1</span>;</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;Node[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> qwq = <span class="number">0</span>;</span><br><span class="line">	queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)<span class="keyword">if</span>(!in[i])&#123;</span><br><span class="line">		q.<span class="built_in">push</span>(i);</span><br><span class="line">		vis[i] = <span class="number">1</span>;</span><br><span class="line">		dep[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(q.<span class="built_in">empty</span>())ok = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="keyword">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		dep[u] = ++qwq;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">			<span class="keyword">if</span>(--in[v])&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			q.<span class="built_in">push</span>(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(qwq != n)ok = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		ok = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> n,m;</span><br><span class="line">		cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">			head[i] = <span class="number">-1</span>;</span><br><span class="line">			dep[i] = dict[i] = in[i] = vis[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> opt,f,t;</span><br><span class="line">			cin &gt;&gt; opt &gt;&gt; f &gt;&gt; t;</span><br><span class="line">			Node[i] = &#123;f,t&#125;;</span><br><span class="line">			<span class="keyword">if</span>(opt)&#123;</span><br><span class="line">				<span class="built_in">addedge</span>(f,t);</span><br><span class="line">				in[t]++;</span><br><span class="line">				dict[i] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">BFS</span>(n);</span><br><span class="line">		<span class="keyword">if</span>(!ok)&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">				<span class="keyword">int</span> &amp; f = Node[i].first,&amp; t = Node[i].second;</span><br><span class="line">				<span class="keyword">if</span>(dep[f] &gt; dep[t])cout &lt;&lt; t &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">				<span class="keyword">else</span> cout &lt;&lt; f &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]CF1417E</title>
    <url>/2020/10/14/solution-CF1417E/</url>
    <content><![CDATA[<h2 id="题意">题意</h2>
<p>给出一个长为<span class="math inline">\(n\)</span>的数组<span class="math inline">\(\{a_i\}\)</span>, 用<span class="math inline">\(x\)</span>异或数组中的每一个元素, 使得在新数组逆序对最少的情况下<span class="math inline">\(x\)</span>最小.求满足题意的逆序对数和<span class="math inline">\(x\)</span></p>
<p><span class="math inline">\(1 \le n \le 3 \cdot 10^5\)</span></p>
<h2 id="题解">题解</h2>
<p>异或让我们考虑0-1Trie.</p>
<p>对于每一个数, 按照从高位到低位的顺序插入Trie, 并对其经过的每个节点维护该数字的下标. 具体来说,<code>idx[u]</code>记录了经过节点<span class="math inline">\(u\)</span>的数字的下标. 由于我们按下标递增的顺序插入元素, 该数组是有序的.</p>
<p>有了<code>idx[]</code>，再结合一个显然的事实: 两个数的大小只取决于其最高位, 我们就可高效计算每一位所影响的逆序对(0-1Trie中,左子树代表的值小于右子树).</p>
<p>具体做法: 从高位开始自上而下遍历整棵0-1Trie. 设当前节点为<span class="math inline">\(u\)</span>, 当<span class="math inline">\(u\)</span>的两个子节点均存在时, 修改该位才能对逆序对数目产生影响. 利用前面维护的下标, 我们可以在线性时间内计算该位对逆序对数目的贡献.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ptr = <span class="number">0</span>;<span class="comment">//右子树idx[]的游标</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x:idx[l])&#123;<span class="comment">//遍历左子树的下标</span></span><br><span class="line">		<span class="keyword">while</span>(ptr &lt; idx[r].<span class="built_in">size</span>() <span class="keyword">and</span> idx[r][ptr] &lt; x)ptr++;<span class="comment">//左子树当前下标贡献的逆序对个数</span></span><br><span class="line">			inv += ptr;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用<span class="math inline">\(sum[][]\)</span>来记录该结果.<span class="math inline">\(sum[i][0]\)</span>表示不修改第<span class="math inline">\(i\)</span>位所贡献的逆序对, <span class="math inline">\(sum[i][1]\)</span>表示修改该位贡献的逆序对.容易看出修改该位后, 原本的逆序对变成了顺序对, 反之亦然.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sum[dep][<span class="number">0</span>] += inv;</span><br><span class="line">sum[dep][<span class="number">1</span>] += (ll)idx[l].<span class="built_in">size</span>()*idx[r].<span class="built_in">size</span>() - inv;</span><br></pre></td></tr></table></figure>
<p>有了sum数组,答案便很容易统计:<span class="math inline">\(inv += \min(sum[i][0],sum[i][1])\)</span>. 而当<span class="math inline">\(sum[i][1] &lt; sum[i][0]\)</span>时, <span class="math inline">\(x\)</span>的第<span class="math inline">\(i\)</span>位为1.</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//E</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">6e6</span>+<span class="number">10</span>;</span><br><span class="line">ll sum[<span class="number">100</span>][<span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> nxt[maxn][<span class="number">2</span>];</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;idx[maxn*<span class="number">2</span>];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">memset</span>(nxt,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(nxt));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">29</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">			<span class="keyword">bool</span> c = ((<span class="number">1ll</span>&lt;&lt;i)&amp;x);</span><br><span class="line">			<span class="keyword">if</span>(!nxt[u][c])nxt[u][c] = size++;</span><br><span class="line">			u = nxt[u][c];</span><br><span class="line">			idx[u].<span class="built_in">push_back</span>(pos);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> l = nxt[pos][<span class="number">0</span>],r = nxt[pos][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(l)<span class="built_in">DFS</span>(l,dep<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">if</span>(r)<span class="built_in">DFS</span>(r,dep<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">if</span>(!l <span class="keyword">or</span> !r)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">int</span> ptr = <span class="number">0</span>,inv = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x:idx[l])&#123;</span><br><span class="line">			<span class="keyword">while</span>(ptr &lt; idx[r].<span class="built_in">size</span>() <span class="keyword">and</span> idx[r][ptr] &lt; x)ptr++;</span><br><span class="line">			inv += ptr;</span><br><span class="line">		&#125;</span><br><span class="line">		sum[dep][<span class="number">0</span>] += inv;</span><br><span class="line">		sum[dep][<span class="number">1</span>] += (ll)idx[l].<span class="built_in">size</span>()*idx[r].<span class="built_in">size</span>() - inv;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;trie;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	trie.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		trie.<span class="built_in">insert</span>(x,i);</span><br><span class="line">	&#125;</span><br><span class="line">	trie.<span class="built_in">DFS</span>(<span class="number">0</span>,<span class="number">29</span>);</span><br><span class="line">	ll X = <span class="number">0</span>,inv = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">29</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">		inv += <span class="built_in">min</span>(sum[i][<span class="number">0</span>],sum[i][<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">if</span>(sum[i][<span class="number">1</span>] &lt; sum[i][<span class="number">0</span>])X += (<span class="number">1ll</span> &lt;&lt; i);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; inv &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; X;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]CF1355C-Count Triangles</title>
    <url>/2020/05/16/solution-CF1355C/</url>
    <content><![CDATA[<p>写这个不是因为这题多难或者有意思,纯粹是纪念一下自己有多傻逼=-=</p>
<h1 id="题意">题意</h1>
<p>给出<span class="math inline">\(A,B,C,D\)</span>求满足<span class="math inline">\(A \leq x \leq B \leq y \leq C \leq z \leq D\)</span>,的<span class="math inline">\(x,y,z\)</span>能组成的三角形个数</p>
<p><span class="math inline">\(1 \leq A \leq B \leq C \leq D \leq 5e5\)</span></p>
<h1 id="思路">思路</h1>
<p>很显然只要满足<span class="math inline">\(z &lt; x+y\)</span>且<span class="math inline">\(C \leq z \leq D\)</span>就行=-=</p>
<p>那么枚举<span class="math inline">\(x\)</span>,把<span class="math inline">\([x+B,x+C]\)</span>加1(用前缀和维护一下就行),再枚举<span class="math inline">\(z\)</span>统计满足<span class="math inline">\(z &lt; x+y\)</span>的个数就行=-=</p>
<p>复杂度<span class="math inline">\(O(C)\)</span></p>
<p><strong>就这玩意都做不出来,我是傻逼</strong></p>
<h1 id="代码">代码</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ll a,b,c,d,ans = <span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = a;i &lt;= b;i++)pre[i+b]++,pre[i+c+<span class="number">1</span>]--;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; maxn;i++)pre[i] += pre[i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; maxn;i++)ans += pre[i]*<span class="built_in">max</span>(<span class="number">0ll</span>,<span class="built_in">min</span>(d,(ll)(i<span class="number">-1</span>)) - c + <span class="number">1</span>); </span><br><span class="line">	cout &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>题解</tag>
        <tag>我是sb</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]CF1433G-Reducing Delivery Cost</title>
    <url>/2020/10/22/solution-CF1433G/</url>
    <content><![CDATA[<h1 id="cf1433greducing-delivery-cost">[CF1433G]Reducing Delivery Cost</h1>
<h2 id="题意">题意</h2>
<p>给出一张无向带权图<span class="math inline">\(G\)</span>和<span class="math inline">\(k\)</span>个点对, 你可以将最多一条边的权值变为0, 求<span class="math inline">\(k\)</span>个点对之间最短路之和的最小值</p>
<p>图中存在重边和自环.</p>
<p><span class="math inline">\(1 \leq n \leq 1000, 1 \leq m \leq \frac{n(n-1)}{2},1 \leq k \leq 1000\)</span></p>
<h2 id="题解">题解</h2>
<p>套路题, 一开始想麻烦了.</p>
<p>设<span class="math inline">\(D[i][j]\)</span>为<span class="math inline">\((i,j)\)</span>间的最短路. 对于每条边<span class="math inline">\((f,t)\)</span>有两种情况:</p>
<ol type="1">
<li>无论该边权值是否为零, 都不在点对<span class="math inline">\((x,y)\)</span>的最短路上. 删掉该边后答案仍为<span class="math inline">\(D[x][y]\)</span>.</li>
<li>删掉该边前/后该边位于点对<span class="math inline">\((x,y)\)</span>的最短路上. 删掉该边后答案为<span class="math inline">\(\min(D[x][f]+D[t][y],D[x][t]+D[f][y])\)</span></li>
</ol>
<p>我们跑<span class="math inline">\(n\)</span>遍Dijkstra预处理出任意点对最短路,再对于每条边枚举<span class="math inline">\(k\)</span>个点对即可求出答案.总复杂度<span class="math inline">\(O(nm\log n + km)\)</span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#define endl &#x27;\n&#x27;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int INF = 1e9+10;</span><br><span class="line">const int maxn = 1e3+10;</span><br><span class="line">const int maxm = maxn*maxn;</span><br><span class="line">typedef pair&lt;int,int&gt; Node;</span><br><span class="line">int head[maxn],vis[maxn],dis[maxn];</span><br><span class="line">int D[maxn][maxn]; </span><br><span class="line">int viscnt[maxm];</span><br><span class="line">struct Edge&#123;</span><br><span class="line">	int f,t,w,next;</span><br><span class="line">	Edge(int f = 0,int t = 0,int w = 0,int next = 0):f(f),t(t),w(w),next(next)&#123;&#125;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line">int cnt = 0,n,m;</span><br><span class="line">void addedge(int f,int t,int w)&#123;</span><br><span class="line">	edge[cnt] = Edge(f,t,w,head[f]);</span><br><span class="line">	head[f] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void dijkstra(int s)&#123;</span><br><span class="line">	for(int i = 0;i &lt;= n;i++)&#123;</span><br><span class="line">		dis[i] = INF;</span><br><span class="line">		vis[i] = 0;</span><br><span class="line">	&#125;</span><br><span class="line">	dis[s] = 0;</span><br><span class="line">	priority_queue&lt;Node,vector&lt;Node&gt;,greater&lt;Node&gt; &gt;pq;</span><br><span class="line">	pq.push(&#123;dis[s],s&#125;);</span><br><span class="line">	while(!pq.empty())&#123;</span><br><span class="line">		int u = pq.top().second;</span><br><span class="line">		pq.pop();</span><br><span class="line">		if(vis[u])continue;</span><br><span class="line">		vis[u] = 1;</span><br><span class="line">		for(int i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">			int v = edge[i].t,w = edge[i].w;</span><br><span class="line">			if(dis[v] &gt; dis[u] + w)&#123;</span><br><span class="line">				dis[v] = dis[u] + w;</span><br><span class="line">				if(!vis[v])&#123;</span><br><span class="line">					pq.push(&#123;dis[v],v&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">	ios::sync_with_stdio(0);</span><br><span class="line">	cin.tie(0);</span><br><span class="line">	memset(head,-1,sizeof(head));</span><br><span class="line">	memset(D,0x3f3f3f3f,sizeof(D));</span><br><span class="line">	int k;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">	for(int i = 1;i &lt;= m;i++)&#123;</span><br><span class="line">		int f,t,w;</span><br><span class="line">		cin &gt;&gt; f &gt;&gt; t &gt;&gt; w;</span><br><span class="line">		addedge(f,t,w);</span><br><span class="line">		addedge(t,f,w);</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i = 1;i &lt;= n;i++)&#123;</span><br><span class="line">		dijkstra(i);</span><br><span class="line">		for(int j = 1;j &lt;= n;j++)D[i][j] = D[j][i] = dis[j];</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;Node&gt;path; </span><br><span class="line">	for(int i = 1;i &lt;= k;i++)&#123;</span><br><span class="line">		int x,y;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		path.push_back(&#123;x,y&#125;);</span><br><span class="line">	&#125; </span><br><span class="line">	ll ans = LLONG_MAX;</span><br><span class="line">	for(int i = 0;i &lt; cnt;i++)&#123;</span><br><span class="line">		int f = edge[i].f,t = edge[i].t;</span><br><span class="line">		ll tans = 0;</span><br><span class="line">		for(int j = 0;j &lt; k;j++)&#123;</span><br><span class="line">			int x = path[j].first,y = path[j].second;</span><br><span class="line">			tans += min(&#123;D[x][y],D[x][f]+D[t][y],D[x][t]+D[f][y]&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		ans = min(ans,tans);	</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]-CF1454E</title>
    <url>/2020/11/25/solution-CF1454E/</url>
    <content><![CDATA[<h2 id="题意">题意</h2>
<p>给出一棵基环树, 求树上简单路径条数</p>
<p><span class="math inline">\(3 \leq n \leq 2 \cdot 10^5\)</span></p>
<h2 id="题解">题解</h2>
<p>将基环树看作一个环, 环上连接着一些树, 设第<span class="math inline">\(i\)</span>棵树有<span class="math inline">\(cnt_i\)</span>个节点.</p>
<p>路径分为两种情况:</p>
<ol type="1">
<li>在树内. 有<span class="math inline">\(\frac{cnt_i \cdot (cnt_i - 1)}{2}\)</span>条</li>
<li>由树内到树外, 有<span class="math inline">\(cnt_i \cdot (n - cnt_i)\)</span>条(这里只计算了一半, 但当计算完全部子树后答案是完整的)</li>
</ol>
<p>通过一遍<span class="math inline">\(DFS\)</span>求出环, 再通过一次<span class="math inline">\(DFS\)</span>求出每个子树大小, 答案为 <span class="math display">\[
\sum_{i \in subtree}\frac{cnt_i\cdot(cnt_i-1)}{2} + cnt_{i}\cdot(n - cnt_i)
\]</span> 复杂度<span class="math inline">\(O(n)\)</span></p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//E</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = maxn*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn],pa[maxn];</span><br><span class="line"><span class="keyword">bool</span> loop[maxn],vis[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> f,t,next;</span><br><span class="line">	<span class="built_in">Edge</span>(<span class="keyword">int</span> f = <span class="number">0</span>,<span class="keyword">int</span> t = <span class="number">0</span>,<span class="keyword">int</span> next = <span class="number">0</span>):<span class="built_in">f</span>(f),<span class="built_in">t</span>(t),<span class="built_in">next</span>(next)&#123;&#125;	</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="keyword">int</span> tcnt,cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	edge[cnt] = <span class="built_in">Edge</span>(f,t,head[f]);</span><br><span class="line">	head[f] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> ok = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ok)<span class="keyword">return</span>;</span><br><span class="line">	vis[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">		<span class="keyword">if</span>(v == fa <span class="keyword">or</span> ok)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(vis[v])&#123;</span><br><span class="line">			<span class="keyword">while</span>(u != v)&#123;</span><br><span class="line">				loop[u] = <span class="number">1</span>;</span><br><span class="line">				u = pa[u];</span><br><span class="line">				ok = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			loop[v] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pa[v] = u;</span><br><span class="line">		<span class="built_in">pre</span>(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	tcnt++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">		<span class="keyword">if</span>(v == fa <span class="keyword">or</span> loop[v])<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">DFS</span>(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		tcnt = <span class="number">0</span>;</span><br><span class="line">		ok = <span class="number">0</span>;</span><br><span class="line">		cnt = <span class="number">0</span>;</span><br><span class="line">		vector&lt;ll&gt;res;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)head[i] = <span class="number">-1</span>,loop[i] = <span class="number">0</span>,pa[i] = vis[i] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> f,t;</span><br><span class="line">			cin &gt;&gt; f &gt;&gt; t;</span><br><span class="line">			<span class="built_in">addedge</span>(f,t);</span><br><span class="line">			<span class="built_in">addedge</span>(t,f);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">pre</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(loop[i])&#123;</span><br><span class="line">				tcnt = <span class="number">0</span>;</span><br><span class="line">				<span class="built_in">DFS</span>(i,<span class="number">-1</span>);</span><br><span class="line">				res.<span class="built_in">push_back</span>(tcnt);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ll ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(ll x:res)ans += x*(x<span class="number">-1</span>)/<span class="number">2</span> + x*(n-x);</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>基环树</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]CF1473E-Minimum Path</title>
    <url>/2021/01/16/solution-CF1473E/</url>
    <content><![CDATA[<h2 id="题意">题意</h2>
<p>给出一个<span class="math inline">\(n\)</span>个点, <span class="math inline">\(m\)</span>条边, 不含自环, 重边的带权无向图, 定义一条路径<span class="math inline">\(&lt;v_1,v_2,...v_k&gt;\)</span>的权值为 <span class="math display">\[
\sum_{i = 1}^k w_{v_i} - \max_{i = 1}^k\{w_{v_i}\} + \min_{i = 1}^k\{w_{v_i}\}
\]</span> 求从点1到其他所有点路径的最小权值</p>
<p><span class="math inline">\(2 \leq n \leq 2e5,1 \leq m \leq 2e5,1 \leq w \leq 1e9\)</span></p>
<h2 id="思路">思路</h2>
<p>原问题要求在权值中减去边权最大值, 加上边权最小值. 我们考虑<strong>将问题约束放宽</strong>: 可以减去和加上任意一条边的边权.</p>
<p>可以发现, 在最短路径中, 减去的必定是边权最大值, 而加上的必定是边权最小值(可用反证法证明), 即放宽后的问题与原问题等价.</p>
<p>求解该问题可以用分层图最短路. 由于必须加上和减去一条边的边权, 故求解最短路径时可能有以下三种情况:</p>
<ol type="1">
<li>先减去边X(图A), 再加上边Y(图B)</li>
<li>先加上边X(图C), 再减去边Y(图D)</li>
<li>加上和减去同一条边X (图S, 相当于原图最短路)</li>
</ol>
<figure>
<img src="https://i.loli.net/2021/01/16/tdNH1ugTGCOhiA2.png" alt="" /><figcaption>pic1.png</figcaption>
</figure>
<p>建图时每层原图为无向边，连接两层图之间的边为有向边, 具体细节见代码. 从1开始跑Dijkstra, 图S, B , D的最小值即为答案.</p>
<p>时间复杂度: <span class="math inline">\(O(m\log n)\)</span></p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll,<span class="keyword">int</span>&gt; node;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = N*<span class="number">6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = maxn*<span class="number">6</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e17</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn],cnt;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line">ll dis[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> f,t;</span><br><span class="line">	ll w;</span><br><span class="line">	<span class="keyword">int</span> next;</span><br><span class="line">	<span class="built_in">Edge</span>(<span class="keyword">int</span> f = <span class="number">0</span>,<span class="keyword">int</span> t = <span class="number">0</span>,ll w = <span class="number">0</span>,<span class="keyword">int</span> next = <span class="number">0</span>):<span class="built_in">f</span>(f),<span class="built_in">t</span>(t),<span class="built_in">w</span>(w),<span class="built_in">next</span>(next)&#123;&#125;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t,ll w)</span></span>&#123;</span><br><span class="line">	edge[cnt] = <span class="built_in">Edge</span>(f,t,w,head[f]);</span><br><span class="line">	head[f] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; maxn;i++)dis[i] = INF;</span><br><span class="line">	dis[s] = <span class="number">0</span>;</span><br><span class="line">	priority_queue&lt;node,vector&lt;node&gt;,greater&lt;node&gt; &gt;pq;</span><br><span class="line">	pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>,s&#125;);</span><br><span class="line">	<span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="keyword">int</span> u = pq.<span class="built_in">top</span>().second;</span><br><span class="line">		pq.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(vis[u])<span class="keyword">continue</span>;</span><br><span class="line">		vis[u] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">			ll w = edge[i].w;</span><br><span class="line">			<span class="keyword">if</span>(dis[v] &gt; dis[u] + w)&#123;</span><br><span class="line">				dis[v] = dis[u] + w;</span><br><span class="line">				<span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">					pq.<span class="built_in">push</span>(&#123;dis[v],v&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">	<span class="built_in">addedge</span>(f,t,w);</span><br><span class="line">	<span class="built_in">addedge</span>(t,f,w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> f,t,w;</span><br><span class="line">		cin &gt;&gt; f &gt;&gt; t &gt;&gt; w;</span><br><span class="line">		<span class="comment">//+0:ori</span></span><br><span class="line">		<span class="comment">//+N:sub first</span></span><br><span class="line">		<span class="comment">//+2*N:sub -&gt; add</span></span><br><span class="line">		<span class="comment">//+3*N:add first</span></span><br><span class="line">		<span class="comment">//+4*N:add -&gt; sub</span></span><br><span class="line">		<span class="built_in">add</span>(f,t,w);</span><br><span class="line">		<span class="built_in">add</span>(f+N,t+N,w);</span><br><span class="line">		<span class="built_in">add</span>(f+<span class="number">2</span>*N,t+<span class="number">2</span>*N,w);</span><br><span class="line">		<span class="built_in">add</span>(f+<span class="number">3</span>*N,t+<span class="number">3</span>*N,w);</span><br><span class="line">		<span class="built_in">add</span>(f+<span class="number">4</span>*N,t+<span class="number">4</span>*N,w);</span><br><span class="line">		<span class="built_in">addedge</span>(f,t+N,<span class="number">0</span>);<span class="comment">//sub</span></span><br><span class="line">		<span class="built_in">addedge</span>(t,f+N,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">addedge</span>(f+N,t+<span class="number">2</span>*N,<span class="number">2</span>*w);<span class="comment">//add</span></span><br><span class="line">		<span class="built_in">addedge</span>(t+N,f+<span class="number">2</span>*N,<span class="number">2</span>*w);</span><br><span class="line">		<span class="built_in">addedge</span>(f,t+<span class="number">3</span>*N,<span class="number">2</span>*w);<span class="comment">//add</span></span><br><span class="line">		<span class="built_in">addedge</span>(t,f+<span class="number">3</span>*N,<span class="number">2</span>*w);</span><br><span class="line">		<span class="built_in">addedge</span>(f+<span class="number">3</span>*N,t+<span class="number">4</span>*N,<span class="number">0</span>);<span class="comment">//sub</span></span><br><span class="line">		<span class="built_in">addedge</span>(t+<span class="number">3</span>*N,f+<span class="number">4</span>*N,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dijkstra</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">min</span>(&#123;dis[i+<span class="number">2</span>*N],dis[i+<span class="number">4</span>*N],dis[i]&#125;) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解] CF906D-Power Tower</title>
    <url>/2020/05/13/solution-CF906D/</url>
    <content><![CDATA[<h1 id="题意">题意</h1>
<p>给定序列<span class="math inline">\(w_1,w_2,...,w_n\)</span>和<span class="math inline">\(q\)</span>组询问,对于每组询问,求<img src="../images/CF906D_1.png" alt="img1" /></p>
<p>当然,需要对这个值膜<span class="math inline">\(m\)</span></p>
<p>(hexo渲染多重幂有问题,只好放原题图片了)</p>
<p><span class="math inline">\(1 \leq n \leq 1e5\)</span>, <span class="math inline">\(1 \leq m \leq 1e9\)</span>, <span class="math inline">\(1 \leq q \leq 1e5\)</span></p>
<h1 id="思路">思路</h1>
<p>考虑扩展欧拉定理:</p>
<p><span class="math display">\[
a^b = \left\{
\begin{array}{lcl}
a^b &amp;&amp; {b &lt; φ(p)} \\
a^{b \bmod φ(p) + φ(p) } &amp;&amp; {b \geq φ(p)}\\
\end{array}
\right.
\]</span></p>
<p>由于<span class="math inline">\(p \geq 2\)</span>时<span class="math inline">\(φ(p)\)</span>为偶数,故<span class="math inline">\(p = φ(p)\)</span>的下降速度是log级别的,换句话说经过最多<span class="math inline">\(log(p)\)</span>次迭代之后<span class="math inline">\(p\)</span>便会变为1.由于<span class="math inline">\(x \bmod 1 == 0\)</span>,我们在<span class="math inline">\(l == r\)</span>或者<span class="math inline">\(p == 1\)</span>时便可跳出递归,单组询问的复杂度为<span class="math inline">\(O(logp)\)</span>,可以接受</p>
<p>在具体实现时,应预处理出<span class="math inline">\(p,φ(p),φ(φ(p)),...,1\)</span>来减少时间开销,同时修改快速幂来适应扩欧定理(upd函数),细节见代码</p>
<h1 id="代码">代码</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CF906D </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line">ll raw[maxn],n,mod;</span><br><span class="line">map&lt;ll,ll&gt;vis;</span><br><span class="line"><span class="function">ll <span class="title">phi</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m = (ll)<span class="built_in">sqrt</span>(x+<span class="number">0.5</span>);</span><br><span class="line">	ll tans = x;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= m;i++)<span class="keyword">if</span>(!(x%i))&#123;</span><br><span class="line">		tans = tans/i*(i<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">while</span>(!(x%i))x /= i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x &gt; <span class="number">1</span>)tans = tans / x * (x<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> tans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">upd</span><span class="params">(ll x,ll p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x&lt;p?x:x%p+p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">Pow</span><span class="params">(ll x,ll d,ll p)</span></span>&#123;</span><br><span class="line">	ll tans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(d == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	ll a = <span class="built_in">Pow</span>(x,d/<span class="number">2</span>,p);</span><br><span class="line">	tans = <span class="built_in">upd</span>(a*a,p);</span><br><span class="line">	<span class="keyword">if</span>(d%<span class="number">2</span>)tans = <span class="built_in">upd</span>(tans*x,p); </span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">upd</span>(tans,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">cal</span><span class="params">(ll l,ll r,ll p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l == r <span class="keyword">or</span> p == <span class="number">1</span>)<span class="keyword">return</span> <span class="built_in">upd</span>(raw[l],p);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">Pow</span>(raw[l],<span class="built_in">cal</span>(l+<span class="number">1</span>,r,vis[p]),p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; mod;</span><br><span class="line">	ll qwq = mod;</span><br><span class="line">	<span class="keyword">while</span>(qwq != <span class="number">1</span>)&#123;</span><br><span class="line">		vis[qwq] = <span class="built_in">phi</span>(qwq);</span><br><span class="line">		qwq = vis[qwq];</span><br><span class="line">	&#125;</span><br><span class="line">	vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)cin &gt;&gt; raw[i];</span><br><span class="line">	<span class="keyword">int</span> q;</span><br><span class="line">	cin &gt;&gt; q;</span><br><span class="line">	<span class="keyword">while</span>(q--)&#123;</span><br><span class="line">		<span class="keyword">int</span> l,r;</span><br><span class="line">		cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">cal</span>(l,r,mod)%mod &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
f(n) = O(g(n)) 
\\ \Rightarrow f(n) \leq c_f \cdot g(n) \\ 
\Rightarrow \frac{1}{f(n)} \geq \frac{1}{c_f\cdot g(n)}\\
\Rightarrow \frac{1}{g(n)} \leq c_f\cdot \frac{1}{f(n)} 对于n &gt;= n_f\\
故有 \frac{1}{g(n)} = O(\frac{1}{f(n)})
\]</span></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]CF1451E2-Bitwise Queries (Hard Version)</title>
    <url>/2020/11/26/solution-CF1451E2/</url>
    <content><![CDATA[<p>小清新构造题</p>
<h2 id="题意">题意</h2>
<p>交互题.</p>
<p>有一个长度为<span class="math inline">\(n\)</span>的数列<span class="math inline">\(\{a_i\}\)</span>, 满足<span class="math inline">\(a_i \in [0,n-1], n \in [4,2^{16}], n = 2^k\)</span></p>
<p>你可以进行最多<span class="math inline">\(n+1\)</span>次询问, 询问分三种:</p>
<p><code>AND i j</code> 返回<span class="math inline">\(a_i \&amp; a_j\)</span>的值</p>
<p><code>OR i j</code> 返回<span class="math inline">\(a_i | a_j\)</span>的值</p>
<p><code>XOR i j</code> 返回<span class="math inline">\(a_i \oplus a_j\)</span>的值</p>
<p>均需满足<span class="math inline">\(1 \leq i,j \leq n\)</span>且<span class="math inline">\(i \ne j\)</span></p>
<p>当确定答案后, 你需要输出<code>!</code>然后在同一行内输出这个数组.</p>
<h2 id="题解">题解</h2>
<p>首先一个显而易见的结论: 询问<span class="math inline">\(a_1\)</span>与<span class="math inline">\(a_2...a_n\)</span>的异或(共<span class="math inline">\(n-1\)</span>次询问), 再在两次询问内求出<span class="math inline">\(a_1\)</span>的值就能还原整个数组. 问题转化为如何求出<span class="math inline">\(a_1\)</span>,</p>
<p>因为数列长度为<span class="math inline">\(n\)</span>值域为<span class="math inline">\([0,n-1]\)</span>, 由鸽巢原理可得:</p>
<ol type="1">
<li><p>数列中至少有两个数字相同</p>
<p>分为两种情况:</p>
<ol type="1">
<li><p><span class="math inline">\(a_1\)</span>与其他至少一个数字相同.</p>
<p>表现为至少一个异或询问<span class="math inline">\(a_1 \oplus a_i\)</span>的答案为<span class="math inline">\(0\)</span>. 一次<code>AND 1 i</code>询问即可求出<span class="math inline">\(a_1\)</span>的值.</p></li>
<li><p><span class="math inline">\(a_i\)</span>与<span class="math inline">\(a_j\)</span>相同(<span class="math inline">\(i,j \ne 1\)</span>).</p>
<p>此时至少两个异或询问的答案相等(<span class="math inline">\(a_1 \oplus a_i = a_1 \oplus a_j\)</span>), 即<span class="math inline">\(a_i = a_j\)</span>. 通过一次<code>AND i j</code>可求出<span class="math inline">\(a_i\)</span>的值, 再由<span class="math inline">\(a_1 \oplus a_i \oplus a_i = a_1\)</span>求出<span class="math inline">\(a_1\)</span></p></li>
</ol></li>
<li><p>数列中全部数字均不相同.</p>
<p>由于<span class="math inline">\(n = 2^k\)</span>且<span class="math inline">\(n \ge 4\)</span>, <span class="math inline">\(k\)</span>位二进制的每一种情况均会出现, 故必存在<span class="math inline">\(a_1 \oplus a_i = 1\)</span>. 显然<span class="math inline">\(a_1\)</span>与<span class="math inline">\(a_i\)</span>只有最后一位不同. 这时一次<code>AND 1 i</code>可获得<span class="math inline">\(a_1\)</span>除了最后一位外的信息. 同理存在<span class="math inline">\(a_1 \oplus a_j = 2\)</span>, <code>AND 1 j</code>可获得<span class="math inline">\(a_1\)</span>最后一位的信息. 两者综合起来即可求出<span class="math inline">\(a_1\)</span></p></li>
</ol>
<p>以上无论何种情况, 询问次数都不超过<span class="math inline">\(n+1\)</span></p>
<p>时间复杂度<span class="math inline">\(O(n\log n)\)</span> (因为有一次不必要的排序来去重)</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//E</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="comment">// #define endl &#x27;\n&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> Xor[maxn],ans[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> w,idx;</span><br><span class="line">	<span class="built_in">Node</span>(<span class="keyword">int</span> w = <span class="number">0</span>,<span class="keyword">int</span> idx = <span class="number">0</span>):<span class="built_in">w</span>(w),<span class="built_in">idx</span>(idx)&#123;&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp; x) <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> w &lt; x.w;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;node[maxn];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;XOR 1 &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">int</span> x;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		Xor[i] = x;</span><br><span class="line">		node[i] = <span class="built_in">Node</span>(x,i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(node+<span class="number">2</span>,node+n+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt;= n;i++)<span class="keyword">if</span>(node[i].w == node[i<span class="number">-1</span>].w)idx = i;</span><br><span class="line">	<span class="keyword">if</span>(!node[<span class="number">2</span>].w)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;AND 1 &quot;</span> &lt;&lt; node[<span class="number">2</span>].idx &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">int</span> x;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		ans[<span class="number">1</span>] = x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(idx)&#123;</span><br><span class="line">		<span class="keyword">int</span> l = node[idx].idx,r = node[idx<span class="number">-1</span>].idx;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;AND &quot;</span> &lt;&lt; l &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">int</span> x;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		ans[<span class="number">1</span>] = Xor[l]^x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> bit_0 = <span class="number">0</span>,bit_1 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(Xor[i] == <span class="number">1</span>)&#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;AND 1 &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">				<span class="keyword">int</span> x;</span><br><span class="line">				cin &gt;&gt; x;</span><br><span class="line">				bit_0 = x;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(Xor[i] == <span class="number">2</span>)&#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;AND 1 &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">				<span class="keyword">int</span> x;</span><br><span class="line">				cin &gt;&gt; x;</span><br><span class="line">				bit_1 = x;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(bit_0 &amp; <span class="number">1</span>)bit_0--;</span><br><span class="line">		<span class="keyword">if</span>(bit_1 &amp; <span class="number">1</span>)bit_0++;</span><br><span class="line">		ans[<span class="number">1</span>] = bit_0;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)ans[i] = Xor[i]^ans[<span class="number">1</span>];</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;! &quot;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>构造</tag>
        <tag>交互</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]CF958F3 Lightsabers (hard)</title>
    <url>/2021/04/04/solution-CF958F3/</url>
    <content><![CDATA[<h2 id="题意">题意</h2>
<p>给出<span class="math inline">\(m\)</span>个集合, 第<span class="math inline">\(i\)</span>个集合有<span class="math inline">\(c_i\)</span>种颜色为<span class="math inline">\(i\)</span>的小球, 保证<span class="math inline">\(\sum_{i = 1}^m c_i = n\)</span>. 现从这些集合中取出<span class="math inline">\(k\)</span>个小球, 问这些小球构成的集合有多少种. 答案模<span class="math inline">\(1009\)</span>.</p>
<p><span class="math inline">\(1 \leq m,k \leq n \leq 2\cdot 10^5\)</span></p>
<h2 id="题解">题解</h2>
<p>普通型生成函数裸题.</p>
<p>设<span class="math inline">\(G(x) = \prod_{i = 1}^m(\sum_{j = 0}^{c_i}x^j)\)</span></p>
<p>那么<span class="math inline">\(G(x)[k]\)</span>即为答案. 问题转换为<span class="math inline">\(m\)</span>个多项式相乘. 使用分治法可在<span class="math inline">\(O(n\log^2n)\)</span>时间内用FFT求解.</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">1009</span>;</span><br><span class="line"><span class="keyword">int</span> raw[maxn],cnt[maxn];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="keyword">int</span>&gt; Poly;</span><br><span class="line"><span class="keyword">const</span> ld PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">int</span> rev[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Comp</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    <span class="built_in">Comp</span> (<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>):<span class="built_in">x</span>(x),<span class="built_in">y</span>(y)&#123;&#125;</span><br><span class="line">    Comp <span class="keyword">operator</span> * (Comp B)&#123;</span><br><span class="line">   		<span class="keyword">return</span> <span class="built_in">Comp</span>(x*B.x - y*B.y,x*B.y + y*B.x);</span><br><span class="line">	&#125;</span><br><span class="line">	Comp <span class="keyword">operator</span> + (Comp B)&#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="built_in">Comp</span>(x + B.x,y + B.y);</span><br><span class="line">	&#125;</span><br><span class="line">	Comp <span class="keyword">operator</span> - (Comp B)&#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="built_in">Comp</span>(x - B.x,y - B.y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Comp F1[maxn],F2[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Comp * A,<span class="keyword">int</span> siz,<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = siz;</span><br><span class="line">	<span class="keyword">int</span> S = <span class="built_in">log2</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)rev[i] = (rev[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (S - <span class="number">1</span>));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)<span class="keyword">if</span>(i &lt; rev[i])<span class="built_in">swap</span>(A[i],A[rev[i]]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i *= <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="function">Comp <span class="title">Wn</span><span class="params">(cos(PI/i),type*sin(PI/i))</span></span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j += i*<span class="number">2</span>)&#123;</span><br><span class="line">			<span class="function">Comp <span class="title">W</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; i;k++)&#123;</span><br><span class="line">				Comp facx = A[j+k],facy = W*A[j+k+i];</span><br><span class="line">				A[j+k] = facx + facy;</span><br><span class="line">				A[j+k+i] = facx - facy;</span><br><span class="line">				W = W*Wn;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>(type == <span class="number">-1</span>)<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)A[i].x = ((A[i].x/n + <span class="number">0.5</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Poly <span class="title">mul</span><span class="params">(Poly A,Poly B)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = A.<span class="built_in">size</span>(),m = B.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">int</span> siz = n + m - <span class="number">1</span>;</span><br><span class="line">	<span class="function">Poly <span class="title">C</span><span class="params">(siz)</span></span>;</span><br><span class="line">	<span class="keyword">if</span>(siz &lt; <span class="number">64</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++)C[i+j] = (C[i+j] + <span class="number">1LL</span>*A[i]*B[j])%p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> C;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> fsiz = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(fsiz &lt;= siz)fsiz *= <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; fsiz;i++)F1[i] = F2[i] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)F1[i] = A[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)F2[i] = B[i];</span><br><span class="line">	<span class="built_in">FFT</span>(F1,fsiz,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">FFT</span>(F2,fsiz,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; fsiz;i++)F1[i] = F1[i]*F2[i];</span><br><span class="line">	<span class="built_in">FFT</span>(F1,fsiz,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; siz;i++)&#123;</span><br><span class="line">		C[i] = ((ll)F1[i].x)%p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Poly <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Poly</span>(cnt[l]+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> m = (l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">mul</span>(<span class="built_in">solve</span>(l,m),<span class="built_in">solve</span>(m+<span class="number">1</span>,r));</span><br><span class="line">&#125;</span><br><span class="line">Poly ans;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n,m,k;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		cnt[x]++;</span><br><span class="line">	&#125;</span><br><span class="line">	Poly ans = <span class="built_in">solve</span>(<span class="number">1</span>,m);</span><br><span class="line">	cout &lt;&lt; ans[k] &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>FFT</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>solution-HDU4746</title>
    <url>/2020/06/22/solution-HDU4746/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>[题解]Gym102798-C Rencontre (CCPC2020威海站)</title>
    <url>/2020/11/18/solution-Gym102798-C/</url>
    <content><![CDATA[<h1 id="题意">题意</h1>
<p>给出一棵<span class="math inline">\(n\)</span>个点的带权无根树, 给出三个点的集合. 在每个集合任取一点, 在树上寻找新的一个点使得该点到三点的路径和最短. 求路径和期望</p>
<p>$ 1 n ^5,1 w $</p>
<h1 id="题解">题解</h1>
<p>首先考虑这样一个问题: 给出树上三点<span class="math inline">\(a,b,c\)</span>, 求这三点汇聚到一点<span class="math inline">\(v\)</span>的最短路径(设为<span class="math inline">\(f(a,b,c)\)</span>) <span class="math display">\[
f(a,b,c) = \min\{v\in V |dis(a,v) + dis(b,v) + dis(c,v)\}
\]</span></p>
<p><img src="C:\Users\frien\AppData\Roaming\Typora\typora-user-images\image-20201119121551047.png" alt="image-20201119121551047" style="zoom: 33%;" /></p>
<p>如上图所示, <span class="math inline">\(a,b,c\)</span>为<span class="math inline">\(3,4,5\)</span>. 观察易得汇合点<span class="math inline">\(v\)</span>为<span class="math inline">\(2\)</span>, 即<span class="math inline">\(a,b,c\)</span>的LCA中深度最深的那个. 此时<span class="math inline">\(a,b\space a,c \space b,c\)</span>间的每条边都恰好经过一次, 即: <span class="math display">\[
f(a,b,c) = \frac{1}{2}(dis(a,b) + dis(a,c) + dis(b,c))
\]</span> 由期望的性质<span class="math inline">\(E(X + Y) = E(X) + E(Y)\)</span>, 我们可以分别计算两个集合<span class="math inline">\(j,k\)</span>中各点的距离和. 通过一遍DFS来计算子树<span class="math inline">\(u\)</span>中属于集合<span class="math inline">\(i\)</span>的节点个数<span class="math inline">\(num[u][i]\)</span>, 再对每条边分别统计贡献<span class="math inline">\(g\)</span>. 设<span class="math inline">\(cnt_i\)</span>为集合<span class="math inline">\(i\)</span>的大小. <span class="math display">\[
g(e_i,j,k) = ((cnt_i - num[u][j])*num[u][k] + (cnt_k - num[u][k])*cnt_j)*e_i.w
\]</span> 答案即为 <span class="math display">\[
\sum_{j = 1}^3 \sum_{k = j+1}^3\frac{\sum_{i = 1}^{n-1}g(e_i,j,k)}{2\cdot cnt_j \cdot cnt_k}
\]</span></p>
<h1 id="代码">代码</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> ld;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn],cnt,use[maxn][<span class="number">4</span>],num[maxn][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll sum[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> f,t,w,next;</span><br><span class="line">	<span class="built_in">Edge</span>(<span class="keyword">int</span> f = <span class="number">0</span>,<span class="keyword">int</span> t = <span class="number">0</span>,<span class="keyword">int</span> w = <span class="number">0</span>,<span class="keyword">int</span> next = <span class="number">0</span>):<span class="built_in">f</span>(f),<span class="built_in">t</span>(t),<span class="built_in">w</span>(w),<span class="built_in">next</span>(next)&#123;&#125;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">	edge[cnt] = <span class="built_in">Edge</span>(f,t,w,head[f]);</span><br><span class="line">	head[f] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">3</span>;i++)<span class="keyword">if</span>(use[u][i])num[u][i] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].t,w = edge[i].w;</span><br><span class="line">		<span class="keyword">if</span>(v == fa)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">DFS</span>(v,u);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">3</span>;j++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k = j+<span class="number">1</span>;k &lt;= <span class="number">3</span>;k++)&#123;</span><br><span class="line">				sum[j][k] += (num[<span class="number">0</span>][j] - num[v][j])*num[v][k]*w;</span><br><span class="line">				sum[j][k] += (num[<span class="number">0</span>][k] - num[v][k])*num[v][j]*w;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">3</span>;j++)num[u][j] += num[v][j];</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout.<span class="built_in">setf</span>(ios::fixed,ios::floatfield);</span><br><span class="line">	cout.<span class="built_in">precision</span>(<span class="number">10</span>);</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> f,t,w;</span><br><span class="line">		cin &gt;&gt; f &gt;&gt; t &gt;&gt; w;</span><br><span class="line">		<span class="built_in">addedge</span>(f,t,w);</span><br><span class="line">		<span class="built_in">addedge</span>(t,f,w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">3</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> m;</span><br><span class="line">		cin &gt;&gt; m;</span><br><span class="line">		num[<span class="number">0</span>][i] = m;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++)&#123;</span><br><span class="line">			<span class="keyword">int</span> x;</span><br><span class="line">			cin &gt;&gt; x;</span><br><span class="line">			use[x][i] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">DFS</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">	ld ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">3</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt;= <span class="number">3</span>;j++)ans += (<span class="keyword">double</span>)sum[i][j]/num[<span class="number">0</span>][i]/num[<span class="number">0</span>][j]/<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>PS: 当时我这题题意转述的时候锅了, 导致队友直接一个点分治敲上去, 敲完才发现不对劲=-= 不然这题是有可能做出来的</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>CCPC</tag>
        <tag>树形DP</tag>
        <tag>Regional</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]CCPC网络赛2019 B - array</title>
    <url>/2020/09/19/solution-HDU6703/</url>
    <content><![CDATA[<h1 id="ccpc网络赛2019-b---array">[CCPC网络赛2019] B - array</h1>
<h2 id="题意">题意</h2>
<p>给出一个数列<span class="math inline">\(\{a_i\}\)</span>,维护两种操作:</p>
<ul>
<li><code>1 pos</code> : 把<span class="math inline">\(a_{pos}\)</span>加上<span class="math inline">\(10^7\)</span></li>
<li><code>2 r k</code>: 找到一个不小于<span class="math inline">\(k\)</span>且不等于<span class="math inline">\(a_1,...,a_r\)</span>的最小值<span class="math inline">\(x\)</span></li>
</ul>
<p>共有<span class="math inline">\(m\)</span>组询问,强制在线.</p>
<p><span class="math inline">\(1 \leq n,m \leq 10^5\)</span>,<span class="math inline">\(1 \leq a_i \leq n\)</span>. 保证<span class="math inline">\(1 \leq pos,r,k\leq n\)</span></p>
<h2 id="解法">解法</h2>
<p>建一棵权值线段树,每个点存储该数原来的位置.维护<span class="math inline">\(Set\)</span>操作和<span class="math inline">\(minv\)</span>.</p>
<p>对于操作1,由限制易得等同于删除<span class="math inline">\(a_{pos}\)</span>.</p>
<p>对于操作2,我们搜索权值线段树里<span class="math inline">\([k,n]\)</span>中大于<span class="math inline">\(r\)</span>的第一个最小值,若不存在则答案为<span class="math inline">\(n+1\)</span>.</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HDU6703 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segtree</span>&#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> NO_OPT = INT_MAX;</span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;setv,maxv;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(size &lt; n)size *= <span class="number">2</span>;</span><br><span class="line">		setv.<span class="built_in">assign</span>(size*<span class="number">2</span>,NO_OPT);</span><br><span class="line">		maxv.<span class="built_in">assign</span>(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(NO_OPT != setv[x])&#123;</span><br><span class="line">			setv[<span class="built_in">ls</span>(x)] = setv[<span class="built_in">rs</span>(x)] = setv[x];</span><br><span class="line">			maxv[<span class="built_in">ls</span>(x)] = maxv[<span class="built_in">rs</span>(x)] = setv[x];</span><br><span class="line">			setv[x] = NO_OPT;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		maxv[x] = <span class="built_in">max</span>(maxv[<span class="built_in">ls</span>(x)],maxv[<span class="built_in">rs</span>(x)]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">		<span class="built_in">pushdown</span>(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			setv[x] = v;</span><br><span class="line">			maxv[x] = v;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">Set</span>(l,r,v,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="built_in">Set</span>(l,r,v,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="built_in">pushup</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		r++;</span><br><span class="line">		<span class="built_in">Set</span>(l,r,v,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="built_in">pushdown</span>(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> maxv[x] &lt; v)<span class="keyword">return</span> NO_OPT;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(setv[x] != NO_OPT)&#123;</span><br><span class="line">				maxv[x] = setv[x];</span><br><span class="line">				setv[x] = NO_OPT;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(maxv[x] &gt;= v)<span class="keyword">return</span> lx;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">return</span> NO_OPT;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> idx1 = <span class="built_in">kth</span>(l,v,<span class="built_in">ls</span>(x),lx,m),idx2 = NO_OPT;</span><br><span class="line">		<span class="keyword">if</span>(idx1 == NO_OPT)idx2 = <span class="built_in">kth</span>(l,v,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">min</span>(idx1,idx2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">kth</span>(l,v,<span class="number">0</span>,<span class="number">0</span>,size); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="keyword">int</span> lstans = <span class="number">0</span>;</span><br><span class="line">		segtree seg;</span><br><span class="line">		<span class="keyword">int</span> n,m;</span><br><span class="line">		cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">raw</span>(n+<span class="number">10</span>);</span><br><span class="line">		seg.<span class="built_in">init</span>(<span class="number">1e5</span>+<span class="number">10</span>);</span><br><span class="line">		seg.<span class="built_in">Set</span>(<span class="number">0</span>,<span class="number">0</span>,INF);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">			cin &gt;&gt; raw[i];</span><br><span class="line">			seg.<span class="built_in">Set</span>(raw[i],raw[i],i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">			<span class="keyword">int</span> opt,l,r;</span><br><span class="line">			cin &gt;&gt; opt &gt;&gt; l;</span><br><span class="line">			l ^= lstans;</span><br><span class="line">			<span class="keyword">if</span>(opt == <span class="number">1</span>)&#123;</span><br><span class="line">				seg.<span class="built_in">Set</span>(raw[l],raw[l],INF);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				cin &gt;&gt; r;</span><br><span class="line">				r ^= lstans;</span><br><span class="line">				lstans = seg.<span class="built_in">kth</span>(r,l+<span class="number">1</span>);</span><br><span class="line">				<span class="keyword">if</span>(lstans == INT_MAX)lstans = n+<span class="number">1</span>;</span><br><span class="line">				cout &lt;&lt; lstans &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>CCPC</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>CCPC</tag>
        <tag>线段树</tag>
        <tag>权值线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]ICPC2017-2018-Daejeon-E How Many to Be Happy?</title>
    <url>/2021/03/28/solution-ICPC2017-2018-Daejeon-E/</url>
    <content><![CDATA[<h2 id="题意">题意</h2>
<p>给出一个带权无向图<span class="math inline">\((1 \leq n \le 100, 1 \le m \le 500)\)</span>, 设的最小生成树为<span class="math inline">\(G\)</span>.</p>
<p>对于每条边<span class="math inline">\(e\)</span>, 设<span class="math inline">\(G&#39;\)</span>为必须包含<span class="math inline">\(e\)</span>的最小生成树. 定义<span class="math inline">\(H(e)\)</span>为存在于<span class="math inline">\(G\)</span>但不存在于<span class="math inline">\(G&#39;\)</span>的边的数目.</p>
<p>求<span class="math inline">\(\sum_{i = 1}^mH(e_i)\)</span></p>
<h2 id="题解">题解</h2>
<p>考虑转化原问题.</p>
<p>对于某条边<span class="math inline">\(e\)</span>, 设权值比它小的边的集合为<span class="math inline">\(E&#39;\)</span>. 显然只有<span class="math inline">\(E&#39;\)</span>才会影响到<span class="math inline">\(e\)</span>是否在最小生成树中. 而要确保<span class="math inline">\(e\)</span>被添加到最小生成树中, <span class="math inline">\(E&#39;\)</span>组成的图中<span class="math inline">\(e\)</span>的两端必须不连通. 至此问题转化为最小割, 求<span class="math inline">\(m\)</span>次最小割即可求解.</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = maxn*maxn*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>+<span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> from,to,next,w,cap,flow;</span><br><span class="line">	<span class="built_in">Edge</span>(<span class="keyword">int</span> from = <span class="number">0</span>,<span class="keyword">int</span> to = <span class="number">0</span>,<span class="keyword">int</span> w = <span class="number">0</span>):<span class="built_in">from</span>(from),<span class="built_in">to</span>(to),<span class="built_in">w</span>(w)&#123;&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge &amp; X)<span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> w &lt; X.w;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;edge[maxm],edge2[maxm];</span><br><span class="line"><span class="keyword">int</span> head[maxn],deep[maxn],vis[maxn],cur[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m,cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">int</span> cap,<span class="keyword">int</span> flow)</span></span>&#123;</span><br><span class="line">	edge[cnt].from = from;</span><br><span class="line">	edge[cnt].to = to;</span><br><span class="line">	edge[cnt].cap = cap;</span><br><span class="line">	edge[cnt].flow = flow;</span><br><span class="line">	edge[cnt].next = head[from];</span><br><span class="line">	head[from] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)cur[i] = head[i];</span><br><span class="line">	queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">	q.<span class="built_in">push</span>(s);</span><br><span class="line">	vis[s] = <span class="number">1</span>;</span><br><span class="line">	deep[s] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="keyword">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">			<span class="keyword">if</span>(!vis[v] <span class="keyword">and</span> edge[i].cap &gt; edge[i].flow)&#123;</span><br><span class="line">				vis[v] = <span class="number">1</span>;</span><br><span class="line">				deep[v] = deep[u] + <span class="number">1</span>;</span><br><span class="line">				q.<span class="built_in">push</span>(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> t,<span class="keyword">int</span> approve)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(u == t <span class="keyword">or</span> approve == <span class="number">0</span>)<span class="keyword">return</span> approve;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>,delta = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = cur[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		cur[u] = i;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(deep[u] + <span class="number">1</span> == deep[v] <span class="built_in"><span class="keyword">and</span></span> (delta = <span class="built_in">DFS</span>(v,t,<span class="built_in">min</span>(approve,edge[i].cap - edge[i].flow))) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			edge[i].flow += delta;</span><br><span class="line">			edge[i^<span class="number">1</span>].flow -= delta;</span><br><span class="line">			flow += delta;approve -= delta;</span><br><span class="line">			<span class="keyword">if</span>(!approve)<span class="keyword">break</span>; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">BFS</span>(s,t))&#123;</span><br><span class="line">		flow += <span class="built_in">DFS</span>(s,t,INF);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> f,t,w;</span><br><span class="line">		cin &gt;&gt; f &gt;&gt; t &gt;&gt; w;</span><br><span class="line">		edge2[i] = <span class="built_in">Edge</span>(f,t,w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(edge2+<span class="number">1</span>,edge2+m+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">		cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)head[j] = <span class="number">-1</span>,deep[j] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> s = edge2[i].from,t = edge2[i].to;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; i;j++)<span class="keyword">if</span>(edge2[j].w &lt; edge2[i].w)&#123;</span><br><span class="line">			<span class="keyword">int</span> f = edge2[j].from,t = edge2[j].to;</span><br><span class="line">			<span class="built_in">addedge</span>(f,t,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">addedge</span>(t,f,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">addedge</span>(t,f,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">addedge</span>(f,t,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		ans += <span class="built_in">Dinic</span>(s,t);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>网络流</tag>
        <tag>ICPC</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]-CF954I Yet Another String Matching Problem</title>
    <url>/2021/03/31/solution-CF954I/</url>
    <content><![CDATA[<p><del>孩子的第一道卷积题</del></p>
<h2 id="题意">题意</h2>
<p>假设两个相等长度的字符串<span class="math inline">\(u,v\)</span>. 每次可以进行一次操作将<span class="math inline">\(u,v\)</span>中某种字符同时全部变为另一种字符, 设<span class="math inline">\(F(u,v)\)</span>为使得<span class="math inline">\(u,v\)</span>相等的最小操作次数.</p>
<p>现在给出两个字符串<span class="math inline">\(s,t\)</span>, 且保证<span class="math inline">\(|s| \geq |t|\)</span>. 求对于<span class="math inline">\(s\)</span>的全部长度为<span class="math inline">\(|t|\)</span>的子串<span class="math inline">\(s&#39;\)</span>, <span class="math inline">\(F(s&#39;,t)\)</span>的值各为多少.</p>
<p>保证<span class="math inline">\(\sum = \{\text{a,b,c,d,e,f}\}\)</span>, <span class="math inline">\(1 \leq |t| \leq |s| \leq 1.25\cdot 10^5\)</span></p>
<h2 id="题解">题解</h2>
<p>首先求解<span class="math inline">\(F(u,v)\)</span>. 我们建一张图, 图中节点为字母<span class="math inline">\(a...f\)</span>. 对所有的<span class="math inline">\(i = 1...|u|\)</span>, 连边<span class="math inline">\((u[i],v[i])\)</span>. 显然答案最小值为该图任意生成树边的数目, 可以简单地用并查集求解. 暴力求解复杂度为<span class="math inline">\(O(|s|^2)\)</span>.</p>
<p>考虑优化. 设<span class="math inline">\(n = |s|,m = |t|.\)</span> 设<span class="math inline">\(f[c][d][idx]\)</span>为<span class="math inline">\(s[idx- m + 1...idx]\)</span>中字符<span class="math inline">\(c\)</span>与<span class="math inline">\(t\)</span>中字符<span class="math inline">\(d\)</span>下标(从0开始)一一对应的数目. 例如<span class="math inline">\(s = \text{bbcdefa}, t = \text{ddcb}\)</span>. 则<span class="math inline">\(f[&#39;b&#39;][&#39;d&#39;][3] = 2\)</span>.</p>
<p>求出<span class="math inline">\(f[c][d][idx]\)</span>后, 对于每个<span class="math inline">\(f[c][d][idx] &gt; 0\)</span>, 从<span class="math inline">\(c\)</span>向<span class="math inline">\(d\)</span>连一条边, 再按<span class="math inline">\(F(u,v)\)</span>的方法求解, 便能求出每个<span class="math inline">\(idx\)</span>的答案.</p>
<p>下面是FFT处理这类字符串匹配问题的套路做法:</p>
<p>假设我们需要求<span class="math inline">\(f[c][d]\)</span>. 设多项式<span class="math inline">\(g,h\)</span>. 令<span class="math inline">\(g(i) = [s[i] == c],h(i) = [t[j] == d]\)</span>. 此后将<span class="math inline">\(h\)</span><strong>翻转</strong>, 我们发现<span class="math inline">\(g\)</span>与<span class="math inline">\(h\)</span>的卷积: <span class="math display">\[
(g \ast h)[i] = \sum_{j = 0}^i g[j]\cdot h[i-j]
\]</span> 恰好是我们想要的<span class="math inline">\(f[c][d][]\)</span>.</p>
<p>枚举每个<span class="math inline">\(c,d \in \sum\)</span>, 便能高效求解问题. 时间复杂度<span class="math inline">\(|\sum|^2n\log n\)</span></p>
<p>优化: 容易发现<span class="math inline">\(g\)</span>和<span class="math inline">\(h\)</span>各只有<span class="math inline">\(6\)</span>种, 因此我们只需做<span class="math inline">\(12\)</span>次(而非<span class="math inline">\(36\)</span>次)DFT. 并且<span class="math inline">\(c == d\)</span>的情况显然对答案没有贡献, 无需考虑.</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> complex&lt;ld&gt; cld;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;cld&gt; Poly;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">6e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ld PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">int</span> rev[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Poly &amp; A,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	A.<span class="built_in">clear</span>();</span><br><span class="line">	A.<span class="built_in">shrink_to_fit</span>();</span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(size &lt;= n)size *= <span class="number">2</span>;</span><br><span class="line">	A.<span class="built_in">assign</span>(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT_init</span><span class="params">(Poly A)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">int</span> S = <span class="built_in">log2</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)rev[i] = (rev[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (S - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Poly &amp; A,<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)<span class="keyword">if</span>(i &lt; rev[i])<span class="built_in">swap</span>(A[i],A[rev[i]]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i *= <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="function">cld <span class="title">Wn</span><span class="params">(cos(PI/i),type*sin(PI/i))</span></span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j += i*<span class="number">2</span>)&#123;</span><br><span class="line">			<span class="function">cld <span class="title">W</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; i;k++)&#123;</span><br><span class="line">				cld facx = A[j+k],facy = W*A[j+k+i];</span><br><span class="line">				A[j+k] = facx + facy;</span><br><span class="line">				A[j+k+i] = facx - facy;</span><br><span class="line">				W *= Wn;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(type == <span class="number">-1</span>)<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (<span class="keyword">int</span>)A.<span class="built_in">size</span>();i++)A[i].<span class="built_in">real</span>((<span class="keyword">int</span>)(A[i].<span class="built_in">real</span>()/A.<span class="built_in">size</span>() + <span class="number">0.5</span>));</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;f[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">Poly DFTA[<span class="number">10</span>],DFTB[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> father[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)father[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findset</span><span class="params">(<span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> father[e] == e?e:father[e] = <span class="built_in">findset</span>(father[e]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">un</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	father[<span class="built_in">findset</span>(x)] = <span class="built_in">findset</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">findset</span>(u) == <span class="built_in">findset</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="string">&#x27;a&#x27;</span>;i &lt;= <span class="string">&#x27;f&#x27;</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="string">&#x27;a&#x27;</span>;j &lt;= <span class="string">&#x27;f&#x27;</span>;j++)<span class="keyword">if</span>(i != j)&#123;</span><br><span class="line">			<span class="keyword">int</span> u = i - <span class="string">&#x27;a&#x27;</span>,v = j - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">			<span class="keyword">if</span>(f[u][v][idx] &lt;= <span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(!<span class="built_in">check</span>(u,v))cnt++;</span><br><span class="line">			<span class="built_in">un</span>(u,v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	string s,t;</span><br><span class="line">	cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">	Poly A,B;</span><br><span class="line">	n = s.<span class="built_in">size</span>(),m = t.<span class="built_in">size</span>();</span><br><span class="line">	<span class="built_in">init</span>(A,n);</span><br><span class="line">	<span class="built_in">FFT_init</span>(A);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>;c &lt;= <span class="string">&#x27;f&#x27;</span>;c++)&#123;</span><br><span class="line">		<span class="built_in">init</span>(DFTA[c - <span class="string">&#x27;a&#x27;</span>],n);</span><br><span class="line">		<span class="built_in">init</span>(DFTB[c - <span class="string">&#x27;a&#x27;</span>],n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)<span class="keyword">if</span>(s[i] == c)DFTA[c - <span class="string">&#x27;a&#x27;</span>][i] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++)<span class="keyword">if</span>(t[j] == c)DFTB[c - <span class="string">&#x27;a&#x27;</span>][m - j - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">FFT</span>(DFTA[c - <span class="string">&#x27;a&#x27;</span>],<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">FFT</span>(DFTB[c - <span class="string">&#x27;a&#x27;</span>],<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>;c &lt;= <span class="string">&#x27;f&#x27;</span>;c++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">char</span> d = <span class="string">&#x27;a&#x27;</span>;d &lt;= <span class="string">&#x27;f&#x27;</span>;d++)<span class="keyword">if</span>(c != d)&#123;</span><br><span class="line">			A = DFTA[c - <span class="string">&#x27;a&#x27;</span>],B = DFTB[d - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (<span class="keyword">int</span>)A.<span class="built_in">size</span>();i++)A[i] *= B[i];</span><br><span class="line">			<span class="built_in">FFT</span>(A,<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (<span class="keyword">int</span>)A.<span class="built_in">size</span>();i++)f[c - <span class="string">&#x27;a&#x27;</span>][d - <span class="string">&#x27;a&#x27;</span>].<span class="built_in">push_back</span>((<span class="keyword">int</span>)A[i].<span class="built_in">real</span>());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = m<span class="number">-1</span>;i &lt; n;i++)cout &lt;&lt; <span class="built_in">cal</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>题解</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]HDU7047-Link with Balls</title>
    <url>/2021/08/11/solution-HDU7047/</url>
    <content><![CDATA[<h2 id="题意">题意</h2>
<p>给你两类盒子, 每类<span class="math inline">\(n\)</span>个, 编号分别从<span class="math inline">\(1\)</span>到<span class="math inline">\(n\)</span>.</p>
<p>​ 第一类: 可以从第<span class="math inline">\(i\)</span>个盒子里拿出<span class="math inline">\(i\)</span>的任意非负整数倍数个小球</p>
<p>​ 第二类: 可以从第<span class="math inline">\(i\)</span>个盒子里拿出最少<span class="math inline">\(0\)</span>个最多<span class="math inline">\(i\)</span>个小球.</p>
<p>多组数据<span class="math inline">\((1 \leq t \leq 10^5)\)</span>, 每组数据给出<span class="math inline">\(1 \leq n,m \leq 10^6\)</span>, 求从这<span class="math inline">\(2n\)</span>个盒子里拿出<span class="math inline">\(m\)</span>个小球的方案数模<span class="math inline">\(1e9+7\)</span>.</p>
<h2 id="题解">题解</h2>
<p>懒得从组合意义的角度考虑, 可以用生成函数去做.</p>
<p>第一类第<span class="math inline">\(i\)</span>个盒子对应的生成函数是 <span class="math display">\[
\sum_{j = 0}^{∞}x^{i\cdot j}
\]</span></p>
<p>第二类对应的是 <span class="math display">\[
\sum_{j = 0}^ix^i
\]</span></p>
<p>那么答案即为: <span class="math display">\[
[m](\prod_{i = 1}^{n}\sum_{j = 0}^{∞}x^{i\cdot j})\cdot(\prod_{i = 1}^{n}\sum_{j = 0}^ix^i) \\
=[m](\prod_{i = 1}^{n}\frac{1}{1 - x^i})\cdot(\prod_{i = 1}^{n}\frac{1-x^{i+1}}{1-x})\\
=[m]\frac{1-x^{n+1}}{(1-x)^{n+1}}\\
=[m](1-x^{n+1})\cdot \sum_{i = 0}^{∞}C_{n+i}^ix^i\\
= C_{n+m}^m - C_{m-1}^{n}
\]</span></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>生成函数</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]洛谷P2257-YY的GCD</title>
    <url>/2020/06/17/solution-P2257/</url>
    <content><![CDATA[<p>**本文思路部分来自于这篇题解*:<a href="https://www.luogu.com.cn/blog/qlwpc/">凄魉</a> <a href="https://www.luogu.com.cn/blog/qlwpc/solution-p2257">题解 P2257 【YY的GCD】</a></p>
<h1 id="题意">题意</h1>
<p>多组数据,求 <span class="math display">\[
\sum_{i = 1}^n\sum_{j = 1}^m [\gcd(i,j) == k],k \in prime
\]</span></p>
<p><span class="math inline">\(T = 10^4,1 \leq n,m \leq 10^7\)</span></p>
<h1 id="思路">思路</h1>
<h2 id="前置">前置</h2>
<p>首先我们在求 <span class="math display">\[
\sum_{i = 1}^n\sum_{j = 1}^m [\gcd(i,j) == 1]
\]</span></p>
<p>时有这么一种做法,利用了莫比乌斯函数<span class="math inline">\(\mu\)</span>的性质: <span class="math display">\[
\sum_{d|n}\mu(d) = [n = 1]
\]</span></p>
<hr />
<p><span class="math display">\[
\begin{align}
&amp;\sum_{i=1}^{n}\sum_{i=1}^{m}[\gcd(i,j) == 1] \\
&amp;=\sum_{i=1}^{n}\sum_{i=1}^{m}\epsilon(\gcd(i,j))\\
&amp;=\sum_{i=1}^{n}\sum_{i=1}^{m}\sum_{d|gcd(i,j)}\mu(d)\\
&amp;=\sum_{d = 1}^{\min(n,m)}\mu(d)\sum_{i = 1}^n[d|i]\sum_{j = 1}^{m}[d|j]\\
&amp;=\sum_{d=1}^{\min(n,m)}\mu(d)\lfloor \frac{n}{d}\rfloor \lfloor \frac{m}{d} \rfloor
\end{align}
\]</span> 那么我们只要构造一个数论函数<span class="math inline">\(f\)</span>,使得 <span class="math display">\[
\sum_{d|n}f(d) = [n \in prime]
\]</span></p>
<p>答案就变为了 <span class="math display">\[
\sum_{d=1}^{\min(n,m)}f(d)\lfloor \frac{n}{d}\rfloor \lfloor \frac{m}{d} \rfloor
\]</span></p>
<h2 id="构造方法">构造方法</h2>
<p>形式化地,设数论函数<span class="math inline">\(g\)</span>,构造<span class="math inline">\(f\)</span>使得<span class="math inline">\(\sum_{d|n}f(d) = g(n)\)</span></p>
<ol type="1">
<li>对于<span class="math inline">\(k \in [1,n]\)</span>,使<span class="math inline">\(f(k) = g(k)\)</span></li>
<li><span class="math inline">\(f(n) = f(n) - \sum_{d|n,d \neq n}f(d)\)</span></li>
</ol>
<p>如此,我们有: <span class="math display">\[
\sum_{d|n}f(d) = \sum_{d|n,d \neq n}f(d) + f(n) = g(n)
\]</span> 第二步可以采用类似埃氏筛的方法,复杂度<span class="math inline">\(O(n\ln n)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; maxn;i++)f[i] = g[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; maxn;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = i+i;j &lt; maxn;j += i)f[j] -= f[i];</span><br></pre></td></tr></table></figure>
<p>对于本题,我们设<span class="math inline">\(g(n) = [n \in prine]\)</span>即可,可以在<span class="math inline">\(O(n)\)</span>时间内筛出<span class="math inline">\(g\)</span>.</p>
<p>总复杂度:<span class="math inline">\(O(n + n\ln n + T \sqrt{\min(n,m)})\)</span></p>
<h1 id="代码">代码</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P2257</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"><span class="keyword">bool</span> not_p[maxn];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;prime;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	not_p[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; maxn;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!not_p[i])&#123;</span><br><span class="line">			f[i] = <span class="number">1</span>;</span><br><span class="line">			prime.<span class="built_in">push_back</span>(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> p:prime)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">ll</span>(p)*i &gt;= maxn)<span class="keyword">break</span>;</span><br><span class="line">			not_p[p*i] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%p == <span class="number">0</span>)<span class="keyword">break</span>; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; maxn;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i+i;j &lt; maxn;j += i)f[j] -= f[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; maxn;i++)f[i] += f[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">cal</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	ll tans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>,r = <span class="number">0</span>;l &lt;= <span class="built_in">min</span>(x,y);l = r+<span class="number">1</span>)&#123;</span><br><span class="line">		r = <span class="built_in">min</span>(x/(x/l),y/(y/l));</span><br><span class="line">		tans += <span class="number">1LL</span>*(f[r] - f[l<span class="number">-1</span>])*(x/l)*(y/l);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">sieve</span>();</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); </span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="keyword">int</span> n,m;</span><br><span class="line">		cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">cal</span>(n,m) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>PS.不是我不喜欢用行间公式,是hexo渲染行间LaTex总出奇怪的bug,凑合着看吧=-=</p>
<h1 id="另一种做法">另一种做法</h1>
<p>以下均有<span class="math inline">\(k \in prime\)</span> <span class="math display">\[
\begin{align}
&amp;\sum_{k = 1}^n\sum_{i = 1}^n\sum_{j = 1}^n[\gcd(i,j) == k]\\
&amp;=\sum_{k = 1}^n\sum_{i = 1}^{\frac{n}{k}}\sum_{j = 1}^{\frac{m}{k}}[\gcd(i,j) == 1]\\
&amp;=\sum_{k = 1}^n\sum_{i = 1}^{\frac{n}{k}}\sum_{j = 1}^{\frac{m}{k}}\sum_{d|\gcd(i,j)}\varphi(d)\\
&amp;=\sum_{k = 1}^n\sum_{d = 1}^{\frac{n}{k}}\varphi(d)\cdot \lfloor\frac{n}{kd}\rfloor\lfloor\frac{m}{kd}\rfloor\\
&amp;设T = kd,枚举T\\
&amp;=\sum_{k = 1}^n\sum_{d=1}^{\frac{n}{k}}\varphi(d)\lfloor\frac{n}{T}\rfloor\lfloor\frac{m}{T}\rfloor\\
&amp;=\sum_{T = 1}^n\lfloor\frac{n}{T}\rfloor\lfloor\frac{m}{T}\rfloor\sum_{k|T}\mu(\frac{T}{k})
\end{align}
\]</span> 可以看出<span class="math inline">\(f(T) = \sum_{k|T}\mu(\frac{T}{k})\)</span>可以预处理</p>
<p>复杂度:不会</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> p:prime)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;<span class="number">1ll</span>*j*p &lt; maxn;j++)f[j*p] += mu[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>code:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//P2257_2 </span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn = 1e7+10;</span><br><span class="line">bool not_p[maxn];</span><br><span class="line">int mu[maxn];</span><br><span class="line">ll f[maxn];</span><br><span class="line">vector&lt;int&gt;prime;</span><br><span class="line">void sieve_mu()&#123;</span><br><span class="line">	mu[1] = not_p[1] = 1;</span><br><span class="line">	for(int i = 2;i &lt; maxn;i++)&#123;</span><br><span class="line">		if(!not_p[i])&#123;</span><br><span class="line">			prime.push_back(i);</span><br><span class="line">			mu[i] = -1;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int p:prime)&#123;</span><br><span class="line">			if(1ll*p*i &gt;= maxn)break;</span><br><span class="line">			not_p[i*p] = 1;</span><br><span class="line">			if(i%p)mu[i*p] = -mu[i];</span><br><span class="line">			else&#123;</span><br><span class="line">				mu[i*p] = 0;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int p:prime)&#123;</span><br><span class="line">		for(int j = 1;1ll*j*p &lt; maxn;j++)f[j*p] += mu[j];</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i = 1;i &lt; maxn;i++)f[i] += f[i-1];</span><br><span class="line">&#125;</span><br><span class="line">ll cal(int n,int m)&#123;</span><br><span class="line">	ll tans = 0;</span><br><span class="line">	for(int l = 1,r = 0;l &lt;= min(n,m);l = r+1)&#123;</span><br><span class="line">		r = min(n/(n/l),m/(m/l));</span><br><span class="line">		tans += (f[r] - f[l-1])*(n/l)*(m/l);</span><br><span class="line">	&#125;</span><br><span class="line">	return tans;</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">	sieve_mu();</span><br><span class="line">	int t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		int n,m;</span><br><span class="line">		cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		cout &lt;&lt; cal(n,m) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>莫比乌斯反演</tag>
        <tag>数学</tag>
        <tag>题解</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]UVA11107 Life Forms</title>
    <url>/2020/06/08/solution-Uva11107/</url>
    <content><![CDATA[<h4 id="题面">题面:</h4>
<p>https://vjudge.net/problem/UVA-11107</p>
<h4 id="思路">思路</h4>
<p>​ 这里给出一种字符串Hash+二分的做法.</p>
<p>​ 对每个字符串分别进行Hash,再二分最长子串的长度<span class="math inline">\(L\)</span>.在判断<span class="math inline">\(L\)</span>是否合法时,只需求出每个字符串中长度为<span class="math inline">\(L\)</span>的<strong>不重复</strong>子串,再统计全部字符串中所有子串的个数.如果有子串出现次数大于等于<span class="math inline">\(\frac{n}{2}+1\)</span>,那么<span class="math inline">\(L\)</span>合法.</p>
<p>​ 实现上,使用map进行统计(<span class="math inline">\(cnt\)</span>)和判重(<span class="math inline">\(vis\)</span>).对每个字符串<span class="math inline">\(s\)</span>,计算以<span class="math inline">\([1...|s| - L+1]\)</span>为起点,长度为<span class="math inline">\(L\)</span>的子串的hash值<span class="math inline">\(h_i\)</span>,去重后添加到<span class="math inline">\(cnt\)</span>里.在添加过程中如果有<span class="math inline">\(cnt[h_i] \geq \frac{n}{2}+1\)</span>那么<span class="math inline">\(L\)</span>合法,同时将该段子串添加到答案中.输出时对答案去重输出即可,同时注意UVA的毒瘤格式要求=-=</p>
<p>​ 这个做法时间效率很低(在不作优化的情况下跑了3.72s),但是比较好想和好写</p>
<h4 id="代码">代码</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//UVA11107</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span>+<span class="number">10</span>,maxs = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> ull x = <span class="number">13331</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ull xp[maxn],H[maxn][maxs];</span><br><span class="line">string raw[maxs];</span><br><span class="line">vector&lt;string&gt;ans;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> L)</span></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> ok = <span class="number">0</span>;</span><br><span class="line">	map&lt;ull,<span class="keyword">int</span>&gt;cnt;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= n;k++)&#123;</span><br><span class="line">		map&lt;ull,<span class="keyword">bool</span>&gt;vis;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i+L<span class="number">-1</span> &lt;= raw[k].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">			ull u = H[i+L<span class="number">-1</span>][k] - H[i<span class="number">-1</span>][k]*xp[L];</span><br><span class="line">			<span class="keyword">if</span>(!vis[u])&#123;</span><br><span class="line">				vis[u] = <span class="number">1</span>;</span><br><span class="line">				cnt[u]++;</span><br><span class="line">				<span class="keyword">if</span>(cnt[u] &gt;= n/<span class="number">2</span>+<span class="number">1</span>)ok = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> L)</span></span>&#123;</span><br><span class="line">	map&lt;ull,<span class="keyword">int</span>&gt;cnt;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= n;k++)&#123;</span><br><span class="line">		map&lt;ull,<span class="keyword">bool</span>&gt;vis;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i+L<span class="number">-1</span> &lt;= raw[k].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">			ull u = H[i+L<span class="number">-1</span>][k] - H[i<span class="number">-1</span>][k]*xp[L];</span><br><span class="line">			<span class="keyword">if</span>(!vis[u])&#123;</span><br><span class="line">				vis[u] = <span class="number">1</span>;</span><br><span class="line">				cnt[u]++;</span><br><span class="line">				<span class="keyword">if</span>(cnt[u] &gt;= n/<span class="number">2</span>+<span class="number">1</span>)&#123;</span><br><span class="line">					string yay = <span class="string">&quot;&quot;</span>;</span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt;= i+L<span class="number">-1</span>;j++)yay += raw[k][j<span class="number">-1</span>];</span><br><span class="line">					ans.<span class="built_in">push_back</span>(yay);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	xp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; maxn;i++)xp[i] = xp[i<span class="number">-1</span>]*x;</span><br><span class="line">	<span class="keyword">bool</span> wtf = <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n) == <span class="number">1</span> <span class="keyword">and</span> n)&#123;</span><br><span class="line">		<span class="keyword">if</span>(wtf)cout &lt;&lt; endl;</span><br><span class="line">		wtf = <span class="number">1</span>;</span><br><span class="line">		ans.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">			string u;</span><br><span class="line">			cin &gt;&gt; u;</span><br><span class="line">			raw[i] = u;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= u.<span class="built_in">size</span>();j++)H[j][i] = H[j<span class="number">-1</span>][i]*x + u[j<span class="number">-1</span>] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> L = <span class="number">1</span>,R = maxn,M,len = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(L &lt;= R)&#123;</span><br><span class="line">			M = (L+R)/<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">check</span>(M))&#123;</span><br><span class="line">				len = M;</span><br><span class="line">				L = M+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> R = M<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">solve</span>(len);</span><br><span class="line">		<span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>());</span><br><span class="line">		<span class="keyword">if</span>(ans.<span class="built_in">size</span>() <span class="keyword">and</span> len)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; ans.<span class="built_in">size</span>();i++)<span class="keyword">if</span>(!i <span class="keyword">or</span> ans[i] != ans[i<span class="number">-1</span>])cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;?\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>题解</tag>
        <tag>Hash</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>template-DP</title>
    <url>/2021/01/14/template-DP/</url>
    <content><![CDATA[<h1 id="单调队列">单调队列</h1>
<h2 id="on求-最大值-最小值-k的子序列个数">O(n)求 最大值-最小值 &lt;= k的子序列个数</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; qmin;    <span class="comment">//保存窗口内的最小值，递增  front保存最小的元素位置</span></span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; qmax;    <span class="comment">//保存窗口内的最大值，递减  front保存最大的元素位置</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;   <span class="comment">//nums[i..j]表示数组的范围</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;        <span class="comment">//表示满足条件的子数组数量</span></span><br><span class="line">    <span class="comment">//依次找到以nums[0],nums[1]...nums[N - 1]作为第一元素的子数组中满足条件的数量有多少个，累加</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; nums.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; nums.<span class="built_in">size</span>())   <span class="comment">// j向右拓展，直到不满足条件</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!qmin.<span class="built_in">empty</span>() &amp;&amp; nums[qmin.<span class="built_in">back</span>()] &gt;= nums[j]) <span class="comment">// 更新qmin中最小值的index</span></span><br><span class="line">                qmin.<span class="built_in">pop_back</span>();</span><br><span class="line">            qmin.<span class="built_in">push_back</span>(j);</span><br><span class="line">            <span class="keyword">while</span>(!qmax.<span class="built_in">empty</span>() &amp;&amp; nums[qmax.<span class="built_in">back</span>()] &lt;= nums[j]) <span class="comment">// 更新qmax中最大值的index</span></span><br><span class="line">                qmax.<span class="built_in">pop_back</span>();</span><br><span class="line">            qmax.<span class="built_in">push_back</span>(j);</span><br><span class="line">            <span class="keyword">if</span>(nums[qmax.<span class="built_in">front</span>()] - nums[qmin.<span class="built_in">front</span>()] &gt; target) <span class="comment">//如果出现不满足条件的，那么包含以nums[i]起始的窗口的所有子数组都不满足条件</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(qmin.<span class="built_in">front</span>() == i)  <span class="comment">// 如果窗口为 0 ，直接弹出</span></span><br><span class="line">            qmin.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">if</span>(qmax.<span class="built_in">front</span>() == i)  <span class="comment">// 如果窗口为 0 ，直接弹出</span></span><br><span class="line">            qmax.<span class="built_in">pop_front</span>();</span><br><span class="line">        res += j - i;          <span class="comment">//如果nums[i..j]满足条件，则其子数组都满足条件， 一共 (j - i)个子数组</span></span><br><span class="line">        i++;                   <span class="comment">//继续寻找以nums[i]为起始点的子数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="单调栈">单调栈</h1>
<h2 id="求全为1的最大子矩形面积">求全为1的最大子矩形面积</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (st.<span class="built_in">empty</span>() || s[j] &gt;= s[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> top;</span><br><span class="line">                <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; s[j] &lt; s[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                    top = st.<span class="built_in">top</span>();</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">int</span> tmp = (j - top) * s[top];</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">push</span>(top);</span><br><span class="line">                s[top] = s[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="基础">基础</h1>
<h2 id="最长上升子序列">最长上升子序列</h2>
<h3 id="nlogn做法">nlogn做法</h3>
<h4 id="二分">二分</h4>
<p><span class="math inline">\(f[i]\)</span>表示长度为<span class="math inline">\(i\)</span>的最长上升子序列中, 最小的末尾数值. <span class="math inline">\(siz\)</span>为最长上升子序列长度.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">f[<span class="number">1</span>] = raw[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> siz = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[siz] &lt; raw[i])f[++siz] = raw[i];</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="built_in">lower_bound</span>(f+<span class="number">1</span>,f+siz+<span class="number">1</span>,raw[i]) - f;</span><br><span class="line">        f[idx] = <span class="built_in">min</span>(f[idx],raw[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="悬线法">悬线法</h2>
<p>同样用来求最大子矩形问题, 时间复杂度<span class="math inline">\(O(nm)\)</span></p>
<p>设<span class="math inline">\(l[x][y],r[x][y],u[x][y]\)</span>为点<span class="math inline">\((x,y)\)</span>可向左/右/上移动的最大距离. (其中向上扩展的最大距离即为"悬线"长度)</p>
<p>求出以上距离后, 再令<span class="math inline">\(L[x][y],R[x][y]\)</span>为<span class="math inline">\((x,y)\)</span>的悬线可以向左/右扩展的最大距离. 有: <span class="math display">\[
L[x][y] = \begin{cases}
\min(l[x-1][y],L[x][y]) &amp; (x-1,y)合法\\
l[x][y] &amp; (x-1,y)非法
\end{cases}
\]</span> 再统计<span class="math inline">\(\max(u[x][y] \cdot (L[x][y] + R[x][y] - 1))\)</span>即为答案.</p>
<h1 id="状压dp">状压dp</h1>
<h2 id="tsp问题">TSP问题</h2>
<p>(变体):给出一个带权完全无向图, 求恰好经过每一点的最短简单路径</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> f[<span class="number">1</span>&lt;&lt;<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0x3f3f3f3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k;i++)f[<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>)][i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> S = <span class="number">1</span>;S &lt; (<span class="number">1</span>&lt;&lt;k);S++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k;i++)<span class="keyword">if</span>(S&amp;(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>)))&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= k;j++)<span class="keyword">if</span>(j != i <span class="keyword">and</span> S&amp;(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>)))&#123;</span><br><span class="line">            f[S][i] = <span class="built_in">min</span>(f[S][i],f[S ^ (<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>))][j] + dis[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll ans = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k;i++)ans = <span class="built_in">min</span>(ans,f[(<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span>][i]);</span><br></pre></td></tr></table></figure>
<h2 id="求无向图简单环个数">求无向图简单环个数</h2>
<p>设<span class="math inline">\(f[S][i]\)</span>表示状态为<span class="math inline">\(S\)</span>, 终点是<span class="math inline">\((1&lt;&lt;i)\)</span>, 起点是<span class="math inline">\(lowbit(S)\)</span>的链的个数:</p>
<p>由于是无向图, 需要减去边的个数后除以2.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)f[(<span class="number">1</span>&lt;&lt;i)][i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> S = <span class="number">1</span>;S &lt; (<span class="number">1</span>&lt;&lt;n);S++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>;u &lt; n;u++)<span class="keyword">if</span>((S &gt;&gt; u) &amp; <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> v:G[u])&#123;</span><br><span class="line">			<span class="keyword">int</span> l = <span class="built_in">lowbit</span>(S);</span><br><span class="line">			<span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;v) &lt; l)<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;v) &gt; l <span class="keyword">and</span> !((S &gt;&gt; v) &amp; <span class="number">1</span>))&#123;</span><br><span class="line">				f[S | (<span class="number">1</span>&lt;&lt;v)][v] += f[S][u];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;v) == l)ans += f[S][u];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans -= m;</span><br><span class="line">cout &lt;&lt; ans / <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<h1 id="数位dp">数位dp</h1>
<p>感觉这个神秘板子部分就数位dp有用啊?</p>
<h2 id="例题1">例题1</h2>
<p>定义一个正整数的价值是把这个数的十进制写出来之后，最长的等差子串的长度。</p>
<p>求<span class="math inline">\([l,r]\)</span>范围内数字价值的总和。</p>
<p><a href="https://zhuanlan.zhihu.com/p/50791875">板子来源</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> T,n,m,len,a[<span class="number">20</span>];</span><br><span class="line">ll l,r,dp[<span class="number">20</span>][<span class="number">15</span>][<span class="number">25</span>][<span class="number">25</span>][<span class="number">20</span>];</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> pre,ll st,ll sum,<span class="keyword">int</span> d,<span class="keyword">int</span> lead,<span class="keyword">int</span> limit)</span></span>&#123;</span><br><span class="line">	<span class="comment">//pos搜到的位置</span></span><br><span class="line">	<span class="comment">//pre前一位数</span></span><br><span class="line">	<span class="comment">//st当前公差最大差值</span></span><br><span class="line">	<span class="comment">//sum整个数字的最大价值</span></span><br><span class="line">	<span class="comment">//d公差</span></span><br><span class="line">	<span class="comment">//lead判断是否有前导0</span></span><br><span class="line">	<span class="comment">//limit判断是否有最高位限制</span></span><br><span class="line">	<span class="keyword">if</span>(pos&gt;len) <span class="keyword">return</span> sum;<span class="comment">//dp结束 </span></span><br><span class="line">	<span class="comment">//记录状态（计划搜索）</span></span><br><span class="line">	<span class="comment">//注意d有负数，最小可以到-9，所以记录时数组下标是d+10 </span></span><br><span class="line">	<span class="keyword">if</span>((dp[pos][pre][st][sum][d+<span class="number">10</span>]!=<span class="number">-1</span>&amp;&amp;(!limit)&amp;&amp;(!lead))) <span class="keyword">return</span> dp[pos][pre][st][sum][d+<span class="number">10</span>]; </span><br><span class="line">	ll ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> res=limit?a[len-pos+<span class="number">1</span>]:<span class="number">9</span>;<span class="comment">//最高位最大值 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=res;i++)&#123;</span><br><span class="line">		<span class="comment">//有前导0且这位也是前导0，一切不变只有位数变化 </span></span><br><span class="line">		<span class="keyword">if</span>((!i)&amp;&amp;lead) ret+=<span class="built_in">dfs</span>(pos+<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-38</span>,<span class="number">1</span>,limit&amp;&amp;(i==res));</span><br><span class="line">		<span class="comment">//有前导0但这位不是前导0（这位是数字的最高位）开始有前一位，一个数形成等差数列 </span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(i&amp;&amp;lead) ret+=<span class="built_in">dfs</span>(pos+<span class="number">1</span>,i,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-38</span>,<span class="number">0</span>,limit&amp;&amp;(i==res));</span><br><span class="line">		<span class="comment">//之前刚搜到1位还没有共差，两位数形成等差数列，记录共差 </span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(d&lt;<span class="number">-9</span>) ret+=<span class="built_in">dfs</span>(pos+<span class="number">1</span>,i,<span class="number">2ll</span>,<span class="number">2ll</span>,i-pre,<span class="number">0</span>,limit&amp;&amp;(i==res));</span><br><span class="line">		<span class="comment">//搜到2位以后，共差若与前两位相同当前等差数列长度增加，若公差变化则更新整个数字的最大价值，等差数列长度又变为2 </span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(d&gt;=<span class="number">-9</span>) ret+=<span class="built_in">dfs</span>(pos+<span class="number">1</span>,i,(i-pre==d)?st+<span class="number">1</span>:<span class="number">2</span>,<span class="built_in">max</span>(sum,(i-pre==d)?st+<span class="number">1</span>:<span class="number">2</span>),(i-pre==d)?d:i-pre,<span class="number">0</span>,limit&amp;&amp;(i==res));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//没有前导0和最高限制时可以直接记录当前dp值以便下次搜到同样的情况可以直接使用。 </span></span><br><span class="line">	<span class="keyword">return</span> (!limit&amp;&amp;!lead)?dp[pos][pre][st][sum][d+<span class="number">10</span>]=ret:ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">part</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">	len=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x) a[++len]=x%<span class="number">10</span>,x/=<span class="number">10</span>;</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-38</span>,<span class="number">1</span>,<span class="number">1</span>);<span class="comment">//-38是随便赋的其实赋成-10就行了…… </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">		<span class="comment">//l是0的时候要特别注意！</span></span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,l?(<span class="built_in">part</span>(r)-<span class="built_in">part</span>(l<span class="number">-1</span>)):(<span class="built_in">part</span>(r)-<span class="built_in">part</span>(l)+<span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例题2">例题2</h2>
<p>求不含前导零且相邻两个数字之差至少为<span class="math inline">\(2\)</span>的正整数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll dp[<span class="number">15</span>][<span class="number">15</span>],ans;<span class="comment">//dp[i][j]表示搜到第i位，前一位是j，的！limit方案totnum；</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">15</span>],len;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> L,R;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> pre,<span class="keyword">int</span> st,<span class="keyword">int</span> limit)</span><span class="comment">//pos当前位置,pre前一位数,st判断前面是否全是0,limit最高位限制 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(pos&gt;len) <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//搜完了 </span></span><br><span class="line">	<span class="keyword">if</span>(!limit&amp;&amp;dp[pos][pre]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[pos][pre];<span class="comment">//没有最高位限制，已经搜过了</span></span><br><span class="line">	ll ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> res=limit?a[len-pos+<span class="number">1</span>]:<span class="number">9</span>;<span class="comment">//当前位最大数字 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=res;i++)<span class="comment">//从0枚举到最大数字 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">abs</span>(i-pre)&lt;<span class="number">2</span>) <span class="keyword">continue</span>;<span class="comment">//不符合题意，继续 </span></span><br><span class="line">		<span class="keyword">if</span>(st&amp;&amp;i==<span class="number">0</span>) ret+=<span class="built_in">dfs</span>(pos+<span class="number">1</span>,<span class="number">-2</span>,<span class="number">1</span>,limit&amp;&amp;i==res);<span class="comment">//如果有前导0，下一位随意 </span></span><br><span class="line">		<span class="keyword">else</span> ret+=<span class="built_in">dfs</span>(pos+<span class="number">1</span>,i,<span class="number">0</span>,limit&amp;&amp;i==res);<span class="comment">//如果没有前导0，继续按部就班地搜 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!limit&amp;&amp;!st) dp[pos][pre]=ret;<span class="comment">//没有最高位限制且没有前导0时记录结果 </span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">part</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	len=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x) a[++len]=x%<span class="number">10</span>,x/=<span class="number">10</span>;</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">	ans=<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">-2</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;L,&amp;R);</span><br><span class="line">    <span class="built_in">part</span>(L<span class="number">-1</span>);ll minn=ans;</span><br><span class="line">	<span class="built_in">part</span>(R);  ll maxx=ans;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,maxx-minn);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="优化">优化</h1>
<h2 id="斜率优化">斜率优化</h2>
<p>维护<span class="math inline">\(y_i = k_i x + b_i\)</span>的最小值. update(<span class="math inline">\(k,b\)</span>)需要保证斜率<span class="math inline">\(k\)</span>单调递减. 其他情况自己推一下即可.</p>
<p>原理如下图. 插入时, <code>line</code>存构成当前下凸壳的直线, <code>point[i]</code>代表直线<code>line[i]</code>和<code>line[i-1]</code>的交点横坐标. 新加入一条直线(<span class="math inline">\(l_3)\)</span>时, 设<span class="math inline">\(l_3\)</span>和<span class="math inline">\(l_2\)</span>交于<span class="math inline">\(B\)</span>, <span class="math inline">\(l_2\)</span>和<span class="math inline">\(l_1\)</span>交于<span class="math inline">\(A\)</span>. 若<span class="math inline">\(B.x &lt; A.x\)</span>则显然<span class="math inline">\(l_2\)</span>不再组成下凸壳, 将其删去. 使用单调栈维护这一过程即可. 查询时在<code>point</code>上二分即可找到对应直线.</p>
<p><strong><img src="template-DP.assets/image-20220824102152715.png" alt="image-20220824102152715" style="zoom:33%;" /></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;<span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sgn</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x &gt; <span class="number">0</span>) - (x &lt; <span class="number">0</span>);&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Frac</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> u,d;</span><br><span class="line">	<span class="built_in">Frac</span>(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">		ll sg = <span class="built_in">sgn</span>(a) * <span class="built_in">sgn</span>(b);</span><br><span class="line">		<span class="keyword">if</span>(a &lt; <span class="number">0</span>)a = -a;</span><br><span class="line">		<span class="keyword">if</span>(b &lt; <span class="number">0</span>)b = -b;</span><br><span class="line">		<span class="comment">//ll g = __gcd(a,b);</span></span><br><span class="line">		<span class="comment">//if(g &gt; 1)a /= g,b /= g;</span></span><br><span class="line">		u = sg * a,d = b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Frac &amp; x) <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (__int128)u * x.d &lt; (__int128)d * x.u; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt;= (<span class="keyword">const</span> Frac &amp; x) <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="built_in"><span class="keyword">return</span></span> (__int128)u * x.d &lt;= (__int128)d * x.u; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> Frac &amp; x) <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> u == x.u <span class="keyword">and</span> d == x.d;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> k,b;</span><br><span class="line">	<span class="built_in">Line</span>(<span class="keyword">int</span> k = <span class="number">0</span>,<span class="keyword">int</span> b = <span class="number">0</span>):<span class="built_in">k</span>(k),<span class="built_in">b</span>(b)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> k * x + b;</span><br><span class="line">	&#125;</span><br><span class="line">	Frac <span class="keyword">operator</span> ^ (<span class="keyword">const</span> Line &amp; B)<span class="keyword">const</span>&#123;<span class="comment">//return intersection.x</span></span><br><span class="line">		<span class="keyword">return</span> &#123;B.b - b,k - B.k&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Line&gt;line;</span><br><span class="line">vector&lt;Frac&gt;inter;<span class="comment">//intersector.x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	Frac x = &#123;-INF,<span class="number">1</span>&#125;;</span><br><span class="line">	Line cur = <span class="built_in">Line</span>(k,b);</span><br><span class="line">	<span class="keyword">while</span>(line.<span class="built_in">size</span>() <span class="built_in"><span class="keyword">and</span></span> (x = line.<span class="built_in">back</span>() ^ cur) &lt;= inter.<span class="built_in">back</span>())&#123;</span><br><span class="line">		line.<span class="built_in">pop_back</span>(),inter.<span class="built_in">pop_back</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	line.<span class="built_in">push_back</span>(cur);</span><br><span class="line">	inter.<span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	Frac v = &#123;x,<span class="number">1</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> idx = <span class="built_in">upper_bound</span>(<span class="built_in">ALL</span>(inter),v) - inter.<span class="built_in">begin</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> line[idx](x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>[题解]IOI2014-Wall</title>
    <url>/2020/09/12/solution-Wall/</url>
    <content><![CDATA[<h1 id="english-version">English version</h1>
<p>We will use lazy tag to solve this problem. Let <span class="math inline">\(upv[x]\)</span> be the maximum bound of node <span class="math inline">\(x\)</span>, and <span class="math inline">\(lowv[x]\)</span> be the minimum bound of node <span class="math inline">\(x\)</span>. As we only care about single point value, the leaf node's <span class="math inline">\(lowv[]\)</span> is the answer. Now the problem is how to maintain those two arrays. Now we assume we are operating on node <span class="math inline">\(x\)</span>, and the value of operation is <span class="math inline">\(h\)</span>.</p>
<p>Part 1: Adding phase</p>
<p>​ In this part we maintain <span class="math inline">\(lowv[x]\)</span>. If <span class="math inline">\(lowv[x] &lt; h\)</span> or there's no operation on <span class="math inline">\(x\)</span>, let <span class="math inline">\(lowv[x] = h\)</span>.</p>
<p>Part 2: Removing phase</p>
<p>​ We maintain <span class="math inline">\(upv[x]\)</span> just like part one. If <span class="math inline">\(upv[x] &gt; h\)</span>,let <span class="math inline">\(upv[x] = h\)</span>. Notice if <span class="math inline">\(lowv[x] &gt; h\)</span>, let <span class="math inline">\(lowv[x] = h\)</span>.</p>
<p>Part 3: Pushdown.</p>
<p>​ Just apply Part 1 and 2 on child nodes(<span class="math inline">\(y\)</span>). If node's <span class="math inline">\(lowv[y]\)</span> greater than <span class="math inline">\(upv[x]\)</span>, cut it off and vice versa.</p>
<h2 id="code">Code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P-4-E </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NO_OPT = INT_MAX;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segtree</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;upv,lowv;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(size &lt; n)size *= <span class="number">2</span>;</span><br><span class="line">		upv.<span class="built_in">assign</span>(size*<span class="number">2</span>,NO_OPT);</span><br><span class="line">		lowv.<span class="built_in">assign</span>(size*<span class="number">2</span>,NO_OPT);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(upv[x] != NO_OPT)&#123;</span><br><span class="line">			upv[<span class="built_in">ls</span>(x)] = <span class="built_in">min</span>(upv[x],upv[<span class="built_in">ls</span>(x)]);</span><br><span class="line">			upv[<span class="built_in">rs</span>(x)] = <span class="built_in">min</span>(upv[x],upv[<span class="built_in">rs</span>(x)]);</span><br><span class="line">			<span class="keyword">if</span>(lowv[<span class="built_in">ls</span>(x)] != NO_OPT <span class="keyword">and</span> lowv[<span class="built_in">ls</span>(x)] &gt; upv[x])lowv[<span class="built_in">ls</span>(x)] = upv[x];</span><br><span class="line">			<span class="keyword">if</span>(lowv[<span class="built_in">rs</span>(x)] != NO_OPT <span class="keyword">and</span> lowv[<span class="built_in">rs</span>(x)] &gt; upv[x])lowv[<span class="built_in">rs</span>(x)] = upv[x];</span><br><span class="line">			upv[x] = NO_OPT;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(lowv[x] != NO_OPT)&#123;</span><br><span class="line">			<span class="keyword">if</span>(lowv[<span class="built_in">ls</span>(x)] != NO_OPT)lowv[<span class="built_in">ls</span>(x)] = <span class="built_in">max</span>(lowv[<span class="built_in">ls</span>(x)],lowv[x]);</span><br><span class="line">			<span class="keyword">else</span> lowv[<span class="built_in">ls</span>(x)] = lowv[x];</span><br><span class="line">			<span class="keyword">if</span>(lowv[<span class="built_in">rs</span>(x)] != NO_OPT)lowv[<span class="built_in">rs</span>(x)] = <span class="built_in">max</span>(lowv[<span class="built_in">rs</span>(x)],lowv[x]);</span><br><span class="line">			<span class="keyword">else</span> lowv[<span class="built_in">rs</span>(x)] = lowv[x];</span><br><span class="line">			<span class="keyword">if</span>(upv[<span class="built_in">ls</span>(x)] != NO_OPT <span class="keyword">and</span> upv[<span class="built_in">ls</span>(x)] &lt; lowv[x])upv[<span class="built_in">ls</span>(x)] = lowv[x];</span><br><span class="line">			<span class="keyword">if</span>(upv[<span class="built_in">rs</span>(x)] != NO_OPT <span class="keyword">and</span> upv[<span class="built_in">rs</span>(x)] &lt; lowv[x])upv[<span class="built_in">rs</span>(x)] = lowv[x];</span><br><span class="line">			lowv[x] = NO_OPT;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">		<span class="built_in">pushdown</span>(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			upv[x] = <span class="built_in">min</span>(upv[x],v);</span><br><span class="line">			<span class="keyword">if</span>(lowv[x] != NO_OPT <span class="keyword">and</span> lowv[x] &gt; v)lowv[x] = v;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">up</span>(l,r,v,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="built_in">up</span>(l,r,v,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		<span class="built_in">up</span>(l,r,v,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">low</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">		<span class="built_in">pushdown</span>(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			<span class="keyword">if</span>(lowv[x] == NO_OPT <span class="keyword">or</span> lowv[x] &lt; v)lowv[x] = v;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">low</span>(l,r,v,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="built_in">low</span>(l,r,v,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">low</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		<span class="built_in">low</span>(l,r,v,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(idx &gt;= rx)<span class="keyword">return</span> NO_OPT;</span><br><span class="line">		<span class="built_in">pushdown</span>(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)<span class="keyword">return</span> lowv[x];</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(idx &lt; m)<span class="keyword">return</span> <span class="built_in">get</span>(idx,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">get</span>(idx,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">get</span>(idx,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	segtree seg;</span><br><span class="line">	seg.<span class="built_in">init</span>(n+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="keyword">int</span> opt,l,r,v;</span><br><span class="line">		r++;</span><br><span class="line">		cin &gt;&gt; opt &gt;&gt; l &gt;&gt; r &gt;&gt; v;</span><br><span class="line">		r++;</span><br><span class="line">		<span class="keyword">if</span>(opt == <span class="number">1</span>)seg.<span class="built_in">low</span>(l,r,v);</span><br><span class="line">		<span class="keyword">else</span> seg.<span class="built_in">up</span>(l,r,v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> ans = seg.<span class="built_in">get</span>(i);</span><br><span class="line">		cout &lt;&lt; (ans == NO_OPT?<span class="number">0</span>:ans) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="题意简述">题意简述</h2>
<p>https://codeforces.com/edu/course/2/lesson/5/4/practice/contest/280801/problem/E</p>
<p>或:</p>
<p>https://www.luogu.com.cn/problem/P4560</p>
<p>长度为<span class="math inline">\(n\)</span>的序列初始为空,维护两种操作:</p>
<ol type="1">
<li>Add(L,R,v): 将<span class="math inline">\([L,R]\)</span>中小于<span class="math inline">\(v\)</span>的值改变为<span class="math inline">\(v\)</span></li>
<li>Remove(L,R,v):将<span class="math inline">\([L,R]\)</span>中大于<span class="math inline">\(v\)</span>的值改变为<span class="math inline">\(v\)</span></li>
</ol>
<p>给出<span class="math inline">\(m\)</span>个操作,输出操作全部完成后的序列.</p>
<p><span class="math inline">\(1 \leq n \leq 2\cdot10^6,1 \leq m \leq 5\cdot10^5\)</span></p>
<h2 id="思路">思路</h2>
<p>对每个节点维护<span class="math inline">\(upv[]\)</span>和<span class="math inline">\(lowv[]\)</span>,表示该节点值的上限和下限.查询时对每个点做一次单点查询,答案为<span class="math inline">\(lowv[x]\)</span>.</p>
<p>下放节点时<span class="math inline">\(upv\)</span>和<span class="math inline">\(lowv\)</span>的关系比较显然,细节请见代码.</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>[模板]计算几何</title>
    <url>/2020/05/09/template-geometry/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="二维">二维</h1>
<h2 id="起手式待补充">起手式(待补充):</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> ld;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.14159265358979</span>; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">	ld x,y;</span><br><span class="line">	<span class="built_in">Point</span>(ld x = <span class="number">0</span>,ld y = <span class="number">0</span>):<span class="built_in">x</span>(x),<span class="built_in">y</span>(y)&#123;&#125;</span><br><span class="line">	Point <span class="keyword">operator</span> + (Point B)&#123;<span class="keyword">return</span> <span class="built_in">Point</span>(x+B.x,y+B.y);&#125;</span><br><span class="line">	Point <span class="keyword">operator</span> - (Point B)&#123;<span class="keyword">return</span> <span class="built_in">Point</span>(x-B.x,y-B.y);&#125;</span><br><span class="line">	Point <span class="keyword">operator</span> * (ld w)&#123;<span class="keyword">return</span> <span class="built_in">Point</span>(x*w,y*w);&#125;</span><br><span class="line">	Point <span class="keyword">operator</span> / (ld w)&#123;<span class="keyword">return</span> <span class="built_in">Point</span>(x/w,y/w);&#125;</span><br><span class="line">	<span class="function">Point <span class="title">Rotate_90_clock</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">Point</span>(y,-x);&#125;<span class="comment">//顺时针旋转90°</span></span><br><span class="line">	<span class="function">ld <span class="title">len2</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> x*x + y*y;&#125;<span class="comment">//长度的平方</span></span><br><span class="line">	<span class="function">ld <span class="title">len</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>(<span class="built_in">sqrt</span>(x*x + y*y));&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Point &amp; A) <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x == A.x?y &lt; A.y:x &lt; A.x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;point[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span>&#123;</span></span><br><span class="line">	Point O;</span><br><span class="line">	ld R;</span><br><span class="line">	<span class="built_in">Circle</span>(Point O = <span class="built_in">Point</span>(<span class="number">0</span>,<span class="number">0</span>),ld R = <span class="number">0</span>):<span class="built_in">O</span>(O),<span class="built_in">R</span>(R)&#123;&#125;</span><br><span class="line">	<span class="function">ld <span class="title">R2</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> R*R;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"><span class="function">ld <span class="title">Dot</span><span class="params">(Vector A,Vector B)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> A.x*B.x + A.y*B.y;</span><br><span class="line">&#125;<span class="comment">//点积</span></span><br><span class="line"><span class="function">ld <span class="title">Cross</span><span class="params">(Vector A,Vector B)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> A.x*B.y - A.y*B.x;</span><br><span class="line">&#125;<span class="comment">//二维叉积</span></span><br><span class="line"><span class="function">Point <span class="title">Line_inter</span><span class="params">(Point P0,Point V0,Point P1,Point V1)</span></span>&#123;</span><br><span class="line">	ld t = <span class="built_in">Cross</span>(P1 - P0,V1)/<span class="built_in">Cross</span>(V0,V1);</span><br><span class="line">	<span class="keyword">return</span> P0 + V0 * t;</span><br><span class="line">&#125;<span class="comment">//返回两向量交点.P和V分别为向量起点终点*</span></span><br><span class="line"><span class="function">Circle <span class="title">p2circle</span><span class="params">(Point A,Point B)</span></span>&#123;</span><br><span class="line">	Circle tans = <span class="built_in">Circle</span>((A+B)/<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	tans.R = (tans.O - A).<span class="built_in">len</span>();</span><br><span class="line">	<span class="keyword">return</span> tans;</span><br><span class="line">&#125;<span class="comment">//两点的外接圆</span></span><br><span class="line"><span class="function">Circle <span class="title">p2circle</span><span class="params">(Point A,Point B,Point C)</span></span>&#123;</span><br><span class="line">	Circle tans = <span class="built_in">Circle</span>(<span class="built_in">Line_inter</span>((A+B)/<span class="number">2</span>,(B - A).<span class="built_in">Rotate_90_clock</span>(),(A+C)/<span class="number">2</span>,(C - A).<span class="built_in">Rotate_90_clock</span>()),<span class="number">0</span>);</span><br><span class="line">	tans.R = (tans.O - A).<span class="built_in">len</span>();</span><br><span class="line">	<span class="keyword">return</span> tans;</span><br><span class="line">&#125;<span class="comment">//三点共圆</span></span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">to_rad</span><span class="params">(<span class="keyword">double</span> deg)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> deg*(PI/<span class="number">180</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Vector <span class="title">Rotate</span><span class="params">(Vector A,<span class="keyword">double</span> rad)</span></span>&#123;<span class="comment">//逆时针 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Vector</span>(A.x*<span class="built_in">cos</span>(rad) - A.y*<span class="built_in">sin</span>(rad),A.x*<span class="built_in">sin</span>(rad) + A.y*<span class="built_in">cos</span>(rad));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="点到直线及线段距离">点到直线及线段距离</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ld <span class="title">LinePointDist</span><span class="params">(Point p,Point a,Point b)</span></span>&#123;<span class="comment">//点到直线</span></span><br><span class="line">	Vector v1 = b-a,v2 = p-a;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">fabs</span>(<span class="built_in">Cross</span>(v1,v2) / <span class="built_in">len</span>(v1));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ld <span class="title">SegPointDist</span><span class="params">(Point p,Point a,Point b)</span></span>&#123;<span class="comment">//点到线段</span></span><br><span class="line">	<span class="keyword">if</span>(a == b)<span class="keyword">return</span> <span class="built_in">len</span>(p - a);</span><br><span class="line">	Vector v1 = b-a,v2 = p-a,v3 = p-b;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">Dot</span>(v1,v2) &lt; eps)<span class="keyword">return</span> <span class="built_in">len</span>(v2);</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">Dot</span>(v1,v3) &gt; eps)<span class="keyword">return</span> <span class="built_in">len</span>(v3);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">LinePointDist</span>(p,a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="按角度旋转点">按角度旋转点</h2>
<p>设点<span class="math inline">\(A(x,y)\)</span>绕点<span class="math inline">\(R(x_{r},y_{r})\)</span>逆时针旋转<span class="math inline">\(\theta\)</span>弧度后得到点<span class="math inline">\(A’(x&#39;,y&#39;)\)</span>, 则有: <span class="math display">\[
x&#39; = (x - x_r)\cdot\cos(\theta) - (y - y_r)\cdot\sin(\theta) + x_r\\
y&#39; = (x - x_r)\cdot\sin(\theta) + (y - y_r)\cdot\cos(\theta) + y_r
\]</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(ld &amp; x,ld &amp; y,ld theta,ld rx,ld ry)</span></span>&#123;</span><br><span class="line">    ld nx = (x - rx)*<span class="built_in">cos</span>(theta) - (y - ry)*<span class="built_in">sin</span>(theta) + rx;</span><br><span class="line">    ld ny = (x - rx)*<span class="built_in">sin</span>(theta) + (y - ry)*<span class="built_in">cos</span>(theta) + ry;</span><br><span class="line">    x = nx,y = ny;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="凸包">凸包</h2>
<p>输入顶点, 返回凸包. raw为原顶点数组,hull为凸包顶点数组</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;Point&gt; <span class="title">ConvexHull</span><span class="params">(vector&lt;Point&gt;raw)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(raw.<span class="built_in">size</span>() == <span class="number">1</span>)<span class="keyword">return</span> raw;</span><br><span class="line">	<span class="built_in">sort</span>(raw.<span class="built_in">begin</span>(),raw.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">int</span> n = raw.<span class="built_in">size</span>(),idx = <span class="number">0</span>;</span><br><span class="line">	vector&lt;Point&gt;<span class="built_in">hull</span>(<span class="number">2</span>*n+<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(idx &gt; <span class="number">1</span> <span class="keyword">and</span> <span class="built_in">Cross</span>(hull[idx<span class="number">-1</span>] - hull[idx<span class="number">-2</span>],raw[i] - hull[idx<span class="number">-1</span>]) &lt;= <span class="number">0</span>)idx--;</span><br><span class="line">		hull[idx++] = raw[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> k = idx;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-2</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">while</span>(idx &gt; k <span class="keyword">and</span> <span class="built_in">Cross</span>(hull[idx<span class="number">-1</span>] - hull[idx<span class="number">-2</span>],raw[i] - hull[idx<span class="number">-1</span>]) &lt;= <span class="number">0</span>)idx--;</span><br><span class="line">		hull[idx++] = raw[i];</span><br><span class="line">	&#125;</span><br><span class="line">	hull.<span class="built_in">resize</span>(idx<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> hull;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="闵可夫斯基和">闵可夫斯基和</h2>
<p>点集<span class="math inline">\(A,B\)</span>的闵可夫斯基和为<span class="math inline">\(C = \{a+b|a\in A,b \in B\}\)</span></p>
<p><img src="https://images.cnblogs.com/cnblogs_com/xzyxzy/1374475/o_%E9%97%B5%E5%8F%AF%E5%A4%AB%E6%96%AF%E5%9F%BA%E5%92%8C1.png" alt="img" style="zoom:33%;" /></p>
<p>复杂度<span class="math inline">\(O(n)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;Point&gt; <span class="title">minkowski</span><span class="params">(vector&lt;Point&gt; &amp; C1,vector&lt;Point&gt; &amp; C2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = (<span class="keyword">int</span>)C1.<span class="built_in">size</span>(),m = (<span class="keyword">int</span>)C2.<span class="built_in">size</span>();</span><br><span class="line">	vector&lt;Point&gt;<span class="built_in">s1</span>(n),<span class="built_in">s2</span>(m),<span class="built_in">A</span>(n+m+<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n<span class="number">-1</span>;i++)s1[i] = C1[i+<span class="number">1</span>] - C1[i];</span><br><span class="line">	s1[n<span class="number">-1</span>] = C1[<span class="number">0</span>] - C1[n<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m<span class="number">-1</span>;i++)s2[i] = C2[i+<span class="number">1</span>] - C2[i];</span><br><span class="line">	s2[m<span class="number">-1</span>] = C2[<span class="number">0</span>] - C2[m<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">	A[tot] = C1[<span class="number">0</span>] + C2[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">int</span> p1 = <span class="number">0</span>,p2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p1 &lt; n <span class="keyword">and</span> p2 &lt; m)&#123;</span><br><span class="line">		tot++;</span><br><span class="line">		A[tot] = A[tot<span class="number">-1</span>] + (<span class="built_in">Cross</span>(s1[p1],s2[p2]) &gt;= eps?s1[p1++]:s2[p2++]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(p1 &lt; n)&#123;</span><br><span class="line">		++tot;</span><br><span class="line">		A[tot] = A[tot<span class="number">-1</span>] + s1[p1++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(p2 &lt;= m)&#123;</span><br><span class="line">		++tot;</span><br><span class="line">		A[tot] = A[tot<span class="number">-1</span>] + s2[p2++];</span><br><span class="line">	&#125;</span><br><span class="line">	A.<span class="built_in">resize</span>(tot+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多边形面积">多边形面积</h2>
<p>_Point为多边形点集,n为顶点数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">PolyArea</span><span class="params">(Point * _Point,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> area = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; n;i++)&#123;</span><br><span class="line">		area += <span class="built_in">Cross</span>(_Point[i] - _Point[<span class="number">1</span>],_Point[i+<span class="number">1</span>] - _Point[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> area/<span class="number">2</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最小圆覆盖">最小圆覆盖</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> ld;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">	ld x,y;</span><br><span class="line">	<span class="built_in">Point</span>(ld x = <span class="number">0</span>,ld y = <span class="number">0</span>):<span class="built_in">x</span>(x),<span class="built_in">y</span>(y)&#123;&#125;</span><br><span class="line">	Point <span class="keyword">operator</span> + (Point B)&#123;<span class="keyword">return</span> <span class="built_in">Point</span>(x+B.x,y+B.y);&#125;</span><br><span class="line">	Point <span class="keyword">operator</span> - (Point B)&#123;<span class="keyword">return</span> <span class="built_in">Point</span>(x-B.x,y-B.y);&#125;</span><br><span class="line">	Point <span class="keyword">operator</span> * (ld w)&#123;<span class="keyword">return</span> <span class="built_in">Point</span>(x*w,y*w);&#125;</span><br><span class="line">	Point <span class="keyword">operator</span> / (ld w)&#123;<span class="keyword">return</span> <span class="built_in">Point</span>(x/w,y/w);&#125;</span><br><span class="line">	<span class="function">Point <span class="title">Rotate_90_clock</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">Point</span>(y,-x);&#125;<span class="comment">//顺时针旋转90°</span></span><br><span class="line">	<span class="function">ld <span class="title">len2</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> x*x + y*y;&#125;<span class="comment">//长度的平方</span></span><br><span class="line">	<span class="function">ld <span class="title">len</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>(<span class="built_in">sqrt</span>(x*x + y*y));&#125;</span><br><span class="line">&#125;point[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span>&#123;</span></span><br><span class="line">	Point O;</span><br><span class="line">	ld R;</span><br><span class="line">	<span class="built_in">Circle</span>(Point O = <span class="built_in">Point</span>(<span class="number">0</span>,<span class="number">0</span>),ld R = <span class="number">0</span>):<span class="built_in">O</span>(O),<span class="built_in">R</span>(R)&#123;&#125;</span><br><span class="line">	<span class="function">ld <span class="title">R2</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> R*R;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"><span class="function">ld <span class="title">Dot</span><span class="params">(Vector A,Vector B)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> A.x*B.x + A.y*B.y;</span><br><span class="line">&#125;<span class="comment">//点积</span></span><br><span class="line"><span class="function">ld <span class="title">Cross</span><span class="params">(Vector A,Vector B)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> A.x*B.y - A.y*B.x;</span><br><span class="line">&#125;<span class="comment">//二维叉积</span></span><br><span class="line"><span class="function">Point <span class="title">Line_inter</span><span class="params">(Point P0,Point V0,Point P1,Point V1)</span></span>&#123;</span><br><span class="line">	ld t = <span class="built_in">Cross</span>(P1 - P0,V1)/<span class="built_in">Cross</span>(V0,V1);</span><br><span class="line">	<span class="keyword">return</span> P0 + V0 * t;</span><br><span class="line">&#125;<span class="comment">//返回两向量交点.P和V分别为向量起点终点*</span></span><br><span class="line"><span class="function">Circle <span class="title">p2circle</span><span class="params">(Point A,Point B)</span></span>&#123;</span><br><span class="line">	Circle tans = <span class="built_in">Circle</span>((A+B)/<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	tans.R = (tans.O - A).<span class="built_in">len</span>();</span><br><span class="line">	<span class="keyword">return</span> tans;</span><br><span class="line">&#125;<span class="comment">//两点的外接圆</span></span><br><span class="line"><span class="function">Circle <span class="title">p2circle</span><span class="params">(Point A,Point B,Point C)</span></span>&#123;</span><br><span class="line">	Circle tans = <span class="built_in">Circle</span>(<span class="built_in">Line_inter</span>((A+B)/<span class="number">2</span>,(B - A).<span class="built_in">Rotate_90_clock</span>(),(A+C)/<span class="number">2</span>,(C - A).<span class="built_in">Rotate_90_clock</span>()),<span class="number">0</span>);</span><br><span class="line">	tans.R = (tans.O - A).<span class="built_in">len</span>();</span><br><span class="line">	<span class="keyword">return</span> tans;</span><br><span class="line">&#125;<span class="comment">//三点共圆</span></span><br><span class="line"><span class="function">Circle <span class="title">Min_Cir_Cover</span><span class="params">(Point * point,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="built_in">random_shuffle</span>(point+<span class="number">1</span>,point+n+<span class="number">1</span>);</span><br><span class="line">	Circle res;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>((point[i] - res.O).<span class="built_in">len2</span>() &gt; res.<span class="built_in">R2</span>())&#123;</span><br><span class="line">			res = <span class="built_in">Circle</span>(point[i],<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; i;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>((point[j] - res.O).<span class="built_in">len2</span>() &gt; res.<span class="built_in">R2</span>())&#123;</span><br><span class="line">					res = <span class="built_in">p2circle</span>(point[i],point[j]);</span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt; j;k++)&#123;</span><br><span class="line">						<span class="keyword">if</span>((point[k] - res.O).<span class="built_in">len2</span>() &gt; res.<span class="built_in">R2</span>())&#123;</span><br><span class="line">							res = <span class="built_in">p2circle</span>(point[i],point[j],point[k]);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;<span class="comment">//最小圆覆盖,输入点集数组和点的数量,返回一个圆</span></span><br></pre></td></tr></table></figure>
<h2 id="判断点在凸包内部及边界">判断点在凸包内部及边界</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Left</span><span class="params">(Point P,Point A,Point B)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Cross</span>(B - A,P - A) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Right</span><span class="params">(Point P,Point A,Point B)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Cross</span>(P - A,B - A) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Point_in_Convex</span><span class="params">(Point P,vector&lt;Point&gt; &amp; C)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = C.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">Left</span>(P,C[<span class="number">0</span>],C[n - <span class="number">1</span>]) <span class="keyword">or</span> <span class="built_in">Right</span>(P,C[<span class="number">0</span>],C[<span class="number">1</span>]))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">1</span>, r = n - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (l &lt; r - <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">Left</span>(P, C[<span class="number">0</span>], C[m])) &#123;</span><br><span class="line">			l = m;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			r = m;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">Right</span>(P, C[l], C[r]))<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三维">三维</h1>
<h2 id="起手式">起手式:</h2>
<p>鸽子biss</p>
<h2 id="叉乘写为矩阵形式">叉乘写为矩阵形式</h2>
<p><span class="math display">\[
\vec a \times \vec b = A^* \vec b =  \left(
\begin{array}{cccc} 
   0 &amp; -z_1 &amp; y_1\\
   z_1 &amp; 0 &amp; -x_1\\
   -y_1 &amp; x_1 &amp; 0
\end{array}
\right) \left(
\begin{array}{cccc} 
   x_2\\
   y_2\\
   z_2
\end{array}
\right)
\]</span></p>
<p><span class="math inline">\(A^*\)</span>称为<code>dual martix</code></p>
<h2 id="最小球覆盖">最小球覆盖</h2>
<p>来自上交红书《ACM国际大学生程序设计竞赛-算法与实现》</p>
<p><strong>下标从0开始</strong></p>
<p>复杂度: <span class="math inline">\(O(n)\)</span></p>
<p>输入:</p>
<p>​ <code>npoint</code> 全局变量, 点的个数</p>
<p>​ <code>pt</code> 全局变量, 点的坐标</p>
<p>调用 <code>smallest_ball()</code></p>
<p>输出:</p>
<p>​ <code>res</code> 全局变量, 球心坐标</p>
<p>​ <code>radius</code> 全局变量, 球的半径</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">double</span> eps = <span class="number">1e-9</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tpoint</span>&#123;</span></span><br><span class="line">	<span class="keyword">double</span> x,y,z;</span><br><span class="line">	<span class="built_in">Tpoint</span>(<span class="keyword">double</span> x = <span class="number">0</span>,<span class="keyword">double</span> y = <span class="number">0</span>,<span class="keyword">double</span> z = <span class="number">0</span>):<span class="built_in">x</span>(x),<span class="built_in">y</span>(y),<span class="built_in">z</span>(z)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> npoint,nouter;</span><br><span class="line">Tpoint pt[maxn],outer[<span class="number">4</span>],res;</span><br><span class="line"><span class="keyword">double</span> radius,tmp;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">dist</span><span class="params">(Tpoint p1,Tpoint p2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> dx = p1.x - p2.x,dy = p1.y - p2.y,dz = p1.z - p2.z;</span><br><span class="line">	<span class="keyword">return</span> (dx*dx + dy*dy + dz*dz);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">dot</span><span class="params">(Tpoint p1,Tpoint p2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> p1.x*p2.x + p1.y*p2.y + p1.z*p2.z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ball</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Tpoint q[<span class="number">3</span>];<span class="keyword">double</span> m[<span class="number">3</span>][<span class="number">3</span>], sol[<span class="number">3</span>],L[<span class="number">3</span>],det;</span><br><span class="line">	res.x = res.y = res.z = radius = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in"><span class="keyword">switch</span></span>(nouter)&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>: res = outer[<span class="number">0</span>];<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			res.x = (outer[<span class="number">0</span>].x+outer[<span class="number">1</span>].x)/<span class="number">2</span>;</span><br><span class="line">			res.y = (outer[<span class="number">0</span>].y+outer[<span class="number">1</span>].y)/<span class="number">2</span>;</span><br><span class="line">			res.z = (outer[<span class="number">0</span>].z+outer[<span class="number">1</span>].z)/<span class="number">2</span>;</span><br><span class="line">			radius = <span class="built_in">dist</span>(res,outer[<span class="number">0</span>]);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">2</span>;i++)&#123;</span><br><span class="line">				q[i].x = outer[i+<span class="number">1</span>].x - outer[<span class="number">0</span>].x;</span><br><span class="line">				q[i].y = outer[i+<span class="number">1</span>].y - outer[<span class="number">0</span>].y;</span><br><span class="line">				q[i].z = outer[i+<span class="number">1</span>].z - outer[<span class="number">0</span>].z;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">2</span>;i++)</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">2</span>;j++)m[i][j] = <span class="built_in">dot</span>(q[i],q[j])*<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">2</span>;i++)sol[i] = <span class="built_in">dot</span>(q[i],q[i]);</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">fabs</span>(det = m[<span class="number">0</span>][<span class="number">0</span>]*m[<span class="number">1</span>][<span class="number">1</span>] - m[<span class="number">0</span>][<span class="number">1</span>]*m[<span class="number">1</span>][<span class="number">0</span>])&lt;eps)<span class="keyword">return</span>;</span><br><span class="line">			L[<span class="number">0</span>] = (sol[<span class="number">0</span>]*m[<span class="number">1</span>][<span class="number">1</span>] - sol[<span class="number">1</span>]*m[<span class="number">0</span>][<span class="number">1</span>])/det;</span><br><span class="line">			L[<span class="number">1</span>] = (sol[<span class="number">1</span>]*m[<span class="number">0</span>][<span class="number">0</span>] - sol[<span class="number">0</span>]*m[<span class="number">1</span>][<span class="number">0</span>])/det;</span><br><span class="line">			res.x = outer[<span class="number">0</span>].x + q[<span class="number">0</span>].x*L[<span class="number">0</span>] + q[<span class="number">1</span>].x*L[<span class="number">1</span>];</span><br><span class="line">			res.y = outer[<span class="number">0</span>].y + q[<span class="number">0</span>].y*L[<span class="number">0</span>] + q[<span class="number">1</span>].y*L[<span class="number">1</span>];</span><br><span class="line">			res.z = outer[<span class="number">0</span>].z + q[<span class="number">0</span>].z*L[<span class="number">0</span>] + q[<span class="number">1</span>].z*L[<span class="number">1</span>];</span><br><span class="line">			radius = <span class="built_in">dist</span>(res,outer[<span class="number">0</span>]);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)&#123;</span><br><span class="line">				q[i].x = outer[i+<span class="number">1</span>].x - outer[<span class="number">0</span>].x;</span><br><span class="line">				q[i].y = outer[i+<span class="number">1</span>].y - outer[<span class="number">0</span>].y;</span><br><span class="line">				q[i].z = outer[i+<span class="number">1</span>].z - outer[<span class="number">0</span>].z;</span><br><span class="line">				sol[i] = <span class="built_in">dot</span>(q[i],q[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++)m[i][j] = <span class="built_in">dot</span>(q[i],q[j])*<span class="number">2</span>;</span><br><span class="line">			det = m[<span class="number">0</span>][<span class="number">0</span>] * m[<span class="number">1</span>][<span class="number">1</span>] * m[<span class="number">2</span>][<span class="number">2</span>]</span><br><span class="line">				+ m[<span class="number">0</span>][<span class="number">1</span>] * m[<span class="number">1</span>][<span class="number">2</span>] * m[<span class="number">2</span>][<span class="number">0</span>]</span><br><span class="line">				+ m[<span class="number">0</span>][<span class="number">2</span>] * m[<span class="number">2</span>][<span class="number">1</span>] * m[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">				- m[<span class="number">0</span>][<span class="number">2</span>] * m[<span class="number">1</span>][<span class="number">1</span>] * m[<span class="number">2</span>][<span class="number">0</span>]</span><br><span class="line">				- m[<span class="number">0</span>][<span class="number">1</span>] * m[<span class="number">1</span>][<span class="number">0</span>] * m[<span class="number">2</span>][<span class="number">2</span>]</span><br><span class="line">				- m[<span class="number">0</span>][<span class="number">0</span>] * m[<span class="number">1</span>][<span class="number">2</span>] * m[<span class="number">2</span>][<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">fabs</span>(det) &lt; eps)<span class="keyword">return</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++)&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)m[i][j] = sol[i];</span><br><span class="line">				L[j] = (m[<span class="number">0</span>][<span class="number">0</span>] * m[<span class="number">1</span>][<span class="number">1</span>] * m[<span class="number">2</span>][<span class="number">2</span>]</span><br><span class="line">					+ m[<span class="number">0</span>][<span class="number">1</span>] * m[<span class="number">1</span>][<span class="number">2</span>] * m[<span class="number">2</span>][<span class="number">0</span>]</span><br><span class="line">					+ m[<span class="number">0</span>][<span class="number">2</span>] * m[<span class="number">2</span>][<span class="number">1</span>] * m[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">					- m[<span class="number">0</span>][<span class="number">2</span>] * m[<span class="number">1</span>][<span class="number">1</span>] * m[<span class="number">2</span>][<span class="number">0</span>]</span><br><span class="line">					- m[<span class="number">0</span>][<span class="number">1</span>] * m[<span class="number">1</span>][<span class="number">0</span>] * m[<span class="number">2</span>][<span class="number">2</span>]</span><br><span class="line">					- m[<span class="number">0</span>][<span class="number">0</span>] * m[<span class="number">1</span>][<span class="number">2</span>] * m[<span class="number">2</span>][<span class="number">1</span>]</span><br><span class="line">					)/det;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)m[i][j] = <span class="built_in">dot</span>(q[i],q[j])*<span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			res = outer[<span class="number">0</span>];</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)&#123;</span><br><span class="line">				res.x += q[i].x * L[i];</span><br><span class="line">				res.y += q[i].y * L[i];</span><br><span class="line">				res.z += q[i].z * L[i];</span><br><span class="line">			&#125;</span><br><span class="line">			radius = <span class="built_in">dist</span>(res,outer[<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minball</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="built_in">ball</span>();</span><br><span class="line">	<span class="keyword">if</span>(nouter &lt; <span class="number">4</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">dist</span>(res,pt[i]) - radius &gt; eps)&#123;</span><br><span class="line">				outer[nouter] = pt[i];</span><br><span class="line">				++nouter;</span><br><span class="line">				<span class="built_in">minball</span>(i);</span><br><span class="line">				--nouter;</span><br><span class="line">				<span class="keyword">if</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">					Tpoint Tt = pt[i];</span><br><span class="line">					<span class="built_in">memmove</span>(&amp;pt[<span class="number">1</span>],&amp;pt[<span class="number">0</span>],<span class="built_in"><span class="keyword">sizeof</span></span>(Tpoint)*i);</span><br><span class="line">					pt[<span class="number">0</span>] = Tt;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">smallest_ball</span><span class="params">()</span></span>&#123;</span><br><span class="line">	radius = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; npoint;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">dist</span>(res,pt[i]) - radius &gt; eps)&#123;</span><br><span class="line">			nouter = <span class="number">1</span>;</span><br><span class="line">			outer[<span class="number">0</span>] = pt[i];</span><br><span class="line">			<span class="built_in">minball</span>(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>(radius);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; npoint;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; npoint;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x,y,z;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">		pt[i] = <span class="built_in">Tpoint</span>(x,y,z);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.10lf&quot;</span>,<span class="built_in">smallest_ball</span>());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>[模板]图论</title>
    <url>/2020/05/09/template-graph-theory/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="建图">建图</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = maxn*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn],pa[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> f,t,next;</span><br><span class="line">	<span class="built_in">Edge</span>(<span class="keyword">int</span> f = <span class="number">0</span>,<span class="keyword">int</span> t = <span class="number">0</span>,<span class="keyword">int</span> next = <span class="number">0</span>):<span class="built_in">f</span>(f),<span class="built_in">t</span>(t),<span class="built_in">next</span>(next)&#123;&#125;	</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="keyword">int</span> tcnt,cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	edge[cnt] = <span class="built_in">Edge</span>(f,t,head[f]);</span><br><span class="line">	head[f] = cnt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最短路">最短路</h1>
<h2 id="spfa">SPFA</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)dis[i] = INF;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dis[v] &gt; dis[u] + edge[i].w)&#123;</span><br><span class="line">                dis[v] = dis[u] + edge[i].w;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">                    vis[v] = <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="spfa优化">SPFA优化</h2>
<p><em>来自OI-Wiki</em></p>
<p>除了队列优化（SPFA）之外，Bellman-Ford 还有其他形式的优化，这些优化在部分图上效果明显，但在某些特殊图上，最坏复杂度可能达到指数级。</p>
<ul>
<li>堆优化：将队列换成堆，与 Dijkstra 的区别是允许一个点多次入队。在有负权边的图可能被卡成指数级复杂度。</li>
<li>栈优化：将队列换成栈（即将原来的 BFS 过程变成 DFS），在寻找负环时可能具有更高效率，但最坏时间复杂度仍然为指数级。</li>
<li>LLL 优化：将普通队列换成双端队列，每次将入队结点距离和队内距离平均值比较，如果更大则插入至队尾，否则插入队首。</li>
<li>SLF 优化：将普通队列换成双端队列，每次将入队结点距离和队首比较，如果更大则插入至队尾，否则插入队首。</li>
<li>D´Esopo-Pape 算法：将普通队列换成双端队列，如果一个节点之前没有入队，则将其插入队尾，否则插入队首。</li>
</ul>
<h2 id="dijkstra">Dijkstra</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> pair &lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; node;</span><br><span class="line">	priority_queue&lt;node,vector&lt;node&gt;,greater&lt;node&gt; &gt;q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;=n;i++)dis[i] = INF;</span><br><span class="line">	dis[s] = <span class="number">0</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dis[s],s));</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="keyword">int</span> u = q.<span class="built_in">top</span>().second;</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(vis[u])<span class="keyword">continue</span>;</span><br><span class="line">		vis[u] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">			<span class="keyword">if</span>(dis[v] &gt; dis[u] + edge[i].w)&#123;</span><br><span class="line">				dis[v] = dis[u] + edge[i].w;</span><br><span class="line">				<span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">					q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dis[v],v));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="网络流">网络流</h1>
<h2 id="最大流">最大流</h2>
<h3 id="edmonds-karp">Edmonds-Karp</h3>
<p>(慎用) <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn],parent[maxn],approve[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> from,to,next,w,cap,flow;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="keyword">int</span> n,m,start,to,cnt,ans;<span class="comment">//cnt = 0 so we can calculate &quot;backedge&quot; easily</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">int</span> cap,<span class="keyword">int</span> flow)</span></span>&#123;</span><br><span class="line">	edge[cnt].cap = cap;</span><br><span class="line">	edge[cnt].flow = flow;</span><br><span class="line">	edge[cnt].to = to;</span><br><span class="line">	edge[cnt].from = from;</span><br><span class="line">	edge[cnt].next = head[from];</span><br><span class="line">	head[from] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">	<span class="built_in">memset</span>(approve,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(approve)); </span><br><span class="line">	q.<span class="built_in">push</span>(s);</span><br><span class="line">	approve[s] = INF;</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="keyword">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">			<span class="keyword">if</span>(!approve[v] <span class="keyword">and</span> edge[i].cap &gt; edge[i].flow)&#123;</span><br><span class="line">				parent[v] = i;</span><br><span class="line">				approve[v] = <span class="built_in">min</span>(approve[u],edge[i].cap - edge[i].flow);</span><br><span class="line">				q.<span class="built_in">push</span>(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(approve[t])<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> approve[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EK</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">int</span> delta = <span class="built_in">BFS</span>(s,t);</span><br><span class="line">		<span class="keyword">if</span>(!delta)<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> u = t;u != s;u = edge[parent[u]].from)&#123;</span><br><span class="line">			<span class="keyword">int</span> curp = parent[u];</span><br><span class="line">			edge[curp].flow += delta;</span><br><span class="line">			edge[curp^<span class="number">1</span>].flow -= delta;</span><br><span class="line">		&#125;</span><br><span class="line">		flow += delta;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="dinic">Dinic</h3>
<p>记得加上容量为0的反向弧=-=</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">addedge</span>(f,t,w,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">addedge</span>(t,f,<span class="number">0</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> t,cap,flow,rev;</span><br><span class="line">	<span class="keyword">bool</span> is_rev;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt;G[maxn];</span><br><span class="line"><span class="keyword">int</span> cur[maxn],dis[maxn],vis[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dinic</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t,<span class="keyword">int</span> cap,<span class="keyword">int</span> flow,<span class="keyword">bool</span> is_rev = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> rev_cnt = G[t].<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">if</span>(is_rev)rev_cnt--;</span><br><span class="line">		G[f].<span class="built_in">push_back</span>(&#123;t,cap,flow,rev_cnt,is_rev&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">		<span class="built_in">addedge</span>(f,t,w,<span class="number">0</span>,<span class="literal">false</span>);</span><br><span class="line">		<span class="built_in">addedge</span>(t,f,<span class="number">0</span>,<span class="number">0</span>,<span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">			G[i].<span class="built_in">clear</span>();</span><br><span class="line">			G[i].<span class="built_in">shrink_to_fit</span>();</span><br><span class="line">			cur[i] = vis[i] = dis[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		flow = <span class="number">0</span>;</span><br><span class="line">		n = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">		n = N + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)cur[i] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)vis[i] = <span class="number">0</span>;</span><br><span class="line">		queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">		q.<span class="built_in">push</span>(s);</span><br><span class="line">		vis[s] = <span class="number">1</span>;</span><br><span class="line">		dis[s] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">			<span class="keyword">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">			q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> it:G[u])&#123;</span><br><span class="line">				<span class="keyword">int</span> v = it.t;</span><br><span class="line">				<span class="keyword">if</span>(!vis[v] <span class="keyword">and</span> it.cap &gt; it.flow)&#123;</span><br><span class="line">					vis[v] = <span class="number">1</span>;</span><br><span class="line">					dis[v] = dis[u] + <span class="number">1</span>;</span><br><span class="line">					q.<span class="built_in">push</span>(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> vis[t];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> T,<span class="keyword">int</span> appr)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(u == T <span class="keyword">or</span> !appr)<span class="keyword">return</span> appr;</span><br><span class="line">		<span class="keyword">int</span> flow = <span class="number">0</span>,delta = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> &amp; i = cur[u];i &lt; (<span class="keyword">int</span>)G[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">			<span class="keyword">auto</span> it = G[u][i];</span><br><span class="line">			<span class="keyword">int</span> v = it.t;</span><br><span class="line">			<span class="comment">// cur[u] = i;</span></span><br><span class="line">			<span class="keyword">if</span>(dis[u] + <span class="number">1</span> == dis[v] <span class="built_in"><span class="keyword">and</span></span> (delta = <span class="built_in">DFS</span>(v,T,<span class="built_in">min</span>(appr,it.cap - it.flow))) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">				G[u][i].flow += delta;</span><br><span class="line">				G[v][it.rev].flow -= delta;</span><br><span class="line">				flow += delta;</span><br><span class="line">				appr -= delta;</span><br><span class="line">				<span class="keyword">if</span>(!appr)<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> flow;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Maxflow</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">BFS</span>(s,t))&#123;</span><br><span class="line">			<span class="comment">// cout &lt;&lt; &quot;flow: &quot; &lt;&lt; flow &lt;&lt; endl;</span></span><br><span class="line">	 		flow += <span class="built_in">DFS</span>(s,t,INF);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> flow;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;dic;</span><br></pre></td></tr></table></figure>
<h2 id="最小费用最大流">最小费用最大流</h2>
<p>全局变量flow为最大流,cost为最小费用</p>
<p>记得反向边容量为0费用为负=-=</p>
<p><strong>注意使用到了全局变量n</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn],approve[maxn],dis[maxn],vis[maxn];</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; parent[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> t,w,cap,flow,cost,rev;</span><br><span class="line">	<span class="keyword">bool</span> is_rev;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> n,m,start,to,cnt,ans,flow,cost;</span><br><span class="line">vector&lt;Edge&gt;G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t,<span class="keyword">int</span> cap,<span class="keyword">int</span> flow,<span class="keyword">int</span> cost,<span class="keyword">bool</span> is_rev)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> rev_cnt = G[t].<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span>(is_rev)rev_cnt--;</span><br><span class="line">	G[f].<span class="built_in">push_back</span>(&#123;t,<span class="number">0</span>,cap,flow,cost,rev_cnt,is_rev&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t,<span class="keyword">int</span> cap,<span class="keyword">int</span> flow,<span class="keyword">int</span> cost)</span></span>&#123;</span><br><span class="line">	<span class="built_in">addedge</span>(f,t,cap,flow,cost,<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">addedge</span>(t,f,<span class="number">0</span>,<span class="number">0</span>,-cost,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		dis[i] = INF;</span><br><span class="line">		vis[i] = <span class="number">0</span>;</span><br><span class="line">		approve[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">	q.<span class="built_in">push</span>(s);</span><br><span class="line">	approve[s] = INF;</span><br><span class="line">	dis[s] = <span class="number">0</span>;</span><br><span class="line">	vis[s] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="keyword">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		vis[u] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">			Edge it = G[u][i];</span><br><span class="line">			<span class="keyword">int</span> v = it.t;</span><br><span class="line">			<span class="keyword">if</span>(dis[v] &gt; dis[u] + it.cost <span class="keyword">and</span> it.cap &gt; it.flow)&#123;</span><br><span class="line">				parent[v] = &#123;u,i&#125;;</span><br><span class="line">				approve[v] = <span class="built_in">min</span>(approve[u],it.cap - it.flow);</span><br><span class="line">				dis[v] = dis[u] + it.cost;</span><br><span class="line">				<span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">					vis[v] = <span class="number">1</span>;</span><br><span class="line">					q.<span class="built_in">push</span>(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> approve[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EK</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line"><span class="comment">//	int flow = 0;</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">int</span> delta = <span class="built_in">spfa</span>(s,t);</span><br><span class="line">		<span class="keyword">if</span>(!delta)<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> u = t;u != s;u = parent[u].first)&#123;</span><br><span class="line">			<span class="keyword">auto</span> [curpx,curpy] = parent[u];</span><br><span class="line">			G[curpx][curpy].flow += delta;</span><br><span class="line">			<span class="keyword">int</span> rev = G[curpx][curpy].rev;</span><br><span class="line">			G[u][rev].flow -= delta;</span><br><span class="line">		&#125;</span><br><span class="line">		flow += delta;</span><br><span class="line">		cost += dis[t]*delta;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="上下界网络流">上下界网络流</h2>
<p>以下设源汇点为<span class="math inline">\(s_1,t_1\)</span>, 超级源汇为<span class="math inline">\(S,T\)</span>, 每条边的上界为<span class="math inline">\(u\)</span>, 下界为<span class="math inline">\(l\)</span></p>
<h3 id="无源无汇上下界可行流">无源无汇上下界可行流</h3>
<p>将原网络拆成两个图: 下界网络(每条边的容量和流量都是<span class="math inline">\(l_i\)</span>, 不用实际建出) 和差网络(每条边的容量为<span class="math inline">\(u_i - l_i\)</span>, 流量为<span class="math inline">\(0\)</span>).</p>
<p>设<span class="math inline">\(pflow[i]\)</span>为第<span class="math inline">\(i\)</span>个点的净流量(即流入量减流出量). 如果<span class="math inline">\(pflow[i] &gt; 0\)</span>, 在差网络上建一条<span class="math inline">\((S,i,pflow[i])\)</span>的边来补偿<span class="math inline">\(i\)</span>点缺失的流出量. 如果<span class="math inline">\(pflow[i] &lt; 0\)</span>, 建一条<span class="math inline">\((i,T,-pflow[i])\)</span>的边. 然后跑从<span class="math inline">\(S\)</span>到<span class="math inline">\(T\)</span>的最大流, 如果<span class="math inline">\(S\)</span>的任一出边或者<span class="math inline">\(T\)</span>的任一入边没有满流则不存在可行流. 否则每条边的可行流为<span class="math inline">\(flow_i + l_i\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">int</span> S = n+<span class="number">1</span>,T = n+<span class="number">2</span>;</span><br><span class="line">N = T+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">	<span class="keyword">int</span> f,t,l,u;</span><br><span class="line">	cin &gt;&gt; f &gt;&gt; t &gt;&gt; l &gt;&gt; u;</span><br><span class="line">	pflow[f] -= l,pflow[t] += l;</span><br><span class="line">	lowedge[cnt] = l;</span><br><span class="line">	<span class="built_in">add</span>(f,t,u-l);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(pflow[i] &gt; <span class="number">0</span>)<span class="built_in">add</span>(S,i,pflow[i]);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pflow[i] &lt; <span class="number">0</span>)<span class="built_in">add</span>(i,T,-pflow[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Dinic</span>(S,T);</span><br><span class="line"><span class="keyword">bool</span> ok = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[S];~i;i = edge[i].next)&#123;</span><br><span class="line">	<span class="keyword">if</span>(edge[i].cap != edge[i].flow)ok = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; (ok?<span class="string">&quot;YES\n&quot;</span>:<span class="string">&quot;NO&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(ok)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m*<span class="number">2</span>;i += <span class="number">2</span>)cout &lt;&lt; edge[i].flow + lowedge[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="有源有汇上下界可行流">有源有汇上下界可行流</h3>
<p>在无源无汇上下界可行流的基础上, 建一条<span class="math inline">\((t_i,s_i,\infin)\)</span>的边. 这条边的流量就是可行流流量</p>
<h3 id="有源有汇上下界最大流">有源有汇上下界最大流</h3>
<p>在有源有汇上下界可行流的基础上:</p>
<p>先跑一次<span class="math inline">\(S\)</span>到<span class="math inline">\(T\)</span>的最大流, 设<span class="math inline">\(flow_1\)</span> = <span class="math inline">\((t_i,s_i,\infin)\)</span>边的流量并判断是否存在可行流. 如果存在就把这条边删掉, 再在残余网络上跑一次从<span class="math inline">\(s_i\)</span>到<span class="math inline">\(t_i\)</span>的最大流<span class="math inline">\(flow_2\)</span>. 答案即为<span class="math inline">\(flow_1 + flow2\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m,s1,t1;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; s1 &gt;&gt; t1;</span><br><span class="line">	<span class="keyword">int</span> S = n+<span class="number">1</span>,T = n+<span class="number">2</span>;</span><br><span class="line">	N = T+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> f,t,l,u;</span><br><span class="line">		cin &gt;&gt; f &gt;&gt; t &gt;&gt; l &gt;&gt; u;</span><br><span class="line">		pflow[f] -= l,pflow[t] += l;</span><br><span class="line">		lowedge[cnt] = l;</span><br><span class="line">		<span class="built_in">add</span>(f,t,u-l);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(pflow[i] &gt; <span class="number">0</span>)<span class="built_in">add</span>(S,i,pflow[i]);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(pflow[i] &lt; <span class="number">0</span>)<span class="built_in">add</span>(i,T,-pflow[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">add</span>(t1,s1,INF);</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">Dinic</span>(S,T);</span><br><span class="line">	<span class="keyword">bool</span> ok = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[S];~i;i = edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">if</span>(edge[i].cap != edge[i].flow)ok = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[s1];~i;i = edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">if</span>(edge[i].t == t1)&#123;</span><br><span class="line">			flow += <span class="built_in">abs</span>(edge[i].flow);</span><br><span class="line">			edge[i].flow = edge[i^<span class="number">1</span>].flow = edge[i].cap = edge[i^<span class="number">1</span>].cap = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	flow += <span class="built_in">Dinic</span>(s1,t1);</span><br><span class="line">	<span class="keyword">if</span>(ok)&#123;</span><br><span class="line">		cout &lt;&lt; flow;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;please go home to sleep&quot;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="有源有汇上下界最小流">有源有汇上下界最小流</h3>
<p>同有源有汇上下界最大流, 只是在第二步时跑<span class="math inline">\(t_i\)</span>到<span class="math inline">\(s_i\)</span>的最大流, 答案为<span class="math inline">\(flow_1- flow_2\)</span></p>
<h2 id="常用模型">常用模型</h2>
<h3 id="dag最小覆盖问题">DAG最小覆盖问题</h3>
<p>给定有向图<span class="math inline">\(G=(V,E)\)</span> 且 <span class="math inline">\(n = |V|\)</span>. 设 <span class="math inline">\(P\)</span> 是 <span class="math inline">\(G\)</span> 的一个简单路(顶点不相交)的集合. 如果 <span class="math inline">\(V\)</span> 中每个定点恰好在<span class="math inline">\(P\)</span>的一条路上, 则称<span class="math inline">\(P\)</span>是<span class="math inline">\(G\)</span>的一个路径覆盖. <span class="math inline">\(P\)</span>中路径可以从<span class="math inline">\(V\)</span>的任何一个定点开始, 长度也是任意的, 特别地, 可以为<span class="math inline">\(0\)</span>. <span class="math inline">\(G\)</span>的最小路径覆盖是<span class="math inline">\(G\)</span>所含路径条数最少的路径覆盖.</p>
<p>将原图的点拆为<span class="math inline">\(i\)</span>和<span class="math inline">\(i+n\)</span>. 设超级源<span class="math inline">\(S\)</span>, 超级汇<span class="math inline">\(T\)</span>. <span class="math inline">\(S\)</span>向点<span class="math inline">\(1...n\)</span>连边, 点<span class="math inline">\(1+n...n+n\)</span>向<span class="math inline">\(T\)</span>连边, 若有<span class="math inline">\(&lt;i,j&gt;\in E\)</span>则<span class="math inline">\(i\)</span>向<span class="math inline">\(j+n\)</span>连边. 求出<span class="math inline">\(S\)</span>到<span class="math inline">\(T\)</span>的最大流<span class="math inline">\(f\)</span>, 则<span class="math inline">\(n - f\)</span>为路径条数最少的路径覆盖. 方案可从流量网络中还原.</p>
<p>建图:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> S = <span class="number">2</span>*n+<span class="number">1</span>,T = <span class="number">2</span>*n+<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="built_in">add</span>(S,i,<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">add</span>(i+n,T,<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> f,t;</span><br><span class="line">		cin &gt;&gt; f &gt;&gt; t;</span><br><span class="line">		<span class="built_in">add</span>(f,t+n,<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	N = T;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="built_in">Dinic</span>(S,T);</span><br></pre></td></tr></table></figure>
<p>求方案:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solution</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> nxt[maxn],has[maxn];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)nxt[i] = <span class="number">-1</span>,has[i] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= cnt;i+=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">int</span> u = edge[i].f,v = edge[i].t - n;</span><br><span class="line">		<span class="keyword">if</span>(edge[i].flow == <span class="number">1</span> <span class="keyword">and</span> v &gt; <span class="number">1</span> <span class="keyword">and</span> u &lt;= n)&#123;</span><br><span class="line">			nxt[u] = v;</span><br><span class="line">			has[v] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)<span class="keyword">if</span>(!has[i])&#123;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="keyword">int</span> u = nxt[i];</span><br><span class="line">		<span class="keyword">while</span>(u != <span class="number">-1</span>)&#123;</span><br><span class="line">			cout &lt;&lt; u &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">			u = nxt[u];</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二分图匹配">二分图匹配</h1>
<h2 id="常识性知识">常识性知识</h2>
<ul>
<li><p>所有的树是二分图</p></li>
<li><p>所有的网格图和四边形图是二分图</p></li>
<li><p>设<span class="math inline">\(u,v\)</span>为两个<span class="math inline">\(k\)</span>进制数且<span class="math inline">\(u,v\)</span>只有一位不同且该位差值为1. 若图中的所有边的两个顶点<span class="math inline">\(u_i,v_i\)</span>均满足该性质, 则该图是二分图(将每一位加起来后的值按奇偶分类)</p></li>
<li><p><strong>最大匹配数</strong>：最大匹配的匹配边的数目</p>
<p><strong>最小点覆盖数</strong>：选取最少的点，使任意一条边至少有一个端点被选择</p>
<p><strong>最大独立数</strong>：选取最多的点，使任意所选两点均不相连</p>
<p><strong>最小路径覆盖数</strong>：对于一个 DAG（有向无环图），选取最少条路径，使得每个顶点属于且仅属于一条路径。路径长可以为 0（即单个点）。</p>
<p>定理1：最大匹配数 = 最小点覆盖数（Konig 定理）</p>
<p>定理2：最大匹配数 = 最大独立数</p>
<p>定理3：最小路径覆盖数 = 顶点数 - 最大匹配数</p></li>
</ul>
<h2 id="二分图最大匹配">二分图最大匹配</h2>
<h3 id="网络流做法">网络流做法</h3>
<p>建立超级源<span class="math inline">\(S\)</span>和超级汇<span class="math inline">\(T\)</span>, 从<span class="math inline">\(S\)</span>向每个左端点连边, 每个右端点向<span class="math inline">\(T\)</span>连边, 端点之间按给出的图连边(仅从左端点向右端点), 边权均为1.</p>
<p><span class="math inline">\(S\)</span>到<span class="math inline">\(T\)</span>的最大流就是最大匹配</p>
<p>用Dinic实现 复杂度<span class="math inline">\(O(\sqrt n m)\)</span></p>
<h3 id="km">KM</h3>
<p>复杂度<span class="math inline">\(O(nm)\)</span></p>
<p><code>match[v]</code>为<span class="math inline">\(v\)</span>的匹配点.</p>
<p>a为左端点点的个数, b为右端点点的个数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">KM</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">		<span class="keyword">if</span>(vis[v])<span class="keyword">continue</span>;</span><br><span class="line">		vis[v] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(!match[v] <span class="keyword">or</span> <span class="built_in">KM</span>(match[v]))&#123;</span><br><span class="line">			match[v] = u;</span><br><span class="line">			match[u] = v;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> match_cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= a;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= a+b;j++)vis[j] = <span class="number">0</span>;</span><br><span class="line">    match_cnt += <span class="built_in">KM</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; match_cnt;</span><br></pre></td></tr></table></figure>
<h2 id="二分图最大带权匹配">二分图最大带权匹配</h2>
<p>复杂度<span class="math inline">\(O(n^3)\)</span>. 使用<code>addEdge(f,t,w)</code>加边. 注意下标从0开始. <strong>有空改成自己的板子</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hungarian</span> &#123;</span>  <span class="comment">// km</span></span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; matchx;  <span class="comment">// 左集合对应的匹配点</span></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; matchy;  <span class="comment">// 右集合对应的匹配点</span></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; pre;     <span class="comment">// 连接右集合的左点</span></span><br><span class="line">  vector&lt;<span class="keyword">bool</span>&gt; visx;   <span class="comment">// 拜访数组 左</span></span><br><span class="line">  vector&lt;<span class="keyword">bool</span>&gt; visy;   <span class="comment">// 拜访数组 右</span></span><br><span class="line">  vector&lt;T&gt; lx;</span><br><span class="line">  vector&lt;T&gt; ly;</span><br><span class="line">  vector&lt;vector&lt;T&gt; &gt; g;</span><br><span class="line">  vector&lt;T&gt; slack;</span><br><span class="line">  T inf;</span><br><span class="line">  T res;</span><br><span class="line">  queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  <span class="keyword">int</span> org_n;</span><br><span class="line">  <span class="keyword">int</span> org_m;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">hungarian</span>(<span class="keyword">int</span> _n, <span class="keyword">int</span> _m) &#123;</span><br><span class="line">    org_n = _n;</span><br><span class="line">    org_m = _m;</span><br><span class="line">    n = <span class="built_in">max</span>(_n, _m);</span><br><span class="line">    inf = numeric_limits&lt;T&gt;::<span class="built_in">max</span>();</span><br><span class="line">    res = <span class="number">0</span>;</span><br><span class="line">    g = vector&lt;vector&lt;T&gt; &gt;(n, vector&lt;T&gt;(n));</span><br><span class="line">    matchx = vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">-1</span>);</span><br><span class="line">    matchy = vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">-1</span>);</span><br><span class="line">    pre = vector&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">    visx = vector&lt;<span class="keyword">bool</span>&gt;(n);</span><br><span class="line">    visy = vector&lt;<span class="keyword">bool</span>&gt;(n);</span><br><span class="line">    lx = vector&lt;T&gt;(n, -inf);</span><br><span class="line">    ly = vector&lt;T&gt;(n);</span><br><span class="line">    slack = vector&lt;T&gt;(n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    g[u][v] = <span class="built_in">max</span>(w, <span class="number">0</span>);  <span class="comment">// 负值还不如不匹配 因此设为0不影响</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    visy[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (matchy[v] != <span class="number">-1</span>) &#123;</span><br><span class="line">      q.<span class="built_in">push</span>(matchy[v]);</span><br><span class="line">      visx[matchy[v]] = <span class="literal">true</span>;  <span class="comment">// in S</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到新的未匹配点 更新匹配点 pre 数组记录着&quot;非匹配边&quot;上与之相连的点</span></span><br><span class="line">    <span class="keyword">while</span> (v != <span class="number">-1</span>) &#123;</span><br><span class="line">      matchy[v] = pre[v];</span><br><span class="line">      <span class="built_in">swap</span>(v, matchx[pre[v]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">push</span>(i);</span><br><span class="line">    visx[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!visy[v]) &#123;</span><br><span class="line">            T delta = lx[u] + ly[v] - g[u][v];</span><br><span class="line">            <span class="keyword">if</span> (slack[v] &gt;= delta) &#123;</span><br><span class="line">              pre[v] = u;</span><br><span class="line">              <span class="keyword">if</span> (delta) &#123;</span><br><span class="line">                slack[v] = delta;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">check</span>(v)) &#123;  <span class="comment">// delta=0 代表有机会加入相等子图 找增广路</span></span><br><span class="line">                                      <span class="comment">// 找到就return 重建交错树</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 没有增广路 修改顶标</span></span><br><span class="line">      T a = inf;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visy[j]) &#123;</span><br><span class="line">          a = <span class="built_in">min</span>(a, slack[j]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visx[j]) &#123;  <span class="comment">// S</span></span><br><span class="line">          lx[j] -= a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (visy[j]) &#123;  <span class="comment">// T</span></span><br><span class="line">          ly[j] += a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// T&#x27;</span></span><br><span class="line">          slack[j] -= a;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visy[j] &amp;&amp; slack[j] == <span class="number">0</span> &amp;&amp; <span class="built_in">check</span>(j)) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始顶标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        lx[i] = <span class="built_in">max</span>(lx[i], g[i][j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="built_in">fill</span>(slack.<span class="built_in">begin</span>(), slack.<span class="built_in">end</span>(), inf);</span><br><span class="line">      <span class="built_in">fill</span>(visx.<span class="built_in">begin</span>(), visx.<span class="built_in">end</span>(), <span class="literal">false</span>);</span><br><span class="line">      <span class="built_in">fill</span>(visy.<span class="built_in">begin</span>(), visy.<span class="built_in">end</span>(), <span class="literal">false</span>);</span><br><span class="line">      <span class="built_in">bfs</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// custom</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (g[i][matchx[i]] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        res += g[i][matchx[i]];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        matchx[i] = <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; org_n; i++) &#123;</span><br><span class="line">      cout &lt;&lt; matchx[i] + <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="应用">应用</h2>
<h3 id="二分图最大点独立集">二分图最大点独立集</h3>
<p>个数为顶点数-最大匹配数</p>
<h3 id="二分图最小点覆盖könig-定理">二分图最小点覆盖(König 定理)</h3>
<p>最小点覆盖: 选择最小的点集<span class="math inline">\(S\)</span> 使得任意一条边至少有一个顶点在<span class="math inline">\(S\)</span>里. 二分图的最小点覆盖数 = 最大匹配数.</p>
<p>构造方案: 从左边的未匹配点开始dfs, 从左向右走未匹配边, 从右向左走匹配边(类似KM), 将经过的点全部标记. 左边的未标记点和右边的标记点就是<span class="math inline">\(S\)</span>.</p>
<p><code>match[v] = u</code>表示<span class="math inline">\(u,v\)</span>是一条匹配边. <code>mvis[]</code>代表该过程标记的点. (在用Dinic求二分图时需要去掉源点汇点<code>S,T</code>)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> match[maxn],mvis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MVC</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> S,<span class="keyword">int</span> T,<span class="keyword">bool</span> flag)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(u == S <span class="keyword">or</span> u == T)<span class="keyword">return</span>;</span><br><span class="line">	mvis[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(flag)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!mvis[match[u]])<span class="built_in">MVC</span>(match[u],S,T,!flag);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">			<span class="keyword">if</span>(mvis[v])<span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">MVC</span>(v,S,T,!flag);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mvc</code>即为所求点集:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n1;i++)<span class="keyword">if</span>(!match[i])&#123;</span><br><span class="line">		<span class="built_in">MVC</span>(i,S,T,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;mvc;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n1;i++)<span class="keyword">if</span>(!mvis[i])mvc.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n1+<span class="number">1</span>;i &lt;= n1+n2;i++)<span class="keyword">if</span>(mvis[i])mvc.<span class="built_in">push_back</span>(i);</span><br></pre></td></tr></table></figure>
<h3 id="二分图博弈">二分图博弈</h3>
<p>考虑如下问题: 有两名玩家<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>, 轮流进行游戏且<span class="math inline">\(A\)</span>先手. 玩家每次可从当前状态转移到相邻的状态, 且已经访问过的状态不能再次访问. 状态可分为两个不相交的集合(建成二分图). 不能操作的玩家输.</p>
<p>概念:</p>
<ul>
<li>完美匹配: 图中所有点均属于最大匹配</li>
<li>必经点: 任意一个最大匹配均包含的点</li>
<li>非必经点: 至少一个最大匹配不包含的点.</li>
</ul>
<p>结论: 如果状态图最大匹配是完美匹配, 则<span class="math inline">\(A\)</span>必败. 否则, 如果游戏从非必经点开始, <span class="math inline">\(A\)</span>必胜. 其他情况<span class="math inline">\(A\)</span>必败.</p>
<p>简要推导: 如果<span class="math inline">\(A\)</span>从必经点开始, 那么<span class="math inline">\(B\)</span>总存在一种策略让自己走非匹配边, 使得<span class="math inline">\(A\)</span>必须走上匹配边, 最后<span class="math inline">\(A\)</span>将无路可走. 而如果<span class="math inline">\(A\)</span>从非必经点开始, 则<span class="math inline">\(A\)</span>一定会走到一个必经点, 转换为<span class="math inline">\(B\)</span>从必经点开始.</p>
<p>至此问题转化为求二分图中的所有非必经点.</p>
<h4 id="方法一-km">方法一: KM</h4>
<p>时间复杂度<span class="math inline">\(O(nm)\)</span>, 适用于比较小的图.</p>
<p>全局变量: <code>bool unne[]</code>. <span class="math inline">\(unne[i] = 1\)</span>表示<span class="math inline">\(i\)</span>为非必经点.</p>
<p>需要先跑一遍KM, 再对每个点<span class="math inline">\(i\)</span>跑<code>unness(i)</code>. <strong>注意特判度为0的点</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> unne[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unness</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(unne[u])<span class="keyword">return</span>;</span><br><span class="line">	unne[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">		<span class="keyword">if</span>(match[v])<span class="built_in">unness</span>(match[v]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法2网络流">方法2:网络流</h4>
<p>这里用Dinic跑. 建图约定: 和超级源相连的点颜色标为<span class="math inline">\(1\)</span>, 和超级汇相连的点颜色标为<span class="math inline">\(0\)</span>. 从<span class="math inline">\(S\)</span>出发走非满流边能到达的和<span class="math inline">\(S\)</span>相邻的点, 以及从<span class="math inline">\(T\)</span>出发走满流边能到达的和<span class="math inline">\(T\)</span>相邻的点均为非必经点. 复杂度<span class="math inline">\(O(\sqrt n m)\)</span></p>
<p>使用时调用<code>cal_unne(S,1)</code>和<code>cal_unne(T,0)</code>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> unne[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal_unne</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(col[u] == c)unne[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">		<span class="keyword">if</span>(edge[i].cap - edge[i].flow == c <span class="keyword">and</span> !unne[v])<span class="built_in">cal_unne</span>(v,c);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法3-判断单个点">方法3: 判断单个点</h4>
<p>假设判断点<span class="math inline">\(s\)</span>. 先建出整个图, 但不连接<span class="math inline">\(S-s\)</span>, <span class="math inline">\(s-T\)</span>. 跑一遍网络流. 再将<span class="math inline">\(S-s,s-T\)</span>连接, 在残量网络里继续跑网络流. 如果流量增加那么<span class="math inline">\(s\)</span>是非必经点.</p>
<h1 id="连通性与环">连通性与环</h1>
<h2 id="割点">割点</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dfn[u])<span class="keyword">return</span>;</span><br><span class="line">	dfn[u] = low[u] = dfsclock++;</span><br><span class="line">	<span class="keyword">int</span> child = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">			<span class="built_in">Tarjan</span>(v,fa);</span><br><span class="line">			low[u] = <span class="built_in">min</span>(low[v],low[u]);</span><br><span class="line">			<span class="keyword">if</span>(u == fa)child++;</span><br><span class="line">			<span class="keyword">if</span>(low[v] &gt;= dfn[u] <span class="keyword">and</span> u != fa)iscut[u] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		low[u] = <span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(fa == u <span class="keyword">and</span> child &gt; <span class="number">1</span>)iscut[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="scc强连通分量">SCC/强连通分量</h2>
<h3 id="kosaraju">Kosaraju</h3>
<p>G为原图，GT为反图，GD为缩点后的DAG</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt;G[maxn],GT[maxn],GD[maxn],GDR[maxn];</span><br><span class="line"><span class="keyword">int</span> sccno[maxn],siz[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> out[maxn];</span><br><span class="line"><span class="keyword">int</span> scccnt;</span><br><span class="line">map&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">bool</span>&gt;dup;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;r_topo;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	G[f].<span class="built_in">push_back</span>(t);</span><br><span class="line">	GT[t].<span class="built_in">push_back</span>(f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addDAG</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	GD[f].<span class="built_in">push_back</span>(t);</span><br><span class="line">	GDR[t].<span class="built_in">push_back</span>(f);</span><br><span class="line">	out[f]++;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">DFS1</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(vis[u])<span class="keyword">return</span>;</span><br><span class="line">	vis[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> v:G[u])<span class="built_in">DFS1</span>(v);</span><br><span class="line">	r_topo.<span class="built_in">push_back</span>(u);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS2</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(sccno[u])<span class="keyword">return</span>;</span><br><span class="line">	sccno[u] = scccnt;</span><br><span class="line">	siz[scccnt]++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> v:GT[u])<span class="built_in">DFS2</span>(v);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findscc</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)<span class="built_in">DFS1</span>(i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!sccno[r_topo[i]])&#123;</span><br><span class="line">			scccnt++;</span><br><span class="line">			<span class="built_in">DFS2</span>(r_topo[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildmap</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">1</span>;u &lt;= n;u++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> v:G[u])&#123;</span><br><span class="line">			<span class="keyword">if</span>(sccno[u] != sccno[v])&#123;</span><br><span class="line">				<span class="comment">// not nessseary</span></span><br><span class="line">				<span class="comment">// if(!dup[&#123;sccno[u],sccno[v]&#125;])&#123;</span></span><br><span class="line">				<span class="comment">// 	dup[&#123;sccno[u],sccno[v]&#125;] = 1;</span></span><br><span class="line">				<span class="comment">// &#125;</span></span><br><span class="line">				<span class="built_in">addDAG</span>(sccno[u],sccno[v]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="桥">桥</h2>
<p>一种比较好理解的求桥的方法 <strong>(注意无法用来求割顶</strong></p>
<p><span class="math inline">\(dp[u]\)</span>表示跨过<span class="math inline">\(u\)</span>的反向边的数量.如果<span class="math inline">\(dp[u] == 0\)</span>则<span class="math inline">\(&lt;fa,u&gt;\)</span>为桥(<span class="math inline">\(fa\)</span>是<span class="math inline">\(u\)</span>的父亲)</p>
<p>调用时需初始化<span class="math inline">\(dep[root] = 1\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cal_bri</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	dp[u] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">		<span class="keyword">if</span>(v == fa)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(!dep[v])&#123;</span><br><span class="line">			dep[v] = dep[u]+<span class="number">1</span>;</span><br><span class="line">			<span class="built_in">Cal_bri</span>(v,u);</span><br><span class="line">			dp[u] += dp[v];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(dep[v] &gt; dep[u])dp[u]--;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(dep[v] &lt; dep[u])&#123;</span><br><span class="line">				dp[u]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!dp[u] <span class="keyword">and</span> dep[u] &gt; <span class="number">1</span>)ok = <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="仙人掌">仙人掌</h2>
<p>(接上文)点仙人掌中求环并缩点</p>
<p><span class="math inline">\(backcnt\)</span>为全局变量,初始化为<span class="math inline">\(n+1\)</span>(点的个数+1)</p>
<p><span class="math inline">\(phash[u]\)</span>返回环的标号,从<span class="math inline">\(n+1\)</span>开始.若不在环内则<span class="math inline">\(phash[u] == u\)</span></p>
<p>调用时初始化<span class="math inline">\(dep[root] = 1\)</span>,注意缩点后需要重新寻找根节点(缩点代码未给出)</p>
<p>原理参见https://codeforces.com/blog/entry/68138 这个东西应该找简单环都可以用(? <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cal_bri</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	dp[u] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">bool</span> ok = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = rhead[u];~i;i = redge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = redge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(v == fa)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(!dep[v])&#123;</span><br><span class="line">			dep[v] = dep[u]+<span class="number">1</span>;</span><br><span class="line">			<span class="built_in">Cal_bri</span>(v,u);</span><br><span class="line">			dp[u] += dp[v];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(dep[v] &gt; dep[u])dp[u]--;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(dep[v] &lt; dep[u])&#123;</span><br><span class="line">				in[v]++;</span><br><span class="line">				dp[u]++;</span><br><span class="line">				ok = <span class="number">1</span>;</span><br><span class="line">				redge[i].cnt = ++backcnt;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ok)phash[u] = backcnt;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		phash[u] = u;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = rhead[u];~i;i = redge[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = redge[i].to;</span><br><span class="line">			<span class="keyword">if</span>(v == fa)<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(phash[v] != v <span class="keyword">and</span> !in[v])&#123;</span><br><span class="line">				phash[u] = phash[v];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="bfs求最小环">BFS求最小环</h2>
<p>见代码=-=可以画个BFS树或者手模感悟一下</p>
<p>记得得枚举1...n的所有起点,所以复杂度是<span class="math inline">\(O(n^2)\)</span> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">	dis[s] = <span class="number">0</span>;</span><br><span class="line">	queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;q;</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(s,<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="keyword">auto</span> now = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">int</span> u = now.first,fa = now.second;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">			<span class="keyword">if</span>(v == fa)<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(dis[v] == <span class="number">-1</span>)&#123;</span><br><span class="line">				dis[v] = dis[u]+<span class="number">1</span>;</span><br><span class="line">				q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(v,u));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				ans = <span class="built_in">min</span>(ans,dis[v]+dis[u]+<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="floyd求最小环">Floyd求最小环</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> val[maxn + <span class="number">1</span>][maxn + <span class="number">1</span>];  <span class="comment">// 原图的邻接矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">floyd</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> dis[maxn + <span class="number">1</span>][maxn + <span class="number">1</span>];  <span class="comment">// 最短路矩阵</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) dis[i][j] = val[i][j];  <span class="comment">// 初始化最短路矩阵</span></span><br><span class="line">  <span class="keyword">int</span> ans = inf;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">        ans = std::<span class="built_in">min</span>(ans, dis[i][j] + val[i][k] + val[k][j]);  <span class="comment">// 更新答案</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        dis[i][j] = std::<span class="built_in">min</span>(</span><br><span class="line">            dis[i][j], dis[i][k] + dis[k][j]);  <span class="comment">// 正常的 floyd 更新最短路矩阵</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="sat">2-SAT</h1>
<p>参数a,x,b,y代表<span class="math inline">\(x_a\)</span>为x或<span class="math inline">\(x_b\)</span>为y x,y是bool 是的我知道这个变量起的很弱智 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P4782</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">4E6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> from,to,next;</span><br><span class="line">&#125;edge[maxm],edgeT[maxm];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;r_topo;</span><br><span class="line"><span class="keyword">int</span> scc_no[maxn],scc_cnt;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span>,cntT = <span class="number">1</span>,head[maxn],headT[maxn],n,m,q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	edge[cnt].from = f;</span><br><span class="line">	edge[cnt].to = t;</span><br><span class="line">	edge[cnt].next = head[f];</span><br><span class="line">	head[f] = cnt++;</span><br><span class="line">	edgeT[cntT].from = t;</span><br><span class="line">	edgeT[cntT].to = f;</span><br><span class="line">	edgeT[cntT].next = headT[t];</span><br><span class="line">	headT[t] = cntT++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS1</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(vis[u])<span class="keyword">return</span>;</span><br><span class="line">	vis[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		<span class="built_in">DFS1</span>(edge[i].to);</span><br><span class="line">	&#125;</span><br><span class="line">	r_topo.<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS2</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(scc_no[u])<span class="keyword">return</span>;</span><br><span class="line">	scc_no[u] = scc_cnt;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = headT[u];~i;i = edgeT[i].next)<span class="built_in">DFS2</span>(edgeT[i].to);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findscc</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">2</span>*n;i++)<span class="built_in">DFS1</span>(i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>*n<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!scc_no[r_topo[i]])&#123;</span><br><span class="line">			scc_cnt++;</span><br><span class="line">			<span class="built_in">DFS2</span>(r_topo[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen(&quot;P4782.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">	<span class="built_in">memset</span>(headT,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(headT));</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> a,b,x,y;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;a,&amp;x,&amp;b,&amp;y);</span><br><span class="line">		<span class="built_in">addedge</span>(a+n*(x&amp;<span class="number">1</span>),b+n*(y^<span class="number">1</span>));</span><br><span class="line">		<span class="built_in">addedge</span>(b+n*(y&amp;<span class="number">1</span>),a+n*(x^<span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">findscc</span>();</span><br><span class="line">	<span class="keyword">bool</span> ok = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)<span class="keyword">if</span>(scc_no[i] == scc_no[i+n])&#123;</span><br><span class="line">		ok = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!ok)<span class="built_in">printf</span>(<span class="string">&quot;IMPOSSIBLE&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;POSSIBLE\n&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,scc_no[i] &gt; scc_no[i+n]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="弦图">弦图</h1>
<h2 id="定义">定义</h2>
<p>子图: 点集和边集均为原图点集和边集子集的图.</p>
<p>导出子图: 点集为原图点集的子集, 且边集中所有边的两个端点都在导出子图的点集中.</p>
<p>团: 是完全图的子图</p>
<p>单纯点: 设<span class="math inline">\(N(x)\)</span>为所有与<span class="math inline">\(x\)</span>相邻的点的集合, 若<span class="math inline">\(\{x\} + N(x)\)</span>的导出子图是团, 则<span class="math inline">\(x\)</span>是单纯点</p>
<h2 id="完美消除序列">完美消除序列</h2>
<p>此处完美消除序列(Perfect Elimination Ordering)的定义为: 令 <span class="math inline">\(n=|V|\)</span>，完美消除序列 <span class="math inline">\(v_1,v_2,\ldots ,v_n\)</span> 为 <span class="math inline">\(1,2,\ldots ,n\)</span> 的一个排列，满足 <span class="math inline">\(v_i\)</span> 在 <span class="math inline">\(\{v_i,v_{i+1},\ldots ,v_n\}\)</span> 的导出子图中为单纯点.</p>
<p>注意该定义可能与部分论文顺序相反.</p>
<h3 id="最大势算法mcs">最大势算法(MCS)</h3>
<h4 id="优先队列做法">优先队列做法</h4>
<p><strong>已弃用, 有可能RE</strong></p>
<p>复杂度: <span class="math inline">\(O((n+m)\log n)\)</span></p>
<p>输入: <span class="math inline">\(n\)</span>, 点数</p>
<p><span class="math inline">\(head[],edge[],cnt\)</span>, 无向图(全局变量)</p>
<p>使用的全局变量:<span class="math inline">\(vis[]\)</span></p>
<p>输出: <code>vector&lt;int&gt;</code>, 长度为<span class="math inline">\(n\)</span>的完美消除序列.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">MCS</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;res;</span><br><span class="line">	priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;pq;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		label[i] = vis[i] = <span class="number">0</span>;</span><br><span class="line">		pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>,i&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> step = <span class="number">1</span>;step &lt;= n;step++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(pq.<span class="built_in">size</span>())&#123;</span><br><span class="line">			<span class="keyword">int</span> u = pq.<span class="built_in">top</span>().second;</span><br><span class="line">			pq.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">if</span>(!vis[u])&#123;</span><br><span class="line">				res.<span class="built_in">push_back</span>(u);</span><br><span class="line">				vis[u] = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">					<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">					<span class="keyword">if</span>(vis[v])<span class="keyword">continue</span>;</span><br><span class="line">					label[v]++;</span><br><span class="line">					pq.<span class="built_in">push</span>(&#123;label[v],v&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="链表做法">链表做法</h4>
<p>复杂度<span class="math inline">\(O(n+m)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">MCS</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> best = <span class="number">0</span>;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;res;</span><br><span class="line">	vector&lt;list&lt;<span class="keyword">int</span>&gt; &gt;<span class="built_in">link</span>(n+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		label[i] = vis[i] = <span class="number">0</span>;</span><br><span class="line">		link[<span class="number">0</span>].<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> step = <span class="number">1</span>;step &lt;= n;step++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(best &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!link[best].<span class="built_in">size</span>())&#123;</span><br><span class="line">				best--;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> u = link[best].<span class="built_in">front</span>();</span><br><span class="line">			link[best].<span class="built_in">pop_front</span>();</span><br><span class="line">			<span class="keyword">if</span>(!vis[u])&#123;</span><br><span class="line">				vis[u] = <span class="number">1</span>;</span><br><span class="line">				res.<span class="built_in">push_back</span>(u);</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">					<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">					<span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">						label[v]++;</span><br><span class="line">						link[label[v]].<span class="built_in">push_back</span>(v);</span><br><span class="line">						<span class="keyword">if</span>(label[v] &gt; best)best = label[v];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断完美消除序列是否合法">判断完美消除序列是否合法</h3>
<p>根据完美消除序列的定义，设 <span class="math inline">\(v_i\)</span> 在 <span class="math inline">\({v_i,v_{i+1},\ldots , v_n}\)</span> 中相邻的点从小到大为 <span class="math inline">\(\{v_{c_1},v_{c_2},\ldots ,v_{c_k} \}\)</span>，则只需判断 <span class="math inline">\(v_{c_1}\)</span> 与其他点是否直接连通即可</p>
<p>输入:<code>int n</code>-图的点数 <code>vector&lt;int&gt; &amp; peo</code>-完美消除序列</p>
<p>输出: 该序列是否合法</p>
<p>时间复杂度<span class="math inline">\(O(m\log n + n)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chord_check</span><span class="params">(<span class="keyword">int</span> n,vector&lt;<span class="keyword">int</span>&gt; &amp; peo)</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">bool</span> mark[maxn];</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> rank[maxn];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)rank[peo[i]] = i,mark[i] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> u:peo)&#123;</span><br><span class="line">		vector&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;tmp;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">			<span class="keyword">if</span>(!mark[v])tmp.<span class="built_in">push_back</span>(&#123;rank[v],v&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">sort</span>(tmp.<span class="built_in">begin</span>(),tmp.<span class="built_in">end</span>());</span><br><span class="line">		<span class="keyword">if</span>(tmp.<span class="built_in">size</span>())&#123;</span><br><span class="line">			<span class="keyword">int</span> u = tmp[<span class="number">0</span>].second;</span><br><span class="line">			set&lt;<span class="keyword">int</span>&gt;tmpadj;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">				<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">				tmpadj.<span class="built_in">insert</span>(v);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; (<span class="keyword">int</span>)tmp.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(!tmpadj.<span class="built_in">count</span>(tmp[i].second))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		mark[u] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="弦图最大独立集最小团覆盖">弦图最大独立集/最小团覆盖</h2>
<p>最大独立集: 从前往后遍历完美消除序列, 每次选取不在独立集且与独立集无邻边的点加入独立集中.</p>
<p>最小团覆盖: 设最大独立集为 <span class="math inline">\(\{v_1,v_2,\ldots ,v_t\}\)</span>, 则团的集合<span class="math inline">\(\{\)</span> <span class="math inline">\(\{v_1+N(v_1)\},\{v_2+N(v_2)\},... ,\{v_t+N(v_t)\}\)</span> <span class="math inline">\(\}\)</span>为图的最小团覆盖. 时间复杂度均为 <span class="math inline">\(O(n+m)\)</span></p>
<h2 id="弦图的色数弦图的团数">弦图的色数/弦图的团数</h2>
<p>一种构造方法：按完美消除序列从后往前依次给每个点染色，给每个点染上可以染的最小颜色。时间复杂度 <span class="math inline">\(O(m+n)\)</span>。</p>
<p>正确性证明：设以上方法使用了 <span class="math inline">\(t\)</span> 种颜色，则 <span class="math inline">\(t\ge \chi(G)\)</span>。由于团上每个点都是不同的颜色，所以 <span class="math inline">\(t=\omega(G)\)</span>，由 <strong>Lemma 1</strong>，<span class="math inline">\(t=\omega(G)\le \chi(G)\)</span>。综上，可得 <span class="math inline">\(t=\chi(G)=\omega(G)\)</span>。</p>
<p>无需染色方案，只需求出弦图的色数/团数时，可以取 <span class="math inline">\(|\{x\}+N(x)|\)</span> 的最大值得到。</p>
<h1 id="树">树</h1>
<h2 id="最小生成树">最小生成树</h2>
<h3 id="结论">结论</h3>
<ul>
<li>同一个图的任意最小生成树上, 每种权值的边的数量是固定的.</li>
<li>切分定理：对于给定图的任意割，横跨两个割集的边中权值严格最小的边必定在最小生成树上</li>
<li>假设权值为<span class="math inline">\(w\)</span>的边需要<span class="math inline">\(k\)</span>条来形成最小生成树且已经加入<span class="math inline">\(k\)</span>条, 那么无论选择了哪些合法的边, 图的联通状态都是相同的</li>
</ul>
<h3 id="prim">Prim</h3>
<p><span class="math inline">\(dis[i]\)</span>表示第<span class="math inline">\(i\)</span>条树边的长度,标号从<span class="math inline">\(2\)</span>到<span class="math inline">\(n\)</span>.</p>
<p><span class="math inline">\(d[i][j]\)</span>为边<span class="math inline">\(&lt;i,j&gt;\)</span>权值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)vis[i] = <span class="number">0</span>,dis[i] = INF;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)<span class="keyword">if</span>(!vis[j])&#123;</span><br><span class="line">			<span class="keyword">if</span>(!x <span class="keyword">or</span> dis[x] &gt; dis[j])x = j;</span><br><span class="line">		&#125;</span><br><span class="line">		vis[x] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)<span class="keyword">if</span>(!vis[j])&#123;</span><br><span class="line">			dis[j] = <span class="built_in">min</span>(dis[j],d[x][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ll tans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		tans += dis[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="欧拉序">欧拉序</h2>
<h3 id="定义-1">定义</h3>
<p>在dfs整个树的过程中, 第一次访问或回溯时均记录下经过的节点即为欧拉序. 例:</p>
<p><img src="E:\Github\hexo\source\_posts\image-20211109105112159.png" alt="image-20211109105112159" style="zoom:50%;" /></p>
<p>这棵树的欧拉序(根节点为1)为<code>1 2 3 4 3 7 3 2 5 6 5 2 1</code></p>
<p>一棵<span class="math inline">\(n\)</span>个节点的树欧拉序长度为<span class="math inline">\(2n - 1\)</span>. (<span class="math inline">\(n\)</span>个点, <span class="math inline">\(n-1\)</span>条边)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> clk;<span class="comment">//下标指针</span></span><br><span class="line"><span class="keyword">int</span> euler[maxn],dep[maxn],fir[maxn],lst[maxn];<span class="comment">//欧拉序, 深度, 节点第一次(最后一次)在欧拉序中出现的位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	euler[++clk] = u;</span><br><span class="line">	fir[u] = lst[u] = clk;</span><br><span class="line">	dep[u] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> v:G[u])&#123;</span><br><span class="line">		<span class="keyword">if</span>(v != fa)&#123;</span><br><span class="line">			<span class="built_in">dfs</span>(v,u);</span><br><span class="line">			euler[++clk] = u;</span><br><span class="line">            lst[u] = clk;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="将树上问题转化为区间问题">将树上问题转化为区间问题</h3>
<p>欧拉序可将一棵树映射为一维的区间. <span class="math inline">\([fir[u],lst[u]]\)</span>之间的欧拉序对应的是以<span class="math inline">\(u\)</span>为根的子树的区间.</p>
<h3 id="求解lca">求解LCA</h3>
<p><span class="math inline">\(O(n\log n)\)</span>预处理, <span class="math inline">\(O(1)\)</span>查询. <span class="math inline">\(u,v\)</span>之间的LCA即为欧拉序<span class="math inline">\([fir[u],fir[v]]\)</span>之间深度最小的点.</p>
<p>ST表中保存的是点的编号, 但按点的深度来比较.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ST_init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	lg[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)ST[i][<span class="number">0</span>] = euler[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; maxn;i++)lg[i] = lg[i&gt;&gt;<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j) &lt;= n;j++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i +(<span class="number">1</span>&lt;&lt;j) - <span class="number">1</span>&lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> v1 = ST[i][j - <span class="number">1</span>],v2 = ST[i + (<span class="number">1</span>&lt;&lt;(j - <span class="number">1</span>))][j - <span class="number">1</span>];</span><br><span class="line">		ST[i][j] = dep[v1] &lt; dep[v2]?v1:v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(fir[u] &gt; fir[v])<span class="built_in">swap</span>(u,v);</span><br><span class="line">	u = fir[u],v = fir[v];</span><br><span class="line">	<span class="keyword">int</span> k = lg[v-u+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> v1 = ST[u][k],v2 = ST[v - (<span class="number">1</span>&lt;&lt;k) + <span class="number">1</span>][k];</span><br><span class="line">	<span class="keyword">return</span> dep[v1] &lt; dep[v2]?v1:v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dfs序">DFS序</h2>
<p><img src="E:\Github\hexo\source\_posts\image-20211109105112159.png" alt="image-20211109105112159" style="zoom:50%;" /></p>
<p>上图的DFS序(不唯一)为<code>1 2 3 4 4 7 7 3 5 6 6 5 2 1</code></p>
<p>一棵大小为<span class="math inline">\(n\)</span>的树DFS序长度为<span class="math inline">\(2n\)</span>.</p>
<h2 id="最近公共祖先lca-倍增">最近公共祖先(LCA)-倍增</h2>
<p>预处理<span class="math inline">\(O(n)\)</span>, 单次查询<span class="math inline">\(O(\log)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(u == fa)<span class="keyword">return</span>;</span><br><span class="line">	dep[u] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">	pa[u][<span class="number">0</span>] = fa;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;(<span class="number">1</span>&lt;&lt;i) &lt;= dep[u];i++)pa[u][i] = pa[pa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> [v,w]:G[u])<span class="keyword">if</span>(fa != v)<span class="built_in">pre</span>(v,u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dep[a] &gt; dep[b])<span class="built_in">swap</span>(a,b);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">30</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(dep[a] &lt;= dep[b] - (<span class="number">1</span>&lt;&lt;i))b = pa[b][i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(a == b)<span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">30</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(pa[a][i] == pa[b][i])<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			a = pa[a][i];b = pa[b][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重心">重心</h2>
<p><span class="math inline">\(w[u]\)</span>为删去<span class="math inline">\(u\)</span>后剩余连通分量的最大值, <span class="math inline">\(rt\)</span>为树的重心</p>
<p>树最多有两个相邻的重心</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cent</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	siz[u] = <span class="number">1</span>;</span><br><span class="line">	w[u] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(v != fa)&#123;</span><br><span class="line">			<span class="built_in">cent</span>(v,u);</span><br><span class="line">			siz[u] += siz[v];</span><br><span class="line">			w[u] = <span class="built_in">max</span>(w[u],siz[v]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	w[u] = <span class="built_in">max</span>(w[u],n - siz[u]);</span><br><span class="line">	<span class="keyword">if</span>(!rt <span class="keyword">or</span> w[u] &lt; w[rt])rt = u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最大独立集">最大独立集</h2>
<p>树也是二分图, 最大独立集可以在多项式时间内求.</p>
<p>例题: 求最大带权独立集.</p>
<h3 id="写法1">写法1</h3>
<p><code>w[]</code>是点权, <code>ans[u]</code>代表以<span class="math inline">\(u\)</span>为根的子树最大带权独立集权值和, <code>fa</code>和<code>gr</code>分别代表<span class="math inline">\(u\)</span>的父亲和祖父. <code>f[u][0]</code>为<span class="math inline">\(u\)</span>所有儿子节点<code>ans</code>的和, <code>f[u][1]</code>为<span class="math inline">\(u\)</span>所有孙子节点<code>ans</code>的和.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa,<span class="keyword">int</span> gr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> v:G[u])<span class="keyword">if</span>(v != fa)&#123;</span><br><span class="line">		<span class="built_in">dfs</span>(v,u,fa);</span><br><span class="line">	&#125;</span><br><span class="line">	ans[u] = <span class="built_in">max</span>(f[u][<span class="number">0</span>],f[u][<span class="number">1</span>] + w[u]);</span><br><span class="line">	f[fa][<span class="number">0</span>] += ans[u];</span><br><span class="line">	f[gr][<span class="number">1</span>] += ans[u];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="写法2方便扩展和还原方案">写法2(方便扩展和还原方案)</h3>
<p><code>f[u][0]</code>表示<span class="math inline">\(u\)</span>不在独立集里的最优答案, <code>f[u][1]</code>表示<span class="math inline">\(u\)</span>在独立集里的最优答案.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(f[u][c] != <span class="number">-1</span>)<span class="keyword">return</span> f[u][c];</span><br><span class="line">	<span class="keyword">int</span> x = (c?w[u]:<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> v:G[u])<span class="keyword">if</span>(v != fa)&#123;</span><br><span class="line">		<span class="keyword">int</span> r = <span class="built_in">dfs</span>(v,u,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(!c)r = <span class="built_in">max</span>(r,<span class="built_in">dfs</span>(v,u,<span class="number">1</span>));</span><br><span class="line">		x += r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f[u][c] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dmst最小树形图有向图最小生成树">DMST/最小树形图/有向图最小生成树</h2>
<p>Edmond's Algorithm. 代码来自<a href="https://acm.hdu.edu.cn/showproblem.php?pid=6990">HDU6990</a>的官方题解.</p>
<p>输入: es[] = edge(起点, 终点, 权值)</p>
<p>调用solve(顶点数, 边数)</p>
<p>输出: ans[], <code>ans[i]</code>代表以<span class="math inline">\(i\)</span>为根的DMST权值(即<span class="math inline">\(i\)</span>到其它点都有一条路径可达), 若不存在则为<span class="math inline">\(-1\)</span></p>
<p>时间复杂度<span class="math inline">\(O(mlogn)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DMST</span>&#123;</span></span><br><span class="line">    <span class="keyword">const</span> ll inf = <span class="number">4e13</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span> <span class="keyword">int</span> u, v; ll w; &#125; es[maxn];</span><br><span class="line">    <span class="keyword">int</span> ls[maxn], rs[maxn], dis[maxn];</span><br><span class="line">    ll val[maxn], tag[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, ll t)</span> </span>&#123; val[x] += t;tag[x] += t; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ls[x]) <span class="built_in">update</span>(ls[x], tag[x]);</span><br><span class="line">        <span class="keyword">if</span> (rs[x]) <span class="built_in">update</span>(rs[x], tag[x]);</span><br><span class="line">        tag[x] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x | y;</span><br><span class="line">        <span class="keyword">if</span> (val[x] &gt; val[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        <span class="built_in">push_down</span>(x);</span><br><span class="line">        rs[x] = <span class="built_in">merge</span>(rs[x], y);</span><br><span class="line">        <span class="keyword">if</span> (dis[ls[x]] &lt; dis[rs[x]]) <span class="built_in">swap</span>(ls[x], rs[x]);</span><br><span class="line">        dis[x] = dis[rs[x]] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> top[maxn], fa[maxn], ine[maxn];</span><br><span class="line">    <span class="keyword">int</span> findset[maxn]; <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> findset[x] ? findset[x] = <span class="built_in">find</span>(findset[x]) : x; &#125;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ch[maxn];</span><br><span class="line"></span><br><span class="line">    ll ans[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, ll s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ch[u].<span class="built_in">empty</span>())</span><br><span class="line">            ans[u] = s &gt;= inf ? <span class="number">-1</span> : s;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">for</span> (<span class="keyword">int</span> v : ch[u])</span><br><span class="line">            <span class="built_in">dfs</span>(v, s - val[ine[v]]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; ++i) top[i] = fa[i] = ine[i] = findset[i] = <span class="number">0</span>, ch[i].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) es[++m] = &#123; i % n + <span class="number">1</span>, i, inf &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            ls[i] = rs[i] = tag[i] = dis[i] = <span class="number">0</span>;</span><br><span class="line">            val[i] = es[i].w;</span><br><span class="line">            top[es[i].v] = <span class="built_in">merge</span>(top[es[i].v], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (top[x]) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = top[x], y = <span class="built_in">find</span>(es[i].u);</span><br><span class="line">            top[x] = <span class="built_in">merge</span>(ls[i], rs[i]);</span><br><span class="line">            <span class="keyword">if</span> (y == x) <span class="keyword">continue</span>;</span><br><span class="line">            ine[x] = i;</span><br><span class="line">            <span class="keyword">if</span> (!ine[es[i].u]) x = y;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">for</span> (<span class="keyword">int</span> z = ++n; x != z; x = <span class="built_in">find</span>(es[ine[x]].u)) &#123;</span><br><span class="line">                fa[x] = findset[<span class="built_in">find</span>(x)] = z;</span><br><span class="line">                ch[z].<span class="built_in">push_back</span>(x);</span><br><span class="line">                <span class="keyword">if</span> (top[x]) <span class="built_in">update</span>(top[x], -val[ine[x]]);</span><br><span class="line">                top[z] = <span class="built_in">merge</span>(top[z], top[x]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ll sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            sum += val[ine[i]];</span><br><span class="line">        <span class="built_in">dfs</span>(n, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;dmst;</span><br></pre></td></tr></table></figure>
<h2 id="树同构">树同构</h2>
<h3 id="ahu算法">AHU算法</h3>
<p>用于解决有根树同构问题, 可以将每个子树映射到一个编号, 编号(<code>hsh[]</code>)相等则同构. 是一个确定性算法. 下面的实现是<span class="math inline">\(O(n \log n)\)</span>的但可优化至<span class="math inline">\(O(n)\)</span>. 使用时, 将两棵树存在同一个图中.</p>
<p>对于无根树A, B, 求出重心后分情况讨论:</p>
<ul>
<li>重心数量不同, 不同构.</li>
<li>均只有一个重心, 以重心为根求解, 编号相同则同构.</li>
<li>均只有两个重心, 若树<span class="math inline">\(A\)</span>以重心1为根的编号, 和树<span class="math inline">\(B\)</span>以重心1<strong>或</strong>重心2为根的编号相同, 则同构.</li>
</ul>
<p>求解编号时, 预处理出树的深度. 按深度由大到小一层层计算. 每个节点的编号信息为其所有叶子节点的编号排序之后的数组. 将该数组映射便得到该节点的编号.</p>
<p>下面的实现默认两个子树大小相等, 且树B的节点为原节点<span class="math inline">\(+n\)</span>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALL(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="keyword">int</span> hsh[maxn],dep[maxn];</span><br><span class="line">map&lt;vector&lt;<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; id;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;rd[maxn];</span><br><span class="line"><span class="keyword">int</span> cid;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal_dep</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	dep[u] = (fa == <span class="number">-1</span>?<span class="number">1</span>:dep[fa] + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> v:G[u])<span class="keyword">if</span>(v != fa)<span class="built_in">cal_dep</span>(v,u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">in</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> r1,<span class="keyword">int</span> r2)</span></span>&#123;</span><br><span class="line">	cid = <span class="number">0</span>;id.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n*<span class="number">2</span>;i++)dep[i] = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cal_dep</span>(r1,<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">cal_dep</span>(r2,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n*<span class="number">2</span>;i++)rd[i].<span class="built_in">clear</span>(),hsh[i] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n*<span class="number">2</span>;i++)rd[dep[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n;i &gt;= <span class="number">1</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> u:rd[i])&#123;</span><br><span class="line">			vector&lt;<span class="keyword">int</span>&gt;tmp;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> v:G[u])tmp.<span class="built_in">push_back</span>(hsh[v]);</span><br><span class="line">			<span class="built_in">sort</span>(<span class="built_in">ALL</span>(tmp));</span><br><span class="line">			<span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(id.<span class="built_in">count</span>(tmp))x = id[tmp];</span><br><span class="line">			<span class="keyword">else</span> x = id[tmp] = ++cid;</span><br><span class="line">			hsh[u] = x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以用递归写法:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> hsh[maxn];</span><br><span class="line">map&lt;vector&lt;<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; id;</span><br><span class="line"><span class="keyword">int</span> cid;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;cur;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> v:G[u])<span class="keyword">if</span>(v != fa)&#123;</span><br><span class="line">		<span class="built_in">dfs</span>(v,u);</span><br><span class="line">		cur.<span class="built_in">push_back</span>(hsh[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(<span class="built_in">ALL</span>(cur));</span><br><span class="line">	<span class="keyword">int</span> &amp; tid = id[cur];</span><br><span class="line">	<span class="keyword">if</span>(!tid)tid = ++cid;</span><br><span class="line">	hsh[u] = tid;</span><br><span class="line">	<span class="keyword">return</span> tid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断无根树是否同构:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __;</span><br><span class="line">cin &gt;&gt; __;</span><br><span class="line"><span class="keyword">while</span>(__--)&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	cid = <span class="number">0</span>;</span><br><span class="line">	id.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n*<span class="number">2</span>;i++)siz[i] = w[i] = hsh[i] = <span class="number">0</span>,G[i].<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> f,t;</span><br><span class="line">		cin &gt;&gt; f &gt;&gt; t;</span><br><span class="line">		G[f].<span class="built_in">push_back</span>(t);</span><br><span class="line">		G[t].<span class="built_in">push_back</span>(f);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> f,t;</span><br><span class="line">		cin &gt;&gt; f &gt;&gt; t;</span><br><span class="line">		f += n,t += n;</span><br><span class="line">		G[f].<span class="built_in">push_back</span>(t);</span><br><span class="line">		G[t].<span class="built_in">push_back</span>(f);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> rt1 = <span class="number">0</span>,rt2 = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cent</span>(<span class="number">1</span>,<span class="number">0</span>,rt1);</span><br><span class="line">	<span class="built_in">cent</span>(n+<span class="number">1</span>,<span class="number">0</span>,rt2);</span><br><span class="line">	<span class="keyword">int</span> xrt1 = <span class="number">-1</span>,xrt2 = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> v:G[rt1])<span class="keyword">if</span>(w[v] == w[rt1])xrt1 = v;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> v:G[rt2])<span class="keyword">if</span>(w[v] == w[rt2])xrt2 = v;</span><br><span class="line">	<span class="built_in">dfs</span>(rt1,<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">dfs</span>(rt2,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">bool</span> ok = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>((xrt1 == <span class="number">-1</span> <span class="keyword">and</span> xrt2 != <span class="number">-1</span>) <span class="built_in"><span class="keyword">or</span></span> (xrt2 == <span class="number">-1</span> <span class="keyword">and</span> xrt1 != <span class="number">-1</span>))ok = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(xrt1 == <span class="number">-1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(hsh[rt1] != hsh[rt2])ok = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(hsh[rt1] != hsh[rt2])&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n*<span class="number">2</span>;i++)hsh[i] = <span class="number">0</span>;</span><br><span class="line">				cid = <span class="number">0</span>;id.<span class="built_in">clear</span>();</span><br><span class="line">				<span class="built_in">dfs</span>(rt1,<span class="number">-1</span>);</span><br><span class="line">				<span class="built_in">dfs</span>(xrt2,<span class="number">-1</span>);</span><br><span class="line">				<span class="keyword">if</span>(hsh[rt1] != hsh[xrt2])ok = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; (ok?<span class="string">&quot;YES\n&quot;</span>:<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="点分治">点分治</h2>
<p>具体看lyd的书.这里只放几道例题</p>
<h3 id="例题1-tree">例题1-Tree</h3>
<p>求树上间距小于等于<span class="math inline">\(k\)</span>的点对个数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P4178</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn],vis[maxn],cnt;</span><br><span class="line"><span class="keyword">int</span> dis[maxn],bal[maxn],siz[maxn];<span class="comment">//权值,平衡因子,子树大小</span></span><br><span class="line"><span class="keyword">int</span> mapp[maxn],par[maxn],occur[maxn],tot;<span class="comment">//树上点的映射,该点属于根的哪颗子树,出现次数,待处理的总数</span></span><br><span class="line"><span class="keyword">int</span> root,n,k,ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> f,t,w,next;</span><br><span class="line">	<span class="built_in">Edge</span>(<span class="keyword">int</span> f = <span class="number">0</span>,<span class="keyword">int</span> t = <span class="number">0</span>,<span class="keyword">int</span> w = <span class="number">0</span>,<span class="keyword">int</span> next = <span class="number">0</span>):<span class="built_in">f</span>(f),<span class="built_in">t</span>(t),<span class="built_in">w</span>(w),<span class="built_in">next</span>(next)&#123;&#125;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">	edge[cnt] = <span class="built_in">Edge</span>(f,t,w,head[f]);</span><br><span class="line">	head[f] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> dis[a] &lt; dis[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_root</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa,<span class="keyword">int</span> rawsiz)</span></span>&#123;</span><br><span class="line">	siz[u] = <span class="number">1</span>,bal[u] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">		<span class="keyword">if</span>(vis[v] <span class="keyword">or</span> v == fa)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">get_root</span>(v,u,rawsiz);</span><br><span class="line">		siz[u] += siz[v];</span><br><span class="line">		bal[u] = <span class="built_in">max</span>(bal[u],siz[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	bal[u] = <span class="built_in">max</span>(bal[u],rawsiz - siz[u]);</span><br><span class="line">	<span class="keyword">if</span>(!root <span class="keyword">or</span> bal[root] &gt; bal[u])root = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_dis</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa,<span class="keyword">int</span> w,<span class="keyword">int</span> parent)</span></span>&#123;</span><br><span class="line">	mapp[++tot] = u;</span><br><span class="line">	dis[u] = w,par[u] = parent;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">		<span class="keyword">if</span>(vis[v] <span class="keyword">or</span> v == fa)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">get_dis</span>(v,u,w + edge[i].w,parent);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cal</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	tot = <span class="number">0</span>;</span><br><span class="line">	mapp[++tot] = u;</span><br><span class="line">	dis[u] = <span class="number">0</span>,par[u] = u;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">		<span class="keyword">if</span>(vis[v])<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">get_dis</span>(v,u,edge[i].w,v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(mapp+<span class="number">1</span>,mapp+tot+<span class="number">1</span>,cmp);</span><br><span class="line">	<span class="comment">// cout &lt;&lt; tot &lt;&lt; endl;</span></span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">1</span>,r = tot;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= tot;i++)occur[par[mapp[i]]]++;</span><br><span class="line">	<span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">		<span class="keyword">if</span>(dis[mapp[l]] + dis[mapp[r]] &gt; k)occur[par[mapp[r--]]]--;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			ans += (r - l + <span class="number">1</span> - occur[par[mapp[l]]]);</span><br><span class="line">			occur[par[mapp[l++]]]--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Divide</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	vis[u] = <span class="number">1</span>;</span><br><span class="line">	dis[u] = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">Cal</span>(u);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">		<span class="keyword">if</span>(vis[v])<span class="keyword">continue</span>;</span><br><span class="line">		root = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">get_root</span>(v,<span class="number">-1</span>,siz[v]);</span><br><span class="line">		<span class="built_in">Divide</span>(root);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> f,t,w;</span><br><span class="line">		cin &gt;&gt; f &gt;&gt; t &gt;&gt; w;</span><br><span class="line">		<span class="built_in">addedge</span>(f,t,w);</span><br><span class="line">		<span class="built_in">addedge</span>(t,f,w);</span><br><span class="line">	&#125;</span><br><span class="line">	cin &gt;&gt; k;</span><br><span class="line">	<span class="built_in">get_root</span>(<span class="number">1</span>,<span class="number">-1</span>,n);</span><br><span class="line">	<span class="built_in">Divide</span>(root);</span><br><span class="line">	cout &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例题2-ioi2011race">例题2-[IOI2011]Race</h3>
<p>给出一棵树,求路径和为k的最短路径长度(边数)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P4149</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = maxn*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1E9</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn],vis[maxn],dis[maxn],dep[maxn];</span><br><span class="line"><span class="keyword">int</span> bal[maxn],siz[maxn],par[maxn];</span><br><span class="line"><span class="keyword">int</span> mapp[maxn],mindis[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt,ans,root,n,k,tot;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> f,t,w,next;</span><br><span class="line">	<span class="built_in">Edge</span>(<span class="keyword">int</span> f = <span class="number">0</span>,<span class="keyword">int</span> t = <span class="number">0</span>,<span class="keyword">int</span> w = <span class="number">0</span>,<span class="keyword">int</span> next = <span class="number">0</span>):<span class="built_in">f</span>(f),<span class="built_in">t</span>(t),<span class="built_in">w</span>(w),<span class="built_in">next</span>(next)&#123;&#125;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">	edge[cnt] = <span class="built_in">Edge</span>(f,t,w,head[f]);</span><br><span class="line">	head[f] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> dis[a] &lt; dis[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_root</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa,<span class="keyword">int</span> rawsiz)</span></span>&#123;</span><br><span class="line">	siz[u] = <span class="number">1</span>,bal[u] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">		<span class="keyword">if</span>(vis[v] <span class="keyword">or</span> v == fa)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">get_root</span>(v,u,rawsiz);</span><br><span class="line">		siz[u] += siz[v];</span><br><span class="line">		bal[u] = <span class="built_in">max</span>(bal[u],siz[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	bal[u] = <span class="built_in">max</span>(bal[u],rawsiz - siz[u]);</span><br><span class="line">	<span class="keyword">if</span>(!root <span class="keyword">or</span> bal[root] &gt; bal[u])root = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_dis</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa,<span class="keyword">int</span> parent)</span></span>&#123;</span><br><span class="line">	par[u] = parent;</span><br><span class="line">	mapp[++tot] = u;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">		<span class="keyword">if</span>(vis[v] <span class="keyword">or</span> fa == v)<span class="keyword">continue</span>;</span><br><span class="line">		dis[v] = dis[u] + edge[i].w;</span><br><span class="line">		dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">get_dis</span>(v,u,parent);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cal</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	tot = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> pretot = <span class="number">0</span>;</span><br><span class="line">	dep[u] = dis[u] = <span class="number">0</span>,par[u] = u;</span><br><span class="line">	mindis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	mapp[++tot] = u;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">		<span class="keyword">if</span>(vis[v])<span class="keyword">continue</span>;</span><br><span class="line">		pretot = tot;</span><br><span class="line">		dis[v] = edge[i].w;</span><br><span class="line">		dep[v] = <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">get_dis</span>(v,u,v);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = pretot+<span class="number">1</span>;j &lt;= tot;j++)&#123;</span><br><span class="line">			<span class="keyword">int</span> x = mapp[j];</span><br><span class="line">			<span class="keyword">if</span>(k - dis[x] &gt;= <span class="number">0</span>)ans = <span class="built_in">min</span>(ans,mindis[k - dis[x]] + dep[x]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = pretot+<span class="number">1</span>;j &lt;= tot;j++)&#123;</span><br><span class="line">			<span class="keyword">int</span> x = mapp[j];</span><br><span class="line">			<span class="keyword">if</span>(dis[x] &lt; maxn)mindis[dis[x]] = <span class="built_in">min</span>(mindis[dis[x]],dep[x]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= tot;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> j = mapp[i];</span><br><span class="line">		<span class="keyword">if</span>(dis[j] &lt; maxn)mindis[dis[j]] = INF;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Divide</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	vis[u] = <span class="number">1</span>;</span><br><span class="line">	dis[u] = <span class="number">0</span>;</span><br><span class="line">	dep[u] = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">Cal</span>(u);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">		<span class="keyword">if</span>(vis[v])<span class="keyword">continue</span>;</span><br><span class="line">		root = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">get_root</span>(v,<span class="number">-1</span>,siz[v]);</span><br><span class="line">		<span class="built_in">Divide</span>(root);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// freopen(&quot;P4149_1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; maxn;i++)mindis[i] = INF;</span><br><span class="line">	ans = INF;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> f,t,w;</span><br><span class="line">		cin &gt;&gt; f &gt;&gt; t &gt;&gt; w;</span><br><span class="line">		f++;t++;</span><br><span class="line">		<span class="built_in">addedge</span>(f,t,w);</span><br><span class="line">		<span class="built_in">addedge</span>(t,f,w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">get_root</span>(<span class="number">1</span>,<span class="number">-1</span>,n);</span><br><span class="line">	<span class="built_in">Divide</span>(root);</span><br><span class="line">	<span class="keyword">if</span>(ans == INF)ans = <span class="number">-1</span>;</span><br><span class="line">	cout &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="虚树">虚树</h2>
<p>虚树(auxiliary tree)主要用来解决一类树形dp问题. 这类树形dp每次求解只需考虑树中的部分点(称为关键点). 一棵虚树包含全部的关键点以及任意两个关键点之间的LCA. 可以证明<span class="math inline">\(k\)</span>个关键点生成的虚树大小不大于<span class="math inline">\(2k\)</span>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;G[maxn],G2[maxn];<span class="comment">//G2为虚树</span></span><br><span class="line"><span class="keyword">int</span> dfn[maxn],clk;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	dfn[u] = ++clk;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> [v,ww]:G[u])<span class="keyword">if</span>(v != fa)&#123;</span><br><span class="line">		w[v] = <span class="built_in">min</span>(w[u],ww);</span><br><span class="line">		<span class="built_in">dfs</span>(v,u);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">aux_cmp</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> dfn[u] &lt; dfn[v];</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;del_tree;<span class="comment">//这里包含了虚树中的所有点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="comment">//在此实现虚树加边</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_aux_tree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp; key)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> x:del_tree)G2[x].<span class="built_in">clear</span>(),G2[x].<span class="built_in">shrink_to_fit</span>();</span><br><span class="line">	del_tree.<span class="built_in">clear</span>();</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;stk;</span><br><span class="line">	stk.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">sort</span>(<span class="built_in">ALL</span>(key),aux_cmp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> u:key)&#123;</span><br><span class="line">		<span class="keyword">if</span>(stk.<span class="built_in">size</span>() == <span class="number">1</span>)&#123;</span><br><span class="line">			stk.<span class="built_in">push_back</span>(u);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> x = stk.<span class="built_in">back</span>();</span><br><span class="line">		<span class="keyword">int</span> lca = <span class="built_in">LCA</span>(u,x);</span><br><span class="line">		<span class="keyword">if</span>(lca == x)&#123;</span><br><span class="line">			stk.<span class="built_in">push_back</span>(u);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">while</span>(stk.<span class="built_in">size</span>() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">				stk.<span class="built_in">pop_back</span>();</span><br><span class="line">				<span class="keyword">int</span> y = stk.<span class="built_in">back</span>();</span><br><span class="line">				<span class="keyword">if</span>(dfn[y] &gt; dfn[lca])&#123;</span><br><span class="line">					<span class="built_in">addedge</span>(y,x);</span><br><span class="line">					x = y;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(dfn[y] == dfn[lca])&#123;</span><br><span class="line">					<span class="built_in">addedge</span>(lca,x);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span>&#123;</span><br><span class="line">					<span class="built_in">addedge</span>(lca,x);</span><br><span class="line">					stk.<span class="built_in">push_back</span>(lca);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			stk.<span class="built_in">push_back</span>(u);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(stk.<span class="built_in">size</span>() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">int</span> x = stk.<span class="built_in">back</span>();</span><br><span class="line">		<span class="keyword">while</span>(stk.<span class="built_in">size</span>() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">			stk.<span class="built_in">pop_back</span>();</span><br><span class="line">			<span class="built_in">addedge</span>(stk.<span class="built_in">back</span>(),x);</span><br><span class="line">			x = stk.<span class="built_in">back</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>[模板]数学</title>
    <url>/2022/08/23/template-math/</url>
    <content><![CDATA[<p>[TOC]</p>
<hr />
<p><strong>答案不取模，亲人两行泪</strong></p>
<p>212370440130137957</p>
<p>(↑这是一个很大的质数)</p>
<p>19260817</p>
<p>(↑这是一颗很大的子弹)</p>
<p><strong>判断同余时用</strong><span class="math inline">\((a - b) \mod m== 0\)</span></p>
<p>cout不使用科学计数法输出，设置精度: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout.<span class="built_in">setf</span>(ios::fixed,ios::floatfield);</span><br><span class="line">cout.<span class="built_in">precision</span>(<span class="number">2</span>); </span><br></pre></td></tr></table></figure></p>
<table style="width:6%;">
<colgroup>
<col style="width: 5%" />
</colgroup>
<tbody>
<tr class="odd">
<td># 杂项</td>
</tr>
<tr class="even">
<td>## 神秘结论</td>
</tr>
<tr class="odd">
<td><span class="math display">\[
\sum_{i = 1}^n (d(i))^2 \ll n \log^3 n (d为因子个数)
\]</span></td>
</tr>
<tr class="even">
<td>## 大整数</td>
</tr>
<tr class="odd">
<td>(我也不知道从哪copy)的</td>
</tr>
<tr class="even">
<td><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bign</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> d[maxn], len;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clean</span><span class="params">()</span> </span>&#123; <span class="keyword">while</span>(len &gt; <span class="number">1</span> &amp;&amp; !d[len<span class="number">-1</span>]) len--; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">bign</span>() 			&#123; <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(d)); len = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="built_in">bign</span>(<span class="keyword">int</span> num) 	&#123; *<span class="keyword">this</span> = num; &#125; </span><br><span class="line">	<span class="built_in">bign</span>(<span class="keyword">char</span>* num) &#123; *<span class="keyword">this</span> = num; &#125;</span><br><span class="line">    bign <span class="keyword">operator</span> = (<span class="keyword">const</span> <span class="keyword">char</span>* num)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(d)); len = <span class="built_in">strlen</span>(num);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) d[i] = num[len<span class="number">-1</span>-i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="built_in">clean</span>();</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bign <span class="keyword">operator</span> = (<span class="keyword">int</span> num)&#123;</span><br><span class="line">        <span class="keyword">char</span> s[<span class="number">20</span>]; <span class="built_in">sprintf</span>(s, <span class="string">&quot;%d&quot;</span>, num);</span><br><span class="line">        *<span class="keyword">this</span> = s;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    bign <span class="keyword">operator</span> + (<span class="keyword">const</span> bign&amp; b)&#123;</span><br><span class="line">        bign c = *<span class="keyword">this</span>; <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; b.len; i++)&#123;</span><br><span class="line">        	c.d[i] += b.d[i];</span><br><span class="line">        	<span class="keyword">if</span> (c.d[i] &gt; <span class="number">9</span>) c.d[i]%=<span class="number">10</span>, c.d[i+<span class="number">1</span>]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (c.d[i] &gt; <span class="number">9</span>) c.d[i++]%=<span class="number">10</span>, c.d[i]++;</span><br><span class="line">		c.len = <span class="built_in">max</span>(len, b.len);</span><br><span class="line">		<span class="keyword">if</span> (c.d[i] &amp;&amp; c.len &lt;= i) c.len = i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    bign <span class="keyword">operator</span> - (<span class="keyword">const</span> bign&amp; b)&#123;</span><br><span class="line">        bign c = *<span class="keyword">this</span>; <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; b.len; i++)&#123;</span><br><span class="line">        	c.d[i] -= b.d[i];</span><br><span class="line">        	<span class="keyword">if</span> (c.d[i] &lt; <span class="number">0</span>) c.d[i]+=<span class="number">10</span>, c.d[i+<span class="number">1</span>]--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (c.d[i] &lt; <span class="number">0</span>) c.d[i++]+=<span class="number">10</span>, c.d[i]--;</span><br><span class="line">		c.<span class="built_in">clean</span>();</span><br><span class="line">		<span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    bign <span class="keyword">operator</span> * (<span class="keyword">const</span> bign&amp; b)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j; bign c; c.len = len + b.len; </span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; b.len; j++) <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++) </span><br><span class="line">			c.d[i+j] += d[i] * b.d[j];</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; c.len<span class="number">-1</span>; i++)</span><br><span class="line">            c.d[i+<span class="number">1</span>] += c.d[i]/<span class="number">10</span>, c.d[i] %= <span class="number">10</span>;</span><br><span class="line">        c.<span class="built_in">clean</span>();</span><br><span class="line">		<span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    bign <span class="keyword">operator</span> / (<span class="keyword">const</span> bign&amp; b)&#123;</span><br><span class="line">    	<span class="keyword">int</span> i, j;</span><br><span class="line">		bign c = *<span class="keyword">this</span>, a = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">for</span> (i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    	&#123;</span><br><span class="line">    		a = a*<span class="number">10</span> + d[i];</span><br><span class="line">    		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) <span class="keyword">if</span> (a &lt; b*(j+<span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line">    		c.d[i] = j;</span><br><span class="line">    		a = a - b*j;</span><br><span class="line">    	&#125;</span><br><span class="line">    	c.<span class="built_in">clean</span>();</span><br><span class="line">    	<span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    bign <span class="keyword">operator</span> % (<span class="keyword">const</span> bign&amp; b)&#123;</span><br><span class="line">    	<span class="keyword">int</span> i, j;</span><br><span class="line">		bign a = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">for</span> (i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    	&#123;</span><br><span class="line">    		a = a*<span class="number">10</span> + d[i];</span><br><span class="line">    		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) <span class="keyword">if</span> (a &lt; b*(j+<span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line">    		a = a - b*j;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">	bign <span class="keyword">operator</span> += (<span class="keyword">const</span> bign&amp; b)&#123;</span><br><span class="line">        *<span class="keyword">this</span> = *<span class="keyword">this</span> + b;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> bign&amp; b) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len != b.len) <span class="keyword">return</span> len &lt; b.len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span>(d[i] != b.d[i]) <span class="keyword">return</span> d[i] &lt; b.d[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt;(<span class="keyword">const</span> bign&amp; b) <span class="keyword">const</span>&#123;<span class="keyword">return</span> b &lt; *<span class="keyword">this</span>;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> bign&amp; b) <span class="keyword">const</span>&#123;<span class="keyword">return</span> !(b &lt; *<span class="keyword">this</span>);&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> bign&amp; b) <span class="keyword">const</span>&#123;<span class="keyword">return</span> !(*<span class="keyword">this</span> &lt; b);&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> bign&amp; b) <span class="keyword">const</span>&#123;<span class="keyword">return</span> b &lt; *<span class="keyword">this</span> || *<span class="keyword">this</span> &lt; b;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> bign&amp; b) <span class="keyword">const</span>&#123;<span class="keyword">return</span> !(b &lt; *<span class="keyword">this</span>) &amp;&amp; !(b &gt; *<span class="keyword">this</span>);&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">string <span class="title">str</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> s[maxn]=&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) s[len<span class="number">-1</span>-i] = d[i]+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">istream&amp; <span class="keyword">operator</span> &gt;&gt; (istream&amp; in, bign&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    string s;</span><br><span class="line">    in &gt;&gt; s;</span><br><span class="line">    x = s.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; out, <span class="keyword">const</span> bign&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; x.<span class="built_in">str</span>();</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
</tr>
<tr class="odd">
<td>使用例:</td>
</tr>
<tr class="even">
<td><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">bign <span class="title">GCD</span><span class="params">(bign a,bign b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// cout&lt;&lt;&quot;@@@ &quot;&lt;&lt;a&lt;&lt;endl&lt;&lt;&quot;### &quot;&lt;&lt;b&lt;&lt;endl;;</span></span><br><span class="line">	bign k=<span class="number">0</span>,c;</span><br><span class="line">	<span class="keyword">while</span>(b&gt;k)</span><br><span class="line">	&#123;</span><br><span class="line">		c=a%b;</span><br><span class="line">		a=b;</span><br><span class="line">		b=c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">110</span>];</span><br><span class="line">vector &lt;bign&gt; prime;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetPrime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">2</span>;;i+=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> j=<span class="number">2</span>;j&lt;i;j+=<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">if</span>(i%j==<span class="number">0</span>) flag=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(flag)</span><br><span class="line">		&#123;</span><br><span class="line">			bign k=i;</span><br><span class="line">			prime.<span class="built_in">push_back</span>(k);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>((<span class="keyword">int</span>)prime.<span class="built_in">size</span>()&gt;<span class="number">100</span>) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;T;</span><br><span class="line">	<span class="built_in">GetPrime</span>();</span><br><span class="line">	<span class="keyword">while</span>(T--)</span><br><span class="line">	&#123;</span><br><span class="line">		bign n;</span><br><span class="line">		cin&gt;&gt;n;</span><br><span class="line">		bign a=<span class="number">1</span>,b=<span class="number">1</span>,k=<span class="number">1</span>,sum=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> pos=<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(sum*prime[i]&lt;=n) sum=sum*prime[i],pos=i;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=pos;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			</span><br><span class="line">			b=b*prime[i];</span><br><span class="line">			a=a*(prime[i]+k);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// cout&lt;&lt;&quot;@@@ &quot;&lt;&lt;s&lt;&lt;endl;</span></span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		bign s=<span class="built_in">GCD</span>(a,b);</span><br><span class="line">		b=b/s,a=a/s;</span><br><span class="line">		cout&lt;&lt;b&lt;&lt;<span class="string">&quot;/&quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
</tr>
<tr class="odd">
<td>## 随机数发生器</td>
</tr>
<tr class="even">
<td>注意不要用Windows下的<span class="math inline">\(rand()\)</span></td>
</tr>
<tr class="odd">
<td><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mt19937 Rand(seed);</span><br><span class="line">mt19937 Rand(chrono::steady_clock::now().time_since_epoch().count());//cf最好用这个防止被hack</span><br><span class="line">Rand();//返回一个随机数</span><br></pre></td></tr></table></figure></td>
</tr>
<tr class="even">
<td>### 均匀分布</td>
</tr>
<tr class="odd">
<td><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 包含random头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//定义均匀分布对象，均匀分布区间（a,b)为(-10，10)</span></span><br><span class="line">	std::uniform_int_distribution&lt;<span class="keyword">int</span>&gt; uid&#123; <span class="number">-10</span>,<span class="number">10</span> &#125;;</span><br><span class="line">	<span class="comment">//均匀分布区间(a,b)</span></span><br><span class="line">	std::cout &lt;&lt; uid.<span class="built_in">a</span>() &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; uid.<span class="built_in">b</span>() &lt;&lt; std::endl;</span><br><span class="line">	<span class="comment">//定义随机数种子</span></span><br><span class="line">	std::random_device rd;</span><br><span class="line">	<span class="comment">//定义默认随机数生成器</span></span><br><span class="line">	std::default_random_engine dre&#123; <span class="built_in">rd</span>() &#125;;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;五个随机数如下&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">		std::cout &lt;&lt; <span class="built_in">uid</span>(dre) &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
</tr>
<tr class="even">
<td>## 计时</td>
</tr>
<tr class="odd">
<td><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">clock_t</span> start = <span class="built_in">clock</span>();</span><br><span class="line"><span class="comment">// do something...</span></span><br><span class="line"><span class="keyword">clock_t</span> end   = <span class="built_in">clock</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;花费了&quot;</span> &lt;&lt; (<span class="keyword">double</span>)(end - start) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;秒&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure></td>
</tr>
<tr class="even">
<td># 数论</td>
</tr>
<tr class="odd">
<td>## 同余式</td>
</tr>
<tr class="even">
<td>同余属于等价关系, 满足自反、对称、传递三大关系 <span class="math display">\[
\begin{align}
a \equiv a \pmod m\\
a \equiv b \pmod m \iff b \equiv a \pmod m\\
a \equiv b \pmod m \and b \equiv c \pmod m \Rightarrow a \equiv c \pmod m
\end{align}
\]</span> 加、减、乘与一般运算一致. 若<span class="math inline">\(a \equiv b \pmod m\)</span>且<span class="math inline">\(c \equiv d \pmod m\)</span>, 则有 <span class="math display">\[
a+c \equiv b+d \pmod m\\
a-c \equiv b-d \pmod m\\
a*c \equiv b*d \pmod m
\]</span> <strong>除法比较特殊</strong>. 若<span class="math inline">\(ac \equiv bc \pmod m\)</span>, 则 <span class="math display">\[
a \equiv b \pmod{\frac{m}{\gcd(c,m)}}
\]</span></td>
</tr>
<tr class="odd">
<td>其它性质:</td>
</tr>
<tr class="even">
<td><span class="math display">\[
\begin{align}
ax \equiv 0 \pmod p \iff x \equiv 0 \pmod{\frac{p}{\gcd(p,a)}}
\end{align}\\
x \% b == 0 \and \frac{x}{b} \equiv 0 \pmod p \iff x \equiv 0 \pmod{bm}\\
a \equiv b \pmod m \iff a^n \equiv b^n \pmod m\\
a \equiv b \pmod m \and n|m \Rightarrow a \equiv b \pmod n
\]</span></td>
</tr>
<tr class="odd">
<td>## 快速幂</td>
</tr>
<tr class="even">
<td>计算<span class="math inline">\(x^d \mod p\)</span></td>
</tr>
<tr class="odd">
<td>注意<span class="math inline">\(a^b % p = ((a % p)^b) % p\)</span></td>
</tr>
<tr class="even">
<td><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">Pow</span><span class="params">(ll x,ll d)</span></span>&#123;</span><br><span class="line">	ll tans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(d == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>%p;</span><br><span class="line">    x %= p;</span><br><span class="line">	ll a = <span class="built_in">Pow</span>(x,d/<span class="number">2</span>);</span><br><span class="line">	tans = a*a%p;</span><br><span class="line">	<span class="keyword">if</span>(d%<span class="number">2</span>)tans = tans*x%p; </span><br><span class="line">	<span class="keyword">return</span> tans%p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a,LL b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        LL tmp=b;</span><br><span class="line">        b=a%b;</span><br><span class="line">        a=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
</tr>
<tr class="odd">
<td>## 一次不定方程</td>
</tr>
<tr class="even">
<td><span class="math inline">\(\sum_{i = 1}^n a_i \cdot x_i = c\)</span>有整数解当且仅当<span class="math inline">\(\gcd(a_1,a_2,...,a_n) | c\)</span></td>
</tr>
<tr class="odd">
<td>## GCD &amp; exGCD</td>
</tr>
<tr class="even">
<td>x,y,d为全局变量.求x和y使得 <span class="math inline">\(ax + by = d\)</span> 且 <span class="math inline">\(|x| + |y|\)</span>最小.</td>
</tr>
<tr class="odd">
<td>其中 <span class="math inline">\(d = gcd(a,b)\)</span></td>
</tr>
<tr class="even">
<td><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gcd</span><span class="params">(ll a,ll b,ll &amp; d,ll &amp; x,ll &amp; y)</span></span>&#123;</span><br><span class="line">	<span class="comment">//notice d = gcd(a,b)</span></span><br><span class="line">	<span class="keyword">if</span>(!b)d = a,x = <span class="number">1</span>,y = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">gcd</span>(b,a%b,d,y,x);</span><br><span class="line">		y -= x*(a/b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
</tr>
<tr class="odd">
<td>## 逆元</td>
</tr>
<tr class="even">
<td>返回模p下a的逆.不存在则返回-1.</td>
</tr>
<tr class="odd">
<td><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a,ll p)</span></span>&#123;</span><br><span class="line">	ll d,x,y;</span><br><span class="line">	<span class="built_in">gcd</span>(a,p,d,x,y);</span><br><span class="line">	<span class="keyword">return</span> d == <span class="number">1</span>?(x+p)%p:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 线性筛逆元:</td>
</tr>
<tr class="even">
<td>返回模p下1...n的逆.保存在invs里</td>
</tr>
<tr class="odd">
<td><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_inv</span><span class="params">()</span></span>&#123;</span><br><span class="line">	inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; maxn;i++)&#123;</span><br><span class="line">		inv[i] = (ll)(p - p/i)*inv[p%i]%p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
</tr>
<tr class="even">
<td>## a,b不互质时</td>
</tr>
<tr class="odd">
<td><span class="math display">\[
\frac{a}{b} \mod m = \frac{a \mod (mb)}{b}
\]</span></td>
</tr>
<tr class="even">
<td>证: <span class="math display">\[
\begin{align}
&amp;\frac{a}{b} = km + x (x &lt; m)\\
\Rightarrow \space &amp;a =kbm + bx\\
\Rightarrow \space &amp;a \mod (bm) = bx\\
\Rightarrow \space &amp;\frac{a \mod (bm)}{b} = x\\
\Rightarrow \space &amp;\frac{a \mod (bm)}{b} = \frac{a}{b} \mod m
\end{align}
\]</span></td>
</tr>
<tr class="odd">
<td>## 中国剩余定理(CRT)</td>
</tr>
<tr class="even">
<td>求同余方程组 <span class="math display">\[
\begin{cases} x &amp;\equiv a_1 \pmod {m_1} \\ x &amp;\equiv a_2 \pmod {m_2} \\ &amp;\vdots \\ x &amp;\equiv a_k \pmod {m_k} \\ \end{cases}
\]</span> 在<span class="math inline">\([0,\prod_{i = 1}^nm_i])\)</span>中的解. 要求任意<span class="math inline">\(m_i\)</span>两两互质</td>
</tr>
<tr class="odd">
<td>输入: <code>int n</code> 方程组个数, <code>ll a[] ll m[]</code>,方程组的参数和模数</td>
</tr>
<tr class="even">
<td>复杂度:<span class="math inline">\(O(nlogM)\)</span>, 其中<span class="math inline">\(M\)</span>与<span class="math inline">\(m_i\)</span>同阶</td>
</tr>
<tr class="odd">
<td>输出: 方程组在<span class="math inline">\([0,\prod_{i = 1}^nm_i])\)</span>中的解.</td>
</tr>
<tr class="even">
<td>前置: 逆元</td>
</tr>
<tr class="odd">
<td>调用 <code>CRT(n,a,m)</code></td>
</tr>
<tr class="even">
<td><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">CRT</span><span class="params">(<span class="keyword">int</span> n,ll * a,ll * m)</span></span>&#123;</span><br><span class="line">	ll M = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)M *= m[i];</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		ll mt = M/m[i];</span><br><span class="line">		ll ret = <span class="built_in">inv</span>(mt,m[i]);</span><br><span class="line">		ans = (ans + a[i]*mt%M*ret%M)%M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (ans + M)%M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
</tr>
<tr class="odd">
<td>## Eratosthenes筛</td>
</tr>
<tr class="even">
<td><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!n_prime[i])&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = i*<span class="number">2</span>;j &lt;= n;j += i)n_prime[j] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	n_prime[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
</tr>
<tr class="odd">
<td>## 线性筛</td>
</tr>
<tr class="even">
<td><strong>筛素因子时记得直接去掉最后一个素因子, 否则复杂度不对</strong></td>
</tr>
<tr class="odd">
<td>### 线性筛素数</td>
</tr>
<tr class="even">
<td><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> not_p[maxn];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;prime;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">euler_sieve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	not_p[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!not_p[i])&#123;</span><br><span class="line">			prime.<span class="built_in">push_back</span>(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> p:prime)&#123;</span><br><span class="line">			<span class="keyword">if</span>((ll)p*i &gt;= n)<span class="keyword">break</span>;</span><br><span class="line">			not_p[p*i] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%p == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
</tr>
<tr class="odd">
<td>### 线性筛<span class="math inline">\(\varphi\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\varphi(n)\)</span>: 小于等于<span class="math inline">\(n\)</span>的正整数中与<span class="math inline">\(n\)</span>互质的数个数</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\varphi\)</span>的一些性质(以下<span class="math inline">\(p\)</span>代表素数) <span class="math display">\[
\varphi(p) = p-1\\
如果i \% p == 0, \varphi(i*p) = \varphi(i)*p\\
否则\varphi(i*p) = \varphi(i)*(p-1)
\]</span></td>
</tr>
<tr class="even">
<td>phi[n]为<span class="math inline">\(\varphi(n)\)</span>,prime里存的素数</td>
</tr>
<tr class="odd">
<td><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> phi[maxn];</span><br><span class="line"><span class="keyword">bool</span> not_p[maxn];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;prime;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eular_sieve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	not_p[<span class="number">1</span>] = phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!not_p[i])&#123;</span><br><span class="line">			phi[i] = i<span class="number">-1</span>;</span><br><span class="line">			prime.<span class="built_in">push_back</span>(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> p:prime)&#123;</span><br><span class="line">			<span class="keyword">if</span>((ll)p*i &gt;= n)<span class="keyword">break</span>;</span><br><span class="line">			not_p[p*i] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%p)phi[i*p] = phi[i]*(p<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				phi[i*p] = phi[i]*p;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
</tr>
<tr class="even">
<td>### 线性筛<span class="math inline">\(\mu\)</span></td>
</tr>
<tr class="odd">
<td><span class="math display">\[
\mu(n)= \begin{cases} 1&amp;n=1\\ 0&amp;n\text{ 含有平方因子}\\ (-1)^k&amp;k\text{ 为 }n\text{ 的本质不同质因子个数}\\ \end{cases}
\]</span></td>
</tr>
<tr class="even">
<td><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> phi[maxn],mu[maxn];</span><br><span class="line"><span class="keyword">bool</span> not_p[maxn];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;prime;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve_mu</span><span class="params">()</span></span>&#123;</span><br><span class="line">	not_p[<span class="number">1</span>] = mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; maxn;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!not_p[i])&#123;</span><br><span class="line">			mu[i] = <span class="number">-1</span>;</span><br><span class="line">			prime.<span class="built_in">push_back</span>(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> p:prime)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">ll</span>(p)*i &gt;= maxn)<span class="keyword">break</span>;</span><br><span class="line">			not_p[p*i] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%p)mu[i*p] = -mu[i];</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				mu[i*p] = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
</tr>
<tr class="odd">
<td>## 杜教筛</td>
</tr>
<tr class="even">
<td>详细请见杜教筛笔记.</td>
</tr>
<tr class="odd">
<td>杜教筛快速筛<span class="math inline">\(\varphi\)</span>和<span class="math inline">\(\mu\)</span>的前缀和.<span class="math inline">\(maxn = n^{\frac{2}{3}}\)</span>时复杂度为<span class="math inline">\(O(n^{\frac{2}{3}})\)</span></td>
</tr>
<tr class="even">
<td><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1664510</span>;</span><br><span class="line"><span class="keyword">bool</span> not_p[maxn];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;prime;</span><br><span class="line">ll mu[maxn],phi[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	phi[<span class="number">1</span>] = mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; maxn;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!not_p[i])&#123;</span><br><span class="line">			mu[i] = <span class="number">-1</span>;</span><br><span class="line">			phi[i] = i<span class="number">-1</span>;</span><br><span class="line">			prime.<span class="built_in">push_back</span>(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> p:prime)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="number">1LL</span>*p*i &gt;= maxn)<span class="keyword">break</span>;</span><br><span class="line">			not_p[i*p] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%p)&#123;</span><br><span class="line">				phi[i*p] = phi[i]*(p<span class="number">-1</span>);</span><br><span class="line">				mu[i*p] = -mu[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				phi[i*p] = phi[i]*p;</span><br><span class="line">				mu[i*p] = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; maxn;i++)mu[i] += mu[i<span class="number">-1</span>],phi[i] += phi[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">map&lt;<span class="keyword">int</span>,ll&gt;Mu,Phi;</span><br><span class="line"><span class="function">ll <span class="title">du_mu</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x &lt; maxn)<span class="keyword">return</span> mu[x];</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(Mu[x])<span class="keyword">return</span> Mu[x];</span><br><span class="line">	ll tans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">2</span>,r = <span class="number">0</span>;l &lt;= x;l = r+<span class="number">1</span>)&#123;</span><br><span class="line">		r = x/(x/l);</span><br><span class="line">		tans -= <span class="number">1LL</span>*(r - l + <span class="number">1</span>)*<span class="built_in">du_mu</span>(x/l);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Mu[x] = tans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">du_phi</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x &lt; maxn)<span class="keyword">return</span> phi[x];</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(Phi[x])<span class="keyword">return</span> Phi[x];</span><br><span class="line">	ll tans = <span class="number">1LL</span>*x*(x+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">2</span>,r = <span class="number">0</span>;l &lt;= x;l = r+<span class="number">1</span>)&#123;</span><br><span class="line">		r = x/(x/l);</span><br><span class="line">		tans -= <span class="number">1LL</span>*(r-l+<span class="number">1</span>)*<span class="built_in">du_phi</span>(x/l);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Phi[x] = tans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
</tr>
<tr class="odd">
<td>## 欧拉函数<span class="math inline">\(φ(x)\)</span></td>
</tr>
<tr class="even">
<td><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">cal_phi</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m = (ll)<span class="built_in">sqrt</span>(x+<span class="number">0.5</span>);</span><br><span class="line">	ll tans = x;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= m;i++)<span class="keyword">if</span>(!(x%i))&#123;</span><br><span class="line">		tans = tans/i*(i<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">while</span>(!(x%i))x /= i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x &gt; <span class="number">1</span>)tans = tans / x * (x<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> tans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
</tr>
<tr class="odd">
<td>### 线性筛<span class="math inline">\(φ(x)\)</span></td>
</tr>
<tr class="even">
<td><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve_phi</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)<span class="keyword">if</span>(!phi[i])</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt;= n;j += i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!phi[j])phi[j] = j;</span><br><span class="line">			phi[j] = phi[j]/i * (i<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
</tr>
<tr class="odd">
<td>## 有理数取模</td>
</tr>
<tr class="even">
<td>求<span class="math inline">\(a/b\)</span> % <span class="math inline">\(p\)</span> （p为质数)</td>
</tr>
<tr class="odd">
<td>由费马小定理<span class="math inline">\(b^{p-1} ≡ 1 \pmod p\)</span> 可得 <span class="math inline">\(b^{p-2} ≡ b^{-1} \pmod p\)</span></td>
</tr>
<tr class="even">
<td>故只需求<span class="math inline">\(a*b^{p-2} \bmod p\)</span></td>
</tr>
<tr class="odd">
<td>a,b过大则先膜一下</td>
</tr>
<tr class="even">
<td>## 欧拉定理</td>
</tr>
<tr class="odd">
<td>若<span class="math inline">\(a,p\)</span>互质,则有</td>
</tr>
<tr class="even">
<td><span class="math inline">\(a^{φ(p)} ≡ 1 \pmod p\)</span></td>
</tr>
<tr class="odd">
<td>### 扩展欧拉定理(无需a,p互质)</td>
</tr>
<tr class="even">
<td><span class="math inline">\(b ≥ φ(p)\)</span>时:</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(a^b ≡ a^{b \space \bmod \space φ(p) +φ(p)} \pmod p\)</span></td>
</tr>
<tr class="even">
<td>例题: 给出<span class="math inline">\(w_1,w_2,..w_n\)</span>和<span class="math inline">\(q\)</span>组询问<span class="math inline">\(l \space r\)</span>. 求<span class="math inline">\(w_l^{w_{l+1}^{...^{w_r}}} \pmod p\)</span>​的值</td>
</tr>
<tr class="odd">
<td><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CF906D </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line">ll raw[maxn],n,mod;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> r1aw[maxn];</span><br><span class="line">map&lt;ll,ll&gt;vis;</span><br><span class="line"><span class="function">ll <span class="title">phi</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">	ll m = (ll)<span class="built_in">sqrt</span>(x+<span class="number">0.5</span>);</span><br><span class="line">	ll tans = x;</span><br><span class="line">	<span class="keyword">for</span>(ll i = <span class="number">2</span>;i &lt;= m;i++)<span class="keyword">if</span>(!(x%i))&#123;</span><br><span class="line">		tans = tans/i*(i<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">while</span>(!(x%i))x /= i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x &gt; <span class="number">1</span>)tans = tans / x * (x<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> tans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">Pow</span><span class="params">(ll x,ll d,ll p)</span></span>&#123;</span><br><span class="line">	ll tans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(d == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>%p;</span><br><span class="line">    x %= p;</span><br><span class="line">	ll a = <span class="built_in">Pow</span>(x,d/<span class="number">2</span>,p);</span><br><span class="line">	tans = a*a%p;</span><br><span class="line">	<span class="keyword">if</span>(d%<span class="number">2</span>)tans = tans*x%p; </span><br><span class="line">	<span class="keyword">return</span> tans%p;</span><br><span class="line">&#125;</span><br><span class="line">ll w[maxn],p0[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l==r) <span class="keyword">return</span> <span class="built_in">min</span>(w[l],w[l]%p0[k]+p0[k]);</span><br><span class="line">	<span class="keyword">if</span> (p0[k]==<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> c=<span class="built_in">cal</span>(l+<span class="number">1</span>,r,k+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (w[l]==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		ll v=<span class="built_in">Pow</span>(w[l],c,p0[k]);</span><br><span class="line">		ll d=<span class="number">1ll</span>&lt;&lt;<span class="number">60</span>,e=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; c;i++) &#123; d/=w[l]; e*=w[l]; <span class="keyword">if</span> (d==<span class="number">0</span>) <span class="keyword">break</span>; &#125;</span><br><span class="line">		<span class="keyword">if</span> (d==<span class="number">0</span>) <span class="keyword">return</span> v+p0[k]; <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">min</span>(e,e%p0[k]+p0[k]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; mod;</span><br><span class="line">	<span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">	p0[idx] = mod;</span><br><span class="line">	<span class="keyword">while</span>(p0[idx] != <span class="number">1</span>)&#123;p0[idx+<span class="number">1</span>] = <span class="built_in">phi</span>(p0[idx]);idx++;&#125;</span><br><span class="line">	<span class="keyword">for</span>(ll i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		cin &gt;&gt; w[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> q;</span><br><span class="line">	cin &gt;&gt; q;</span><br><span class="line">	<span class="keyword">while</span>(q--)&#123;</span><br><span class="line">		<span class="keyword">int</span> l,r;</span><br><span class="line">		cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">cal</span>(l,r,<span class="number">0</span>)%mod &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
</tr>
<tr class="even">
<td>## 原根</td>
</tr>
<tr class="odd">
<td><code>proot(p)</code> 返回素数p的原根</td>
</tr>
<tr class="even">
<td><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt;pri;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">g_test</span><span class="params">(ll g,ll p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(ll x:pri)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">Pow</span>(g,(p<span class="number">-1</span>)/x,p) == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">proot</span><span class="params">(ll p)</span></span>&#123;</span><br><span class="line">	ll tmp = p<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(ll i = <span class="number">2</span>;i &lt;= tmp/i;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(tmp%i == <span class="number">0</span>)&#123;</span><br><span class="line">			pri.<span class="built_in">push_back</span>(i);</span><br><span class="line">			<span class="keyword">while</span>(tmp%i == <span class="number">0</span>)tmp /= i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(tmp != <span class="number">1</span>)pri.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">	ll g = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">g_test</span>(g,p))<span class="keyword">return</span> g;</span><br><span class="line">		g++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
</tr>
<tr class="odd">
<td>## 离散对数(BSGS)</td>
</tr>
<tr class="even">
<td>### 原版</td>
</tr>
<tr class="odd">
<td>只支持模数为<span class="math inline">\(p\)</span>的情况.</td>
</tr>
<tr class="even">
<td><code>bsgs(ll a,ll b,ll p)</code>返回最小的<span class="math inline">\(x\)</span>使得<span class="math inline">\(a^x \equiv b\pmod{p}\)</span>, 不存在则返回<span class="math inline">\(-1\)</span>. 要求<span class="math inline">\(p\)</span>为素数. 时间复杂度<span class="math inline">\(O(\sqrt p \cdot \log(\sqrt{p}))\)</span></td>
</tr>
<tr class="odd">
<td><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsgs</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;f;</span><br><span class="line">	<span class="keyword">int</span> m = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(p));</span><br><span class="line">	b %= p;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">		b = <span class="number">1ll</span>*b*a%p;</span><br><span class="line">		f[b] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> v = <span class="built_in">Pow</span>(a,m,p);</span><br><span class="line">	b = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">		b = <span class="number">1ll</span>*b*v%p;</span><br><span class="line">		<span class="keyword">if</span>(f.<span class="built_in">count</span>(b))<span class="keyword">return</span> (<span class="number">1ll</span>*i*m - f[b] + p)%p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
</tr>
<tr class="even">
<td>求最小的正整数<span class="math inline">\(n\)</span>使得<span class="math inline">\(a^n \equiv 1 \pmod m\)</span></td>
</tr>
<tr class="odd">
<td><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ord</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">	a %= m;</span><br><span class="line">	<span class="keyword">if</span>(__gcd(a,m) != <span class="number">1</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> sq = <span class="built_in">sqrt</span>(m)+<span class="number">1</span>;</span><br><span class="line">	map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;mp;</span><br><span class="line">	ll s = a;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= sq;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!mp.<span class="built_in">count</span>(s))mp[s] = i;</span><br><span class="line">		s = s*a%m;</span><br><span class="line">	&#125;</span><br><span class="line">	ll g = <span class="built_in">inv</span>(<span class="built_in">Pow</span>(a,sq,m),m),x = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt;= m/sq;k++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(mp.<span class="built_in">count</span>(x))<span class="keyword">return</span> sq*k + mp[x];</span><br><span class="line">		x = x*g%m;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
</tr>
<tr class="even">
<td>### 扩展版</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(p\)</span>可以是任意模数. 前置:<code>bsgs exgcd inv</code></td>
</tr>
<tr class="even">
<td><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exbsgs</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(b == <span class="number">1</span> <span class="keyword">or</span> p == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> g = __gcd(a,p),k = <span class="number">0</span>,na = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(g &gt; <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b%g != <span class="number">0</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		k++;</span><br><span class="line">		b /= g;p /= g;na = na*(a/g)%p;</span><br><span class="line">		<span class="keyword">if</span>(na == b)<span class="keyword">return</span> k;</span><br><span class="line">		g = __gcd(a,p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> f = <span class="built_in">bsgs</span>(a,b*<span class="built_in">inv</span>(na,p)%p,p);</span><br><span class="line">	<span class="keyword">if</span>(f == <span class="number">-1</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> f+k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
</tr>
<tr class="odd">
<td>## 拉格朗日插值</td>
</tr>
<tr class="even">
<td>px,py为点坐标,p为模数,k是L(k)那个k inv为逆元</td>
</tr>
<tr class="odd">
<td>返回L(k)</td>
</tr>
<tr class="even">
<td><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">lagrange</span><span class="params">(ll n,ll k)</span></span>&#123;</span><br><span class="line">	ll tans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		ll f = <span class="number">1</span>,g = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)<span class="keyword">if</span>(i != j)&#123;</span><br><span class="line">			f = f*(k - px[j]+p)%p;</span><br><span class="line">			g = g*(px[i] - px[j]+p)%p;</span><br><span class="line">		&#125;</span><br><span class="line">		ll lota = py[i]*f%p*<span class="built_in">inv</span>(g,p)%p;</span><br><span class="line">		tans = (tans+lota)%p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tans; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
</tr>
<tr class="odd">
<td>### 线性求<span class="math inline">\(\sum_{i = 0}^{n}i^k\)</span></td>
</tr>
<tr class="even">
<td>(返回L(k)的值,多项式次数为n.按需更改yi的值,复杂度<span class="math inline">\(O(k)\)</span>)</td>
</tr>
<tr class="odd">
<td>(注意求<span class="math inline">\(\sum_{i = 0}^{n}i^k\)</span>需要调用line_lagrange(k+2,n) )</td>
</tr>
<tr class="even">
<td><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">line_lagrange</span><span class="params">(ll n,ll k)</span></span>&#123;</span><br><span class="line">	ll tans = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">get_inv</span>();</span><br><span class="line">	pre[<span class="number">0</span>] = suf[n+<span class="number">1</span>] = ifac[<span class="number">0</span>] =  <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		pre[i] = pre[i<span class="number">-1</span>]*(k-i)%mod;</span><br><span class="line">		ifac[i] = ifac[i<span class="number">-1</span>]*invs[i]%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n;i &gt;= <span class="number">0</span>;i--)suf[i] = suf[i+<span class="number">1</span>]*(k-i)%mod;</span><br><span class="line">	ll yi = <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		yi = (yi+<span class="built_in">pow_mod</span>(i,n<span class="number">-2</span>))%mod;</span><br><span class="line">		ll a = pre[i<span class="number">-1</span>]*suf[i+<span class="number">1</span>]%mod*yi%mod*ifac[i<span class="number">-1</span>]%mod*ifac[n-i]%mod;</span><br><span class="line">		<span class="keyword">if</span>((n-i)%<span class="number">2</span>)a = mod-a; </span><br><span class="line">		tans = (tans+a+mod)%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
</tr>
<tr class="odd">
<td>## 卢卡斯定理</td>
</tr>
<tr class="even">
<td>Lucas(n,m) = C(n%p,m%p)*Lucas(n/p,m/p)%p</td>
</tr>
<tr class="odd">
<td>p需为素数,fac[]为预处理的阶乘,时间复杂度大约是<span class="math inline">\(O(p + mlogm)\)</span>(预处理需要<span class="math inline">\(O(p)\)</span>)</td>
</tr>
<tr class="even">
<td><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n,ll m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(m &gt; n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> (fac[n]*<span class="built_in">Pow</span>(fac[m],p<span class="number">-2</span>)%p*<span class="built_in">Pow</span>(fac[n-m],p<span class="number">-2</span>)%p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">Lucas</span><span class="params">(ll n,ll m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!m)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">C</span>(n%p,m%p)*<span class="built_in">Lucas</span>(n/p,m/p)%p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
</tr>
</tbody>
</table>
<h2 id="线性基">线性基</h2>
<p>maxbit取值域位数</p>
<p>insert返回0则说明现有基可以表示x</p>
<p>qmax返回异或最大值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinerBasis</span>&#123;</span></span><br><span class="line">	ll base[maxbit+<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">bool</span> vis[maxbit+<span class="number">4</span>];</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = maxbit;~i;i--)&#123;</span><br><span class="line">			<span class="keyword">if</span>(x&amp;(<span class="number">1LL</span>&lt;&lt;i))&#123;</span><br><span class="line">				<span class="keyword">if</span>(!base[i])&#123;</span><br><span class="line">					base[i] = x;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> x ^= base[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">qmax</span><span class="params">()</span></span>&#123;</span><br><span class="line">		ll ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = maxbit;~i;i--)ans = <span class="built_in">max</span>(ans,ans^base[i]);</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;yay;</span><br></pre></td></tr></table></figure>
<h2 id="杜教bm快速求模意义下线性递推式">杜教BM(快速求模意义下线性递推式)</h2>
<p>设<span class="math inline">\(n\)</span>为输入项数, 复杂度<span class="math inline">\(O(n^2\log n)\)</span>. 对于<span class="math inline">\(k\)</span>阶递推式(例如斐波那契数列为2阶递推式)至少需要前<span class="math inline">\(2k\)</span>项</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(x) ((ll)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;ll&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; PII;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="function">ll <span class="title">powmod</span><span class="params">(ll a, ll b)</span> </span>&#123; ll res = <span class="number">1</span>; a %= mod; <span class="built_in">assert</span>(b &gt;= <span class="number">0</span>); <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123; <span class="keyword">if</span> (b &amp; <span class="number">1</span>)res = res * a % mod; a = a * a % mod; &#125;<span class="keyword">return</span> res; &#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"> </span><br><span class="line">ll _, n;</span><br><span class="line"><span class="keyword">namespace</span> linear_seq &#123;</span><br><span class="line">    <span class="keyword">const</span> ll N = <span class="number">10010</span>;</span><br><span class="line">    ll res[N], base[N], _c[N], _md[N];</span><br><span class="line"> </span><br><span class="line">    vector&lt;ll&gt; Md;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(ll* a, ll* b, ll k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">0</span>, k + k) _c[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">0</span>, k) <span class="keyword">if</span> (a[i]) <span class="built_in">rep</span>(j, <span class="number">0</span>, k) _c[i + j] = (_c[i + j] + a[i] * b[j]) % mod;</span><br><span class="line">        <span class="keyword">for</span> (ll i = k + k - <span class="number">1</span>; i &gt;= k; i--) <span class="keyword">if</span> (_c[i])</span><br><span class="line">            <span class="built_in">rep</span>(j, <span class="number">0</span>, <span class="built_in">SZ</span>(Md)) _c[i - k + Md[j]] = (_c[i - k + Md[j]] - _c[i] * _md[Md[j]]) % mod;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">0</span>, k) a[i] = _c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">solve</span><span class="params">(ll n, VI a, VI b)</span> </span>&#123; <span class="comment">// a 系数 b 初值 b[n+1]=a[0]*b[n]+...</span></span><br><span class="line"><span class="comment">//        printf(&quot;%d\n&quot;,SZ(b));</span></span><br><span class="line">        ll ans = <span class="number">0</span>, pnt = <span class="number">0</span>;</span><br><span class="line">        ll k = <span class="built_in">SZ</span>(a);</span><br><span class="line">        <span class="built_in">assert</span>(<span class="built_in">SZ</span>(a) == <span class="built_in">SZ</span>(b));</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">0</span>, k) _md[k - <span class="number">1</span> - i] = -a[i]; _md[k] = <span class="number">1</span>;</span><br><span class="line">        Md.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">0</span>, k) <span class="keyword">if</span> (_md[i] != <span class="number">0</span>) Md.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">0</span>, k) res[i] = base[i] = <span class="number">0</span>;</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((<span class="number">1ll</span> &lt;&lt; pnt) &lt;= n) pnt++;</span><br><span class="line">        <span class="keyword">for</span> (ll p = pnt; p &gt;= <span class="number">0</span>; p--) &#123;</span><br><span class="line">            <span class="built_in">mul</span>(res, res, k);</span><br><span class="line">            <span class="keyword">if</span> ((n &gt;&gt; p) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (ll i = k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) res[i + <span class="number">1</span>] = res[i]; res[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">rep</span>(j, <span class="number">0</span>, <span class="built_in">SZ</span>(Md)) res[Md[j]] = (res[Md[j]] - res[k] * _md[Md[j]]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">0</span>, k) ans = (ans + res[i] * b[i]) % mod;</span><br><span class="line">        <span class="keyword">if</span> (ans &lt; <span class="number">0</span>) ans += mod;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">VI <span class="title">BM</span><span class="params">(VI s)</span> </span>&#123;</span><br><span class="line">        <span class="function">VI <span class="title">C</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>)</span>, <span class="title">B</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        ll L = <span class="number">0</span>, m = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(n, <span class="number">0</span>, <span class="built_in">SZ</span>(s)) &#123;</span><br><span class="line">            ll d = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">rep</span>(i, <span class="number">0</span>, L + <span class="number">1</span>) d = (d + (ll)C[i] * s[n - i]) % mod;</span><br><span class="line">            <span class="keyword">if</span> (d == <span class="number">0</span>) ++m;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">2</span> * L &lt;= n) &#123;</span><br><span class="line">                VI T = C;</span><br><span class="line">                ll c = mod - d * <span class="built_in">powmod</span>(b, mod - <span class="number">2</span>) % mod;</span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">SZ</span>(C) &lt; <span class="built_in">SZ</span>(B) + m) C.<span class="built_in">pb</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="built_in">SZ</span>(B)) C[i + m] = (C[i + m] + c * B[i]) % mod;</span><br><span class="line">                L = n + <span class="number">1</span> - L; B = T; b = d; m = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ll c = mod - d * <span class="built_in">powmod</span>(b, mod - <span class="number">2</span>) % mod;</span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">SZ</span>(C) &lt; <span class="built_in">SZ</span>(B) + m) C.<span class="built_in">pb</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="built_in">SZ</span>(B)) C[i + m] = (C[i + m] + c * B[i]) % mod;</span><br><span class="line">                ++m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> C;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">gao</span><span class="params">(VI a, ll n)</span> </span>&#123;</span><br><span class="line">        VI c = <span class="built_in">BM</span>(a);</span><br><span class="line">        c.<span class="built_in">erase</span>(c.<span class="built_in">begin</span>());</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="built_in">SZ</span>(c)) c[i] = (mod - c[i]) % mod;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">solve</span>(n, c, <span class="built_in">VI</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">begin</span>() + <span class="built_in">SZ</span>(c)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n)) &#123;</span><br><span class="line">        vector&lt;ll&gt;v;</span><br><span class="line">        v.<span class="built_in">push_back</span>(<span class="number">1</span>);<span class="comment">/*前几项*/</span>v.<span class="built_in">push_back</span>(<span class="number">5</span>);v.<span class="built_in">push_back</span>(<span class="number">15</span>);</span><br><span class="line">        v.<span class="built_in">push_back</span>(<span class="number">35</span>);v.<span class="built_in">push_back</span>(<span class="number">70</span>);v.<span class="built_in">push_back</span>(<span class="number">126</span>);</span><br><span class="line">        v.<span class="built_in">push_back</span>(<span class="number">210</span>);v.<span class="built_in">push_back</span>(<span class="number">330</span>);v.<span class="built_in">push_back</span>(<span class="number">495</span>);v.<span class="built_in">push_back</span>(<span class="number">715</span>);</span><br><span class="line">        v.<span class="built_in">push_back</span>(<span class="number">1001</span>);</span><br><span class="line">        <span class="comment">//输入n ,输出第n项的值  一般大于10项即可出答案，越多越好</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, linear_seq::<span class="built_in">gao</span>(v, n - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="特殊计数序列">特殊计数序列</h1>
<h2 id="第二类stirling数">第二类Stirling数</h2>
<p>第二类Stirling数<span class="math inline">\(S(n,m)\)</span>计数的是把<span class="math inline">\(n\)</span>个元素的集合划分到<span class="math inline">\(m\)</span>个不可区分的盒子中且没有空盒子的划分个数.</p>
<p><span class="math inline">\(S(n,n) = 1\)</span>, <span class="math inline">\(S(n,0) = 0\space(n &gt; 0)\)</span></p>
<p>递推式: <span class="math inline">\(S(n,m) = m \cdot S(n-1,m) + S(n-1,m-1)\)</span></p>
<h3 id="求第n行">求第n行</h3>
<p><span class="math display">\[
S(n,m) = \sum_{i = 0}^m \frac{i^n}{i!}\cdot\frac{(-1)^{m-i}}{(m-i)!}
\]</span> 用NTT求解即可. <code>finv[i]</code>为<span class="math inline">\(i!\)</span>的逆元, 需要<strong>线性</strong>预处理出来. <code>mul()</code>见NTT板子. 时间复杂度<span class="math inline">\(O(n \log n)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Poly <span class="title">Stirling_row</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="function">Poly <span class="title">A</span><span class="params">(n+<span class="number">1</span>)</span>,<span class="title">B</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		A[i] = <span class="number">1ll</span>*<span class="built_in">Pow</span>(i,n)*finv[i]%p;</span><br><span class="line">		B[i] = ( ( <span class="number">1ll</span> * ((n-i)%<span class="number">2</span>?<span class="number">-1</span>:<span class="number">1</span>) * finv[n-i] )%p+p)%p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">reverse</span>(B.<span class="built_in">begin</span>(),B.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">auto</span> tans = <span class="built_in">mul</span>(A,B);</span><br><span class="line">	tans.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> tans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求第k列">求第k列</h3>
<p><span class="math display">\[
\sum_{n = k}^{\infin}S(n,k) \cdot \frac{x^n}{n!} = \frac{(e^x - 1)^k}{k!}
\]</span></p>
<p>因而有 <span class="math display">\[
S(n,k) = \frac{n!}{k!}\cdot[n](e^x - 1)^k
\]</span> 多项式快速幂即可. 时间复杂度<span class="math inline">\(O(n \log n)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Poly <span class="title">Stirling_Col</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="function">Poly <span class="title">A</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)A[i] = finv[i];</span><br><span class="line">	A = <span class="built_in">powP</span>(A,k,k);</span><br><span class="line">	A.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)A[i] = <span class="number">1ll</span>*A[i]*finv[k]%p*fac[i]%p;</span><br><span class="line">		<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="bell数">Bell数</h2>
<p>Bell数(<span class="math inline">\(B(n)\)</span>)计数的是将一个有<span class="math inline">\(n\)</span>个元素的集合划分成任意个非空子集的方案数. 显然有<span class="math inline">\(B(n) = \sum_{i = 1}^n S(n,i)\)</span></p>
<p>前10个Bell数为<code>1 2 5 15 52 203 877 4140 21147 115975</code> <span class="math display">\[
B(n) = [n]e^{e^x - 1}
\]</span> 多项式指数函数即可. 时间复杂度<span class="math inline">\(O(n\log n)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Poly <span class="title">Bell</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="function">Poly <span class="title">A</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)A[i] = finv[i];</span><br><span class="line">	A = <span class="built_in">expP</span>(A);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)A[i] = <span class="number">1ll</span>*A[i]*fac[i]%p;</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="博弈论">博弈论</h1>
<h2 id="威佐夫游戏">威佐夫游戏</h2>
<p>两人轮流取两堆筹码，其中取法有两种：取走一堆中任意个筹码，或从两堆中取走相同数目的筹码。取完所有筹码的一方获胜。</p>
<p>(1为先手胜)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(n1&gt;n2)  <span class="built_in">swap</span>(n1,n2);</span><br><span class="line">temp=<span class="built_in">floor</span>((n2-n1)*(<span class="number">1</span>+<span class="built_in">sqrt</span>(<span class="number">5.0</span>))/<span class="number">2.0</span>);</span><br><span class="line"><span class="keyword">if</span>(temp==n1) cout&lt;&lt;<span class="string">&quot;0&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;1&quot;</span>&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<h1 id="矩阵">矩阵</h1>
<h2 id="定义快速幂">定义&amp;快速幂</h2>
<p><strong>注意：vector版的矩阵会比数组慢起码2倍，时间吃紧的时候慎用</strong></p>
<p>数组版:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,a,b) for(int i = a;i &lt;= b;i++)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line">	ll A[maxn][maxn];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">initer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)A[i][j] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)A[i][i] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix &amp; a)&#123;</span><br><span class="line">		Matrix res;</span><br><span class="line">		<span class="built_in">memset</span>(res.A,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(res.A));</span><br><span class="line">		<span class="built_in">FOR</span>(k,<span class="number">1</span>,n)</span><br><span class="line">			<span class="built_in">FOR</span>(i,<span class="number">1</span>,n)</span><br><span class="line">				<span class="built_in">FOR</span>(j,<span class="number">1</span>,n)&#123;</span><br><span class="line">					res.A[i][j] = (res.A[i][j] + (A[i][k]*a.A[k][j]));</span><br><span class="line">					<span class="keyword">if</span>(res.A[i][j] &gt; MOD2)res.A[i][j] -= MOD2;</span><br><span class="line">				&#125;</span><br><span class="line">		<span class="built_in">FOR</span>(i,<span class="number">1</span>,n)</span><br><span class="line">			<span class="built_in">FOR</span>(j,<span class="number">1</span>,n)res.A[i][j] %= MOD;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>vector版:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; Matrix;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Minit</span><span class="params">(Matrix &amp; a)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)a[i][j] = (i == j);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix &amp; a,<span class="keyword">const</span> Matrix &amp; b)&#123;<span class="comment">//需保证a的列数等于b的行数且两个矩阵都不为空</span></span><br><span class="line">	<span class="keyword">int</span> n = a.<span class="built_in">size</span>(),m = b.<span class="built_in">size</span>(),r = b[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">	<span class="function">Matrix <span class="title">res</span><span class="params">(n,vector&lt;<span class="keyword">int</span>&gt;(m))</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; m;k++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; r;j++)&#123;</span><br><span class="line">				res[i][j] = (res[i][j] + (<span class="number">1ll</span>*a[i][k]*b[k][j])%MOD)%MOD;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Matrix <span class="title">matrixPow</span><span class="params">(Matrix x,ll d)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = x.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function">Matrix <span class="title">ans</span><span class="params">(n,vector&lt;<span class="keyword">int</span>&gt;(n))</span></span>;</span><br><span class="line">	<span class="built_in">Minit</span>(ans);</span><br><span class="line">	<span class="keyword">while</span>(d)&#123;</span><br><span class="line">		<span class="keyword">if</span>(d&amp;<span class="number">1</span>)ans = ans*x;</span><br><span class="line">		x = x*x;</span><br><span class="line">		d /= <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="置换矩阵">置换矩阵</h2>
<p>每一行每一列有且仅有一个<span class="math inline">\(1\)</span>, 其余元素为<span class="math inline">\(0\)</span>的矩阵为置换矩阵.</p>
<p>置换矩阵的逆是它的转置.</p>
<h2 id="循环矩阵">循环矩阵</h2>
<p>除第一行外, 其余每行都是上一行循环右移一格的矩阵是循环矩阵. 循环矩阵的乘积仍是循环矩阵.</p>
<p>因此只需保存和计算循环矩阵的第一行, 两个循环矩阵相乘复杂度为<span class="math inline">\(O(n^2)\)</span></p>
<figure>
<img src="E:\Github\hexo\source_posts\image-20210924200136207.png" alt="image-20210924200136207" /><figcaption aria-hidden="true">image-20210924200136207</figcaption>
</figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="keyword">int</span>&gt; cirMatrix;<span class="comment">//循环矩阵只需保存第一行</span></span><br><span class="line"><span class="function">Matrix <span class="title">buildCirMatrix</span><span class="params">(<span class="keyword">const</span> cirMatrix &amp; a)</span></span>&#123;<span class="comment">//构建循环矩阵,此处为右移</span></span><br><span class="line">	<span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function">Matrix <span class="title">res</span><span class="params">(n,vector&lt;<span class="keyword">int</span>&gt;(n))</span></span>;</span><br><span class="line">	res[<span class="number">0</span>] = a;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">		res[i][<span class="number">0</span>] = res[i<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; n;j++)res[i][j] = res[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">cirMatrix <span class="keyword">operator</span> * (<span class="keyword">const</span> cirMatrix &amp; a,<span class="keyword">const</span> cirMatrix &amp; b)&#123;</span><br><span class="line">	Matrix A = <span class="built_in">Matrix</span>(<span class="number">1</span>,a);</span><br><span class="line">	Matrix B = <span class="built_in">buildCirMatrix</span>(b);</span><br><span class="line">	<span class="keyword">return</span> (A*B)[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">cirMatrix <span class="title">matrixPow</span><span class="params">(cirMatrix x,ll d)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = x.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function">cirMatrix <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">	ans[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(d)&#123;</span><br><span class="line">		<span class="keyword">if</span>(d&amp;<span class="number">1</span>)ans = ans*x;</span><br><span class="line">		x = x*x;</span><br><span class="line">		d /= <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高斯消元">高斯消元</h2>
<p>输入一个<span class="math inline">\(n\)</span>行<span class="math inline">\(n+1\)</span>列的矩阵,其中<span class="math inline">\(A[i][n]\)</span>代表等式右边第<span class="math inline">\(i\)</span>个值. 复杂度<span class="math inline">\(O(n^3)\)</span></p>
<p><code>gauss(矩阵,n)</code>返回1有解, 返回0无解</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">gauss</span><span class="params">(vector&lt;vector&lt;ld&gt; &gt; &amp; A,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> r = i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt; n;j++)<span class="keyword">if</span>(<span class="built_in">fabs</span>(A[j][i]) &gt; <span class="built_in">fabs</span>(A[r][i]))r = j;</span><br><span class="line">		<span class="keyword">if</span>(r != i)<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n+<span class="number">1</span>;j++)<span class="built_in">swap</span>(A[i][j],A[r][j]);</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">fabs</span>(A[i][i]) &lt;= eps)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = n;j &gt;= i;j--)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k = i+<span class="number">1</span>;k &lt; n;k++)&#123;<span class="comment">//提高精度</span></span><br><span class="line">				A[k][j] -= A[k][i]/A[i][i]*A[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt; n;j++)A[i][n] -= A[j][n]*A[i][j];</span><br><span class="line">		A[i][n] /= A[i][i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异或方程组">异或方程组</h3>
<p>时间复杂度<span class="math inline">\(O(\frac{n^3}{w})\)</span>, <span class="math inline">\(w = 32或64\)</span>, 取决于评测机位数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxb = <span class="number">1005</span>;</span><br><span class="line">vector&lt;bitset&lt;maxb&gt; &gt; <span class="built_in">a</span>(m,bitset&lt;maxb&gt;());</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xorRank</span><span class="params">(vector&lt;bitset&lt;maxb&gt; &gt; &amp; a,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">	<span class="comment">//n个未知数, m个方程</span></span><br><span class="line">	<span class="keyword">int</span> mr = <span class="number">-1</span>,i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i &lt; m <span class="keyword">and</span> j &lt; n)&#123;</span><br><span class="line">		<span class="keyword">int</span> r = i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k = i;k &lt; m;k++)<span class="keyword">if</span>(a[k][j])&#123;r = k;<span class="keyword">break</span>;&#125;</span><br><span class="line">		<span class="keyword">if</span>(a[r].<span class="built_in">test</span>(j))&#123;</span><br><span class="line">			mr = <span class="built_in">max</span>(mr,r);</span><br><span class="line">			<span class="keyword">if</span>(r != i)<span class="built_in">swap</span>(a[r],a[i]);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> u = i+<span class="number">1</span>;u &lt; m;u++)<span class="keyword">if</span>(a[u].<span class="built_in">test</span>(j))a[u] ^= a[i];</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//else return 0; //某一行全为0, 说明有多解</span></span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k = m<span class="number">-1</span>;k &gt;= <span class="number">0</span>;k--)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = k+<span class="number">1</span>;j &lt; m;j++)a[k][m<span class="number">-1</span>] = (a[k][m<span class="number">-1</span>] ^ (a[j][m<span class="number">-1</span>] &amp; a[k][j]));</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> i;<span class="comment">//返回该矩阵的秩</span></span><br><span class="line">	<span class="comment">//return mr+1;//返回最少使用了几个方程组来得到解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="行列式">行列式</h2>
<h3 id="浮点数版">浮点数版</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ld eps = <span class="number">1e-9</span>;</span><br><span class="line"><span class="function">ld <span class="title">caldet</span><span class="params">(vector&lt;vector&lt;ld&gt; &gt; &amp; a,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	ld det = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> k = i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt; n;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">fabs</span>(a[j][i]) &gt; <span class="built_in">fabs</span>(a[k][i]))k = j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">fabs</span>(a[k][i]) &lt; eps)&#123;</span><br><span class="line">			det = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">swap</span>(a[i],a[k]);</span><br><span class="line">		<span class="keyword">if</span>(i != k)det = -det;</span><br><span class="line">		det *= a[i][i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt; n;j++)a[i][j] /= a[i][i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j != i <span class="keyword">and</span> <span class="built_in">fabs</span>(a[j][i]) &gt; eps)&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k = i+<span class="number">1</span>;k &lt; n;k++)&#123;</span><br><span class="line">					a[j][k] -= a[i][k] * a[j][i];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> det;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="整数版">整数版</h3>
<p>输入一个vector矩阵, 输出行列式模<span class="math inline">\(p\)</span>的值. 均摊复杂度<span class="math inline">\(O(n^3 + n^2\log n)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">caldet</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; &amp; a,<span class="keyword">int</span> n,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> det = <span class="number">1</span>,w = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt; n;j++)&#123;</span><br><span class="line">			<span class="keyword">while</span>(a[i][i])&#123;</span><br><span class="line">				<span class="keyword">int</span> div = a[j][i]/a[i][i];</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k = i;k &lt; n;k++)&#123;</span><br><span class="line">					a[j][k] = (a[j][k] - <span class="number">1ll</span>*div*a[i][k]%p + p)%p;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">swap</span>(a[i],a[j]);w = -w;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">swap</span>(a[i],a[j]);w = -w;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)det = <span class="number">1ll</span>*a[i][i]*det % p;</span><br><span class="line">	det = (<span class="number">1ll</span>*w*det + p)%p;</span><br><span class="line">	<span class="keyword">return</span> det;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="kirchhoff-矩阵树定理">Kirchhoff 矩阵树定理</h2>
<p>矩阵树定理用于求解图的生成树个数. 来源: https://oi-wiki.org/graph/matrix-tree/</p>
<p>设<span class="math inline">\(t(G)\)</span>为图<span class="math inline">\(G\)</span>的全部生成树边权积的和(当边权为1时即为全部生成树的个数)</p>
<p>即 <span class="math display">\[
t(G) = \sum_{T \in G} \prod_{e \in T}w_e
\]</span> 其中<span class="math inline">\(T\)</span>代表图<span class="math inline">\(G\)</span>的生成树, <span class="math inline">\(e\)</span>为生成树上的边，<span class="math inline">\(w_e\)</span>为边的权值.</p>
<p>以下所讨论的图允许重边但不允许自环(去掉自环即可).</p>
<h3 id="无向图形式-行列式">无向图形式-行列式</h3>
<p>设<span class="math inline">\(D\)</span>为无向图<span class="math inline">\(G\)</span>的度数矩阵, <span class="math inline">\(A\)</span>为无向图的邻接矩阵. <span class="math inline">\(deg(x)\)</span>为点<span class="math inline">\(x\)</span>的度数.</p>
<p>则<span class="math inline">\(D[i][i] = deg(i) \cdot[i == j]\)</span>, <span class="math inline">\(A[i][j] = |i与j间的连边权值之和|\)</span></p>
<p>设<span class="math inline">\(Laplace\)</span>矩阵<span class="math inline">\(L = D - A\)</span>. <span class="math inline">\(L_r\)</span>为<span class="math inline">\(L\)</span>的<span class="math inline">\(n-1\)</span>阶主子式(即将矩阵<span class="math inline">\(L\)</span>去掉第<span class="math inline">\(r\)</span>行第<span class="math inline">\(r\)</span>)列.</p>
<p>则对任意的<span class="math inline">\(r\)</span>, <span class="math inline">\(L_r\)</span>的行列式为该无向图的生成树个数. 即<span class="math inline">\(t(G) = det(L_r)\)</span></p>
<h3 id="无向图形式-特征值">无向图形式-特征值</h3>
<p>若<span class="math inline">\(\lambda_1,\lambda_2,...,\lambda_{n-1}\)</span>为<span class="math inline">\(L\)</span>的<span class="math inline">\(n-1\)</span>个非负特征值, 则有 <span class="math display">\[
t(G) = \frac{1}{n}\prod_{i = 1}^{n-1}\lambda_i
\]</span></p>
<h3 id="有向图形式">有向图形式</h3>
<p>有向图的生成树分两种: 根向, 所有边均由儿子指向父亲; 叶向, 所有边均由父亲指向儿子.</p>
<p>设<span class="math inline">\(D^{out}\)</span>为有向图<span class="math inline">\(G\)</span>的出度矩阵, <span class="math inline">\(D^{in}\)</span>为有向图<span class="math inline">\(G\)</span>的入度矩阵, 两者与无向图形式相同.</p>
<p><span class="math inline">\(A\)</span>为有向图邻接矩阵, <span class="math inline">\(A[i][j] = |i指向j的边数|\)</span></p>
<p>设入度Laplace矩阵<span class="math inline">\(L^{in} = D^{in} - A\)</span>, 出度Laplace矩阵为<span class="math inline">\(L^{out} = D^{out} - A\)</span></p>
<p>则以<span class="math inline">\(k\)</span>为根的叶向生成树个数为<span class="math inline">\(t^{leaf}(G,k) = det(L_k^{in})\)</span>, 根向生成树个数为<span class="math inline">\(t^{root}(G,k) =det(L_k^{out})\)</span>.</p>
<p>若要求所有生成树, 枚举<span class="math inline">\(k\)</span>并求和即可.</p>
<h3 id="带权形式">带权形式</h3>
<p>对有向图无向图均适用. 将带权边转化为无权的重边, 重边次数为边权即可.</p>
<h3 id="best定理">BEST定理</h3>
<p>通过图中所有边恰好一次且行遍所有顶点的回路称为欧拉回路.</p>
<p>具有欧拉回路的无向图或有向图称为欧拉图.</p>
<p>设 <span class="math inline">\(G\)</span> 是有向欧拉图，那么 <span class="math inline">\(G\)</span> 的不同欧拉回路总数 <span class="math inline">\(ec(G)\)</span> 是 <span class="math display">\[
ec(G) = t^{root}(G,k)\prod_{v\in V}(\deg (v) - 1)! 
\]</span></p>
<p>注意，对欧拉图 <span class="math inline">\(G\)</span> 的任意两个节点 <span class="math inline">\(k, k&#39;\)</span>，都有 <span class="math inline">\(t^{root}(G,k)=t^{root}(G,k&#39;)\)</span>，且欧拉图 <span class="math inline">\(G\)</span> 的所有节点的入度和出度相等。</p>
<h2 id="一些例题">一些例题</h2>
<h3 id="加速递推式">加速递推式</h3>
<p>以<span class="math inline">\(Fibonacci\)</span>为例:</p>
<p><span class="math inline">\(f(1) = f(2) = 1,f(n) = f(n-1) + f(n-2),(n \geq 10^9)\)</span>,求<span class="math inline">\(f(n)\)</span></p>
<p>设 <span class="math display">\[
F_i = 
\begin{bmatrix}
    f_{i+1}\\
    f_i
\end{bmatrix},
F_0 = 
\begin{bmatrix}
 f_1\\
 f_0
\end{bmatrix}
\]</span> 且<span class="math inline">\(F_i = A^i \cdot F_0\)</span></p>
<p>则有 <span class="math display">\[
A = 
\begin{bmatrix}
1 &amp; 1\\
1 &amp; 0
\end{bmatrix}
\]</span> 一般地, 对于递推式<span class="math inline">\(f(i) = \sum_{i = 1}^{k}a_i \cdot f(i-k)\)</span></p>
<p>有: <span class="math display">\[
F_i = 
\begin{bmatrix}
f(i+k-1)\\
f(i+k-2)\\
...\\
f(i)
\end{bmatrix},
A = \begin{bmatrix}
a_1 &amp; a_2 &amp; a_3 &amp; ... &amp; a_k\\
1 &amp; 0 &amp; 0&amp; \cdots &amp; 0\\
0 &amp; 1 &amp; 0 &amp; \cdots &amp; 0\\
0 &amp; 0 &amp; 1 &amp; \cdots &amp; 0\\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\
0 &amp; 0 &amp; \cdots &amp; 1 &amp; 0
\end{bmatrix}
\]</span> 且<span class="math inline">\(F_n = A^n \cdot F_0\)</span></p>
<h3 id="求包含严格k条边的方案数最短路">求包含严格k条边的方案数/最短路</h3>
<p>1.无权图求从<span class="math inline">\(i\)</span>到<span class="math inline">\(j\)</span>经过<span class="math inline">\(k\)</span>条边的方案数:求邻接矩阵的<span class="math inline">\(k\)</span>次幂即可</p>
<p>2.有向图求包含<span class="math inline">\(k\)</span>条边的最短路:求邻接矩阵的<span class="math inline">\(k\)</span>次幂,<strong>把普通矩阵乘法改为Floyd</strong></p>
<h1 id="分数规划">0-1分数规划</h1>
<p>给出数列<span class="math inline">\(\{a_i\},\{b_i\}\)</span>,求一组<span class="math inline">\(w_i \in \{0,1\}\)</span>, 使得 <span class="math display">\[
\frac{\sum_{i = 1}^na_i \cdot w_i}{\sum_{i = 1}^nb_i \cdot w_i}
\]</span> 最大或最小</p>
<p>或给出<span class="math inline">\(n\)</span>个物品,每个物品有两个权值<span class="math inline">\(a_i\)</span>和<span class="math inline">\(b_i\)</span>, 选择任意个物品使得<span class="math inline">\(\frac{\sum a_i}{\sum b_i}\)</span>最大</p>
<h2 id="二分法">二分法</h2>
<p><span class="math display">\[
\frac{\sum_{i = 1}^na_i \cdot w_i}{\sum_{i = 1}^nb_i \cdot w_i} \ge M \Leftrightarrow \sum_{i = 1}^n w_i \cdot (a_i - M\cdot b_i) \ge 0
\]</span></p>
<p>因此只需判断$_{i = 1}^n w_i (a_i - Mb_i) <span class="math inline">\(的最大值是否非负即可对\)</span>M$二分.</p>
<h2 id="dinkelbach-算法迭代法">Dinkelbach 算法(迭代法)</h2>
<p>将上一轮的答案作为输入进行迭代.注意此时答案应为<span class="math inline">\(\frac{\sum_{i = 1}^na_i}{\sum_{i = 1}^nb_i}\)</span>, 而不是变形后的式子.</p>
<h2 id="例题">例题</h2>
<h3 id="poj2728desert-king">[POJ2728]Desert King</h3>
<p>给出<span class="math inline">\(n \leq 10^3\)</span>个点的横纵坐标和高度, 两点间距离为欧几里得距离, 价值为高度之差绝对值. 所有点构成一个完全图. 求一棵生成树使得</p>
<p>距离/价值比最小.</p>
<h4 id="二分法-1">二分法</h4>
<p>此题是有一定限制的0-1分数规划(所选的"物品"构成一棵生成树). 直接求边权为<span class="math inline">\(w_i \cdot (a_i - M\cdot b_i)\)</span>的最小生成树, 判断是否有解即可二分.</p>
<p>由于是完全图, 采用不加优化的Prim求解.</p>
<p>复杂度大概是<span class="math inline">\(O(n^2 \log((R - L)*2^{-eps}))\)</span></p>
<p>由于二分法较慢, 本题需要猜一个答案上界(100)才能通过=-=</p>
<p>用时<code>2610ms</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//POJ2728</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> ld;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ld INF = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ld eps = <span class="number">1e-5</span>;</span><br><span class="line">ld G[maxn][maxn],dis[maxn];</span><br><span class="line"><span class="keyword">int</span> x[maxn],y[maxn],h[maxn],n;</span><br><span class="line">ld w[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function">ld <span class="title">Dis</span><span class="params">(<span class="keyword">int</span> idx1,<span class="keyword">int</span> idx2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>((x[idx1] - x[idx2])*(x[idx1] - x[idx2])+(y[idx1] - y[idx2])*(y[idx1] - y[idx2]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">prim</span><span class="params">(ld M)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)vis[i] = <span class="number">0</span>,dis[i] = INF;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)<span class="keyword">if</span>(!vis[j])&#123;</span><br><span class="line">			<span class="keyword">if</span>(!x <span class="keyword">or</span> dis[x] &gt; dis[j])x = j;</span><br><span class="line">		&#125;</span><br><span class="line">		vis[x] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)<span class="keyword">if</span>(!vis[j])&#123;</span><br><span class="line">			dis[j] = <span class="built_in">min</span>(dis[j],w[j][x] - M*G[j][x]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ld tans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)tans += dis[i];</span><br><span class="line">	<span class="keyword">return</span> tans &gt;= <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n) == <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!n)<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x[i],&amp;y[i],&amp;h[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">				G[i][j] = <span class="built_in">Dis</span>(i,j);</span><br><span class="line">				w[i][j] = <span class="built_in">abs</span>(h[i] - h[j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ld M = <span class="number">0</span>,L = <span class="number">0</span>,R = <span class="number">100</span>;</span><br><span class="line">		<span class="keyword">while</span>(R - L &gt;= eps)&#123;</span><br><span class="line">			M = (L+R)/<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">prim</span>(M))L = M;</span><br><span class="line">			<span class="keyword">else</span> R = M;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%.3f\n&quot;</span>,L);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="迭代法">迭代法</h4>
<p>求生成树时仍按边权<span class="math inline">\(w_i \cdot (a_i - M\cdot b_i)\)</span>来计算. 但统计答案则计算<span class="math inline">\(\frac{\sum_{i = 1}^na_i}{\sum_{i = 1}^nb_i}\)</span></p>
<p>跑的飞快(<code>250ms</code>)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//POJ2728</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> ld;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ld INF = <span class="number">1e9</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ld eps = <span class="number">1e-5</span>;</span><br><span class="line">ld G[maxn][maxn],dis[maxn];</span><br><span class="line"><span class="keyword">int</span> x[maxn],y[maxn],h[maxn],to[maxn],n;</span><br><span class="line">ld w[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function">ld <span class="title">Dis</span><span class="params">(<span class="keyword">int</span> idx1,<span class="keyword">int</span> idx2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>((x[idx1] - x[idx2])*(x[idx1] - x[idx2])+(y[idx1] - y[idx2])*(y[idx1] - y[idx2]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ld <span class="title">prim</span><span class="params">(ld M)</span></span>&#123;</span><br><span class="line">	ld up = <span class="number">0</span>,down = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)vis[i] = <span class="number">0</span>,dis[i] = INF,to[i] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)<span class="keyword">if</span>(!vis[j])&#123;</span><br><span class="line">			<span class="keyword">if</span>(!x <span class="keyword">or</span> dis[x] &gt; dis[j])x = j;</span><br><span class="line">		&#125;</span><br><span class="line">		vis[x] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)<span class="keyword">if</span>(!vis[j])&#123;</span><br><span class="line">			<span class="keyword">if</span>(dis[j] &gt; w[x][j] - M*G[x][j])dis[j] = w[x][j] - M*G[x][j],to[j] = x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		up += w[i][to[i]];</span><br><span class="line">		down += G[i][to[i]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> up/down;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n) == <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!n)<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x[i],&amp;y[i],&amp;h[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">				G[i][j] = <span class="built_in">Dis</span>(i,j);</span><br><span class="line">				w[i][j] = <span class="built_in">abs</span>(h[i] - h[j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ld ans = <span class="number">0</span>,lans = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">fabs</span>(lans - ans) &gt; eps)&#123;</span><br><span class="line">			lans = ans;</span><br><span class="line">			ans = <span class="built_in">prim</span>(ans);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%.3f\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="多项式">多项式</h1>
<h2 id="fft">FFT</h2>
<p>复数类操作:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">complex&lt;<span class="keyword">double</span>&gt;m;</span><br><span class="line">m.<span class="built_in">real</span>();m.<span class="built_in">imag</span>();<span class="comment">//获取实部虚部的值</span></span><br><span class="line">m.<span class="built_in">real</span>(<span class="number">114</span>);m.<span class="built_in">imag</span>(<span class="number">514</span>);<span class="comment">//为实部虚部赋值</span></span><br></pre></td></tr></table></figure>
<p>包括手写复数类, DFT与IDFT, 多项式乘法.</p>
<ul>
<li><p>复数类: <span class="math inline">\(x\)</span>为实部, <span class="math inline">\(y\)</span>为虚部</p></li>
<li><p><code>FFT(Comp * A,int siz,int type)</code></p>
<p>A: 复数数组, 全局变量, 为待求解的多项式</p>
<p>siz: 多项式长度. 需保证为2的次方</p>
<p>type: 1为DFT, -1为IDFT</p></li>
<li><p><code>Poly mul(Poly A,Poly B)</code></p>
<p>多项式乘法. 输入两个多项式<span class="math inline">\(A,B\)</span>, 长度分别为<span class="math inline">\(n,m\)</span>(也就是<span class="math inline">\(n-1,m-1\)</span>阶). 返回一个长度<span class="math inline">\(n - m + 1\)</span>的多项式, 为<span class="math inline">\(A,B\)</span>的乘积.</p>
<p><code>Poly</code>为<code>vector&lt;int&gt;</code>.</p></li>
</ul>
<p><strong>!!!切记在点值表示法下相乘时, 两个IDFT的长度必须相同!!!</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="keyword">int</span>&gt; Poly;</span><br><span class="line"><span class="keyword">const</span> ld PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">int</span> rev[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Comp</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    <span class="built_in">Comp</span> (<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>):<span class="built_in">x</span>(x),<span class="built_in">y</span>(y)&#123;&#125;</span><br><span class="line">    Comp <span class="keyword">operator</span> * (Comp B)&#123;</span><br><span class="line">   		<span class="keyword">return</span> <span class="built_in">Comp</span>(x*B.x - y*B.y,x*B.y + y*B.x);</span><br><span class="line">	&#125;</span><br><span class="line">	Comp <span class="keyword">operator</span> + (Comp B)&#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="built_in">Comp</span>(x + B.x,y + B.y);</span><br><span class="line">	&#125;</span><br><span class="line">	Comp <span class="keyword">operator</span> - (Comp B)&#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="built_in">Comp</span>(x - B.x,y - B.y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Comp F1[maxn],F2[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Comp * A,<span class="keyword">int</span> siz,<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = siz;</span><br><span class="line">	<span class="keyword">int</span> S = <span class="built_in">log2</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)rev[i] = (rev[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (S - <span class="number">1</span>));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)<span class="keyword">if</span>(i &lt; rev[i])<span class="built_in">swap</span>(A[i],A[rev[i]]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i *= <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="function">Comp <span class="title">Wn</span><span class="params">(cos(PI/i),type*sin(PI/i))</span></span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j += i*<span class="number">2</span>)&#123;</span><br><span class="line">			<span class="function">Comp <span class="title">W</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; i;k++)&#123;</span><br><span class="line">				Comp facx = A[j+k],facy = W*A[j+k+i];</span><br><span class="line">				A[j+k] = facx + facy;</span><br><span class="line">				A[j+k+i] = facx - facy;</span><br><span class="line">				W = W*Wn;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>(type == <span class="number">-1</span>)<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)A[i].x = (<span class="keyword">int</span>)((A[i].x/n + <span class="number">0.5</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Poly <span class="title">mul</span><span class="params">(Poly A,Poly B)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = A.<span class="built_in">size</span>(),m = B.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">int</span> siz = n + m - <span class="number">1</span>;</span><br><span class="line">	<span class="function">Poly <span class="title">C</span><span class="params">(siz)</span></span>;</span><br><span class="line">	<span class="keyword">if</span>(siz &lt; <span class="number">64</span>)&#123;<span class="comment">//小于等于64项直接暴力算</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++)C[i+j] = (C[i+j] + <span class="number">1LL</span>*A[i]*B[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> C;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> fsiz = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(fsiz &lt;= siz)fsiz *= <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; fsiz;i++)F1[i] = F2[i] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)F1[i] = A[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)F2[i] = B[i];</span><br><span class="line">	<span class="built_in">FFT</span>(F1,fsiz,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">FFT</span>(F2,fsiz,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; fsiz;i++)F1[i] = F1[i]*F2[i];</span><br><span class="line">	<span class="built_in">FFT</span>(F1,fsiz,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; siz;i++)&#123;</span><br><span class="line">		C[i] = ((ll)F1[i].x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="卷积">卷积</h3>
<p><span class="math display">\[
C[i] = \sum_{j = 0}^iA[j]B[i-j]
\]</span></p>
<p>卷积等同于多项式乘积</p>
<h2 id="ntt">NTT</h2>
<p>从OI-wiki抄来的, 用法和上面的FFT一致. 记得自己手写一遍</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">6e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(d == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>%p;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="built_in">Pow</span>(x,d/<span class="number">2</span>);</span><br><span class="line">	tans = <span class="number">1ll</span>*a*a%p;</span><br><span class="line">	<span class="keyword">if</span>(d%<span class="number">2</span>)tans = <span class="number">1ll</span>*tans*x%p; </span><br><span class="line">	<span class="keyword">return</span> tans%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="keyword">int</span>&gt; Poly;</span><br><span class="line"><span class="keyword">int</span> F1[maxn],F2[maxn];</span><br><span class="line"><span class="keyword">int</span> rev[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> * A,<span class="keyword">int</span> lim,<span class="keyword">int</span> opt)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i, j, k, m, gn, g, tmp;</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)rev[i] = (i &amp; <span class="number">1</span>)*(lim &gt;&gt; <span class="number">1</span>) + (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>);</span><br><span class="line"> 	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; lim; ++i)<span class="keyword">if</span> (rev[i] &lt; i) <span class="built_in">swap</span>(A[i], A[rev[i]]);</span><br><span class="line"> 	<span class="keyword">for</span>(m = <span class="number">2</span>; m &lt;= lim; m &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">	    k = m &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	    gn = <span class="built_in">Pow</span>(<span class="number">3</span>,(p - <span class="number">1</span>) / m);</span><br><span class="line">	    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; lim; i += m) &#123;</span><br><span class="line">	    	g = <span class="number">1</span>;</span><br><span class="line">	    	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; k; ++j, g = <span class="number">1ll</span> * g * gn % p) &#123;</span><br><span class="line">	    	    tmp = <span class="number">1ll</span> * A[i + j + k] * g % p;</span><br><span class="line">	    	    A[i + j + k] = (A[i + j] - tmp + p) % p;</span><br><span class="line">	     	 	A[i + j] = (A[i + j] + tmp) % p;</span><br><span class="line">	    	&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(opt == <span class="number">-1</span>)&#123;</span><br><span class="line">    	<span class="built_in">reverse</span>(A+<span class="number">1</span>,A+lim);</span><br><span class="line">    	<span class="keyword">int</span> inv = <span class="built_in">Pow</span>(lim,p<span class="number">-2</span>);</span><br><span class="line">    	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; lim; ++i) A[i] = <span class="number">1ll</span> * A[i] * inv % p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Poly <span class="title">mul</span><span class="params">(Poly A,Poly B)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = A.<span class="built_in">size</span>(),m = B.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">int</span> siz = n + m - <span class="number">1</span>;</span><br><span class="line">	<span class="function">Poly <span class="title">C</span><span class="params">(siz)</span></span>;</span><br><span class="line">	<span class="keyword">if</span>(siz &lt; <span class="number">64</span>)&#123;<span class="comment">//小于等于64项直接暴力算</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++)C[i+j] = (C[i+j] + <span class="number">1LL</span>*A[i]*B[j]%p)%p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> C;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> fsiz = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(fsiz &lt;= siz)fsiz *= <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; fsiz;i++)F1[i] = F2[i] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)F1[i] = A[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)F2[i] = B[i];</span><br><span class="line">	<span class="built_in">NTT</span>(F1,fsiz,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">NTT</span>(F2,fsiz,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; fsiz;i++)F1[i] = <span class="number">1ll</span>*F1[i]*F2[i]%p;</span><br><span class="line">	<span class="built_in">NTT</span>(F1,fsiz,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; siz;i++)&#123;</span><br><span class="line">		C[i] = F1[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与FFT的区别在点值表示法相乘时, NTT需要取模. 另外注意原根需与模数对应</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (<span class="keyword">int</span>)A.<span class="built_in">size</span>();i++)A[i] = <span class="number">1ll</span>*A[i]*B[i]%p;</span><br></pre></td></tr></table></figure>
<h2 id="分治fftntt">分治FFT/NTT</h2>
<p>设有<span class="math inline">\(n\)</span>个多项式, 第<span class="math inline">\(i\)</span>个为<span class="math inline">\(Func[i]\)</span></p>
<p>就嗯分治完事了. 时间复杂度<span class="math inline">\(O(n\log^2 n)\)</span>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;Poly&gt;Func;</span><br><span class="line"><span class="function">Poly <span class="title">cal</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(R - <span class="number">1</span> == L)<span class="keyword">return</span> Func[L];</span><br><span class="line">	<span class="keyword">int</span> M = (L+R)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">mul</span>(<span class="built_in">cal</span>(L,M),<span class="built_in">cal</span>(M,R));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="求逆">求逆</h2>
<p>板子来源: <a href="https://blog.orzsiyuan.com/archives/Polynomial-Inversion/">Siyuan -「算法笔记」多项式求逆</a></p>
<p>调用<code>invP(Poly A)</code>,返回模<span class="math inline">\(x^n\)</span>意义下<span class="math inline">\(A\)</span>的逆. 其中<span class="math inline">\(A\)</span>是一个<span class="math inline">\(n-1\)</span>次多项式(实际上是一个长度为<span class="math inline">\(n\)</span>的<code>vector&lt;int&gt;</code>)</p>
<p>时间复杂度: <span class="math inline">\(O(nlogn)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> P[maxn],Q[maxn];</span><br><span class="line"><span class="function">Poly <span class="title">invP</span><span class="params">(Poly A)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">int</span> siz = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(siz &lt; n)siz *= <span class="number">2</span>;</span><br><span class="line">	A.<span class="built_in">resize</span>(siz);</span><br><span class="line">	<span class="function">Poly <span class="title">I</span><span class="params">(siz)</span></span>;</span><br><span class="line">	I[<span class="number">0</span>] = <span class="built_in">Pow</span>(A[<span class="number">0</span>],p<span class="number">-2</span>);<span class="comment">//inv(A[0]);</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> h = <span class="number">2</span>;h &lt;= siz;h *= <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">int</span> H = h*<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= H;i++)P[i] = Q[i] = <span class="number">0</span>;<span class="comment">//重要,必须清空</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; h;i++)P[i] = A[i],Q[i] = I[i];</span><br><span class="line">		<span class="built_in">NTT</span>(P,H,<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">NTT</span>(Q,H,<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; H;i++)&#123;</span><br><span class="line">			P[i] = <span class="number">1ll</span>*Q[i]*(<span class="number">2</span> - <span class="number">1ll</span>*P[i]*Q[i]%p + p)%p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">NTT</span>(P,H,<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; h;i++)I[i] = P[i];</span><br><span class="line">	&#125;</span><br><span class="line">	I.<span class="built_in">resize</span>(n);</span><br><span class="line">	<span class="keyword">return</span> I;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="求导-积分">求导, 积分</h2>
<p>derP求导, intP积分, 复杂度均为<span class="math inline">\(O(n)\)</span>. 其中积分需要先预处理逆元<code>inv[]</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Poly <span class="title">derP</span><span class="params">(Poly A,<span class="keyword">bool</span> samelen = <span class="number">1</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function">Poly <span class="title">D</span><span class="params">(n<span class="number">-1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)D[i<span class="number">-1</span>] = <span class="number">1ll</span>*i*A[i]%p;</span><br><span class="line">	<span class="keyword">if</span>(samelen)D.<span class="built_in">resize</span>(n);</span><br><span class="line">	<span class="keyword">return</span> D;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Poly <span class="title">intP</span><span class="params">(Poly A,<span class="keyword">bool</span> samelen = <span class="number">1</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function">Poly <span class="title">ans</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)ans[i] = <span class="number">1ll</span>*inv[i]*A[i<span class="number">-1</span>]%p;</span><br><span class="line">	<span class="keyword">if</span>(samelen)ans.<span class="built_in">resize</span>(n);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="取对数">取对数</h2>
<p>输入<span class="math inline">\(A(x)\)</span>, 求<span class="math inline">\(B(x) \equiv ln(A(x)) \pmod {x^n}\)</span>. 两边同时求导得: <span class="math display">\[
B&#39;(x) = \frac{A&#39;(x)}{A(x)}\text dx
\]</span> 再积分: <span class="math display">\[
B(x) = ln(A(x)) = \int B&#39;(x)\text dx = \int\frac{A&#39;(x)}{A(x)}\text dx
\]</span> 需要求逆,求导和积分, 需保证<span class="math inline">\(A[0] = 1\)</span>. 复杂度<span class="math inline">\(O(n\log n)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Poly <span class="title">lnP</span><span class="params">(Poly A)</span></span>&#123;</span><br><span class="line">	Poly tans = <span class="built_in">intP</span>(<span class="built_in">mul</span>(<span class="built_in">derP</span>(A),<span class="built_in">invP</span>(A)));</span><br><span class="line">	tans.<span class="built_in">resize</span>((<span class="keyword">int</span>)A.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">return</span> tans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="指数函数">指数函数</h2>
<p>前置: 求<span class="math inline">\(\ln\)</span></p>
<p>和求逆基本相同, 返回<span class="math inline">\(e^{A(x)}\)</span>. 复杂度<span class="math inline">\(O(nlogn)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Poly <span class="title">expP</span><span class="params">(Poly A)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">int</span> siz = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(siz &lt; n)siz *= <span class="number">2</span>;</span><br><span class="line">	A.<span class="built_in">resize</span>(siz);</span><br><span class="line">	<span class="function">Poly <span class="title">E</span><span class="params">(siz)</span></span>;</span><br><span class="line">	E[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> h = <span class="number">2</span>;h &lt;= siz;h *= <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="function">Poly <span class="title">B</span><span class="params">(h)</span>,<span class="title">C</span><span class="params">(h)</span></span>;;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; h;i++)B[i] = C[i] = E[i];</span><br><span class="line">		B = <span class="built_in">lnP</span>(B);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; h;i++)B[i] = (<span class="number">1ll</span>*-B[i] + A[i] + <span class="number">2ll</span>*p)%p;</span><br><span class="line">		B[<span class="number">0</span>] = (B[<span class="number">0</span>] + <span class="number">1</span>)%p;</span><br><span class="line">		B = <span class="built_in">mul</span>(B,C);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; h;i++)E[i] = B[i];</span><br><span class="line">	&#125;</span><br><span class="line">	E.<span class="built_in">resize</span>(n);</span><br><span class="line">	<span class="keyword">return</span> E;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速幂">快速幂</h2>
<p>求<span class="math inline">\(A(x)^k\)</span>, 显然有<span class="math inline">\(A(x)^k = e^{k\cdot ln(A(x))}\)</span></p>
<p>保证<span class="math inline">\(A[0] = 1\)</span>时:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Poly <span class="title">powP</span><span class="params">(Poly A,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	A = <span class="built_in">lnP</span>(A);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (<span class="keyword">int</span>)A.<span class="built_in">size</span>();i++)A[i] = <span class="number">1ll</span>*A[i]*k%p;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">expP</span>(A);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math inline">\(A[0] \neq 1\)</span>时:</p>
<p>首先判断是否有<span class="math inline">\(k \ge n\)</span>且<span class="math inline">\(A[0] == 0\)</span>. 若是, 则返回一个全为<span class="math inline">\(0\)</span>的多项式. <strong>注意, 必须在取模前判断大小, 且下面的模板没有包含这部分内容</strong></p>
<p>然后对指数取模, 若输入的指数<span class="math inline">\(k &gt; p\)</span>, 则令<code>k1 = k % p</code>, <code>k2 = k % (p - 1)</code> (即<span class="math inline">\(k2\)</span>对<span class="math inline">\(\varphi(p)\)</span>取模)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Poly <span class="title">powP</span><span class="params">(Poly A,<span class="keyword">int</span> k1,<span class="keyword">int</span> k2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = A.<span class="built_in">size</span>(),d = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(d &lt; n <span class="keyword">and</span> !A[d])d++;</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">1ll</span>*d*k1 &gt;= n)<span class="keyword">return</span> <span class="built_in">Poly</span>(n);</span><br><span class="line">	A.<span class="built_in">erase</span>(A.<span class="built_in">begin</span>(),A.<span class="built_in">begin</span>()+d);</span><br><span class="line">	<span class="keyword">int</span> k = <span class="built_in">Pow</span>(A[<span class="number">0</span>],p<span class="number">-2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (<span class="keyword">int</span>)A.<span class="built_in">size</span>();i++)A[i] = <span class="number">1ll</span>*A[i]*k%p;</span><br><span class="line">	A = <span class="built_in">powP</span>(A,k1);</span><br><span class="line">	A.<span class="built_in">resize</span>(n);</span><br><span class="line">	k = <span class="built_in">Pow</span>(k,p - <span class="number">1</span> - k2);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (<span class="keyword">int</span>)A.<span class="built_in">size</span>();i++)A[i] = <span class="number">1ll</span>*A[i]*k%p;</span><br><span class="line">	d *= k1;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">		A[i] = (i &gt;= d?A[i-d]:<span class="number">0</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高阶差分前缀和">高阶差分/前缀和</h2>
<p>求<span class="math inline">\(A[]\)</span>的<span class="math inline">\(k\)</span>阶差分/前缀和. 设<span class="math inline">\(A\)</span>的OGF: <span class="math inline">\(F(x) = \sum_{i = 0}^{\infin}A_ix^i\)</span></p>
<p>显然前缀和是<span class="math inline">\(F(x)\cdot\sum_{i=0}^{\infin}x^i = F(x)\cdot \frac{1}{1-x}\)</span>, 差分是<span class="math inline">\(F(x)\cdot(1-x)\)</span></p>
<p>那么<span class="math inline">\(k\)</span>阶前缀和是<span class="math inline">\(F(x)\cdot (\frac{1}{1-x})^k\)</span>, 差分是<span class="math inline">\(F(x)\cdot(1-x)^k\)</span>. 复杂度为<span class="math inline">\(O(nlogk)\)</span>, 但常数巨大且很不好写.</p>
<p>另有结论:</p>
<p>前缀和<span class="math inline">\(F(x)\cdot\sum_{i = 0}^nC_{k+i-1}^ix^i\)</span></p>
<p>差分<span class="math inline">\(F(x)\cdot\sum_{i=0}^n(-1)^iC_n^ix^i\)</span></p>
<p>复杂度<span class="math inline">\(O(n\log n)\)</span>. 使用前先预处理逆元.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Poly <span class="title">presumP</span><span class="params">(Poly A,ll k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function">Poly <span class="title">G</span><span class="params">(n)</span></span>;</span><br><span class="line">	G[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)G[i] = G[i<span class="number">-1</span>]*(k+i<span class="number">-1</span>)%p*inv[i]%p;</span><br><span class="line">	A = <span class="built_in">mul</span>(A,G);</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Poly <span class="title">diffP</span><span class="params">(Poly A,ll k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function">Poly <span class="title">G</span><span class="params">(n)</span></span>;</span><br><span class="line">	G[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)G[i] = (G[i<span class="number">-1</span>]*(<span class="number">-1</span>) + p)%p*(k-i+<span class="number">1</span>)%p*inv[i]%p;	</span><br><span class="line">	A = <span class="built_in">mul</span>(A,G);</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="前缀和与差分">前缀和与差分</h1>
<h3 id="区间加多项式">区间加多项式</h3>
<p>给出<span class="math inline">\(f(x)\)</span>和<span class="math inline">\([L,R]\)</span>, 对<span class="math inline">\(a[L...R]\)</span>分别加上<span class="math inline">\(f(1),f(2),...,f(R-L+1)\)</span>.</p>
<p>结论: <span class="math inline">\(k\)</span>阶多项式的<span class="math inline">\(k+1\)</span>阶差分余项为常数. 对<span class="math inline">\(k+1\)</span>阶差分后的余项做<span class="math inline">\(k+1\)</span>次前缀和即可还原原多项式.</p>
<p>为了维护该操作, 我们先对原数组做<span class="math inline">\(k+1\)</span>阶差分, 然后算出<span class="math inline">\(f(1),...,f(k+1)\)</span>的<span class="math inline">\(k+1\)</span>阶差分. 此后可以按一般的差分来维护.</p>
<p>细节见代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> d[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">diff</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp;a,<span class="keyword">int</span> cnt)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(cnt--)<span class="keyword">for</span>(<span class="keyword">int</span> i = (<span class="keyword">int</span>)a.<span class="built_in">size</span>() - <span class="number">1</span>;i &gt; <span class="number">0</span>;i--)&#123;a[i] -=a[i<span class="number">-1</span>];<span class="keyword">if</span>(a[i] &lt; <span class="number">0</span>)a[i] += p;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp;a,<span class="keyword">int</span> cnt)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(cnt--)<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; (<span class="keyword">int</span>)a.<span class="built_in">size</span>();i++)a[i] = (a[i] + a[i<span class="number">-1</span>])%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll x,vector&lt;ll&gt;fac)</span></span>&#123;</span><br><span class="line">	ll res = <span class="number">0</span>,times = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(ll v:fac)&#123;</span><br><span class="line">		res = (res + v*times%p)%p;</span><br><span class="line">		times = times*x%p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">g</span><span class="params">(ll x,vector&lt;ll&gt;fac,ll len)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (-<span class="built_in">f</span>(x+len,fac) + p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">setf</span>(ios::fixed,ios::floatfield);</span><br><span class="line">	cout.<span class="built_in">precision</span>(<span class="number">12</span>);	 </span><br><span class="line">	<span class="keyword">int</span> n,m,q;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">a</span>(n+<span class="number">100</span>);</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">6</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)cin &gt;&gt; a[i];</span><br><span class="line">	<span class="built_in">diff</span>(a,num);</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="keyword">int</span> l,r,k;</span><br><span class="line">		cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;</span><br><span class="line">		l--,r--;</span><br><span class="line">		vector&lt;ll&gt;<span class="built_in">fac</span>(k+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = k;i &gt;= <span class="number">0</span>;i--)cin &gt;&gt; fac[i];</span><br><span class="line">		vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">add</span>(<span class="number">10</span>+<span class="number">1</span>),<span class="built_in">sub</span>(<span class="number">10</span>+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">10</span>;i++)add[i] = <span class="built_in">f</span>(i+<span class="number">1</span>,fac),sub[i] = <span class="built_in">g</span>(i+<span class="number">1</span>,fac,r - l + <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">diff</span>(add,num);</span><br><span class="line">		<span class="built_in">diff</span>(sub,num);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">10</span>;i++)a[i+l] += add[i],a[i+r+<span class="number">1</span>] += sub[i],a[i+l] %= p,a[i+r+<span class="number">1</span>] %= p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pre</span>(a,num+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span>(q--)&#123;</span><br><span class="line">		<span class="keyword">int</span> l,r;</span><br><span class="line">		cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">		l--,r--;</span><br><span class="line">		ll ans = (a[r] - (l?a[l<span class="number">-1</span>]:<span class="number">0</span>) + p)%p;</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="组合数学">组合数学</h1>
<h2 id="杂乱的结论">杂乱的结论</h2>
<h3 id="长度为n-可选1m的本质不同序列个数">长度为n, 可选[1,m]的本质不同序列个数</h3>
<p>(本质不同即将序列排序后两个序列不相同) <span class="math display">\[
C_{n+m-1}^{m-1}
\]</span></p>
<h3 id="递推组合数">递推组合数</h3>
<p><span class="math display">\[
C_n^0 = 1\\
C_n^i = C_n^{i-1}\cdot \frac{n-i+1}{i}\\
C_{n+i-1}^i = C_{n+i-2}^{i-1}\cdot \frac{n+i-1}{i}
\]</span></p>
<h3 id="常用公式">常用公式</h3>
<p>$$ <span class="math display">\[\begin{align}

\sum_{i = 0}^n C_n^i &amp;= 2^n\\

\sum_{i = 0}^n C_n^i \cdot x^i &amp;= (x+1)^n(二项式定理)\\

\sum_{i = 0,i += 2}^n C_n^i &amp;= 2^{n-1}\\

\sum_{i=1}^nC_n^i \cdot i &amp;= n \cdot 2^{n-1}\\

\sum_{i = 0}^r C_m^i \cdot C_n^{r - i} &amp;= C_{n+m}^r\\

\sum_{i = 0}^n (C_n^i)^2 = C_{2n}^n\\


\end{align}\]</span> $$</p>
<h4 id="常用结论">常用结论</h4>
<p><span class="math display">\[
\sum_{i = 1}^ni*m^{n-i} *C(n,i) = n(m+1)^{n-1}
\]</span></p>
<h1 id="生成函数">生成函数</h1>
<h2 id="ogf">OGF</h2>
<p><span class="math display">\[
f(x) = \sum_{i = 0}^{\infin}h_ix^i
\]</span></p>
<h3 id="常用公式-1">常用公式</h3>
<ul>
<li>Part1</li>
</ul>
<p><span class="math display">\[
\begin{align}
\sum_{i=0}^nx^i &amp;= \frac{1-x^{n+1}}{1-x} (等比数列求和)\\
\sum_{i=0}^\infin x^i &amp;= \frac{1}{1-x}\\
\sum_{i = 0}^\infin x^{c\cdot i} &amp;= \frac{1}{1 - x^c}\\
\sum_{i = 0}^{\infin}(i+1)\cdot x^i &amp;= (\frac{1}{1-x})^2
\end{align}
\]</span></p>
<ul>
<li>Part2 <span class="math display">\[
  \frac{1}{(1-x)^n} = \sum_{i = 0}^\infin C_{n+i-1}^{i-1}x^i\\
  \frac{1}{(1-x)^{n+1}} = \sum_{i = 0}^\infin C_{n+i}^i x^i
  \]</span></li>
</ul>
<h2 id="egf">EGF</h2>
<p><span class="math display">\[
g(x) = \sum_{i=0}^{\infin}h_x\cdot\frac{x^i}{i!}
\]</span></p>
<h3 id="常用公式-2">常用公式</h3>
<p><span class="math display">\[
\begin{align}
\sum_{i = 0}^{\infin}\frac{x^i}{i!} &amp; = e^x\\
\sum_{i = 0}^{\infin} (-1)^i \frac{x^i}{i!} &amp; = e^{-x} \\
\sum_{i = 0,i +=2}^{\infin}\frac{x^i}{i!} &amp;= \frac{e^x + e^{-x}}{2}\\
\sum_{i = 1,i += 2}^{\infin}\frac{x^i}{i!} &amp; = \frac{e^x - e^{-z}}{2}\\
\sum_{i = 1}^{\infin}(-1)^{i+1} \frac{x^i}{i} &amp; = \ln{(1+x)}
\end{align}
\]</span></p>
<h1 id="反演">反演</h1>
<h2 id="整除分块">整除分块</h2>
<p>设<span class="math inline">\(f(x) = \lfloor \frac{k}{x} \rfloor\)</span></p>
<p><span class="math inline">\(f(x)\)</span>分布呈块状,对于任意一个<span class="math inline">\(i\)</span>,有最大的<span class="math inline">\(j = \lfloor \frac{k}{\lfloor \frac{k}{i} \rfloor} \rfloor\)</span>,使得<span class="math inline">\(f(i) == f(i+1) == ... = f(j)\)</span></p>
<p>对于类似<span class="math inline">\(\sum_{i = 1}^{n}\lfloor \frac{k}{i} \rfloor\)</span>的式子,可分块在<span class="math inline">\(O(\sqrt{n})\)</span>时间内计算完毕</p>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>;l &lt;= n;l = r+<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(k/l)r = <span class="built_in">min</span>(n,k/(k/l));</span><br><span class="line">		<span class="keyword">else</span> r = n;</span><br><span class="line">		ans += (r-l+<span class="number">1</span>)*(k/l);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>对于向上取整, 有 <span class="math display">\[
\lceil \frac{k}{x} \rceil = \lfloor \frac{k - 1}{x}\rfloor + 1
\]</span></p>
<h2 id="狄利克雷dirichlet卷积">狄利克雷(Dirichlet)卷积</h2>
<h3 id="定义">定义</h3>
<p>设<span class="math inline">\(f,g\)</span>为两个数论函数,其狄利克雷卷积<span class="math inline">\(f*g\)</span>为: <span class="math display">\[
f \ast g(n) = \sum_{d|n}f(d)g(\frac{n}{d})
\]</span></p>
<h3 id="常用式子">常用式子</h3>
$$
<span class="math display">\[\begin{aligned}

\varepsilon=\mu \ast 1&amp;\iff\varepsilon(n)=\sum_{d\mid n}\mu(d)\\
d=1 \ast 1&amp;\iff d(n)=\sum_{d\mid n}1\\
\sigma=\text{id} \ast 1&amp;\iff\sigma(n)=\sum_{d\mid n}d\\
\varphi=\mu \ast \text{id}&amp;\iff\varphi(n)=\sum_{d\mid n}d\cdot\mu(\frac{n}{d}) \\


\end{aligned}\]</span>
<p>$$</p>
<h2 id="常用结论-1">常用结论</h2>
<p><span class="math display">\[
\sum_{d|n}^n\varphi(d) = n
\]</span></p>
<p><span class="math display">\[
[\gcd(i,j) == 1] = \epsilon(\gcd(i,j) = \sum_{d|\gcd(i,j)}\mu(d)
\]</span></p>
<h2 id="套路题">套路题</h2>
<h2 id="sum_i1ngcdin"><span class="math inline">\(\sum_{i=1}^ngcd(i,n)\)</span></h2>
<p><span class="math display">\[
\begin{align}
&amp;\sum_{i=1}^n\gcd(i,n)\\
&amp;=\sum_{d|n}d\sum_{i=1}^n[\gcd(i,n)==d]\\
&amp;=\sum_{d|n}d\sum_{i=1}^{\frac{n}{d}}[\gcd(i,n)==1]\\
&amp;=\sum_{d|n}d\cdotφ(\frac{n}{d})
\end{align}
\]</span></p>
<h2 id="sum_i-1nsum_j1ngcdij"><span class="math inline">\(\sum_{i = 1}^n\sum_{j=1}^n\gcd(i,j)\)</span></h2>
<p><span class="math display">\[
\begin{align}
&amp;\sum_{i = 1}^n\sum_{j=1}^n\gcd(i,j)\\
&amp;= \sum_{d=1}^nd\sum_{i=1}^n\sum_{j=1}^n[gcd(i,j) == d]\\
&amp;=\sum_{d=1}^nd\sum_{i=1}^{\frac{n}{d}}\sum_{j=1}^{\frac{n}{d}}[gcd(i,j)==1]\\
&amp;=\sum_{d=1}^nd(2\cdot\sum_{i=1}^{\frac{n}{d}}\varphi(i) - 1)
\end{align}
\]</span></p>
<p>关于最后一步,我们设<span class="math inline">\(f(x) = \sum_{i=1}^{n}\sum_{j=1}^{n}[gcd(i,j)==1]\)</span></p>
<p>手画一下,容易看出<span class="math inline">\(f(x) = 2\cdot\sum_{i=1}^n\varphi(i) - 1\)</span></p>
<p>另一种做法:</p>
<p>我们知道<span class="math inline">\(\varphi\)</span>有这么一个性质,<span class="math inline">\(\sum_{d|n}^{n}\varphi(d) = n\)</span></p>
<p>也就是<span class="math inline">\(\sum_{d|\gcd(i,j)}^{n}\varphi(d) = \gcd(i,j)\)</span></p>
<p>那么: <span class="math display">\[
\begin{align}
&amp;\sum_{i = 1}^n\sum_{j = 1}^n\gcd(i,j)\\
&amp;=\sum_{i=1}^n\sum_{j=1}^n\sum_{d|\gcd(i,j)}\varphi(d)\\
&amp;=\sum_{d = 1}^n\varphi(d)\sum_{i=1}^n[d|i]\sum_{j=1}^n[d|j]\\
&amp;=\sum_{d = 1}^n\varphi(d)\cdot\lfloor\frac{n}{d}\rfloor\lfloor\frac{m}{d}\rfloor
\end{align}
\]</span> 少处理个前缀和=-=而且我感觉这个做法更好理解</p>
<p>例题:洛谷P2398</p>
<h2 id="sum_i-1nsum_ji1ngcdij"><span class="math inline">\(\sum_{i = 1}^{n}\sum_{j=i+1}^{n}\gcd(i,j)\)</span></h2>
<p>和上面那个基本一样 <span class="math display">\[
\begin{align}
&amp;\sum_{i = 1}^n\sum_{j=i+1}^n\gcd(i,j)\\
&amp;= \sum_{d=1}^nd\sum_{i=1}^n\sum_{j=i+1}^n[gcd(i,j) == d]\\
&amp;=\sum_{d=1}^nd\sum_{i=1}^{\frac{n}{d}}\sum_{j=i+1}^{\frac{n}{d}}[gcd(i,j)==1]\\
&amp;=\sum_{d=1}^nd(\sum_{i=1}^{\frac{n}{d}}\varphi(i) - 1)
\end{align}
\]</span> (最后一步的化简和上一题大同小异,手画一下就有了)</p>
<h2 id="sum_i1nsum_i1mgcdij-1"><span class="math inline">\(\sum_{i=1}^{n}\sum_{i=1}^{m}[\gcd(i,j) == 1]\)</span></h2>
<p>前置知识: <span class="math display">\[
\epsilon(n)=\sum_{d|n}\mu(d)= \begin{cases} 1&amp;n=1\\ 
0&amp;otherwise 
\end{cases}
\]</span></p>
<p>开始愉快地推式子: <span class="math display">\[
\begin{align}
&amp;\sum_{i=1}^{n}\sum_{i=1}^{m}[\gcd(i,j) == 1] \\
&amp;=\sum_{i=1}^{n}\sum_{i=1}^{m}\epsilon(\gcd(i,j))\\
&amp;=\sum_{i=1}^{n}\sum_{i=1}^{m}\sum_{d|gcd(i,j)}\mu(d)\\
&amp;=\sum_{d = 1}^{\min(n,m)}\mu(d)\sum_{i = 1}^n[d|i]\sum_{j = 1}^{m}[d|j]\\
&amp;=\sum_{d=1}^{\min(n,m)}\mu(d)\lfloor \frac{n}{d}\rfloor \lfloor \frac{m}{d} \rfloor
\end{align}
\]</span> 同理,我们有: <span class="math display">\[
\sum_{i = 1}^n\sum_{j = 1}^n\sum_{k = 1}^n [\gcd(i,j,k) == 1] = \sum_{d = 1}^n \mu(d)(\lfloor \frac{n}{d}\rfloor)^3
\]</span></p>
<h1 id="杂项">杂项</h1>
<h2 id="小学数学">小学数学</h2>
<p><span class="math display">\[
\sum a_i \cdot b_j = \frac{\sum a_i^2 - \sum b_j^2}{2}
\]</span></p>
<p>因为<span class="math inline">\((a+b)^2 = a^2 + b^2 + 2ab\)</span></p>
<p><span class="math display">\[
\sum_{i = 1}^n i = \frac{n \cdot(n+1)}{2}\\
\sum_{i = 1}^n i^2  = \frac{n \cdot (n+1) \cdot(2n + 1)}{6}\\
\sum_{i = 1}^n i^3 = (\frac{n \cdot (n+1)}{2})^2
\]</span></p>
<h2 id="杂乱的知识点">杂乱的知识点</h2>
<ul>
<li><p><span class="math display">\[
  \lfloor \frac{a}{bc} \rfloor = \lfloor \frac{\lfloor \frac{a}{b} \rfloor}{c} \rfloor
  \]</span></p></li>
<li><p><span class="math display">\[
  a +b = a\oplus b + 2\cdot a \&amp;b = a|b + a \&amp;b
  \]</span></p></li>
<li><p>设<span class="math inline">\(c(n)\)</span>为第<span class="math inline">\(n\)</span>个Catalan数, 则有<span class="math inline">\(\sum_{k = 0}^{n-1}c(k)\cdot c(n-1-k) = c(n)\)</span></p></li>
<li><p>区间加平方和(范围<span class="math inline">\([l,n]\)</span>)可通过差分进行. 设差分数组为<span class="math inline">\(d\)</span>, 每次对<span class="math inline">\([l,n]\)</span>加平方和的操作转换为<code>d[l]++,d[l+1]++</code>, 然后求d的3阶前缀和即可单点查询.</p></li>
<li><p>对于一个<span class="math inline">\(n\)</span>个点的竞赛图(有向完全图), 不经过重复边的最长路最大为<span class="math inline">\((n为偶数): \frac{n\cdot (n-1)}{2} - \frac{n}{2} + 1\)</span>;<span class="math inline">\((n为奇数):\frac{n\cdot (n-1)}{2}\)</span>; 最小为<span class="math inline">\(n-1\)</span></p></li>
</ul>
<h2 id="图兰定理">图兰定理</h2>
<p>对于一个有 <span class="math inline">\(n\)</span>个点的无向图，若其中不存在三个点的环，则边数不超过 <span class="math inline">\(n^2/4\)</span></p>
<h2 id="pick定理">Pick定理</h2>
<p>给定一个顶点均为整点(坐标为整数的点)的简单多边形,其面积<span class="math inline">\(A\)</span>和内部格点数<span class="math inline">\(I\)</span>,边上格点数<span class="math inline">\(B\)</span>的关系是: <span class="math inline">\(A = I+B/2 - 1\)</span></p>
<h2 id="cayley公式">Cayley公式</h2>
<p>一个有<span class="math inline">\(n\)</span>个节点的完全图有<span class="math inline">\(n^{n-2}\)</span>种不同的生成树</p>
<h2 id="polya定理1">Polya定理1</h2>
<pre><code>-仅旋转,染色数和顶点数均为n.欧拉函数优化(抄自Lskkkno1的题解qwq)</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">polya</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	ll tans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i*i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n%i)<span class="keyword">continue</span>;</span><br><span class="line">		tans += (<span class="built_in">cal_phi</span>(n/i)*<span class="built_in">pow_mod</span>(n,i<span class="number">-1</span>))%MOD;</span><br><span class="line">		<span class="keyword">if</span>(i*i != n)tans += <span class="built_in">cal_phi</span>(i)*<span class="built_in">pow_mod</span>(n,n/i<span class="number">-1</span>)%MOD;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tans%MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
C_k^k +C_{k+1}^k +...+C_{n}^k（n &gt; k)
\]</span></p>
<h2 id="某些数列">某些数列</h2>
<p>对于数列<span class="math inline">\(\{1,2,2,3,3,3,4,4,4,4,...\}\)</span>(数<span class="math inline">\(i\)</span>出现了<span class="math inline">\(i\)</span>)次, 有通项公式 <span class="math display">\[
a_n = \frac{1+2\sqrt{2n}}{2}
\]</span></p>
<p><span class="math display">\[
\sum_{i = 1}^\infin i \cdot \frac{1}{a^i}
\]</span></p>
<p>海伦公式</p>
<p><span class="math inline">\(a,b,c\)</span>为三角形边长, <span class="math inline">\(s = \frac{a+b+c}{2}\)</span></p>
<p>三角形面积为<span class="math inline">\(S = \sqrt{s(s-a)(s-b)(s-c)}\)</span></p>
<h2 id="组合数奇偶性">组合数奇偶性</h2>
<p>对于<span class="math inline">\(C_n^k\)</span>, 如果<span class="math inline">\(n\&amp;k == k\)</span>为奇数, 否则偶数.(按位and)</p>
<h2 id="生成2进制恰好包含k位的下一个数">生成2进制恰好包含k位的下一个数</h2>
<p>若<span class="math inline">\(x\)</span>里有<span class="math inline">\(k\)</span>个1, 则<code>gen_next(x)</code>为包含<span class="math inline">\(k\)</span>个1的下一位数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gen_next</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> b = x &amp; -x;</span><br><span class="line">	<span class="keyword">int</span> t = x + b;</span><br><span class="line">	<span class="keyword">int</span> c = t &amp; -t;</span><br><span class="line">	<span class="keyword">int</span> m = (c/b &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> t | m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="求区间nm内不含平方因子的数">求区间[n,m]内不含平方因子的数</h2>
<p>筛掉<span class="math inline">\(p^2\)</span>即可. <span class="math inline">\(p\)</span>是素数且<span class="math inline">\(p \in [n,m]\)</span></p>
<h2 id="等比数列">等比数列</h2>
<p><span class="math inline">\(a\)</span>为首项, <span class="math inline">\(q\)</span>为公比</p>
<p><span class="math display">\[
求和:S_n = a \cdot \frac{1-q^n}{1-q} (q \ne 1)
\]</span></p>
<p><span class="math display">\[
求积:P_n = a^n \cdot q^{\frac{n(n-1)}{2}}
\]</span></p>
<h2 id="大素数分解">大素数分解</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> prime_fac &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> S = <span class="number">8</span>; <span class="comment">// 随机算法判定次数，8~10 就够了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 龟速乘</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">mult_mod</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b, <span class="keyword">long</span> <span class="keyword">long</span> c)</span> </span>&#123;</span><br><span class="line">        a %= c, b %= c;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tmp = a;</span><br><span class="line">        <span class="keyword">while</span> (b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                ret += tmp;</span><br><span class="line">                <span class="keyword">if</span> (ret &gt; c) ret -= c;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (tmp &gt; c) tmp -= c;</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快速幂</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">qow_mod</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> n, <span class="keyword">long</span> <span class="keyword">long</span> _mod)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> temp = a % _mod;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span>) ret = <span class="built_in">mult_mod</span>(ret, temp, _mod);</span><br><span class="line">            temp = <span class="built_in">mult_mod</span>(temp, temp, _mod);</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是合数返回true，不一定是合数返回false</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> n, <span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">long</span> <span class="keyword">long</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="built_in">qow_mod</span>(a, x, n);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> last = ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++) &#123;</span><br><span class="line">            ret = <span class="built_in">mult_mod</span>(ret, ret, n);</span><br><span class="line">            <span class="keyword">if</span> (ret == <span class="number">1</span> &amp;&amp; last != <span class="number">1</span> &amp;&amp; last != n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            last = ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是素数返回true，不是返回false</span></span><br><span class="line">    <span class="function">mt19937 <span class="title">rng</span><span class="params">(chrono::steady_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Miller_Rabin</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> x = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((x &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123; x &gt;&gt;= <span class="number">1</span>; t++; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> a = <span class="built_in">rng</span>() % (n - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(a, n, x, t))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> factor[<span class="number">100</span>];<span class="comment">// 存质因数</span></span><br><span class="line">    <span class="keyword">int</span> tol; <span class="comment">// 质因数的个数，0~tol-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> t;</span><br><span class="line">        <span class="keyword">while</span> (b) &#123;</span><br><span class="line">            t = a;</span><br><span class="line">            a = b;</span><br><span class="line">            b = t % b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a &gt;= <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">return</span> -a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">pollard_rho</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">long</span> <span class="keyword">long</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>, k = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> x0 = <span class="built_in">rng</span>() % (x - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> y = x0;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            x0 = (<span class="built_in">mult_mod</span>(x0, x0, x) + c) % x;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> d = <span class="built_in">gcd</span>(y - x0, x);</span><br><span class="line">            <span class="keyword">if</span> (d != <span class="number">1</span> &amp;&amp; d != x) <span class="keyword">return</span> d;</span><br><span class="line">            <span class="keyword">if</span> (y == x0) <span class="keyword">return</span> x;</span><br><span class="line">            <span class="keyword">if</span> (i == k) &#123; y = x0; k += k; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对n质因数分解，存入factor，k一般设置为107左右</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findfac</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Miller_Rabin</span>(n)) &#123;</span><br><span class="line">            factor[tol++] = n;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> p = n;</span><br><span class="line">        <span class="keyword">int</span> c = k;</span><br><span class="line">        <span class="keyword">while</span> (p &gt;= n) p = <span class="built_in">pollard_rho</span>(p, c--);</span><br><span class="line">        <span class="built_in">findfac</span>(p, k);</span><br><span class="line">        <span class="built_in">findfac</span>(n / p, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">fac</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        tol = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt;ret;</span><br><span class="line">        <span class="built_in">findfac</span>(n, <span class="number">107</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tol; i++)ret.<span class="built_in">push_back</span>(factor[i]);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="子集">子集</h2>
<h3 id="子集的和与积">子集的和与积</h3>
<ul>
<li><p>对于集合<span class="math inline">\(S = \{a_i\}，i = 1...n\)</span>, 其全部子集中元素和的和为<span class="math inline">\(2^{n-1}\cdot \sum_{i = 1}^na_i\)</span></p></li>
<li><p>其全部子集中元素积的和为<span class="math inline">\(\prod_{i = 1}^n(a_i + 1)\)</span></p></li>
<li><p>从中选出大小为<span class="math inline">\(k\)</span>的全部子集, 元素积的和可用OGF求解, 即 <span class="math display">\[
  \sum_{S&#39; \in S \and |S&#39;| = k}\space \prod_{p_i\in S&#39;}p_i = [k] \prod_{i = 1}^n (1+a_i)
  \]</span> NTT分治即可.</p></li>
</ul>
<h3 id="枚举子集">枚举子集</h3>
<ol type="1">
<li><p>给定集合<span class="math inline">\(m\)</span>, 枚举它的全部子集:</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> S = m;S &gt;= <span class="number">0</span>;S = (S<span class="number">-1</span>)&amp;m)</span><br></pre></td></tr></table></figure></p></li>
<li><p>枚举大小为<span class="math inline">\(n\)</span>的全部集合<span class="math inline">\(m\)</span>, 且对于每个<span class="math inline">\(m\)</span>, 枚举其全部子集<span class="math inline">\(S\)</span>. 时间复杂度<span class="math inline">\(O(3^n)\)</span>:</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">0</span>;m &lt; (<span class="number">1</span>&lt;&lt;n);m++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> S = m;S &gt;= <span class="number">0</span>; S = (S<span class="number">-1</span>)&amp;m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="子集和高维前缀和">子集和/高维前缀和</h3>
<p>求解如下问题:</p>
<p>子集和: <span class="math display">\[
f[S] = \sum_{T \in S}f[T]
\]</span> 超集和: <span class="math display">\[
f[T] = \sum_{T\in S}f[S]
\]</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); j++)</span><br><span class="line">        <span class="keyword">if</span>(j &amp; (<span class="number">1</span> &lt;&lt; i))&#123;</span><br><span class="line">            f[j] += f[j ^ (<span class="number">1</span> &lt;&lt; i)];<span class="comment">//子集和</span></span><br><span class="line">			<span class="comment">//或f[j ^ (1 &lt;&lt; i)] += f[j];</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>时间复杂度<span class="math inline">\(O(n \cdot 2^n)\)</span></p>
<h2 id="求双阶乘的最后64位">求双阶乘的最后64位</h2>
<p>跑起来很快, 大概是<span class="math inline">\(O(log^2(n))\)</span>级别 <span class="math display">\[
(2n - 1)!! = \prod_{i = 1,i += 2}^{2n-1}i
\]</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lld;</span><br><span class="line">lld C[<span class="number">64</span>][<span class="number">64</span>], jc[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poly</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    lld x[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">poly</span>() &#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) x[i] = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="built_in">poly</span>(lld c1, lld c0) : <span class="built_in">poly</span>() &#123; x[<span class="number">1</span>] = c1, x[<span class="number">0</span>] = c0; &#125;</span><br><span class="line">    <span class="function">lld <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> k)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x[k]; &#125;</span><br><span class="line">    <span class="function">lld &amp;<span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123; <span class="keyword">return</span> x[k]; &#125;</span><br><span class="line"></span><br><span class="line">    poly <span class="keyword">operator</span>*(<span class="keyword">const</span> poly &amp;b) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        poly c;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line">                <span class="built_in">c</span>(i) += x[j] * <span class="built_in">b</span>(i-j);</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">poly <span class="title">moveto</span><span class="params">(lld n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        poly ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = jc[<span class="number">0</span>] = <span class="number">1</span>; i &lt; <span class="number">64</span>; i++)</span><br><span class="line">            jc[i] = jc[i<span class="number">-1</span>] * n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; <span class="number">64</span>; j++)</span><br><span class="line">                <span class="built_in">ans</span>(i) += x[j] * jc[j-i] * C[j][i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map&lt;lld, poly&gt; cache;</span><br><span class="line"></span><br><span class="line"><span class="function">poly <span class="title">solve</span><span class="params">(lld n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cache.<span class="built_in">count</span>(n)) <span class="keyword">return</span> cache[n];</span><br><span class="line">    poly half = <span class="built_in">solve</span>(n / <span class="number">2</span>);</span><br><span class="line">    half = half * half.<span class="built_in">moveto</span>(n / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">1</span>) half = half * <span class="built_in">poly</span>(<span class="number">2</span>, n*<span class="number">2</span><span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> cache[n] = half;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">poly <span class="title">Px</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    cache[<span class="number">0</span>] = Px;</span><br><span class="line"></span><br><span class="line">    C[<span class="number">0</span>][<span class="number">0</span>] = C[<span class="number">1</span>][<span class="number">0</span>] = C[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">2</span>; n &lt; <span class="number">64</span>; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        C[n][<span class="number">0</span>] = C[n][n] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>; m &lt; n; m++)</span><br><span class="line">            C[n][m] = C[n<span class="number">-1</span>][m<span class="number">-1</span>] + C[n<span class="number">-1</span>][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">int</span> T; lld n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%llu\n&quot;</span>, <span class="built_in">solve</span>(n)(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\sum_{i = 1}^n \sum_{c \in{cnt} \and c &lt; t[i]}\frac{(n - i)!}{(\prod_{c&#39; \in cnt \and c&#39; \neq c}c&#39;!) \cdot (c-1)!}
\]</span></p>
]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2020/05/09/template-data-structure/</url>
    <content><![CDATA[<h1 id="杂项">杂项</h1>
<h2 id="优化指令">优化指令</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">&quot;/stack:200000000&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">&quot;Ofast,unroll-loops&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC target(<span class="meta-string">&quot;avx,avx2,sse,sse2&quot;</span>)</span></span><br></pre></td></tr></table></figure>
<p>8e9的暴力, CF上跑了733ms...</p>
<p>适用于常数小的多重循环暴力, 建议热身赛的时候测试下能不能用</p>
<h2 id="重载运算符">重载运算符</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="keyword">const</span> Node &amp; a,<span class="keyword">const</span> Node &amp; b)</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (a.v == b.v?a.l &lt; b.l:a.v &lt; b.v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">set&lt;Node,cmp&gt;odt2;</span><br></pre></td></tr></table></figure>
<h2 id="快读">快读</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Precision</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;<span class="built_in">Precision</span>(<span class="keyword">int</span> a)&#123;</span><br><span class="line">    x=a;&#125;&#125;;<span class="class"><span class="keyword">struct</span> <span class="title">SW</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;<span class="built_in">SW</span>(<span class="keyword">int</span> a)&#123;</span><br><span class="line">    x=a;&#125;&#125;;<span class="class"><span class="keyword">struct</span> <span class="title">SF</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;<span class="built_in">SF</span>(<span class="keyword">int</span> a)&#123;</span><br><span class="line">    x=a;&#125;&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Set(x,y,z) SW(x)&lt;&lt;SF(y)&lt;&lt;z&lt;&lt;SW(0)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IO</span>&#123;</span></span><br><span class="line">     </span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> Tp template<span class="meta-string">&lt;typename T&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> _D isdigit(c=gc())</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> _A f|=eb;<span class="meta-keyword">if</span>(f)_R</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> _R return *this</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> _G p1==p2&amp;&amp;(p2=(p1=B)+fread(B,1,S,stdin),p1==p2)?EOF:*p1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> _T(x) while(st[++st[0]]=x%10+<span class="meta-string">&#x27;0&#x27;</span>,x/=10)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> _O operator</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> S=<span class="number">1</span>&lt;&lt;<span class="number">21</span>;<span class="keyword">char</span> B[S],*p1,*p2,sf,t;<span class="keyword">int</span> st[<span class="number">105</span>],H,bs,sw;<span class="keyword">bool</span> eb,f;<span class="function"><span class="keyword">char</span> <span class="title">nex</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _G;&#125;<span class="built_in">IO</span>()&#123;</span><br><span class="line">    bs=<span class="number">6</span>;sf=eb=sw=<span class="number">0</span>;&#125;</span><br><span class="line">    IO&amp; _O &gt;&gt; (<span class="keyword">char</span>&amp;c)&#123;</span><br><span class="line">    _A;<span class="keyword">while</span>(<span class="built_in">T</span>(c=<span class="built_in">gc</span>()))&#123;</span><br><span class="line">    _A;&#125;_R;&#125;<span class="function"><span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    t=(_G++);t==<span class="string">&#x27;\r&#x27;</span>&amp;&amp;<span class="built_in">nex</span>()==<span class="string">&#x27;\n&#x27;</span>&amp;&amp;(<span class="built_in">gc</span>());t==EOF&amp;&amp;(eb=<span class="number">1</span>);<span class="keyword">return</span> t;&#125;</span><br><span class="line">    IO&amp; _O &gt;&gt; (string&amp;s)&#123;</span><br><span class="line">    _A;s=<span class="string">&quot;&quot;</span>;<span class="keyword">char</span> c;<span class="keyword">while</span>(<span class="built_in">T</span>(c=<span class="built_in">gc</span>()))&#123;</span><br><span class="line">    _A;&#125;<span class="keyword">while</span>(s+=c,!<span class="built_in">T</span>(c=<span class="built_in">gc</span>()));_R;&#125;IO&amp; _O &lt;&lt; (Precision x)&#123;</span><br><span class="line">    bs=x.x;_R;&#125;</span><br><span class="line">    IO&amp; _O &gt;&gt; (<span class="keyword">char</span>*c)&#123;</span><br><span class="line">    _A;<span class="keyword">while</span>(<span class="built_in">T</span>(*c=<span class="built_in">gc</span>()))&#123;</span><br><span class="line">    _A;&#125;<span class="keyword">while</span>(!<span class="built_in">T</span>(*++c=<span class="built_in">gc</span>()));*c=<span class="number">0</span>;_R;&#125;<span class="function"><span class="keyword">int</span> <span class="title">P</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c==<span class="string">&#x27;\n&#x27;</span>||c==<span class="string">&#x27;\r&#x27;</span>||c==EOF;&#125;</span><br><span class="line">    IO&amp; _O &gt;&gt; (<span class="keyword">double</span>&amp;x)&#123;</span><br><span class="line">    _A;x=<span class="number">0</span>;<span class="keyword">bool</span> F=<span class="number">0</span>;<span class="keyword">char</span> c;<span class="keyword">while</span>(!_D)&#123;</span><br><span class="line">    F^=(c==<span class="string">&#x27;-&#x27;</span>);_A;&#125;<span class="keyword">while</span>(x=x*<span class="number">10</span>+(c^<span class="number">48</span>),_D&amp;&amp;(<span class="built_in">P</span>(c),<span class="number">1</span>));<span class="keyword">if</span>(c^<span class="string">&#x27;.&#x27;</span>)_R;c=<span class="built_in">gc</span>();</span><br><span class="line">    <span class="keyword">double</span> k=<span class="number">1</span>;<span class="keyword">while</span>(x+=(c^<span class="number">48</span>)*(k*=<span class="number">0.1</span>),_D);F&amp;&amp;(x=-x);_R;&#125;<span class="function"><span class="keyword">void</span> <span class="title">pu</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x--&gt;<span class="number">0</span>)<span class="built_in">pc</span>(sf);&#125;IO&amp; _O &lt;&lt; (SW x)&#123;</span><br><span class="line">    sw=x.x;_R;&#125;</span><br><span class="line">    Tp IO&amp; _O &gt;&gt; (T&amp;x)&#123;</span><br><span class="line">    _A;x=<span class="number">0</span>;<span class="keyword">bool</span> F=<span class="number">0</span>;<span class="keyword">char</span> c;<span class="keyword">while</span>(!_D)&#123;</span><br><span class="line">    F^=(c==<span class="string">&#x27;-&#x27;</span>);_A;&#125;<span class="keyword">while</span>(x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),_D);F&amp;&amp;(x=-x);_R;&#125;</span><br><span class="line">    IO&amp; _O &lt;&lt; (<span class="keyword">const</span> string &amp;s)&#123;</span><br><span class="line">    <span class="keyword">int</span> l=s.<span class="built_in">length</span>();<span class="built_in">pu</span>(sw-l);<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)<span class="built_in">pc</span>(s[i]);_R;&#125;IO&amp; _O &lt;&lt; (<span class="keyword">const</span> <span class="keyword">char</span> c)&#123;</span><br><span class="line">    <span class="built_in">pc</span>(c);_R;&#125;</span><br><span class="line">    IO&amp; _O &lt;&lt; (<span class="keyword">char</span>*c)&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="built_in">strlen</span>(c);<span class="built_in">pu</span>(sw-l);<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)<span class="built_in">pc</span>(c[i]);_R;&#125;<span class="function"><span class="keyword">void</span> <span class="title">CL</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">fwrite</span>(B,<span class="number">1</span>,H,stdout);H=<span class="number">0</span>;&#125;</span><br><span class="line">    IO&amp; _O &lt;&lt; (<span class="keyword">const</span> <span class="keyword">char</span>*c)&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="built_in">strlen</span>(c);<span class="built_in">pu</span>(sw-l);<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)<span class="built_in">pc</span>(c[i]);_R;&#125;IO&amp; _O &lt;&lt; (SF x)&#123;</span><br><span class="line">    sf=x.x;_R;&#125;</span><br><span class="line">    IO&amp; _O &lt;&lt; (<span class="keyword">double</span> x)&#123;</span><br><span class="line">    x&lt;<span class="number">0</span>&amp;&amp;(st[++st[<span class="number">0</span>]]=<span class="string">&#x27;-&#x27;</span>,x=-x);<span class="keyword">double</span> t=<span class="number">0.5</span>;<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=bs;i++)t*=<span class="number">0.1</span>;x+=t;ll y=x;_T(y);<span class="built_in">pu</span>(sw-st[<span class="number">0</span>]-</span><br><span class="line">        <span class="built_in"><span class="keyword">bool</span></span>(bs)-bs);<span class="keyword">while</span>(st[<span class="number">0</span>])<span class="built_in">pc</span>(st[st[<span class="number">0</span>]--]);x-=<span class="built_in">ll</span>(x);<span class="keyword">if</span>(bs)<span class="built_in">pc</span>(<span class="string">&#x27;.&#x27;</span>);<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=bs;i++)<span class="built_in">pc</span>(<span class="built_in"><span class="keyword">int</span></span>(x*=<span class="number">10</span>)+<span class="string">&#x27;0&#x27;</span>),x-=<span class="built_in"><span class="keyword">int</span></span>(x);_R;&#125;</span><br><span class="line">    Tp IO&amp; _O &lt;&lt; (T x)&#123;</span><br><span class="line">    x&lt;<span class="number">0</span>&amp;&amp;(<span class="built_in">pc</span>(<span class="string">&#x27;-&#x27;</span>),x=-x);_T(x);<span class="built_in">pu</span>(<span class="built_in">max</span>(sw-st[<span class="number">0</span>],<span class="number">0</span>));<span class="keyword">while</span>(st[<span class="number">0</span>])<span class="built_in">pc</span>(st[st[<span class="number">0</span>]--]);_R;&#125;<span class="function">_O <span class="title">bool</span><span class="params">()</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !f;&#125;</span><br><span class="line">    <span class="function">IO&amp; <span class="title">getline</span><span class="params">(string&amp;s)</span></span>&#123;</span><br><span class="line">    _A;s=<span class="string">&quot;&quot;</span>;<span class="keyword">char</span> c=<span class="built_in">gc</span>();<span class="keyword">if</span>(!<span class="built_in">P</span>(c))<span class="keyword">while</span>(s+=c,!<span class="built_in">P</span>(c=<span class="built_in">gc</span>()));_R;&#125;<span class="function"><span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    H==S&amp;&amp;(<span class="built_in">CL</span>(),<span class="number">0</span>);B[H++]=c;&#125;</span><br><span class="line">    <span class="function">IO&amp; <span class="title">getline</span><span class="params">(<span class="keyword">char</span>*c)</span></span>&#123;</span><br><span class="line">    _A;*c=<span class="built_in">gc</span>();<span class="keyword">if</span>(!<span class="built_in">P</span>(*c))<span class="keyword">while</span>(!<span class="built_in">P</span>(*++c=<span class="built_in">gc</span>()));*c=<span class="number">0</span>;_R;&#125;<span class="function"><span class="keyword">int</span> <span class="title">T</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c==<span class="string">&#x27; &#x27;</span>||<span class="built_in">P</span>(c);&#125;~<span class="built_in">IO</span>()&#123;</span><br><span class="line">    <span class="built_in">CL</span>();&#125;</span><br><span class="line">&#125;fin,fout;</span><br></pre></td></tr></table></figure>
<h1 id="bitset">Bitset</h1>
<h2 id="常用方法">常用方法</h2>
<p><code>_Find_first()</code> 返回第一个1的位置</p>
<p><code>_Find_next(x)</code> 返回<span class="math inline">\(x\)</span>后第一个1的位置</p>
<p><code>set(x)</code> 将第<span class="math inline">\(x\)</span>位设为1. 不加参数则全部置1</p>
<p><code>reset(x)</code> 将第<span class="math inline">\(x\)</span>为设为0. 不加参数则全部置0.</p>
<p><code>filp(x)</code> 将第<span class="math inline">\(x\)</span>位翻转. 不加参数则全部翻转.</p>
<h1 id="rmq问题">RMQ问题</h1>
<h2 id="st表">ST表</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">STable</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> ST[<span class="number">50005</span>][<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">bool</span> ismax;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ST_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)ST[i][<span class="number">0</span>] = inital[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j) &lt;= n;j++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i +(<span class="number">1</span>&lt;&lt;j) - <span class="number">1</span>&lt;= n;i++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(ismax)ST[i][j] = <span class="built_in">max</span>(ST[i][j - <span class="number">1</span>],ST[i + (<span class="number">1</span>&lt;&lt;(j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">				<span class="keyword">else</span> ST[i][j] = <span class="built_in">min</span>(ST[i][j - <span class="number">1</span>],ST[i + (<span class="number">1</span>&lt;&lt;(j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> k = <span class="built_in">log2</span>(r-l+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(ismax)<span class="keyword">return</span> <span class="built_in">max</span>(ST[l][k],ST[r - (<span class="number">1</span>&lt;&lt;k) + <span class="number">1</span>][k]);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">min</span>(ST[l][k],ST[r - (<span class="number">1</span>&lt;&lt;k) + <span class="number">1</span>][k]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="fenwick树">Fenwick树</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> BIT[<span class="number">5000005</span>],n,m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(index &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		tmp += BIT[index];</span><br><span class="line">		index -= <span class="built_in">lowbit</span>(index);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(index &lt;= n)&#123;</span><br><span class="line">		BIT[index] += x;</span><br><span class="line">		index += <span class="built_in">lowbit</span>(index); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求k小值">求k小值:</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tans = <span class="number">0</span>,tcnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="built_in">log2</span>(n);i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">		tans += (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">		<span class="keyword">if</span>(tans &gt;= n <span class="keyword">or</span> tcnt + BIT[tans] &gt;= k)tans -= (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">		<span class="keyword">else</span> tcnt += BIT[tans];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tans+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>区间修改单点查询见<a href="https://www.luogu.org/problemnew/show/P3368">P3368</a>(懒到爆炸</p>
<h1 id="珂朵莉树">珂朵莉树</h1>
<p>珂朵莉树在<strong>存在区间赋值操作</strong>和<strong>数据随机</strong>的情况下可以维护复杂的区间询问. 复杂度一般为<span class="math inline">\(O(n\log n)\)</span>.</p>
<p>注意如果数据不随机, 但区间赋值操作很多(或者是全部区间赋值没有查询)也可用珂朵莉树维护.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="comment">//节点,表示区间[l,r]的值为v</span></span><br><span class="line">	ll l,r;</span><br><span class="line">	<span class="keyword">mutable</span> ll v;<span class="comment">//必须加mutable, 否则无法修改v</span></span><br><span class="line">	<span class="built_in">Node</span>(ll l,ll r,ll v):<span class="built_in">l</span>(l),<span class="built_in">r</span>(r),<span class="built_in">v</span>(v)&#123;&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> l &lt; x.l;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">set&lt;Node&gt;odt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="comment">//将区间[l,r] (其中l &lt;= idx &lt;= r)分裂为[l,idx-1]和[idx,r]两个区间并返回[idx,r]区间的迭代器</span></span><br><span class="line">	<span class="keyword">auto</span> it = odt.<span class="built_in">lower_bound</span>(<span class="built_in">Node</span>(idx,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">if</span>(it != odt.<span class="built_in">end</span>() <span class="keyword">and</span> it-&gt;l == idx)<span class="keyword">return</span> it;</span><br><span class="line">	it--;</span><br><span class="line">	<span class="keyword">int</span> l = it-&gt;l,r = it-&gt;r,v = it-&gt;v;</span><br><span class="line">	odt.<span class="built_in">erase</span>(it);</span><br><span class="line">	odt.<span class="built_in">insert</span>(<span class="built_in">Node</span>(l,idx<span class="number">-1</span>,v));</span><br><span class="line">	<span class="keyword">return</span> odt.<span class="built_in">insert</span>(<span class="built_in">Node</span>(idx,r,v)).first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="comment">//将[l,r]赋值为v</span></span><br><span class="line">	<span class="keyword">auto</span> end = <span class="built_in">split</span>(r+<span class="number">1</span>),begin = <span class="built_in">split</span>(l);<span class="comment">//必须先r后l,否则会RE</span></span><br><span class="line">	odt.<span class="built_in">erase</span>(begin,end);</span><br><span class="line">	odt.<span class="built_in">insert</span>(<span class="built_in">Node</span>(l,r,v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>维护各个区间的查询均可暴力. 以区间<span class="math inline">\(k\)</span>小值和区间<span class="math inline">\(n\)</span>次方和为例</p>
<p>区间<span class="math inline">\(k\)</span>小值:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> end = <span class="built_in">split</span>(r+<span class="number">1</span>),begin = <span class="built_in">split</span>(l);</span><br><span class="line">	vector&lt;Node&gt;tmp;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> it = begin;it != end;it++)tmp.<span class="built_in">push_back</span>(*it);</span><br><span class="line">	<span class="built_in">sort</span>(tmp.<span class="built_in">begin</span>(),tmp.<span class="built_in">end</span>(),cmp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> it:tmp)&#123;</span><br><span class="line">		k -= (it.r - it.l + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(k &lt;= <span class="number">0</span>)<span class="keyword">return</span> it.v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求<span class="math inline">\(\sum_{i = l}^ra[i]^x \mod p\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PowSum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">auto</span> end = <span class="built_in">split</span>(r+<span class="number">1</span>),begin = <span class="built_in">split</span>(l);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> it = begin;it != end;it++)&#123;</span><br><span class="line">		ans = (ans + <span class="built_in">Pow</span>(it-&gt;v,x,p)%p*(it-&gt;r - it-&gt;l + <span class="number">1</span>)%p)%p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="线段树">线段树</h1>
<p>因为我比较懒，所以这里有一堆弱智线段树方便复制= =</p>
<h2 id="单点修改区间查询线性建树">单点修改,区间查询,线性建树</h2>
<p>调用init(n)初始化.传入一个数组建树.</p>
<p>树根标号为0.</p>
<p><strong>下标从0开始</strong></p>
<p><strong>查询操作区间为[L,R).</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segtree</span>&#123;</span></span><br><span class="line">	<span class="comment">//root idx:0</span></span><br><span class="line">	<span class="comment">//[L,R)</span></span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	vector&lt;ll&gt;sumv;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(size &lt; n)size *= <span class="number">2</span>;</span><br><span class="line">		sumv.<span class="built_in">assign</span>(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(vector&lt;ll&gt; &amp; in,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(lx &lt; (<span class="keyword">int</span>)in.<span class="built_in">size</span>())sumv[x] = in[lx];</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">build</span>(in,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="built_in">build</span>(in,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		sumv[x] = sumv[<span class="built_in">ls</span>(x)] + sumv[<span class="built_in">rs</span>(x)];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(vector&lt;ll&gt; &amp; in)</span></span>&#123;</span><br><span class="line">		<span class="built_in">build</span>(in,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)&#123;</span><br><span class="line">			sumv[x] = v;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(idx &lt; m)<span class="built_in">set</span>(idx,v,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">set</span>(idx,v,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		sumv[x] = sumv[<span class="built_in">ls</span>(x)] + sumv[<span class="built_in">rs</span>(x)];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		<span class="built_in">set</span>(idx,v,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(lx &gt;= l <span class="keyword">and</span> rx &lt;= r)<span class="keyword">return</span> sumv[x];</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		ll s1 = <span class="built_in">sum</span>(l,r,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		ll s2 = <span class="built_in">sum</span>(l,r,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="keyword">return</span> s1+s2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">sum</span>(l,r,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="区间内第一个大于等于x的值的下标">区间内第一个大于等于x的值的下标</h3>
<p><span class="math inline">\(least(L,v)\)</span>返回<span class="math inline">\([L,n)\)</span>里第一个大于等于x的值的下标.如果题目求<span class="math inline">\([L,R]\)</span>的话特判一下下标和R的关系就行.</p>
<p>小于等于与之类似</p>
<p>再次提醒,这种写法的线段树下标从0开始</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">least</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(rx &lt;= l <span class="keyword">or</span> maxv[x] &lt; v)<span class="keyword">return</span> INF;</span><br><span class="line">	<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(maxv[x] &gt;= v)<span class="keyword">return</span> lx;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> INF;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> m = (lx + rx)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> a1 = <span class="built_in">least</span>(l,v,<span class="built_in">ls</span>(x),lx,m),a2 = INF;</span><br><span class="line">	<span class="keyword">if</span>(a1 == INF)a2 = <span class="built_in">least</span>(l,v,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">min</span>(a1,a2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">least</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">least</span>(l,v,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第k个1">第k个1</h3>
<p>给出一个0-1数组,求第k个1的下标.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="comment">//return the idx of kth-one</span></span><br><span class="line">	<span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> k = x,l = <span class="number">0</span>,r = size;</span><br><span class="line">	<span class="keyword">while</span>(k)&#123;</span><br><span class="line">		<span class="keyword">if</span>(r - l == <span class="number">1</span>)<span class="keyword">return</span> l;</span><br><span class="line">		<span class="keyword">int</span> lw = sumv[<span class="built_in">ls</span>(u)],rw = sumv[<span class="built_in">rs</span>(u)];</span><br><span class="line">		<span class="keyword">int</span> m = (l+r)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(lw &gt;= k)&#123;</span><br><span class="line">			u = <span class="built_in">ls</span>(u);</span><br><span class="line">			r = m;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			k -= lw;</span><br><span class="line">			u = <span class="built_in">rs</span>(u);</span><br><span class="line">			l = m;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间合并操作">区间合并操作</h3>
<p>例:求最大连续子段和.</p>
<p>记<span class="math inline">\(seg_x\)</span>为区间<span class="math inline">\(x\)</span>的最大连续子段和.<span class="math inline">\(pre_x\)</span>为最大前缀和,<span class="math inline">\(suf_x\)</span>为最大后缀和,<span class="math inline">\(sum_x\)</span>为区间之和.</p>
<p>记<span class="math inline">\(ls\)</span>为<span class="math inline">\(x\)</span>的左儿子,<span class="math inline">\(rs\)</span>为<span class="math inline">\(x\)</span>的右儿子.</p>
<p>对于一个区间<span class="math inline">\(x\)</span>,它的<span class="math inline">\(seg\)</span>有三种可能:左子区间的<span class="math inline">\(seg\)</span>,右子区间的<span class="math inline">\(seg\)</span>,两个子区间的公共部分.因此我们有: <span class="math display">\[
seg_x = \max(seg_{ls},seg_{rs},suf_{ls}+pre_{rs})
\]</span> 对于<span class="math inline">\(pre\)</span>和<span class="math inline">\(suf\)</span>我们有: <span class="math display">\[
pre_x = max(pre_{ls},sum_{ls}+pre_{rs})\\
suf_x = max(suf_{rs},sum_{rs}+suf_{ls})
\]</span> 其他区间信息的合并与此基本相同.(本题答案为<span class="math inline">\(seg[0]\)</span>)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segtree</span>&#123;</span></span><br><span class="line">	<span class="comment">//root idx:0</span></span><br><span class="line">	<span class="comment">//[L,R)</span></span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	vector&lt;ll&gt;sumv,pre,suf,seg;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(size &lt; n)size *= <span class="number">2</span>;</span><br><span class="line">		sumv.<span class="built_in">assign</span>(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">		pre.<span class="built_in">assign</span>(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">		suf.<span class="built_in">assign</span>(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">		seg.<span class="built_in">assign</span>(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)&#123;</span><br><span class="line">			sumv[x] =  suf[x] = pre[x] = seg[x] = v;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(idx &lt; m)<span class="built_in">set</span>(idx,v,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">set</span>(idx,v,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		sumv[x] = sumv[<span class="built_in">ls</span>(x)] + sumv[<span class="built_in">rs</span>(x)];</span><br><span class="line">		pre[x] = <span class="built_in">max</span>(pre[<span class="built_in">ls</span>(x)],sumv[<span class="built_in">ls</span>(x)]+pre[<span class="built_in">rs</span>(x)]);</span><br><span class="line">		suf[x] = <span class="built_in">max</span>(suf[<span class="built_in">rs</span>(x)],sumv[<span class="built_in">rs</span>(x)]+suf[<span class="built_in">ls</span>(x)]);</span><br><span class="line">		seg[x] = <span class="built_in">max</span>(&#123;seg[<span class="built_in">ls</span>(x)],seg[<span class="built_in">rs</span>(x)],suf[<span class="built_in">ls</span>(x)]+pre[<span class="built_in">rs</span>(x)]&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		<span class="built_in">set</span>(idx,v,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="区间加-单点查询">区间加 单点查询</h2>
<h3 id="差分">差分</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P-3-E </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4e6</span>+<span class="number">10</span>; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fenwick</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	ll BIT[maxn];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		size = n+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//		BIT.assign(n+1,0);</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x &amp; -x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">		ll tans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(d)&#123;</span><br><span class="line">			tans += BIT[d];</span><br><span class="line">			d -= <span class="built_in">lowbit</span>(d); </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> tans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> d,ll v)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(d &lt;= size)&#123;</span><br><span class="line"><span class="comment">//			cout &lt;&lt; d &lt;&lt; endl;</span></span><br><span class="line">			BIT[d] += v;</span><br><span class="line">			d += <span class="built_in">lowbit</span>(d);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		<span class="built_in">add</span>(l,v);</span><br><span class="line">		<span class="built_in">add</span>(r+<span class="number">1</span>,-v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	Fenwick fen;</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	fen.<span class="built_in">init</span>(n);</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="keyword">int</span> opt,l,r,v;</span><br><span class="line">		cin &gt;&gt; opt;</span><br><span class="line">		<span class="keyword">if</span>(opt == <span class="number">1</span>)&#123;</span><br><span class="line">			cin &gt;&gt; l &gt;&gt; r &gt;&gt; v;</span><br><span class="line">			l++;</span><br><span class="line"><span class="comment">//			r--;</span></span><br><span class="line">			fen.<span class="built_in">add</span>(l,r,v);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			cin &gt;&gt; v;</span><br><span class="line">			v++;</span><br><span class="line">			cout &lt;&lt; fen.<span class="built_in">sum</span>(v)&lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="懒标记">懒标记</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segtree</span>&#123;</span><span class="comment">//lazy tag,sum</span></span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	vector&lt;ll&gt;addv;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(size &lt; n)size *= <span class="number">2</span>;</span><br><span class="line"><span class="comment">//		sumv.assign(size*2,0);</span></span><br><span class="line">		addv.<span class="built_in">assign</span>(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp; in,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)&#123;</span><br><span class="line">			addv[x] = in[lx];</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">build</span>(in,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="built_in">build</span>(in,<span class="built_in">rs</span>(x),rx,m);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp; in)</span></span>&#123;</span><br><span class="line">		<span class="built_in">build</span>(in,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(lx &gt;= r <span class="keyword">or</span> l &gt;= rx)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			addv[x] += v;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">add</span>(l,r,v,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="built_in">add</span>(l,r,v,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		<span class="built_in">add</span>(l,r,v,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)<span class="keyword">return</span> addv[x];</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(idx &lt; m)<span class="keyword">return</span> addv[x] + <span class="built_in">sum</span>(idx,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> addv[x] + <span class="built_in">sum</span>(idx,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">sum</span>(idx,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="区间修改区间查询">区间修改,区间查询</h2>
<p>维护如下操作:</p>
<p><span class="math inline">\(A \space l \space r \space v\)</span>：对区间<span class="math inline">\([L,R]\)</span>进行操作<span class="math inline">\(A(l,r,v)\)</span></p>
<p><span class="math inline">\(B \space l \space r\)</span>: 查询<span class="math inline">\(B(l,r)\)</span>的值</p>
<p><span class="math inline">\(A,B\)</span>两种操作需要满足结合律;<span class="math inline">\(A\)</span>需要满足交换律(如果不满足则需要懒标记).<span class="math inline">\(A\)</span>与<span class="math inline">\(B\)</span>需满足分配律</p>
<p>形式化地,设<span class="math inline">\(\otimes\)</span>为操作<span class="math inline">\(A\)</span>,<span class="math inline">\(\odot\)</span>为操作<span class="math inline">\(B\)</span>,线段树维护的操作需要满足:</p>
<ol type="1">
<li><p><span class="math display">\[
 A \otimes B\otimes C = A \otimes (B \otimes C)\\
 A \odot B \odot C = A \odot (B \odot C)
 \]</span> { }</p></li>
<li><p><span class="math display">\[
 A \otimes B = B \otimes A
 \]</span></p></li>
<li><p><span class="math display">\[
 (A \otimes C) \odot (B \otimes C) = (A \odot B) \otimes C
 \]</span></p></li>
</ol>
<h3 id="区间加区间最小值">区间加,区间最小值</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segtree</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> siz = <span class="number">1</span>;</span><br><span class="line">	vector&lt;ll&gt;addv,minv;</span><br><span class="line">	<span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(siz &lt; n)siz *= <span class="number">2</span>;</span><br><span class="line">		minv.<span class="built_in">assign</span>(siz*<span class="number">2</span>,<span class="number">0ll</span>);</span><br><span class="line">		addv.<span class="built_in">assign</span>(siz*<span class="number">2</span>,<span class="number">0ll</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		minv[x] = <span class="built_in">min</span>(minv[<span class="built_in">ls</span>(x)],minv[<span class="built_in">rs</span>(x)]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">		ll &amp; v = addv[x];</span><br><span class="line">		<span class="keyword">if</span>(v)&#123;</span><br><span class="line">			addv[<span class="built_in">ls</span>(x)] += v;addv[<span class="built_in">rs</span>(x)] += v;</span><br><span class="line">			minv[<span class="built_in">ls</span>(x)] += v;</span><br><span class="line">			minv[<span class="built_in">rs</span>(x)] += v;</span><br><span class="line">			v = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx &gt; <span class="number">1</span>)<span class="built_in">pushdown</span>(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			minv[x] += v;</span><br><span class="line">			addv[x] += v;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">add</span>(l,r,v,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="built_in">add</span>(l,r,v,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="built_in">pushup</span>(x);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		<span class="built_in">add</span>(l,r,v,<span class="number">0</span>,<span class="number">0</span>,siz);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">Min</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span> INF;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx &gt; <span class="number">1</span>)<span class="built_in">pushdown</span>(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			<span class="keyword">return</span> minv[x];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		ll m1 = <span class="built_in">Min</span>(l,r,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		ll m2 = <span class="built_in">Min</span>(l,r,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="built_in">pushup</span>(x);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">min</span>(m1,m2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">Min</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Min</span>(l,r,<span class="number">0</span>,<span class="number">0</span>,siz);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;seg;</span><br></pre></td></tr></table></figure>
<h3 id="区间乘区间求和">区间乘,区间求和</h3>
<p>初始数组均为1.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segtree</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> n,size = <span class="number">1</span>;</span><br><span class="line">	vector&lt;ll&gt;sumv,mulv;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		sumv[x] = rx - lx;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">build</span>(<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="built_in">build</span>(<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">build</span>(<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(size &lt; n)&#123;</span><br><span class="line">			size *= <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		sumv.<span class="built_in">assign</span>(size*<span class="number">2</span>,<span class="number">0ll</span>);</span><br><span class="line">		mulv.<span class="built_in">assign</span>(size*<span class="number">2</span>,<span class="number">1ll</span>);</span><br><span class="line">		<span class="built_in">build</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(<span class="keyword">int</span> x,ll v)</span></span>&#123;</span><br><span class="line">		mulv[x] = mulv[x]*v%mod;</span><br><span class="line">		sumv[x] = sumv[x]*v%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		sumv[x] = (sumv[<span class="built_in">ls</span>(x)] + sumv[<span class="built_in">rs</span>(x)])%mod*mulv[x]%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			<span class="built_in">apply</span>(x,v);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">mul</span>(l,r,v,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="built_in">mul</span>(l,r,v,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="built_in">pushup</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		<span class="built_in">mul</span>(l,r,v,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			<span class="keyword">return</span> sumv[x];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		ll s1 = <span class="built_in">sum</span>(l,r,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		ll s2 = <span class="built_in">sum</span>(l,r,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="keyword">return</span> (s1+s2)%mod*mulv[x]%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">sum</span>(l,r,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="区间加区间求和">区间加,区间求和</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segtree</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	vector&lt;ll&gt;sumv,addv;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x*<span class="number">2</span> + <span class="number">1</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x*<span class="number">2</span> + <span class="number">2</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(size &lt; n)size *= <span class="number">2</span>;</span><br><span class="line">		sumv.<span class="built_in">assign</span>(size * <span class="number">2</span>,<span class="number">0ll</span>);</span><br><span class="line">		addv.<span class="built_in">assign</span>(size * <span class="number">2</span>,<span class="number">0ll</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		sumv[x] = sumv[<span class="built_in">ls</span>(x)] + sumv[<span class="built_in">rs</span>(x)];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		ll &amp; v = addv[x];</span><br><span class="line">		<span class="keyword">if</span>(v)&#123;</span><br><span class="line">			<span class="keyword">int</span> len = (rx - lx) / <span class="number">2</span>;</span><br><span class="line">			sumv[<span class="built_in">ls</span>(x)] += v * len;</span><br><span class="line">			sumv[<span class="built_in">rs</span>(x)] += v * len;</span><br><span class="line">			addv[<span class="built_in">ls</span>(x)] += v;</span><br><span class="line">			addv[<span class="built_in">rs</span>(x)] += v;</span><br><span class="line">			v = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(lx &gt;= r <span class="keyword">or</span> l &gt;= rx)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx &gt; <span class="number">1</span>)<span class="built_in">pushdown</span>(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			sumv[x] += (rx - lx) * v;</span><br><span class="line">			addv[x] += v;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx + rx) / <span class="number">2</span>;</span><br><span class="line">		<span class="built_in">add</span>(l,r,v,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="built_in">add</span>(l,r,v,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="built_in">pushup</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		<span class="built_in">add</span>(l,r,v,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx &gt; <span class="number">1</span>)<span class="built_in">pushdown</span>(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)<span class="keyword">return</span> sumv[x];</span><br><span class="line">		<span class="keyword">int</span> m = (lx + rx) / <span class="number">2</span>;</span><br><span class="line">		ll s1 = <span class="built_in">sum</span>(l,r,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		ll s2 = <span class="built_in">sum</span>(l,r,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="built_in">pushup</span>(x);</span><br><span class="line">		<span class="keyword">return</span> s1 + s2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">sum</span>(l,r,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;seg;</span><br></pre></td></tr></table></figure>
<h4 id="维护等差数列区间加等差数列单点查询">维护等差数列(区间加等差数列,单点查询)</h4>
<p>​ 由于<span class="math inline">\(A_n = A_{n-1} + d\)</span>， 维护一个差分数列即可.</p>
<ul>
<li><span class="math inline">\(1 \space l \space r \space a \space d\)</span>： 将<span class="math inline">\([L,R]\)</span>加上首项<span class="math inline">\(a\)</span>公差<span class="math inline">\(d\)</span>的等差数列</li>
<li><span class="math inline">\(2\space x\)</span>: 查询位置<span class="math inline">\(x\)</span>的值</li>
</ul>
<p><strong>此处的add操作是闭区间</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    <span class="keyword">int</span> opt,l,r,a,d;</span><br><span class="line">    cin &gt;&gt; opt &gt;&gt; l;</span><br><span class="line">    <span class="keyword">if</span>(opt == <span class="number">1</span>)&#123;</span><br><span class="line">        cin &gt;&gt; r &gt;&gt; a &gt;&gt; d;</span><br><span class="line">        seg.<span class="built_in">add</span>(l,l,a);</span><br><span class="line">        seg.<span class="built_in">add</span>(r+<span class="number">1</span>,r+<span class="number">1</span>,-a);</span><br><span class="line">        seg.<span class="built_in">add</span>(l+<span class="number">1</span>,r,d);</span><br><span class="line">        seg.<span class="built_in">add</span>(r+<span class="number">1</span>,r+<span class="number">1</span>,-(r-l)*d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; seg.<span class="built_in">sum</span>(<span class="number">1</span>,l) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间加-区间平方和">区间加, 区间平方和</h3>
<p>维护<code>squv[]</code>代表平方和, 显然有 <span class="math display">\[
squv[x] = v \cdot v \cdot len + 2 \cdot v \cdot sumv[x]
\]</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	sumv[x] = (sumv[<span class="built_in">ls</span>(x)] + sumv[<span class="built_in">rs</span>(x)]) % p;</span><br><span class="line">	squv[x] = (squv[<span class="built_in">ls</span>(x)] + squv[<span class="built_in">rs</span>(x)]) % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">	ll &amp; v = addv[x];</span><br><span class="line">	<span class="keyword">if</span>(v)&#123;</span><br><span class="line">		<span class="keyword">if</span>(v &lt; <span class="number">0</span>)v = (v + p) % p;</span><br><span class="line">		<span class="keyword">int</span> len = (rx - lx) / <span class="number">2</span>;</span><br><span class="line">		squv[<span class="built_in">ls</span>(x)] = (squv[<span class="built_in">ls</span>(x)] + v * v % p * len % p + <span class="number">2</span> * sumv[<span class="built_in">ls</span>(x)] * v % p) % p;</span><br><span class="line">		squv[<span class="built_in">rs</span>(x)] = (squv[<span class="built_in">rs</span>(x)] + v * v % p * len % p + <span class="number">2</span> * sumv[<span class="built_in">rs</span>(x)] * v % p) % p;</span><br><span class="line">		sumv[<span class="built_in">ls</span>(x)] = (sumv[<span class="built_in">ls</span>(x)] + v * len % p) % p;</span><br><span class="line">		sumv[<span class="built_in">rs</span>(x)] = (sumv[<span class="built_in">rs</span>(x)] + v * len % p) % p;</span><br><span class="line">		addv[<span class="built_in">ls</span>(x)] = (addv[<span class="built_in">ls</span>(x)] + v) % p;</span><br><span class="line">		addv[<span class="built_in">rs</span>(x)] = (addv[<span class="built_in">rs</span>(x)] + v) % p;</span><br><span class="line">		v = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(lx &gt;= r <span class="keyword">or</span> l &gt;= rx)<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(rx - lx &gt; <span class="number">1</span>)<span class="built_in">pushdown</span>(x,lx,rx);</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">		squv[x] = (squv[x] + (rx - lx) * v % p * v % p + <span class="number">2</span> * sumv[x] * v % p) % p;</span><br><span class="line">		sumv[x] = (sumv[x] + (rx - lx) * v % p) % p;</span><br><span class="line">		addv[x] = (addv[x] + v) % p;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> m = (lx + rx) / <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">add</span>(l,r,v,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">	<span class="built_in">add</span>(l,r,v,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">	<span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间加区间大于x的第一个值">区间加,区间大于x的第一个值</h3>
<p>在线段树上二分即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segtree</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	vector&lt;ll&gt;addv,maxv;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(size &lt; n)size *= <span class="number">2</span>;</span><br><span class="line">		addv.<span class="built_in">assign</span>(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">		maxv.<span class="built_in">assign</span>(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		maxv[x] = <span class="built_in">max</span>(maxv[<span class="built_in">ls</span>(x)],maxv[<span class="built_in">rs</span>(x)]) + addv[x];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			addv[x] += v;</span><br><span class="line">			maxv[x] += v;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">add</span>(l,r,v,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="built_in">add</span>(l,r,v,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="built_in">pushup</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll v)</span></span>&#123;</span><br><span class="line">		<span class="built_in">add</span>(l,r,v,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">least</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx,ll add)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rx &lt;= l <span class="keyword">or</span> maxv[x] + add &lt; v)<span class="keyword">return</span> INF;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(maxv[x] + add &gt;= v)<span class="keyword">return</span> lx;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">return</span> INF;</span><br><span class="line">		&#125;</span><br><span class="line">		add += addv[x];</span><br><span class="line">		<span class="keyword">int</span> m = (lx + rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> a1 = <span class="built_in">least</span>(l,v,<span class="built_in">ls</span>(x),lx,m,add),a2 = INF;</span><br><span class="line">		<span class="keyword">if</span>(a1 == INF)a2 = <span class="built_in">least</span>(l,v,<span class="built_in">rs</span>(x),m,rx,add);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">min</span>(a1,a2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">least</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">least</span>(l,v,<span class="number">0</span>,<span class="number">0</span>,size,addv[<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="区间懒标记">区间懒标记</h2>
<p>本节的区间懒标记均表示<strong>当前节点已经更新, 但当前节点的儿子节点未更新</strong></p>
<h3 id="区间赋值-区间最小值">区间赋值 区间最小值</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e10</span>+<span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segtree</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> NO_OPT = <span class="number">1E9</span>+<span class="number">10</span>;</span><br><span class="line">	vector&lt;ll&gt;setv,minv;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(size &lt; n)size *= <span class="number">2</span>;</span><br><span class="line">		setv.<span class="built_in">assign</span>(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">		minv.<span class="built_in">assign</span>(size*<span class="number">2</span>,<span class="number">0</span>); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(ll &amp; a,ll b)</span></span>&#123;</span><br><span class="line">		a = (b == NO_OPT?a:b);	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(setv[x] == NO_OPT)<span class="keyword">return</span>;</span><br><span class="line">		<span class="built_in">apply</span>(setv[<span class="built_in">ls</span>(x)],setv[x]);</span><br><span class="line">		<span class="built_in">apply</span>(minv[<span class="built_in">ls</span>(x)],setv[x]);</span><br><span class="line">		<span class="built_in">apply</span>(setv[<span class="built_in">rs</span>(x)],setv[x]);</span><br><span class="line">		<span class="built_in">apply</span>(minv[<span class="built_in">rs</span>(x)],setv[x]);</span><br><span class="line">		setv[x] = NO_OPT; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		minv[x] = <span class="built_in">min</span>(minv[<span class="built_in">ls</span>(x)],minv[<span class="built_in">rs</span>(x)]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx &gt; <span class="number">1</span>)<span class="built_in">pushdown</span>(x);</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			<span class="built_in">apply</span>(setv[x],v);</span><br><span class="line">			<span class="built_in">apply</span>(minv[x],v);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">Set</span>(l,r,v,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="built_in">Set</span>(l,r,v,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="built_in">pushup</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll v)</span></span>&#123;</span><br><span class="line">		<span class="built_in">Set</span>(l,r,v,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">Min</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx &gt; <span class="number">1</span>)<span class="built_in">pushdown</span>(x);</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span> INF;</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)<span class="keyword">return</span> minv[x];</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		ll m1 = <span class="built_in">Min</span>(l,r,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		ll m2 = <span class="built_in">Min</span>(l,r,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">min</span>(m1,m2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">Min</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Min</span>(l,r,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<h3 id="区间赋值-区间加">区间赋值 区间加</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segtree</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	vector&lt;ll&gt;sumv,setv;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> NO_OPT = INF+<span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(size &lt; n)size *= <span class="number">2</span>;</span><br><span class="line">		sumv.<span class="built_in">assign</span>(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">		setv.<span class="built_in">assign</span>(size*<span class="number">2</span>,NO_OPT);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(ll &amp; a,ll b)</span></span>&#123;</span><br><span class="line">		a = (b == NO_OPT?a:b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> len = rx - lx;</span><br><span class="line">		<span class="keyword">if</span>(len == <span class="number">1</span> <span class="keyword">or</span> setv[x] == NO_OPT)<span class="keyword">return</span>;</span><br><span class="line">		len /= <span class="number">2</span>;</span><br><span class="line">		<span class="built_in">apply</span>(setv[<span class="built_in">ls</span>(x)],setv[x]);</span><br><span class="line">		<span class="built_in">apply</span>(sumv[<span class="built_in">ls</span>(x)],setv[x]*len);</span><br><span class="line">		<span class="built_in">apply</span>(setv[<span class="built_in">rs</span>(x)],setv[x]);</span><br><span class="line">		<span class="built_in">apply</span>(sumv[<span class="built_in">rs</span>(x)],setv[x]*len);</span><br><span class="line">		setv[x] = NO_OPT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		sumv[x] = sumv[<span class="built_in">ls</span>(x)] + sumv[<span class="built_in">rs</span>(x)];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">		<span class="built_in">pushdown</span>(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			setv[x] = v;</span><br><span class="line">			sumv[x] = v*(rx - lx);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">Set</span>(l,r,v,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="built_in">Set</span>(l,r,v,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="built_in">pushup</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll v)</span></span>&#123;</span><br><span class="line">		<span class="built_in">Set</span>(l,r,v,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">pushdown</span>(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			<span class="keyword">return</span> sumv[x];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		ll s1 = <span class="built_in">sum</span>(l,r,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		ll s2 = <span class="built_in">sum</span>(l,r,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="keyword">return</span> s1+s2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">sum</span>(l,r,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="区间赋值-最大连续子段和区间合并">区间赋值 最大连续子段和(区间合并)</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segtree</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	vector&lt;ll&gt;sumv,setv;</span><br><span class="line">	vector&lt;ll&gt;prev,sufv,segv;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> NO_OPT = INF+<span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(size &lt; n)size *= <span class="number">2</span>;</span><br><span class="line">		sumv.<span class="built_in">assign</span>(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">		setv.<span class="built_in">assign</span>(size*<span class="number">2</span>,NO_OPT);</span><br><span class="line">		prev.<span class="built_in">assign</span>(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">		sufv.<span class="built_in">assign</span>(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">		segv.<span class="built_in">assign</span>(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(ll &amp; a,ll b)</span></span>&#123;</span><br><span class="line">		a = (b == NO_OPT?a:b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> len = rx - lx;</span><br><span class="line">		<span class="keyword">if</span>(len == <span class="number">1</span> <span class="keyword">or</span> setv[x] == NO_OPT)<span class="keyword">return</span>;</span><br><span class="line">		len /= <span class="number">2</span>;</span><br><span class="line">		<span class="built_in">apply</span>(setv[<span class="built_in">ls</span>(x)],setv[x]);</span><br><span class="line">		<span class="built_in">apply</span>(sumv[<span class="built_in">ls</span>(x)],setv[x]*len);</span><br><span class="line">		<span class="built_in">apply</span>(setv[<span class="built_in">rs</span>(x)],setv[x]);</span><br><span class="line">		<span class="built_in">apply</span>(sumv[<span class="built_in">rs</span>(x)],setv[x]*len);</span><br><span class="line">		<span class="keyword">if</span>(setv[x] != NO_OPT)&#123;</span><br><span class="line">			prev[<span class="built_in">ls</span>(x)] = prev[<span class="built_in">rs</span>(x)] = setv[x]*len;</span><br><span class="line">			sufv[<span class="built_in">ls</span>(x)] = sufv[<span class="built_in">rs</span>(x)] = setv[x]*len;</span><br><span class="line">			segv[<span class="built_in">ls</span>(x)] = segv[<span class="built_in">rs</span>(x)] = setv[x]*len;</span><br><span class="line">		&#125;</span><br><span class="line">		setv[x] = NO_OPT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		sumv[x] = sumv[<span class="built_in">ls</span>(x)] + sumv[<span class="built_in">rs</span>(x)];</span><br><span class="line">		sufv[x] = <span class="built_in">max</span>(sufv[<span class="built_in">rs</span>(x)],sufv[<span class="built_in">ls</span>(x)] + sumv[<span class="built_in">rs</span>(x)]);</span><br><span class="line">		prev[x] = <span class="built_in">max</span>(prev[<span class="built_in">ls</span>(x)],prev[<span class="built_in">rs</span>(x)] + sumv[<span class="built_in">ls</span>(x)]);</span><br><span class="line">		segv[x] = <span class="built_in">max</span>(&#123;segv[<span class="built_in">ls</span>(x)],segv[<span class="built_in">rs</span>(x)],prev[<span class="built_in">rs</span>(x)] + sufv[<span class="built_in">ls</span>(x)]&#125;); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">		<span class="built_in">pushdown</span>(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			setv[x] = v;</span><br><span class="line">			sumv[x] = v*(rx - lx);</span><br><span class="line">			<span class="keyword">if</span>(v &gt; <span class="number">0</span>)&#123;</span><br><span class="line">				segv[x] = prev[x] = sufv[x] = v*(rx - lx);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				segv[x] = prev[x] = sufv[x] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">Set</span>(l,r,v,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="built_in">Set</span>(l,r,v,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="built_in">pushup</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll v)</span></span>&#123;</span><br><span class="line">		<span class="built_in">Set</span>(l,r,v,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">pushdown</span>(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			<span class="keyword">return</span> sumv[x];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		ll s1 = <span class="built_in">sum</span>(l,r,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		ll s2 = <span class="built_in">sum</span>(l,r,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="keyword">return</span> s1+s2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">sum</span>(l,r,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="区间取反-第k个值">区间取反 第k个值</h3>
<p>用sum来维护区间取反,每取反一次有<span class="math inline">\(sum_x = len_x - sum_x\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segtree</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	vector&lt;ll&gt;sumv;</span><br><span class="line">	vector&lt;<span class="keyword">bool</span>&gt;inv,tag;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(size &lt; n)size *= <span class="number">2</span>;</span><br><span class="line">		sumv.<span class="built_in">assign</span>(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">		inv.<span class="built_in">assign</span>(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span> <span class="keyword">or</span> !inv[x])<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">int</span> len = (rx - lx)/<span class="number">2</span>;</span><br><span class="line">		sumv[<span class="built_in">ls</span>(x)] = len - sumv[<span class="built_in">ls</span>(x)];</span><br><span class="line">		sumv[<span class="built_in">rs</span>(x)] = len - sumv[<span class="built_in">rs</span>(x)];</span><br><span class="line">		inv[<span class="built_in">ls</span>(x)] = !inv[<span class="built_in">ls</span>(x)];</span><br><span class="line">		inv[<span class="built_in">rs</span>(x)] = !inv[<span class="built_in">rs</span>(x)];</span><br><span class="line">		inv[x] = !inv[x];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		sumv[x] = sumv[<span class="built_in">ls</span>(x)] + sumv[<span class="built_in">rs</span>(x)];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Inv</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">		<span class="built_in">pushdown</span>(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			inv[x] = !inv[x];</span><br><span class="line">			sumv[x] = (rx - lx) - sumv[x];</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">Inv</span>(l,r,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="built_in">Inv</span>(l,r,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="built_in">pushup</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Inv</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="built_in">Inv</span>(l,r,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="built_in">pushdown</span>(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx)<span class="keyword">return</span> INF;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(sumv[x] &gt;= v)<span class="keyword">return</span> lx;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">return</span> INF;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(sumv[<span class="built_in">ls</span>(x)] &gt; v)<span class="keyword">return</span> <span class="built_in">kth</span>(l,v,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">kth</span>(l,v - sumv[<span class="built_in">ls</span>(x)],<span class="built_in">rs</span>(x),m,rx); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">kth</span>(l,v,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="多个懒标记的顺序问题">多个懒标记的顺序问题</h2>
<p>待补充.</p>
<h3 id="区间加-区间乘">区间加, 区间乘</h3>
<p>设<span class="math inline">\(addv[]\)</span>为加法懒标记, <span class="math inline">\(mulv[]\)</span>为乘法懒标记. 我们人为规定乘法懒标记优先级大于加法. 即当<span class="math inline">\(sumv[x]\)</span>和<span class="math inline">\(mulv[x]\)</span>同时存在时, 认为<span class="math inline">\(sumv[x] = mulv[x]*sumv[x] + addv[x]\)</span>.</p>
<p>则更新标记时, 加法直接<span class="math inline">\(addv[x] += v\)</span>, 乘法需要同时影响<span class="math inline">\(addv\)</span>和<span class="math inline">\(mulv\)</span>, 将二者同时乘<span class="math inline">\(v\)</span>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segtree</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> siz = <span class="number">1</span>;</span><br><span class="line">	vector&lt;ll&gt;mulv,addv,sumv;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(siz &lt; n)siz *= <span class="number">2</span>;</span><br><span class="line">		mulv.<span class="built_in">assign</span>(siz*<span class="number">2</span>,<span class="number">1ll</span>);</span><br><span class="line">		addv.<span class="built_in">assign</span>(siz*<span class="number">2</span>,<span class="number">0ll</span>);</span><br><span class="line">		sumv.<span class="built_in">assign</span>(siz*<span class="number">2</span>,<span class="number">0ll</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		ll len = (rx - lx)/<span class="number">2</span>;</span><br><span class="line">		ll &amp; av = addv[x],&amp; mv = mulv[x];</span><br><span class="line">		sumv[<span class="built_in">ls</span>(x)] = (sumv[<span class="built_in">ls</span>(x)]*mv % p + av*len%p)%p; </span><br><span class="line">		sumv[<span class="built_in">rs</span>(x)] = (sumv[<span class="built_in">rs</span>(x)]*mv % p + av*len%p)%p; </span><br><span class="line">		mulv[<span class="built_in">ls</span>(x)] = (mulv[<span class="built_in">ls</span>(x)]*mv)%p;</span><br><span class="line">		mulv[<span class="built_in">rs</span>(x)] = (mulv[<span class="built_in">rs</span>(x)]*mv)%p;</span><br><span class="line">		addv[<span class="built_in">ls</span>(x)] = (addv[<span class="built_in">ls</span>(x)]*mv%p + av)%p;<span class="comment">//规定乘法优先级大于加法</span></span><br><span class="line">		addv[<span class="built_in">rs</span>(x)] = (addv[<span class="built_in">rs</span>(x)]*mv%p + av)%p;		</span><br><span class="line">		av = <span class="number">0</span>,mv = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		sumv[x] = sumv[<span class="built_in">ls</span>(x)] + sumv[<span class="built_in">rs</span>(x)];</span><br><span class="line">		sumv[x] %= p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx &gt; <span class="number">1</span>)<span class="built_in">pushdown</span>(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			sumv[x] = (sumv[x] + v*(rx - lx)%p)%p;</span><br><span class="line">			addv[x] += v;</span><br><span class="line">			addv[x] %= p;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">add</span>(l,r,v,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="built_in">add</span>(l,r,v,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="built_in">pushup</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		r++;</span><br><span class="line">		<span class="built_in">add</span>(l,r,v,<span class="number">0</span>,<span class="number">0</span>,siz);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx &gt; <span class="number">1</span>)<span class="built_in">pushdown</span>(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			sumv[x] = sumv[x]*v%p;</span><br><span class="line">			mulv[x] = (mulv[x]*v)%p;</span><br><span class="line">			addv[x] = (addv[x]*v)%p;<span class="comment">//规定乘法优先级大于加法</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">mul</span>(l,r,v,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="built_in">mul</span>(l,r,v,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="built_in">pushup</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		r++;</span><br><span class="line">		<span class="built_in">mul</span>(l,r,v,<span class="number">0</span>,<span class="number">0</span>,siz);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx &gt; <span class="number">1</span>)<span class="built_in">pushdown</span>(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)<span class="keyword">return</span> sumv[x]%p;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		ll s1 = <span class="built_in">sum</span>(l,r,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		ll s2 = <span class="built_in">sum</span>(l,r,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="keyword">return</span> (s1+s2)%p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		r++;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">sum</span>(l,r,<span class="number">0</span>,<span class="number">0</span>,siz);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp; in,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(lx &lt; (<span class="keyword">int</span>)in.<span class="built_in">size</span>())sumv[x] = in[lx]%p;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">build</span>(in,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="built_in">build</span>(in,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="built_in">pushup</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp; in)</span></span>&#123;</span><br><span class="line">		<span class="built_in">build</span>(in,<span class="number">0</span>,<span class="number">0</span>,siz);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;seg;</span><br></pre></td></tr></table></figure>
<h3 id="区间加-区间赋值-区间求和">区间加 区间赋值 区间求和</h3>
<p>规定<span class="math inline">\(setv\)</span>的优先级大于<span class="math inline">\(addv\)</span>, 即<span class="math inline">\(sumv[x] = setv[x] + addv[x]\)</span>. 在<code>add</code>时直接加即可, 但<code>set</code>要先覆盖掉之前的<code>add</code>操作.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segtree</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	vector&lt;ll&gt;setv,sumv,addv;</span><br><span class="line">	<span class="keyword">const</span> ll NO_OPT = LLONG_MAX; </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(size &lt;= n)size *= <span class="number">2</span>;</span><br><span class="line">		setv.<span class="built_in">assign</span>(size*<span class="number">2</span>,NO_OPT);</span><br><span class="line">		sumv.<span class="built_in">assign</span>(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">		addv.<span class="built_in">assign</span>(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">int</span> len = (rx - lx)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(setv[x] != NO_OPT)&#123;</span><br><span class="line">			addv[<span class="built_in">ls</span>(x)] = addv[<span class="built_in">rs</span>(x)] = <span class="number">0</span>;</span><br><span class="line">			setv[<span class="built_in">ls</span>(x)] = setv[<span class="built_in">rs</span>(x)] = setv[x];</span><br><span class="line">			sumv[<span class="built_in">ls</span>(x)] = sumv[<span class="built_in">rs</span>(x)] = setv[x]*len;</span><br><span class="line">			setv[x] = NO_OPT; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(addv[x])&#123;</span><br><span class="line">			addv[<span class="built_in">ls</span>(x)] += addv[x];</span><br><span class="line">			addv[<span class="built_in">rs</span>(x)] += addv[x];</span><br><span class="line">			sumv[<span class="built_in">ls</span>(x)] += addv[x]*len;</span><br><span class="line">			sumv[<span class="built_in">rs</span>(x)] += addv[x]*len;</span><br><span class="line">			addv[x] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">		sumv[x] = sumv[<span class="built_in">ls</span>(x)] + sumv[<span class="built_in">rs</span>(x)] + addv[x]*len;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">		<span class="built_in">pushdown</span>(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			setv[x] = v;</span><br><span class="line">			addv[x] = <span class="number">0</span>;</span><br><span class="line">			sumv[x] = v*(rx - lx);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">Set</span>(l,r,v,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="built_in">Set</span>(l,r,v,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="built_in">pushup</span>(x,rx - lx);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll v)</span></span>&#123;</span><br><span class="line">		<span class="built_in">Set</span>(l,r,v,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">		<span class="built_in">pushdown</span>(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			addv[x] += v;</span><br><span class="line">			sumv[x] += v*(rx - lx);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">add</span>(l,r,v,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="built_in">add</span>(l,r,v,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="built_in">pushup</span>(x,rx - lx);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll v)</span></span>&#123;</span><br><span class="line">		<span class="built_in">add</span>(l,r,v,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">pushdown</span>(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			<span class="keyword">return</span> sumv[x];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		ll s1 = <span class="built_in">sum</span>(l,r,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		ll s2 = <span class="built_in">sum</span>(l,r,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="keyword">return</span> s1+s2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">sum</span>(l,r,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<h2 id="杂项-1">杂项</h2>
<h3 id="在01数组里寻找最长的一串连续01">在01数组里寻找最长的一串连续0/1</h3>
<p><code>strip(x = 起始位置,v = 0或1)</code></p>
<p>返回连续的0/1串终点的<strong>下一个位置</strong>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strip</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> prel,<span class="keyword">int</span> pre,<span class="keyword">bool</span> v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> lx;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">pushdown</span>(x,lx,rx);</span><br><span class="line">		<span class="keyword">int</span> m = (lx + rx) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">bool</span> ok = <span class="number">0</span>;<span class="comment">//1-goto [m,rx) 0-goto [lx,m)</span></span><br><span class="line">		<span class="keyword">if</span>(v <span class="keyword">and</span> pre + sumv[<span class="built_in">ls</span>(x)] - prel &gt;= m - l)ok = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(!v <span class="built_in"><span class="keyword">and</span></span> (m - pre - sumv[<span class="built_in">ls</span>(x)]) - (l - prel) &gt;= m - l)ok = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(ok)<span class="keyword">return</span> <span class="built_in">strip</span>(l,prel,pre + sumv[<span class="built_in">ls</span>(x)],v,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">strip</span>(l,prel,pre,v,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">strip</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">bool</span> v)</span></span>&#123;</span><br><span class="line">		<span class="comment">//find longest continuous 0 or 1, return the next position.</span></span><br><span class="line">		<span class="comment">//00001111001 (index start from 1)</span></span><br><span class="line">		<span class="comment">//strip(5,1) will return 9</span></span><br><span class="line">		<span class="keyword">int</span> pre = <span class="built_in">sum</span>(<span class="number">0</span>,x<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">strip</span>(x,pre,<span class="number">0</span>,v,<span class="number">0</span>,<span class="number">0</span>,siz);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在01数组里寻找最高位的1">在01数组里寻找最高位的1</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">high</span><span class="params">(<span class="keyword">int</span> pre,<span class="keyword">int</span> tot,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)<span class="keyword">return</span> lx;</span><br><span class="line">	<span class="built_in">pushdown</span>(x,lx,rx);</span><br><span class="line">	<span class="keyword">int</span> m = (lx + rx) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(sumv[<span class="built_in">ls</span>(x)] + pre &lt; tot)<span class="keyword">return</span> <span class="built_in">high</span>(pre + sumv[<span class="built_in">ls</span>(x)],tot,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">high</span>(pre,tot,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">high</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// find highest 1</span></span><br><span class="line">	<span class="keyword">int</span> tot = <span class="built_in">sum</span>(<span class="number">1</span>,siz - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">high</span>(<span class="number">0</span>,tot,<span class="number">0</span>,<span class="number">0</span>,siz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态开点">动态开点</h2>
<p>新增一个结构体<code>Node</code>, 存每个节点的左右儿子下标<code>ls rs</code>, 其余与普通线段树一致. 开空间时可以开得尽可能大. 设有<span class="math inline">\(m\)</span>个询问, 区间长度最大值为<span class="math inline">\(n\)</span>, 空间复杂度为<span class="math inline">\(O(m\log n)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> ls,rs;</span><br><span class="line">	<span class="built_in">Node</span>()&#123;ls = rs = <span class="number">0</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">init</span>(<span class="keyword">int</span> n)&#123;</span><br><span class="line">	<span class="keyword">while</span>(size &lt; n)size *= <span class="number">2</span>;<span class="comment">//此处的n代表了区间的最大范围</span></span><br><span class="line">	setv.<span class="built_in">assign</span>(maxc,NO_OPT);<span class="comment">//注意此处是maxc不是size*2. maxc可以开得尽可能大</span></span><br><span class="line">	minv.<span class="built_in">assign</span>(maxc,<span class="number">0</span>);</span><br><span class="line">	node.<span class="built_in">assign</span>(maxc,<span class="built_in">Node</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> &amp; v = node[x].ls;</span><br><span class="line">	<span class="keyword">return</span> v?v:v = ++cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> &amp; v = node[x].rs;</span><br><span class="line">	<span class="keyword">return</span> v?v:v = ++cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可持久化线段树">可持久化线段树</h2>
<h3 id="可持久化数组">可持久化数组</h3>
<p><span class="math inline">\(ncnt\)</span>为当前版本下标，添加新版本必须修改这个值</p>
<p><code>set(idx = 下标,v = 值,hisver = 要修改的历史版本,curver = 当前历史版本)</code></p>
<p>具体来说, <span class="math inline">\(hisv\)</span>代表了要修改的历史版本号. 修改过后的数组会保存在<span class="math inline">\(curv\)</span>中.</p>
<p><code>get(idx = 下标,Ver = 要查询的历史版本)</code></p>
<p>时空复杂度均为<span class="math inline">\(O(q\log n)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> Ls[maxc],Rs[maxc],sumv[maxc];</span><br><span class="line"><span class="keyword">int</span> hisn[maxn],ncnt = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seg</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(size &lt; n)size *= <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> Ls[x]?Ls[x]:Ls[x] = ++ncnt;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> Rs[x]?Rs[x]:Rs[x] = ++ncnt;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> v,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)&#123;</span><br><span class="line">			sumv[x] = v;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx + rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(idx &lt; m)&#123;</span><br><span class="line">			Rs[x] = Rs[r]; </span><br><span class="line">			<span class="built_in">set</span>(idx,v,<span class="built_in">ls</span>(r),<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			Ls[x] = Ls[r];</span><br><span class="line">			<span class="built_in">set</span>(idx,v,<span class="built_in">rs</span>(r),<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> v,<span class="keyword">int</span> hisv,<span class="keyword">int</span> curv)</span></span>&#123;</span><br><span class="line">		<span class="built_in">set</span>(idx,v,hisn[hisv],hisn[curv],<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> sumv[x];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(idx &lt; m)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">get</span>(idx,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">get</span>(idx,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> ver)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">get</span>(idx,hisn[ver],<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;seg;</span><br></pre></td></tr></table></figure>
<h3 id="主席树">主席树</h3>
<p>查询静态区间k小值.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> Ls[maxc],Rs[maxc],sumv[maxc],hisn[maxc];<span class="comment">//hisn[版本号] = 对应根节点</span></span><br><span class="line"><span class="keyword">int</span> oriv[maxn];<span class="comment">//离散化前的值</span></span><br><span class="line"><span class="keyword">int</span> univ[maxn];<span class="comment">//离散化后的值</span></span><br><span class="line"><span class="keyword">int</span> raw[maxn];</span><br><span class="line"><span class="keyword">int</span> ncnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segtree</span>&#123;</span><span class="comment">//可持久化权值线段树</span></span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="keyword">while</span>(size &lt; n)size *= <span class="number">2</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> Ls[x]?Ls[x]:Ls[x] = ++ncnt;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> Rs[x]?Rs[x]:Rs[x] = ++ncnt;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		sumv[x] = sumv[<span class="built_in">ls</span>(x)] + sumv[<span class="built_in">rs</span>(x)];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> v,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)&#123;</span><br><span class="line">			sumv[x] = sumv[r] + v; </span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(idx &lt; m)&#123;</span><br><span class="line">			Rs[x] = Rs[r];</span><br><span class="line">			<span class="built_in">add</span>(idx,v,<span class="built_in">ls</span>(r),<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			Ls[x] = Ls[r];</span><br><span class="line">			<span class="built_in">add</span>(idx,v,<span class="built_in">rs</span>(r),<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">pushup</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> v,<span class="keyword">int</span> hisv,<span class="keyword">int</span> curv)</span></span>&#123;</span><br><span class="line">		<span class="built_in">add</span>(idx,v,hisn[hisv],hisn[curv],<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> oriv[lx];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> csum = sumv[<span class="built_in">ls</span>(x)] - sumv[<span class="built_in">ls</span>(r)];</span><br><span class="line">		<span class="keyword">if</span>(k &lt;= csum)<span class="keyword">return</span> <span class="built_in">kth</span>(k,<span class="built_in">ls</span>(r),<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">kth</span>(k - csum,<span class="built_in">rs</span>(r),<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">kth</span>(k,hisn[l<span class="number">-1</span>],hisn[r],<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;seg;</span><br></pre></td></tr></table></figure>
<p>离散化部分:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;hsh;</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">	cin &gt;&gt; oriv[i];</span><br><span class="line">	raw[i] = oriv[i];</span><br><span class="line">	hsh[oriv[i]] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp; it:hsh)&#123;it.second = ++tmp;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">	univ[i] = hsh[oriv[i]];</span><br><span class="line">	hisn[i] = ++ncnt;</span><br><span class="line">	seg.<span class="built_in">add</span>(univ[i],<span class="number">1</span>,i<span class="number">-1</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)oriv[univ[i]] = raw[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">	<span class="keyword">int</span> l,r,k;</span><br><span class="line">	cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;</span><br><span class="line">	cout &lt;&lt; seg.<span class="built_in">kth</span>(l,r,k) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求区间mex">求区间mex</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxc = <span class="number">6e7</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> Ls[maxc],Rs[maxc],minv[maxc];</span><br><span class="line"><span class="keyword">int</span> hisn[maxn],ncnt = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seg</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(size &lt; n)size *= <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		minv[x] = <span class="built_in">min</span>(minv[<span class="built_in">ls</span>(x)],minv[<span class="built_in">rs</span>(x)]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> Ls[x]?Ls[x]:Ls[x] = ++ncnt;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> Rs[x]?Rs[x]:Rs[x] = ++ncnt;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> v,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)&#123;</span><br><span class="line">			minv[x] = v;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx + rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(idx &lt; m)&#123;</span><br><span class="line">			Rs[x] = Rs[r]; </span><br><span class="line">			<span class="built_in">set</span>(idx,v,<span class="built_in">ls</span>(r),<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			Ls[x] = Ls[r];</span><br><span class="line">			<span class="built_in">set</span>(idx,v,<span class="built_in">rs</span>(r),<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">pushup</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> v,<span class="keyword">int</span> hisv,<span class="keyword">int</span> curv)</span></span>&#123;</span><br><span class="line">		<span class="built_in">set</span>(idx,v,hisn[hisv],hisn[curv],<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">mex</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">		<span class="comment">//return mex in [L,R]</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">mex</span>(L,hisn[R],<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">mex</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)<span class="keyword">return</span> lx;</span><br><span class="line">		<span class="keyword">int</span> m = (lx + rx) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(minv[<span class="built_in">ls</span>(x)] &lt; L)<span class="keyword">return</span> <span class="built_in">mex</span>(L,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">mex</span>(L,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;seg;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">setf</span>(ios::fixed,ios::floatfield);</span><br><span class="line">	cout.<span class="built_in">precision</span>(<span class="number">12</span>);	 </span><br><span class="line">	<span class="keyword">int</span> n,q;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">	seg.<span class="built_in">init</span>(n + <span class="number">10</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		cin &gt;&gt; raw[i];</span><br><span class="line">		<span class="keyword">if</span>(raw[i] &gt; n + <span class="number">1</span>)raw[i] = n + <span class="number">1</span>;<span class="comment">//mex must &lt;= n</span></span><br><span class="line">		hisn[i] = ++ncnt;</span><br><span class="line">		seg.<span class="built_in">set</span>(raw[i],i,i<span class="number">-1</span>,i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(q--)&#123;</span><br><span class="line">		<span class="keyword">int</span> l,r;</span><br><span class="line">		cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">		cout &lt;&lt; seg.<span class="built_in">mex</span>(l,r) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="势能线段树segment-tree-beats">势能线段树(Segment Tree Beats)</h2>
<h3 id="part1-区间最值暴力修改">Part1: 区间最值&amp;暴力修改</h3>
<p>https://ac.nowcoder.com/acm/problem/226598</p>
<p>https://codeforces.com/blog/entry/57319</p>
<p>势能线段树则总时间复杂度为O(M×∣0势能时线段树操作时间复杂度∣+N×∣节点势能上限降低至0势能时间复杂度∣+M×∣线段树单次操作影响到的节点数目∣×∣操作额外提供的势能∣)</p>
<p>核心思想: 在能跳出的部分尽量跳出(如区间取min时, <code>maxv[x] &lt;= v</code>即可跳出)</p>
<h4 id="区间取min">区间取min</h4>
<p>给出<span class="math inline">\(n\)</span>个初始值和<span class="math inline">\(m\)</span>个操作:</p>
<p><code>0 l r v</code> 对于$ i $, <span class="math inline">\(A_i = min(A_i,v)\)</span></p>
<p><code>1 l r</code>查询区间<span class="math inline">\([L,R]\)</span>最大值</p>
<p><code>2 l r</code>查询区间<span class="math inline">\([L,R]\)</span>的和</p>
<p>令<span class="math inline">\(maxv[]\)</span>维护最大值, <span class="math inline">\(secv[]\)</span>维护严格次大值, <span class="math inline">\(cntv[]\)</span>维护最大值的个数. 每次区间取<span class="math inline">\(min\)</span>分三种情况:</p>
<ol type="1">
<li><span class="math inline">\(maxv[x] \leq v\)</span>, 直接忽略</li>
<li><span class="math inline">\(secv[x] &lt; v &lt; maxv[x]\)</span>, 将最大值改为<span class="math inline">\(v\)</span>即可.</li>
<li><span class="math inline">\(v \leq secv[x]\)</span>, 无法判断如何修改, 暴力修改其子区间.</li>
</ol>
<p>通过势能分析可得其复杂度为<span class="math inline">\(O(m \log n)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sgbt</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> siz = <span class="number">1</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;maxv,cntv,secv,mintag;<span class="comment">//cntv-区间最大值的数量</span></span><br><span class="line">    vector&lt;ll&gt;sumv;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(siz &lt; n)siz *= <span class="number">2</span>;</span><br><span class="line">        maxv.<span class="built_in">assign</span>(siz*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">        cntv.<span class="built_in">assign</span>(siz*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">        secv.<span class="built_in">assign</span>(siz*<span class="number">2</span>,<span class="number">-1</span>);</span><br><span class="line">        sumv.<span class="built_in">assign</span>(siz*<span class="number">2</span>,<span class="number">0ll</span>);</span><br><span class="line">        mintag.<span class="built_in">assign</span>(siz*<span class="number">2</span>,<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        sumv[x] = sumv[<span class="built_in">ls</span>(x)] + sumv[<span class="built_in">rs</span>(x)];</span><br><span class="line">        <span class="keyword">if</span>(maxv[<span class="built_in">ls</span>(x)] == maxv[<span class="built_in">rs</span>(x)])&#123;</span><br><span class="line">            maxv[x] = maxv[<span class="built_in">ls</span>(x)];</span><br><span class="line">            secv[x] = <span class="built_in">max</span>(secv[<span class="built_in">ls</span>(x)],secv[<span class="built_in">rs</span>(x)]);</span><br><span class="line">            cntv[x] = cntv[<span class="built_in">ls</span>(x)] + cntv[<span class="built_in">rs</span>(x)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(maxv[<span class="built_in">ls</span>(x)] &gt; maxv[<span class="built_in">rs</span>(x)])&#123;</span><br><span class="line">            maxv[x] = maxv[<span class="built_in">ls</span>(x)],cntv[x] = cntv[<span class="built_in">ls</span>(x)];</span><br><span class="line">            secv[x] = <span class="built_in">max</span>(maxv[<span class="built_in">rs</span>(x)],secv[<span class="built_in">ls</span>(x)]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            maxv[x] = maxv[<span class="built_in">rs</span>(x)],cntv[x] = cntv[<span class="built_in">rs</span>(x)];</span><br><span class="line">            secv[x] = <span class="built_in">max</span>(maxv[<span class="built_in">ls</span>(x)],secv[<span class="built_in">rs</span>(x)]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> &amp; v = mintag[x];</span><br><span class="line">        <span class="keyword">if</span>(v == <span class="number">-1</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(maxv[<span class="built_in">ls</span>(x)] &gt; v)&#123;</span><br><span class="line">            sumv[<span class="built_in">ls</span>(x)] += <span class="number">1ll</span>*cntv[<span class="built_in">ls</span>(x)]*(v - maxv[<span class="built_in">ls</span>(x)]);</span><br><span class="line">            maxv[<span class="built_in">ls</span>(x)] = v;</span><br><span class="line">            mintag[<span class="built_in">ls</span>(x)] = v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(maxv[<span class="built_in">rs</span>(x)] &gt; v)&#123;</span><br><span class="line">            sumv[<span class="built_in">rs</span>(x)] += <span class="number">1ll</span>*cntv[<span class="built_in">rs</span>(x)]*(v - maxv[<span class="built_in">rs</span>(x)]);</span><br><span class="line">            maxv[<span class="built_in">rs</span>(x)] = v;</span><br><span class="line">            mintag[<span class="built_in">rs</span>(x)] = v;</span><br><span class="line">        &#125;</span><br><span class="line">        v = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">smin</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(rx - lx &gt; <span class="number">1</span>)<span class="built_in">pushdown</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(maxv[x] &lt;= v)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(secv[x] &lt; v)&#123;</span><br><span class="line">                sumv[x] += <span class="number">1ll</span>*cntv[x]*(v - maxv[x]);</span><br><span class="line">                maxv[x] = v;</span><br><span class="line">                mintag[x] = v;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">smin</span>(l,r,v,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">        <span class="built_in">smin</span>(l,r,v,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">        <span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">smin</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        r++;</span><br><span class="line">        <span class="built_in">smin</span>(l,r,v,<span class="number">0</span>,<span class="number">0</span>,siz);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(rx - lx &gt; <span class="number">1</span>)<span class="built_in">pushdown</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)<span class="keyword">return</span> maxv[x];</span><br><span class="line">        <span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> m1 = <span class="built_in">Max</span>(l,r,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">        <span class="keyword">int</span> m2 = <span class="built_in">Max</span>(l,r,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">        <span class="built_in">pushup</span>(x);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(m1,m2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        r++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Max</span>(l,r,<span class="number">0</span>,<span class="number">0</span>,siz);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(rx - lx &gt; <span class="number">1</span>)<span class="built_in">pushdown</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)<span class="keyword">return</span> sumv[x];</span><br><span class="line">        <span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">        ll s1 = <span class="built_in">sum</span>(l,r,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">        ll s2 = <span class="built_in">sum</span>(l,r,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">        <span class="built_in">pushup</span>(x);</span><br><span class="line">        <span class="keyword">return</span> s1+s2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        r++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(l,r,<span class="number">0</span>,<span class="number">0</span>,siz);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp; in,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rx - lx == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(lx &lt; (<span class="keyword">int</span>)in.<span class="built_in">size</span>())&#123;</span><br><span class="line">                sumv[x] = maxv[x] = in[lx];</span><br><span class="line">                cntv[x] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">build</span>(in,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">        <span class="built_in">build</span>(in,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">        <span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp; in)</span></span>&#123;</span><br><span class="line">        <span class="built_in">build</span>(in,<span class="number">0</span>,<span class="number">0</span>,siz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="暴力修改维护区间操作单点修改">暴力修改维护区间操作+单点修改</h4>
<p>例题: <a href="https://codeforces.com/contest/438/problem/D">CF438D - The Child and Sequence</a></p>
<p>区间取模, 区间求和, 单点赋值.</p>
<p>我们定义每个数被取模的最大次数和为线段树的总势能. 容易发现一个数<span class="math inline">\(a\)</span>的势能为<span class="math inline">\(\log a\)</span>, 线段树的总势能为<span class="math inline">\(n \log a\)</span>. 故我们暴力修改最多只需暴力修改<span class="math inline">\(n\log a\)</span>次. 对区间开根号. 总复杂度<span class="math inline">\(O(n \log^2 n)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segtree</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> siz = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> NO_OPT = INT_MAX;</span><br><span class="line">	vector&lt;ll&gt;sumv,maxv,modv;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(siz &lt; n)siz *= <span class="number">2</span>;</span><br><span class="line">		sumv.<span class="built_in">assign</span>(siz*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">		maxv.<span class="built_in">assign</span>(siz*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="comment">// modv.assign(siz*2,NO_OPT);</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;&#125;</span><br><span class="line">	<span class="comment">// void pushdown(int x,int lx,int rx)&#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp; in,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(lx &lt; (<span class="keyword">int</span>)in.<span class="built_in">size</span>())&#123;</span><br><span class="line">				sumv[x] = in[lx];</span><br><span class="line">				maxv[x] = in[lx];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">build</span>(in,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="built_in">build</span>(in,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="built_in">pushup</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp; in)</span></span>&#123;</span><br><span class="line">		<span class="built_in">build</span>(in,<span class="number">0</span>,<span class="number">0</span>,siz);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		sumv[x] = (sumv[<span class="built_in">ls</span>(x)] + sumv[<span class="built_in">rs</span>(x)]);</span><br><span class="line">		maxv[x] = <span class="built_in">max</span>(maxv[<span class="built_in">ls</span>(x)],maxv[<span class="built_in">rs</span>(x)]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(idx &gt;= rx <span class="keyword">or</span> lx &gt; idx)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span> <span class="keyword">and</span> lx == idx)&#123;</span><br><span class="line">			maxv[x] = v;</span><br><span class="line">			sumv[x] = v;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">set</span>(idx,v,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="built_in">set</span>(idx,v,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="built_in">pushup</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		<span class="built_in">set</span>(idx,v,<span class="number">0</span>,<span class="number">0</span>,siz);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">mod</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(maxv[x] &lt; p)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r <span class="keyword">and</span> rx - lx == <span class="number">1</span>)&#123;</span><br><span class="line">			sumv[x] %= p;</span><br><span class="line">			maxv[x] = sumv[x];</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line"> 		<span class="built_in">mod</span>(l,r,p,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line"> 		<span class="built_in">mod</span>(l,r,p,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line"> 		<span class="built_in">pushup</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">mod</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">		r++;</span><br><span class="line">		<span class="built_in">mod</span>(l,r,p,<span class="number">0</span>,<span class="number">0</span>,siz);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)<span class="keyword">return</span> sumv[x];</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		ll s1 = <span class="built_in">sum</span>(l,r,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		ll s2 = <span class="built_in">sum</span>(l,r,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="keyword">return</span> s1+s2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		r++;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">sum</span>(l,r,<span class="number">0</span>,<span class="number">0</span>,siz);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;seg;</span><br></pre></td></tr></table></figure>
<h4 id="暴力修改维护区间操作区间修改">暴力修改维护区间操作+区间修改</h4>
<p>区间开根, 区间加, 区间求和.</p>
<p>定义势能为<span class="math inline">\(C = maxv[x] - minv[x]\)</span>. 当势能为0时说明该段区间所有数均相同, 可将区间开根(或其他类似操作)改为区间赋值.</p>
<p>时间复杂度仍为<span class="math inline">\(O(n\log^2n)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segtree</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> siz = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">const</span> ll NO_OPT = LLONG_MAX;</span><br><span class="line">	vector&lt;ll&gt;maxv,minv,sumv,addv,setv;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(siz &lt; n)siz *= <span class="number">2</span>;</span><br><span class="line">		maxv.<span class="built_in">assign</span>(siz*<span class="number">2</span>,<span class="number">0ll</span>);</span><br><span class="line">		minv.<span class="built_in">assign</span>(siz*<span class="number">2</span>,<span class="number">0ll</span>);</span><br><span class="line">		sumv.<span class="built_in">assign</span>(siz*<span class="number">2</span>,<span class="number">0ll</span>);</span><br><span class="line">		addv.<span class="built_in">assign</span>(siz*<span class="number">2</span>,<span class="number">0ll</span>);</span><br><span class="line">		setv.<span class="built_in">assign</span>(siz*<span class="number">2</span>,NO_OPT);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		sumv[x] = sumv[<span class="built_in">ls</span>(x)] + sumv[<span class="built_in">rs</span>(x)];</span><br><span class="line">		maxv[x] = <span class="built_in">max</span>(maxv[<span class="built_in">ls</span>(x)],maxv[<span class="built_in">rs</span>(x)]);</span><br><span class="line">		minv[x] = <span class="built_in">min</span>(minv[<span class="built_in">ls</span>(x)],minv[<span class="built_in">rs</span>(x)]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">		ll len = (rx - lx)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(setv[x] != NO_OPT)&#123;</span><br><span class="line">			ll &amp; v = setv[x];</span><br><span class="line">			sumv[<span class="built_in">ls</span>(x)] = sumv[<span class="built_in">rs</span>(x)] = v*len;</span><br><span class="line">			setv[<span class="built_in">ls</span>(x)] = setv[<span class="built_in">rs</span>(x)] = v;</span><br><span class="line">			maxv[<span class="built_in">ls</span>(x)] = minv[<span class="built_in">ls</span>(x)] = maxv[<span class="built_in">rs</span>(x)] = minv[<span class="built_in">rs</span>(x)] = v;</span><br><span class="line">			addv[<span class="built_in">ls</span>(x)] = addv[<span class="built_in">rs</span>(x)] = <span class="number">0</span>;</span><br><span class="line">			v = NO_OPT;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(addv[x])&#123;</span><br><span class="line">			ll &amp; v = addv[x];</span><br><span class="line">			addv[<span class="built_in">ls</span>(x)] += v;addv[<span class="built_in">rs</span>(x)] += v;</span><br><span class="line">			sumv[<span class="built_in">ls</span>(x)] += v*len;sumv[<span class="built_in">rs</span>(x)] += v*len;</span><br><span class="line">			maxv[<span class="built_in">ls</span>(x)] += v;maxv[<span class="built_in">rs</span>(x)] += v;</span><br><span class="line">			minv[<span class="built_in">ls</span>(x)] += v;minv[<span class="built_in">rs</span>(x)] += v;</span><br><span class="line">			v = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx &gt; <span class="number">1</span>)<span class="built_in">pushdown</span>(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			addv[x] += v;</span><br><span class="line">			minv[x] += v;maxv[x] += v;</span><br><span class="line">			sumv[x] += v*(rx-lx);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">add</span>(l,r,v,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="built_in">add</span>(l,r,v,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="built_in">pushup</span>(x);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll v)</span></span>&#123;</span><br><span class="line">		r++;</span><br><span class="line">		<span class="built_in">add</span>(l,r,v,<span class="number">0</span>,<span class="number">0</span>,siz);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">sqr</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx &gt; <span class="number">1</span>)<span class="built_in">pushdown</span>(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r <span class="keyword">and</span> maxv[x] == minv[x])&#123;</span><br><span class="line">			setv[x] = <span class="built_in">sqrt</span>(maxv[x]);</span><br><span class="line">			addv[x] = <span class="number">0</span>;</span><br><span class="line">			maxv[x] = minv[x] = setv[x];</span><br><span class="line">			sumv[x] = setv[x]*(rx - lx);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">sqr</span>(l,r,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="built_in">sqr</span>(l,r,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="built_in">pushup</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">sqr</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		r++;</span><br><span class="line">		<span class="built_in">sqr</span>(l,r,<span class="number">0</span>,<span class="number">0</span>,siz);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx &gt; <span class="number">1</span>)<span class="built_in">pushdown</span>(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)<span class="keyword">return</span> sumv[x];</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		ll s1 = <span class="built_in">sum</span>(l,r,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		ll s2 = <span class="built_in">sum</span>(l,r,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="built_in">pushup</span>(x);</span><br><span class="line">		<span class="keyword">return</span> s1+s2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		r++;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">sum</span>(l,r,<span class="number">0</span>,<span class="number">0</span>,siz);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp; in,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(lx &lt; (<span class="keyword">int</span>)in.<span class="built_in">size</span>())&#123;</span><br><span class="line">				minv[x] = maxv[x] = sumv[x] = in[lx];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">build</span>(in,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="built_in">build</span>(in,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="built_in">pushup</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp; in)</span></span>&#123;</span><br><span class="line">		<span class="built_in">build</span>(in,<span class="number">0</span>,<span class="number">0</span>,siz);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;seg;</span><br></pre></td></tr></table></figure>
<h3 id="part2-区间历史最值维护">Part2: 区间历史最值维护</h3>
<h2 id="一些例题">一些例题</h2>
<h3 id="a">A</h3>
<p>区间赋值为0或1,求区间内1的子段个数</p>
<p>比如<code>0 1 0 1 1 0 0 1 1 1</code>答案为3</p>
<p>解法:</p>
<p>维护三个数组，<span class="math inline">\(num[x]\)</span>表示<span class="math inline">\(x\)</span>的线段个数</p>
<p><span class="math inline">\(left[x]\)</span>表示<span class="math inline">\(x\)</span>的左端点是否为1,<span class="math inline">\(right[]\)</span>同理.</p>
<p>小细节:pushup时当<code>right[ls(x)] == 1 and left[rs(x)] == 1</code>时,<code>num[x]--</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segtree</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	vector&lt;ll&gt;sumv,setv,left,right,num;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> NO_OPT = INT_MAX;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(size &lt; n)size *= <span class="number">2</span>;</span><br><span class="line">		sumv.<span class="built_in">assign</span>(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">		setv.<span class="built_in">assign</span>(size*<span class="number">2</span>,NO_OPT);</span><br><span class="line">		left.<span class="built_in">assign</span>(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">		right.<span class="built_in">assign</span>(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">		num.<span class="built_in">assign</span>(size*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(ll &amp; a,ll b)</span></span>&#123;</span><br><span class="line">		a = (b == NO_OPT?a:b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> len = rx - lx;</span><br><span class="line">		<span class="keyword">if</span>(len == <span class="number">1</span> <span class="keyword">or</span> setv[x] == NO_OPT)<span class="keyword">return</span>;</span><br><span class="line">		len /= <span class="number">2</span>;</span><br><span class="line">		<span class="built_in">apply</span>(setv[<span class="built_in">ls</span>(x)],setv[x]);</span><br><span class="line">		<span class="built_in">apply</span>(sumv[<span class="built_in">ls</span>(x)],setv[x]*len);</span><br><span class="line">		<span class="built_in">apply</span>(setv[<span class="built_in">rs</span>(x)],setv[x]);</span><br><span class="line">		<span class="built_in">apply</span>(sumv[<span class="built_in">rs</span>(x)],setv[x]*len);</span><br><span class="line">		<span class="keyword">if</span>(setv[x])&#123;</span><br><span class="line">			num[<span class="built_in">ls</span>(x)] = num[<span class="built_in">rs</span>(x)] = <span class="number">1</span>;</span><br><span class="line">			left[<span class="built_in">ls</span>(x)] = left[<span class="built_in">rs</span>(x)] = right[<span class="built_in">ls</span>(x)] = right[<span class="built_in">rs</span>(x)] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			num[<span class="built_in">ls</span>(x)] = num[<span class="built_in">rs</span>(x)] = <span class="number">0</span>;</span><br><span class="line">			left[<span class="built_in">ls</span>(x)] = left[<span class="built_in">rs</span>(x)] = right[<span class="built_in">ls</span>(x)] = right[<span class="built_in">rs</span>(x)] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		setv[x] = NO_OPT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		sumv[x] = sumv[<span class="built_in">ls</span>(x)] + sumv[<span class="built_in">rs</span>(x)];</span><br><span class="line">		left[x] = left[<span class="built_in">ls</span>(x)];</span><br><span class="line">		right[x] = right[<span class="built_in">rs</span>(x)];</span><br><span class="line">		num[x] = num[<span class="built_in">ls</span>(x)] + num[<span class="built_in">rs</span>(x)] - ((right[<span class="built_in">ls</span>(x)] <span class="keyword">and</span> left[<span class="built_in">rs</span>(x)])?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">		<span class="built_in">pushdown</span>(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			setv[x] = v;</span><br><span class="line">			sumv[x] = v*(rx - lx);</span><br><span class="line">			<span class="keyword">if</span>(v)&#123;</span><br><span class="line">				num[x] = <span class="number">1</span>;</span><br><span class="line">				left[x] = right[x] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				num[x] = <span class="number">0</span>;</span><br><span class="line">				left[x] = right[x] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">Set</span>(l,r,v,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="built_in">Set</span>(l,r,v,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="built_in">pushup</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll v)</span></span>&#123;</span><br><span class="line">		<span class="built_in">Set</span>(l,r,v,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">pushdown</span>(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			<span class="keyword">return</span> sumv[x];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		ll s1 = <span class="built_in">sum</span>(l,r,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		ll s2 = <span class="built_in">sum</span>(l,r,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="keyword">return</span> s1+s2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">sum</span>(l,r,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="b">B</h3>
<p><a href="https://codeforces.com/edu/course/2/lesson/5/4/practice/contest/280801/problem/E">IOI2014-Walls</a></p>
<p>长度为<span class="math inline">\(n\)</span>的序列初始为空,维护两种操作:</p>
<ol type="1">
<li>Add(L,R,v): 将<span class="math inline">\([L,R]\)</span>中小于<span class="math inline">\(v\)</span>的值改变为<span class="math inline">\(v\)</span></li>
<li>Remove(L,R,v):将<span class="math inline">\([L,R]\)</span>中大于<span class="math inline">\(v\)</span>的值改变为<span class="math inline">\(v\)</span></li>
</ol>
<p>给出<span class="math inline">\(m\)</span>个操作,输出操作全部完成后的序列.</p>
<p><span class="math inline">\(1 \leq n \leq 2\cdot10^6,1 \leq m \leq 5\cdot10^5\)</span></p>
<p>对每个节点维护<span class="math inline">\(upv[]\)</span>和<span class="math inline">\(lowv[]\)</span>,表示该节点值的上限和下限.查询时对每个点做一次单点查询,答案为<span class="math inline">\(lowv[x]\)</span>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segtree</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;upv,lowv;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(size &lt; n)size *= <span class="number">2</span>;</span><br><span class="line">		upv.<span class="built_in">assign</span>(size*<span class="number">2</span>,NO_OPT);</span><br><span class="line">		lowv.<span class="built_in">assign</span>(size*<span class="number">2</span>,NO_OPT);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(upv[x] != NO_OPT)&#123;</span><br><span class="line">			upv[<span class="built_in">ls</span>(x)] = <span class="built_in">min</span>(upv[x],upv[<span class="built_in">ls</span>(x)]);</span><br><span class="line">			upv[<span class="built_in">rs</span>(x)] = <span class="built_in">min</span>(upv[x],upv[<span class="built_in">rs</span>(x)]);</span><br><span class="line">			<span class="keyword">if</span>(lowv[<span class="built_in">ls</span>(x)] != NO_OPT <span class="keyword">and</span> lowv[<span class="built_in">ls</span>(x)] &gt; upv[x])lowv[<span class="built_in">ls</span>(x)] = upv[x];</span><br><span class="line">			<span class="keyword">if</span>(lowv[<span class="built_in">rs</span>(x)] != NO_OPT <span class="keyword">and</span> lowv[<span class="built_in">rs</span>(x)] &gt; upv[x])lowv[<span class="built_in">rs</span>(x)] = upv[x];</span><br><span class="line">			upv[x] = NO_OPT;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(lowv[x] != NO_OPT)&#123;</span><br><span class="line">			<span class="keyword">if</span>(lowv[<span class="built_in">ls</span>(x)] != NO_OPT)lowv[<span class="built_in">ls</span>(x)] = <span class="built_in">max</span>(lowv[<span class="built_in">ls</span>(x)],lowv[x]);</span><br><span class="line">			<span class="keyword">else</span> lowv[<span class="built_in">ls</span>(x)] = lowv[x];</span><br><span class="line">			<span class="keyword">if</span>(lowv[<span class="built_in">rs</span>(x)] != NO_OPT)lowv[<span class="built_in">rs</span>(x)] = <span class="built_in">max</span>(lowv[<span class="built_in">rs</span>(x)],lowv[x]);</span><br><span class="line">			<span class="keyword">else</span> lowv[<span class="built_in">rs</span>(x)] = lowv[x];</span><br><span class="line">			<span class="keyword">if</span>(upv[<span class="built_in">ls</span>(x)] != NO_OPT <span class="keyword">and</span> upv[<span class="built_in">ls</span>(x)] &lt; lowv[x])upv[<span class="built_in">ls</span>(x)] = lowv[x];</span><br><span class="line">			<span class="keyword">if</span>(upv[<span class="built_in">rs</span>(x)] != NO_OPT <span class="keyword">and</span> upv[<span class="built_in">rs</span>(x)] &lt; lowv[x])upv[<span class="built_in">rs</span>(x)] = lowv[x];</span><br><span class="line">			lowv[x] = NO_OPT;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">		<span class="built_in">pushdown</span>(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			upv[x] = <span class="built_in">min</span>(upv[x],v);</span><br><span class="line">			<span class="keyword">if</span>(lowv[x] != NO_OPT <span class="keyword">and</span> lowv[x] &gt; v)lowv[x] = v;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">up</span>(l,r,v,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="built_in">up</span>(l,r,v,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		<span class="built_in">up</span>(l,r,v,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">low</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">		<span class="built_in">pushdown</span>(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			<span class="keyword">if</span>(lowv[x] == NO_OPT <span class="keyword">or</span> lowv[x] &lt; v)lowv[x] = v;</span><br><span class="line">			<span class="keyword">if</span>(upv[x] != NO_OPT <span class="keyword">and</span> upv[x] &gt; v)upv[x] = v;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">low</span>(l,r,v,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="built_in">low</span>(l,r,v,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">low</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		<span class="built_in">low</span>(l,r,v,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(idx &gt;= rx)<span class="keyword">return</span> NO_OPT;</span><br><span class="line">		<span class="built_in">pushdown</span>(x,lx,rx);</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)<span class="keyword">return</span> lowv[x];</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(idx &lt; m)<span class="keyword">return</span> <span class="built_in">get</span>(idx,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">get</span>(idx,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">get</span>(idx,<span class="number">0</span>,<span class="number">0</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	segtree seg;</span><br><span class="line">	seg.<span class="built_in">init</span>(n+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="keyword">int</span> opt,l,r,v;</span><br><span class="line">		r++;</span><br><span class="line">		cin &gt;&gt; opt &gt;&gt; l &gt;&gt; r &gt;&gt; v;</span><br><span class="line">		r++;</span><br><span class="line">		<span class="keyword">if</span>(opt == <span class="number">1</span>)seg.<span class="built_in">low</span>(l,r,v);</span><br><span class="line">		<span class="keyword">else</span> seg.<span class="built_in">up</span>(l,r,v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> ans = seg.<span class="built_in">get</span>(i);</span><br><span class="line">		cout &lt;&lt; (ans == NO_OPT?<span class="number">0</span>:ans) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="rope">Rope</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext/rope&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_cxx;</span><br></pre></td></tr></table></figure>
<p>可持久化数组:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext/rope&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_cxx;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span>;</span></span><br><span class="line">rope&lt;<span class="keyword">int</span>&gt; rp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	rp[<span class="number">0</span>].<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		rp[<span class="number">0</span>].<span class="built_in">push_back</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> ver,opt,idx,v;</span><br><span class="line">		cin &gt;&gt; ver &gt;&gt; opt &gt;&gt; idx;</span><br><span class="line">		rp[i] = rp[ver];</span><br><span class="line">		<span class="keyword">if</span>(opt == <span class="number">1</span>)&#123;</span><br><span class="line">			cin &gt;&gt; v;</span><br><span class="line">			rp[i].<span class="built_in">replace</span>(idx,<span class="number">1</span>,v);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">int</span> ans = rp[i][idx];</span><br><span class="line">			cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>push_back():</strong> This function is used to input a character at the end of the rope. <strong><em>Time Complexity:</em></strong> O(log N).</li>
<li><strong>pop_back():</strong> Introduced from C++11(for strings), this function is used to delete the last character from the rope. <strong><em>Time Complexity:</em></strong> O(log N).</li>
<li><strong>insert(int x, crope r1):</strong> Inserts the contents of <strong>r1</strong> before the <strong>xth</strong> element. <em><strong>Time Complexity:</strong> For <strong>Best Case:</strong></em> O(log N) and For <strong>Worst Case:</strong> O(N).</li>
<li><strong>erase(int x, int l):</strong> Erases l elements, starting with the <strong>xth</strong> element. <strong><em>Time Complexity:</em></strong> O(log N).</li>
<li><strong>substr(int x, int l):</strong> Returns a new rope whose elements are the <strong>l</strong> characters starting at the position <strong>x</strong>. <strong><em>Time Complexity:</em></strong> O(log N).</li>
<li><strong>replace(int x, int l, crope r1):</strong> Replaces the <strong>l</strong> elements beginning with the <strong>xth</strong> element with the elements in <strong>r1</strong>. <strong><em>Time Complexity:</em></strong> O(log N).</li>
<li><strong>concatenate(+):</strong> concatenate two ropes using the ‘+’ symbol. <strong><em>Time Complexity:</em></strong> O(1).</li>
</ul>
<h1 id="平衡树">平衡树</h1>
<h2 id="treap">Treap</h2>
<hr />
<p>平衡树1-Treap</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> cnt,size,v,r;</span><br><span class="line">	Node * ch[<span class="number">2</span>];</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(x == v)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">return</span> x&lt;v?<span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Node</span>()&#123;<span class="comment">//null,plz use newnode(x);</span></span><br><span class="line">		ch[<span class="number">0</span>] = ch[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">		cnt = size = v = r = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">()</span></span>&#123;</span><br><span class="line">		size = ch[<span class="number">0</span>]-&gt;size +ch[<span class="number">1</span>]-&gt;size + cnt;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;;</span><br><span class="line">Node * null = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line"><span class="function">Node * <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	Node * tmp = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">	tmp-&gt;ch[<span class="number">0</span>] = tmp-&gt;ch[<span class="number">1</span>] = null;</span><br><span class="line">	tmp-&gt;v = x;</span><br><span class="line">	tmp-&gt;r = <span class="built_in">rand</span>();</span><br><span class="line">	tmp-&gt;size = tmp-&gt;cnt = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node * <span class="title">find</span><span class="params">(Node * o,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(o != null)&#123;</span><br><span class="line">		<span class="keyword">int</span> d = o-&gt;<span class="built_in">cmp</span>(x);</span><br><span class="line">		<span class="keyword">if</span>(d == <span class="number">-1</span>)<span class="keyword">return</span> o;</span><br><span class="line">		<span class="keyword">else</span> o = o-&gt;ch[d];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> null;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(Node *&amp; o,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">	Node * k = o-&gt;ch[d^<span class="number">1</span>];</span><br><span class="line">	o-&gt;ch[d^<span class="number">1</span>] = k-&gt;ch[d];</span><br><span class="line">	k-&gt;ch[d] = o;</span><br><span class="line">	o-&gt;<span class="built_in">maintain</span>();k-&gt;<span class="built_in">maintain</span>();</span><br><span class="line">	o = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node *&amp; o,<span class="keyword">int</span> x,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(o == null)o = <span class="built_in">newnode</span>(x);</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> d = o-&gt;<span class="built_in">cmp</span>(x);</span><br><span class="line">		<span class="keyword">if</span>(d == <span class="number">-1</span>)o-&gt;cnt+=c;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">insert</span>(o-&gt;ch[d],x,c);</span><br><span class="line">			<span class="keyword">if</span>(o-&gt;ch[d]-&gt;r &gt; o-&gt;r)<span class="built_in">rotate</span>(o,d^<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	o-&gt;<span class="built_in">maintain</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node *&amp; o,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">find</span>(o,x) == null)<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> d = o-&gt;<span class="built_in">cmp</span>(x);</span><br><span class="line">	<span class="keyword">if</span>(d == <span class="number">-1</span>)&#123;</span><br><span class="line">		Node * u = o;</span><br><span class="line">		<span class="keyword">if</span>(o-&gt;cnt &gt; <span class="number">1</span>)&#123;</span><br><span class="line">			o-&gt;cnt--;</span><br><span class="line">			o-&gt;size--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(o-&gt;ch[<span class="number">0</span>] != null <span class="keyword">and</span> o-&gt;ch[<span class="number">1</span>] != null)&#123;</span><br><span class="line">			<span class="keyword">int</span> d2 = o-&gt;ch[<span class="number">0</span>]-&gt;r &gt; o-&gt;ch[<span class="number">1</span>]-&gt;r ?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">rotate</span>(o,d2);</span><br><span class="line">			<span class="built_in">remove</span>(o-&gt;ch[d2],x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(o-&gt;ch[<span class="number">0</span>] == null)o = o-&gt;ch[<span class="number">1</span>];<span class="keyword">else</span> o = o-&gt;ch[<span class="number">0</span>];</span><br><span class="line">			<span class="keyword">delete</span> u;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">remove</span>(o-&gt;ch[d],x);</span><br><span class="line">	<span class="keyword">if</span>(o != null)o-&gt;<span class="built_in">maintain</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(Node * o,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="comment">//min</span></span><br><span class="line">	<span class="keyword">int</span> k1 = k;</span><br><span class="line">	<span class="keyword">while</span>(o != null)&#123;</span><br><span class="line">		<span class="keyword">int</span> s = o-&gt;ch[<span class="number">0</span>]-&gt;size;</span><br><span class="line">		<span class="keyword">if</span>(k1 &gt; s <span class="keyword">and</span> k1 &lt;= s + o-&gt;cnt)<span class="keyword">return</span> o-&gt;v;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(k1 &lt;= s) o = o-&gt;ch[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			k1 = k1 - s - o-&gt;cnt;</span><br><span class="line">			o = o-&gt;ch[<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Rank</span><span class="params">(Node * o,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//比x小的数字个数。若不存在x则返回0</span></span><br><span class="line">	<span class="keyword">int</span> ans_ = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">find</span>(o,x) == null)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(o != null)&#123;</span><br><span class="line">		<span class="keyword">if</span>(o-&gt;v == x)&#123;</span><br><span class="line">			ans_ += <span class="number">1</span> + o-&gt;ch[<span class="number">0</span>]-&gt;size;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(o-&gt;v &gt; x)o = o-&gt;ch[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			ans_ += o-&gt;ch[<span class="number">0</span>]-&gt;size + o-&gt;cnt;</span><br><span class="line">			o = o-&gt;ch[<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(Node * o,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans_ = -INF;</span><br><span class="line">	<span class="keyword">while</span>(o != null)&#123;</span><br><span class="line">		<span class="keyword">if</span>(ans_ &lt;= o-&gt;v <span class="keyword">and</span> o-&gt;v &lt; x)&#123;</span><br><span class="line">			ans_ = o-&gt;v;</span><br><span class="line">			o = o-&gt;ch[<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> o = o-&gt;ch[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">upper_bound</span><span class="params">(Node * o,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans_ = INF;</span><br><span class="line">	<span class="keyword">while</span>(o != null)&#123;</span><br><span class="line">		<span class="keyword">if</span>(x &lt; o-&gt;v <span class="keyword">and</span> o-&gt;v &lt; ans_)&#123;</span><br><span class="line">			ans_ = o-&gt;v;</span><br><span class="line">			o = o-&gt;ch[<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> o = o-&gt;ch[<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deltree</span><span class="params">(Node *&amp; o)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(o-&gt;ch[<span class="number">0</span>] != null)<span class="built_in">deltree</span>(o-&gt;ch[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">if</span>(o-&gt;ch[<span class="number">1</span>] != null)<span class="built_in">deltree</span>(o-&gt;ch[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">delete</span> o;</span><br><span class="line">	o = null;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(Node *&amp; src,Node *&amp; dest)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(src-&gt;ch[<span class="number">0</span>] != null)<span class="built_in">merge</span>(src-&gt;ch[<span class="number">0</span>],dest);</span><br><span class="line">	<span class="keyword">if</span>(src-&gt;ch[<span class="number">1</span>] != null)<span class="built_in">merge</span>(src-&gt;ch[<span class="number">1</span>],dest);</span><br><span class="line">	<span class="built_in">insert</span>(dest,src-&gt;v,src-&gt;cnt);</span><br><span class="line">	<span class="keyword">delete</span> src;</span><br><span class="line">	src = null;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="字符串">字符串</h1>
<h2 id="读入">读入</h2>
<h3 id="读入一行">读入一行</h3>
<h4 id="getline">getline</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="built_in">getline</span>(cin,s);</span><br></pre></td></tr></table></figure>
<h3 id="sstream">sstream</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s;</span><br><span class="line">stringstream ss;</span><br><span class="line"><span class="keyword">int</span> a, b, c;</span><br><span class="line"><span class="built_in">getline</span>(cin, s);</span><br><span class="line">ss.<span class="built_in">clear</span>();</span><br><span class="line">ss.<span class="built_in">str</span>(s);</span><br><span class="line">ss &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br></pre></td></tr></table></figure>
<h2 id="kmp">KMP</h2>
<p><span class="math inline">\(Next[i]\)</span>表示自<span class="math inline">\(i\)</span>结束(不包括<span class="math inline">\(i\)</span>)的子串中前后缀相同的长度</p>
<p>最小循环节长度: <span class="math inline">\(i - Next[i]\)</span></p>
<p>例如：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">i</th>
<th style="text-align: center;">0</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">3</th>
<th style="text-align: center;">4</th>
<th style="text-align: center;">5</th>
<th style="text-align: center;">6</th>
<th style="text-align: center;">7</th>
<th style="text-align: center;">8</th>
<th style="text-align: center;">9</th>
<th style="text-align: center;">10</th>
<th style="text-align: center;">11</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(s[i]\)</span></td>
<td style="text-align: center;">A</td>
<td style="text-align: center;">B</td>
<td style="text-align: center;">R</td>
<td style="text-align: center;">A</td>
<td style="text-align: center;">C</td>
<td style="text-align: center;">A</td>
<td style="text-align: center;">D</td>
<td style="text-align: center;">A</td>
<td style="text-align: center;">B</td>
<td style="text-align: center;">R</td>
<td style="text-align: center;">A</td>
<td style="text-align: center;">\</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(Next[i]\)</span></td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">4</td>
</tr>
</tbody>
</table>
<p>可以看出<span class="math inline">\([i - Next[i],i - 1]\)</span>这一段的前后缀是相同的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> Next[<span class="number">1000010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFail</span><span class="params">(string P)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p_size = P.<span class="built_in">size</span>();</span><br><span class="line">	Next[<span class="number">0</span>] = Next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; p_size;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> j = Next[i];</span><br><span class="line">		<span class="keyword">while</span>(j <span class="keyword">and</span> P[i] != P[j])j = Next[j];</span><br><span class="line">		Next[i+<span class="number">1</span>] = (P[j] == P[i]?j+<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KMP</span><span class="params">(string T,string P)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t_size = T.<span class="built_in">size</span>(),p_size = P.<span class="built_in">size</span>();</span><br><span class="line">	<span class="built_in">getFail</span>(P);</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; t_size;i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(j <span class="keyword">and</span> P[j] != T[i])j = Next[j];</span><br><span class="line">		<span class="keyword">if</span>(P[j] == T[i])j++;</span><br><span class="line">		<span class="keyword">if</span>(j == p_size)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i - p_size + <span class="number">2</span>);</span><br><span class="line">			j = Next[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="manacher">Manacher</h2>
<p>最长连续回文子串</p>
<p><span class="math inline">\(len[i] - 1\)</span>表示以i为中心的最长回文串一半的长度(不包括中心)</p>
<p>返回最长连续回文子串的长度</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Manacher</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> len[maxn];</span><br><span class="line">	string raw = <span class="string">&quot;~&quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> ic = <span class="number">0</span>,im = <span class="number">0</span>,ir = <span class="number">0</span>,ans = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(string s = <span class="string">&quot;&quot;</span>)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">			raw += <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">			raw += s[i];</span><br><span class="line">		&#125;</span><br><span class="line">		raw += <span class="string">&quot;|!&quot;</span>;</span><br><span class="line"><span class="comment">//		cout &lt;&lt; raw &lt;&lt; endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> l = raw.<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; l;i++)&#123;</span><br><span class="line">			len[i] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(i &lt; ir)&#123;</span><br><span class="line">				im = <span class="number">2</span>*ic-i;</span><br><span class="line">				len[i] = <span class="built_in">min</span>(ir-i,len[im]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span>(raw[i-len[i]] == raw[i+len[i]])len[i]++;</span><br><span class="line">			<span class="keyword">if</span>(i + len[i] &gt; ir)ic = i,ir = i + len[i];</span><br><span class="line">			<span class="keyword">if</span>(len[i] &gt; len[ic])ic = i;</span><br><span class="line">			ans = <span class="built_in">max</span>(len[i],ans);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">char</span> x:raw)cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> ans<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;yay;</span><br></pre></td></tr></table></figure>
<h2 id="字符串hash-滚动hash">字符串hash (滚动hash)</h2>
<p>​ <span class="math inline">\(H[x]\)</span>为hash值,<span class="math inline">\(xp[d]\)</span>为<span class="math inline">\(x^d\)</span>,<span class="math inline">\(x\)</span>为底数(随便取一个就行),<span class="math inline">\(s\)</span>为字符串.用ull自然溢出来-1s</p>
<p>​ 递推式:<span class="math inline">\(H[i] = H[i-1] \cdot x + (s[i] - &#39;a&#39;)\)</span></p>
<p>​ 查询以<span class="math inline">\(i\)</span>开始长度为<span class="math inline">\(L\)</span>的字符串的hash:$Hash(i,L) = H[i + L - 1] - (H[i-1] xp[L]) $</p>
<p><strong>模板里的get和CompString默认下标从0开始</strong></p>
<p>比较大小和求LCP的复杂度是<span class="math inline">\(O(log|s|)\)</span>的，但一般比后缀数组快.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p1 = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p2 = <span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> x1 = <span class="number">123</span>,x2 = <span class="number">233</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Hash</span>&#123;</span></span><br><span class="line">    vector&lt;ll&gt;xp1,xp2,H1,H2;</span><br><span class="line">    string s;<span class="comment">//非必须</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(string tar)</span></span>&#123;</span><br><span class="line">		s = tar;</span><br><span class="line">		n = s.<span class="built_in">size</span>();</span><br><span class="line">		xp1.<span class="built_in">assign</span>(n + <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">		xp2.<span class="built_in">assign</span>(n + <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">		H1.<span class="built_in">assign</span>(n + <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">		H2.<span class="built_in">assign</span>(n + <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">		xp1[<span class="number">0</span>] = xp2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">			xp1[i] = xp1[i<span class="number">-1</span>] * x1 % p1;</span><br><span class="line">			xp2[i] = xp2[i<span class="number">-1</span>] * x2 % p2;</span><br><span class="line">			H1[i] = (H1[i<span class="number">-1</span>]*x1 % p1 + s[i<span class="number">-1</span>] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>) % p1;</span><br><span class="line">			H2[i] = (H2[i<span class="number">-1</span>]*x2 % p2 + s[i<span class="number">-1</span>] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>) % p2;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Hash</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Hash</span>(string &amp; tar)&#123;</span><br><span class="line">		<span class="built_in">init</span>(tar);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//Hash(i,L)</span></span><br><span class="line">	<span class="function">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; <span class="title">get</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> L)</span></span>&#123;</span><br><span class="line">		x++;</span><br><span class="line">		<span class="keyword">if</span>(x + L &gt; n + <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;<span class="comment">//不要用Rand(), 有效率问题. 记得特判-1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			(H1[x+L<span class="number">-1</span>] - H1[x<span class="number">-1</span>]*xp1[L] % p1 + p1) % p1,</span><br><span class="line">			(H2[x+L<span class="number">-1</span>] - H2[x<span class="number">-1</span>]*xp2[L] % p2 + p2) % p2</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">LCP</span><span class="params">(<span class="keyword">int</span> s1,<span class="keyword">int</span> s2)</span></span>&#123;<span class="comment">//求s[s1...]和s[s2...]的最长公共前缀</span></span><br><span class="line">		<span class="keyword">int</span> L = <span class="number">1</span>,R = n,M;</span><br><span class="line">		<span class="keyword">while</span>(L &lt; R)&#123;</span><br><span class="line">			M = (L+R)/<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">auto</span> it1 = <span class="built_in">get</span>(s1,M);</span><br><span class="line">			<span class="keyword">auto</span> it2 = <span class="built_in">get</span>(s2,M);</span><br><span class="line">			<span class="keyword">if</span>(it1.first != <span class="number">-1</span> <span class="keyword">and</span> it1 == it2)L = M+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> R = M;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> L - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">CompString</span><span class="params">(<span class="keyword">int</span> s1,<span class="keyword">int</span> len1,<span class="keyword">int</span> s2,<span class="keyword">int</span> len2)</span></span>&#123;</span><br><span class="line">		<span class="comment">//比较s[s1..],长度为len1和s[s2..],长度为len2的子串大小.</span></span><br><span class="line">		<span class="comment">//前者大于后者:1 相等:0 小于: -1</span></span><br><span class="line">		<span class="keyword">int</span> tlcp = (s1 == s2?<span class="built_in">min</span>(len1,len2):<span class="built_in">LCP</span>(s1,s2));</span><br><span class="line">		<span class="keyword">if</span>(tlcp &gt;= <span class="built_in">min</span>(len1,len2))&#123;</span><br><span class="line">			<span class="keyword">return</span> len1 &lt; len2?<span class="number">-1</span>:(len1 == len2?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> s[s1 + tlcp] &lt; s[s2 + tlcp]?<span class="number">-1</span>:(s[s1 + tlcp] == s[s2 + tlcp]?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;hsh;</span><br></pre></td></tr></table></figure>
<h4 id="hash判断回文">hash判断回文</h4>
<p>hsh为原串的hash, hshr为反串的hash.</p>
<p>判断<span class="math inline">\(s[l...r]\)</span>是否为回文. <span class="math inline">\(n = |s|\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pali</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = (r - l + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(len &lt;= <span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">auto</span> it1 = hsh.<span class="built_in">get</span>(l,len / <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">auto</span> it2 = hshr.<span class="built_in">get</span>(n - l - len,len / <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> (it1.fit1 == it2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后缀数组">后缀数组</h2>
<p><strong>一晚上速成的垃圾内容 需要细致的重构</strong></p>
<p>注意字符串下标均从0开始</p>
<p><span class="math inline">\(sa\)</span>为后缀数组, <code>sa[i]</code>表示将所有后缀排序后第<span class="math inline">\(i\)</span>小的后缀的编号</p>
<p><code>sa[]</code>的示意图:(p为sa, 下标从0开始)</p>
<p><code>lcp[]</code>的下标从1开始</p>
<p><img src="E:\Github\hexo\source\_posts\image-20211017100809132.png" alt="image-20211017100809132" style="zoom:33%;" /></p>
<p><span class="math inline">\(lcp[i]\)</span>为<span class="math inline">\(s[sa[i]...]\)</span>和<span class="math inline">\(s[sa[i-1]...]\)</span>的最长公共前缀长度(等同于lrj蓝书上的<span class="math inline">\(height\)</span></p>
<p><span class="math inline">\(c\)</span>为等价类,迭代结束后<span class="math inline">\(c\)</span>等同于<span class="math inline">\(rank\)</span>,<span class="math inline">\(c[i]\)</span>代表第<span class="math inline">\(i\)</span>个后缀在<span class="math inline">\(sa\)</span>中的下标</p>
<p>调用时通过<span class="math inline">\(SA(string)\)</span>初始化,<span class="math inline">\(cal()\)</span>计算sa,<span class="math inline">\(getlcp\)</span>计算lcp.</p>
<p><span class="math inline">\(LCP(i,j)\)</span>返回后缀i和j的LCP.</p>
<p>注意LCP和ST用的是数组而不是vector</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> a,b;</span><br><span class="line">	<span class="built_in">Node</span>(<span class="keyword">int</span> a = <span class="number">0</span>,<span class="keyword">int</span> b = <span class="number">0</span>):<span class="built_in">a</span>(a),<span class="built_in">b</span>(b)&#123;&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp; x)&#123;</span><br><span class="line">		<span class="keyword">return</span> a == x.a?b &lt; x.b:a &lt; x.a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SA</span>&#123;</span></span><br><span class="line">	string s;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;sa,c;</span><br><span class="line">	<span class="keyword">int</span> lcp[maxn],ST[maxn][<span class="number">20</span>];</span><br><span class="line">	<span class="built_in">SA</span>(string s = <span class="string">&quot;&quot;</span>):<span class="built_in">s</span>(s)&#123;</span><br><span class="line">		s += <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">		n = s.<span class="built_in">size</span>();</span><br><span class="line">		sa.<span class="built_in">assign</span>(n,<span class="number">0</span>);</span><br><span class="line">		c.<span class="built_in">assign</span>(n,<span class="number">0</span>); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">count_sort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp; sa,vector&lt;<span class="keyword">int</span>&gt; &amp; c)</span></span>&#123;</span><br><span class="line">		vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">pos</span>(n),<span class="built_in">cnt</span>(n),<span class="built_in">sa_new</span>(n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x:c)cnt[x]++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)pos[i] = pos[i<span class="number">-1</span>] + cnt[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x:sa)&#123;</span><br><span class="line">			<span class="keyword">int</span> d = c[x];</span><br><span class="line">			sa_new[pos[d]] = x;</span><br><span class="line">			pos[d]++;</span><br><span class="line">		&#125;</span><br><span class="line">		sa = sa_new;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//init</span></span><br><span class="line">		&#123;</span><br><span class="line">			vector&lt;Node&gt;<span class="built_in">A</span>(n);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)A[i] = <span class="built_in">Node</span>(s[i],i);</span><br><span class="line">			<span class="built_in">sort</span>(A.<span class="built_in">begin</span>(),A.<span class="built_in">end</span>());</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)sa[i] = A[i].b;</span><br><span class="line">			c[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">				c[sa[i]] = c[sa[i<span class="number">-1</span>]] + (A[i].a != A[i<span class="number">-1</span>].a);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;k) &lt; n)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)sa[i] = (sa[i] - (<span class="number">1</span>&lt;&lt;k) + n)%n;</span><br><span class="line">			<span class="built_in">count_sort</span>(sa,c);</span><br><span class="line">			vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">c_new</span>(n);</span><br><span class="line">			c_new[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">				pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;now = &#123;c[sa[i]],c[(sa[i] + (<span class="number">1</span>&lt;&lt;k)) % n]&#125;;</span><br><span class="line">				pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;prev = &#123;c[sa[i<span class="number">-1</span>]],c[(sa[i<span class="number">-1</span>] + (<span class="number">1</span>&lt;&lt;k)) % n]&#125;;</span><br><span class="line">				c_new[sa[i]] = c_new[sa[i<span class="number">-1</span>]] + (now != prev);</span><br><span class="line">			&#125;</span><br><span class="line">			k++;</span><br><span class="line">			c = c_new;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ST_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)ST[i][<span class="number">0</span>] = lcp[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j) &lt;= n;j++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;j) <span class="number">-1</span> &lt;= n;i++)</span><br><span class="line">				ST[i][j] = <span class="built_in">min</span>(ST[i][j - <span class="number">1</span>],ST[i + (<span class="number">1</span>&lt;&lt;(j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">LCP</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">		L = c[L],R = c[R];</span><br><span class="line">		<span class="keyword">if</span>(L &gt; R)<span class="built_in">swap</span>(L,R);</span><br><span class="line">		L++;</span><br><span class="line">		<span class="keyword">int</span> k = <span class="built_in">log2</span>(R - L + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">min</span>(ST[L][k],ST[R - (<span class="number">1</span>&lt;&lt;k) + <span class="number">1</span>][k]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getlcp</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> j = sa[c[i] - <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">while</span>(s[i+k] == s[j+k])k++;</span><br><span class="line">			lcp[c[i]] = k;</span><br><span class="line">			<span class="keyword">if</span>(k)k--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">ST_init</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,sa[i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,lcp[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(string x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> k = x.<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">int</span> L = <span class="number">0</span>,R = n,M;</span><br><span class="line">		<span class="keyword">while</span>(L &lt; R)&#123;</span><br><span class="line">			M = (L+R)/<span class="number">2</span>;</span><br><span class="line">			string u = s.<span class="built_in">substr</span>(sa[M],k);</span><br><span class="line">			<span class="keyword">if</span>(u &gt;= x)R = M;</span><br><span class="line">			<span class="keyword">else</span> L = M+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> L;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">upper_bound</span><span class="params">(string x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> k = x.<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">int</span> L = <span class="number">0</span>,R = n,M;</span><br><span class="line">		<span class="keyword">while</span>(L &lt; R)&#123;</span><br><span class="line">			M = (L+R)/<span class="number">2</span>;</span><br><span class="line">			string u = s.<span class="built_in">substr</span>(sa[M],k);</span><br><span class="line">			<span class="keyword">if</span>(u &lt;= x)L = M+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> R = M;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> L;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(string x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">upper_bound</span>(x) - <span class="built_in">lower_bound</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>附上个不用vector的,留着给POJ这种0202年还不兹磁C++11的OJ用(注意下标依旧从0开始)</p>
<p><strong>如果T了的话把pair改成自己写的结构体.pair排序很慢</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sa[maxn],pos[maxn],cnt[maxn],sa_new[maxn],c[maxn],c_new[maxn];</span><br><span class="line">pair&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;A[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SA</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//init</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)A[i] = &#123;s[i],i&#125;;</span><br><span class="line">		<span class="built_in">sort</span>(A,A+n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)sa[i] = A[i].second;</span><br><span class="line">		c[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">			c[sa[i]] = c[sa[i<span class="number">-1</span>]] + (A[i].first != A[i<span class="number">-1</span>].first);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;k) &lt; n)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)sa[i] = (sa[i] - (<span class="number">1</span>&lt;&lt;k) + n)%n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)cnt[i] = pos[i] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)cnt[c[i]]++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)pos[i] = pos[i<span class="number">-1</span>] + cnt[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)sa_new[pos[c[sa[i]]]++] = sa[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)sa[i] = sa_new[i];</span><br><span class="line">		c_new[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">			c_new[sa[i]] = c_new[sa[i<span class="number">-1</span>]] + (c[sa[i]] != c[sa[i<span class="number">-1</span>]] <span class="keyword">or</span> c[(sa[i] + (<span class="number">1</span>&lt;&lt;k)) % n] != c[(sa[i<span class="number">-1</span>] + (<span class="number">1</span>&lt;&lt;k)) % n]);</span><br><span class="line">		&#125;</span><br><span class="line">		k++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)c[i] = c_new[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="应用">应用</h3>
<h4 id="循环拼接">循环拼接</h4>
<p>对字符串<span class="math inline">\(s\)</span>的每个循环节进行排序</p>
<p>例如 <code>s = "abacba"</code></p>
<p>即为对<code>"abacba","bacbaa","acbaab","cbaaba","baabac","aabacb"</code>进行排序</p>
<p>解法:将字符串本身拼接在其后面, 求<span class="math inline">\(s+s\)</span>的后缀数组即可.</p>
<h4 id="在线模式匹配">在线模式匹配</h4>
<p>每个字符串均为某些字符串的后缀的前缀. 假设模式串为<span class="math inline">\(t\)</span>, 长度为<span class="math inline">\(|t|\)</span>, 那么我们只需根据后缀数组在文本串<span class="math inline">\(s\)</span>中找到长度为<span class="math inline">\(|k|\)</span>的后缀的前缀, 二分即可</p>
<p>每次查找复杂度:<span class="math inline">\(O(|t|logn)\)</span></p>
<p>文本串为<span class="math inline">\(s\)</span>, 模式串为<span class="math inline">\(t\)</span>.调用<code>check(t)</code>即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(string x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = x.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>,R = n,M;</span><br><span class="line">    <span class="keyword">while</span>(L &lt;= R)&#123;</span><br><span class="line">        M = (L+R)/<span class="number">2</span>;</span><br><span class="line">        string u = s.<span class="built_in">substr</span>(sa[M],k);</span><br><span class="line">        <span class="keyword">if</span>(u == x)<span class="keyword">return</span> sa[M];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(u &lt; x)L = M+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> R = M<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="统计字符串t在s中出现次数可重叠">统计字符串t在s中出现次数(可重叠)</h4>
<p>思想同上.二分出上下界即可</p>
<p>代码见模板部分的<code>count()</code></p>
<h4 id="从字符串首尾取字符-使新串字典序最小">从字符串首尾取字符, 使新串字典序最小</h4>
<p>当首尾字符不等时,显然取最小的最优.</p>
<p>当首尾字符相等时,需要判断由<span class="math inline">\(L\)</span>开始的子串和由<span class="math inline">\(R\)</span>开始的反子串的字典序大小,并取其中小的那个.</p>
<p>暴力求最坏需要<span class="math inline">\(O(n)\)</span>, 而后缀数组可以做到<span class="math inline">\(O(1)\)</span>判断. 我们在<span class="math inline">\(s\)</span>后加上一个<span class="math inline">\(s\)</span>中未出现的字符,再将<span class="math inline">\(s\)</span>反转之后的<span class="math inline">\(s&#39;\)</span>拼在其后.对新的<span class="math inline">\(s|s&#39;\)</span>求后缀数组.</p>
<p>由<span class="math inline">\(L\)</span>开始的子串排名为<span class="math inline">\(rank[L]\)</span>, 由<span class="math inline">\(R\)</span>开始的反子串排名为<span class="math inline">\(rank[N - 2 - R]\)</span>. (<span class="math inline">\(N\)</span>为<span class="math inline">\(s|s&#39;\)</span>的长度. -2是因为我们在两个串中间拼接了一个特殊字符)</p>
<p>例题:[USACO07DEC]Best Cow Line G</p>
<p>输入一个整数<span class="math inline">\(n\)</span>,接下来<span class="math inline">\(n\)</span>行每行一个字符.</p>
<p>输出从字符串首尾取字符, 能得到的最小字典序的新串.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P2870</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SA</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;sa,c;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">count_sort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp; sa,vector&lt;<span class="keyword">int</span>&gt; &amp; c)</span></span>&#123;</span><br><span class="line">		vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">pos</span>(n),<span class="built_in">cnt</span>(n),<span class="built_in">sa_new</span>(n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x:c)cnt[x]++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)pos[i] = pos[i<span class="number">-1</span>] + cnt[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x:sa)&#123;</span><br><span class="line">			<span class="keyword">int</span> d = c[x];</span><br><span class="line">			sa_new[pos[d]] = x;</span><br><span class="line">			pos[d]++;</span><br><span class="line">		&#125;</span><br><span class="line">		sa = sa_new;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)sa.<span class="built_in">push_back</span>(<span class="number">0</span>),c.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="comment">//init</span></span><br><span class="line">		&#123;</span><br><span class="line">			vector&lt;pair&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; &gt;<span class="built_in">A</span>(n);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)A[i] = &#123;s[i],i&#125;;</span><br><span class="line">			<span class="built_in">sort</span>(A.<span class="built_in">begin</span>(),A.<span class="built_in">end</span>());</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)sa[i] = A[i].second;</span><br><span class="line">			c[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">				c[sa[i]] = c[sa[i<span class="number">-1</span>]] + (A[i].first != A[i<span class="number">-1</span>].first);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;k) &lt; n)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)sa[i] = (sa[i] - (<span class="number">1</span>&lt;&lt;k) + n)%n;</span><br><span class="line">			<span class="built_in">count_sort</span>(sa,c);</span><br><span class="line">			vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">c_new</span>(n);</span><br><span class="line">			c_new[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">				pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;now = &#123;c[sa[i]],c[(sa[i] + (<span class="number">1</span>&lt;&lt;k)) % n]&#125;;</span><br><span class="line">				pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;prev = &#123;c[sa[i<span class="number">-1</span>]],c[(sa[i<span class="number">-1</span>] + (<span class="number">1</span>&lt;&lt;k)) % n]&#125;;</span><br><span class="line">				c_new[sa[i]] = c_new[sa[i<span class="number">-1</span>]] + (now != prev);</span><br><span class="line">			&#125;</span><br><span class="line">			k++;</span><br><span class="line">			c = c_new;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,sa[i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,N;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)cin &gt;&gt; s[i];</span><br><span class="line">	s[n] = <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">	<span class="keyword">int</span> idx = n+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)s[idx++] = s[i];</span><br><span class="line">	N = <span class="number">2</span>*(n+<span class="number">1</span>);</span><br><span class="line">	SA yay;</span><br><span class="line">	yay.n = N;</span><br><span class="line">	yay.<span class="built_in">cal</span>();</span><br><span class="line">	<span class="keyword">int</span> L = <span class="number">0</span>,R = n<span class="number">-1</span>,cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(L &lt;= R)&#123;</span><br><span class="line">		<span class="keyword">if</span>(yay.c[L] &lt; yay.c[N - <span class="number">2</span> - R])cout &lt;&lt; s[L++];</span><br><span class="line">		<span class="keyword">else</span> cout &lt;&lt; s[R--];</span><br><span class="line">		cnt++;</span><br><span class="line">		<span class="keyword">if</span>(cnt%<span class="number">80</span> == <span class="number">0</span>)cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="lcp的应用">LCP的应用</h3>
<h4 id="最长公共子串">最长公共子串</h4>
<p>给出两个字符串<span class="math inline">\(s,t\)</span>, 求它们的最长公共连续子串.</p>
<p>我们在<span class="math inline">\(s\)</span>和<span class="math inline">\(t\)</span>之间拼接一个未出现的特殊字符, 然后求LCP.将后缀分为两类:从<span class="math inline">\(s\)</span>开始的后缀和从<span class="math inline">\(t\)</span>开始的.显然答案为<span class="math inline">\(\max\{LCP[i]\},i与i-1为不同类\)</span></p>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P-5-B </span></span><br><span class="line"><span class="comment">//SA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SA</span>&#123;</span></span><br><span class="line">	string s;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;sa,c;</span><br><span class="line">	<span class="keyword">int</span> lcp[maxn],ST[maxn][<span class="number">20</span>];</span><br><span class="line">	<span class="built_in">SA</span>(string s = <span class="string">&quot;&quot;</span>):<span class="built_in">s</span>(s)&#123;</span><br><span class="line">		s += <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">		n = s.<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)sa.<span class="built_in">push_back</span>(<span class="number">0</span>),c.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">count_sort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp; sa,vector&lt;<span class="keyword">int</span>&gt; &amp; c)</span></span>&#123;</span><br><span class="line">		vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">pos</span>(n),<span class="built_in">cnt</span>(n),<span class="built_in">sa_new</span>(n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x:c)cnt[x]++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)pos[i] = pos[i<span class="number">-1</span>] + cnt[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x:sa)&#123;</span><br><span class="line">			<span class="keyword">int</span> d = c[x];</span><br><span class="line">			sa_new[pos[d]] = x;</span><br><span class="line">			pos[d]++;</span><br><span class="line">		&#125;</span><br><span class="line">		sa = sa_new;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//init</span></span><br><span class="line">		&#123;</span><br><span class="line">			vector&lt;pair&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; &gt;<span class="built_in">A</span>(n);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)A[i] = &#123;s[i],i&#125;;</span><br><span class="line">			<span class="built_in">sort</span>(A.<span class="built_in">begin</span>(),A.<span class="built_in">end</span>());</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)sa[i] = A[i].second;</span><br><span class="line">			c[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">				c[sa[i]] = c[sa[i<span class="number">-1</span>]] + (A[i].first != A[i<span class="number">-1</span>].first);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;k) &lt; n)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)sa[i] = (sa[i] - (<span class="number">1</span>&lt;&lt;k) + n)%n;</span><br><span class="line">			<span class="built_in">count_sort</span>(sa,c);</span><br><span class="line">			vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">c_new</span>(n);</span><br><span class="line">			c_new[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">				pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;now = &#123;c[sa[i]],c[(sa[i] + (<span class="number">1</span>&lt;&lt;k)) % n]&#125;;</span><br><span class="line">				pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;prev = &#123;c[sa[i<span class="number">-1</span>]],c[(sa[i<span class="number">-1</span>] + (<span class="number">1</span>&lt;&lt;k)) % n]&#125;;</span><br><span class="line">				c_new[sa[i]] = c_new[sa[i<span class="number">-1</span>]] + (now != prev);</span><br><span class="line">			&#125;</span><br><span class="line">			k++;</span><br><span class="line">			c = c_new;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ST_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)ST[i][<span class="number">0</span>] = lcp[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j) &lt;= n;j++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;j) <span class="number">-1</span> &lt;= n;i++)</span><br><span class="line">				ST[i][j] = <span class="built_in">min</span>(ST[i][j - <span class="number">1</span>],ST[i + (<span class="number">1</span>&lt;&lt;(j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">LCP</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">		L = c[L],R = c[R];</span><br><span class="line">		<span class="keyword">if</span>(L &gt; R)<span class="built_in">swap</span>(L,R);</span><br><span class="line">		L++;</span><br><span class="line">		<span class="keyword">int</span> k = <span class="built_in">log2</span>(R - L + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">min</span>(ST[L][k],ST[R - (<span class="number">1</span>&lt;&lt;k) + <span class="number">1</span>][k]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getlcp</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> j = sa[c[i] - <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">while</span>(s[i+k] == s[j+k])k++;</span><br><span class="line">			lcp[c[i]] = k;</span><br><span class="line">			<span class="keyword">if</span>(k)k--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">ST_init</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> idx = <span class="number">0</span>,len = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> now = n - <span class="number">1</span> - sa[i],pre = n - <span class="number">1</span> - sa[i<span class="number">-1</span>];</span><br><span class="line">			<span class="keyword">if</span>((pre &gt; b <span class="keyword">and</span> now &lt;= b) <span class="built_in"><span class="keyword">or</span></span> (pre &lt;= b <span class="keyword">and</span> now &gt; b))&#123;</span><br><span class="line">				<span class="keyword">if</span>(len &lt; lcp[i])&#123;</span><br><span class="line">					idx = sa[i];len = lcp[i];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; s.<span class="built_in">substr</span>(idx,len);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(string x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> k = x.<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">int</span> L = <span class="number">0</span>,R = n,M;</span><br><span class="line">		<span class="keyword">while</span>(L &lt; R)&#123;</span><br><span class="line">			M = (L+R)/<span class="number">2</span>;</span><br><span class="line">			string u = s.<span class="built_in">substr</span>(sa[M],k);</span><br><span class="line">			<span class="keyword">if</span>(u &gt;= x)R = M;</span><br><span class="line">			<span class="keyword">else</span> L = M+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> L;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">upper_bound</span><span class="params">(string x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> k = x.<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">int</span> L = <span class="number">0</span>,R = n,M;</span><br><span class="line">		<span class="keyword">while</span>(L &lt; R)&#123;</span><br><span class="line">			M = (L+R)/<span class="number">2</span>;</span><br><span class="line">			string u = s.<span class="built_in">substr</span>(sa[M],k);</span><br><span class="line">			<span class="keyword">if</span>(u &lt;= x)L = M+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> R = M;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> L;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(string x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">upper_bound</span>(x) - <span class="built_in">lower_bound</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	string s,t;</span><br><span class="line">	cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">	a = s.<span class="built_in">size</span>(),b = t.<span class="built_in">size</span>();</span><br><span class="line">	s = s+<span class="string">&#x27;#&#x27;</span>+t;</span><br><span class="line">	<span class="function">SA <span class="title">yay</span><span class="params">(s)</span></span>;</span><br><span class="line">	yay.<span class="built_in">cal</span>();</span><br><span class="line">	yay.<span class="built_in">getlcp</span>();</span><br><span class="line">	yay.<span class="built_in">output</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="两子串最长公共前缀">两子串最长公共前缀</h4>
<p><span class="math display">\[
LCP(sa[i],sa[j]) = min\{lcp[i+1],...,lcp[j]\}
\]</span></p>
<p>于是就转化成了RMQ问题.</p>
<p>具体代码见模板中的<code>LCP()</code></p>
<h4 id="比较一个字符中两子串的关系">比较一个字符中两子串的关系</h4>
<p>设需要比较<span class="math inline">\(A = s[a...b]\)</span>和<span class="math inline">\(B = s[c...d]\)</span>的关系.</p>
<p>若<span class="math inline">\(lcp(a,c) \ge \min(|A|,|B|)\)</span>,则<span class="math inline">\(A &lt; B\)</span>等价于<span class="math inline">\(|A| &lt; |B|\)</span></p>
<p>否则, <span class="math inline">\(A &lt; B\)</span>等价于<span class="math inline">\(rank[a] &lt; rank[c]\)</span></p>
<p>注意: 如果要将两个字符串<span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>拼接在一起, 且需统计<span class="math inline">\(A\)</span>中小于等于<span class="math inline">\(B\)</span>的子串个数时, 应该按<span class="math inline">\(B + A\)</span>的方式拼接(前缀相同时更短的字符串rank更小)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CompString</span><span class="params">(<span class="keyword">int</span> s1,<span class="keyword">int</span> len1,<span class="keyword">int</span> s2,<span class="keyword">int</span> len2)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> tlcp = (s1 == s2?<span class="built_in">min</span>(len1,len2):<span class="built_in">LCP</span>(s1,s2));</span><br><span class="line">		<span class="keyword">if</span>(tlcp &gt;= <span class="built_in">min</span>(len1,len2))&#123;</span><br><span class="line">			<span class="keyword">return</span> len1 &lt; len2?<span class="number">-1</span>:(len1 == len2?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> c[s1] &lt; c[s2]?<span class="number">-1</span>:(c[s1] == c[s2]?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>注意: 可以只用<span class="math inline">\(lcp\)</span>来比较字符串大小(这样就可以用hash等方法来求<span class="math inline">\(lcp\)</span>而不用写SA). 只要把上面的第6行替换为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> s[s1 + tlcp] &lt; s[s2 + tlcp]?<span class="number">-1</span>:(s[s1 + tlcp] == s[s2 + tlcp]?<span class="number">0</span>:<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>即可.</p>
<h4 id="不同子串的数目">不同子串的数目</h4>
<p><span class="math display">\[
\frac{n(n+1)}{2} - \sum_{i = 1}^n lcp[i]
\]</span></p>
<p>怎么推的忘了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">    ans += n - sa[i] - <span class="number">1</span> - lcp[i];</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans;</span><br></pre></td></tr></table></figure>
<h4 id="出现至少k次的子串的最大长度">出现至少k次的子串的最大长度</h4>
<p>首先<span class="math inline">\(lcp[i]\)</span>表示<span class="math inline">\(sa[i]\)</span>和<span class="math inline">\(sa[i-1]\)</span>的最大公共长度</p>
<p>那么相邻的<span class="math inline">\(k-1\)</span>个<span class="math inline">\(lcp\)</span>的最小值就是该子串出现<span class="math inline">\(k\)</span>次的最大公共长度.</p>
<p>所以我们求出相邻<span class="math inline">\(k-1\)</span>个<span class="math inline">\(lcp\)</span>的最小值, 再求这些最小值的最大值就是答案</p>
<p>可以用单调队列或者单调栈在<span class="math inline">\(O(n)\)</span>时间内解决.</p>
<p>例题: [USACO06DEC]Milk Patterns G</p>
<p>输入第一行为<span class="math inline">\(n,k\)</span> <span class="math inline">\(n\)</span>为字符串长度,<span class="math inline">\(k\)</span>为出现至少<span class="math inline">\(k\)</span>次</p>
<p>下面的<span class="math inline">\(n\)</span>行每行一个数字.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P2852 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,s[maxn];</span><br><span class="line"><span class="keyword">int</span> sa[maxn],pos[maxn],cnt[maxn],sa_new[maxn],c[maxn],c_new[maxn],lcp[maxn];</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;A[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SA</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)A[i] = &#123;s[i],i&#125;;</span><br><span class="line">	<span class="built_in">sort</span>(A,A+n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)sa[i] = A[i].second;</span><br><span class="line">	c[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">		c[sa[i]] = c[sa[i<span class="number">-1</span>]] + (A[i].first != A[i<span class="number">-1</span>].first);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;k) &lt; n)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)sa[i] = (sa[i] - (<span class="number">1</span>&lt;&lt;k) + n)%n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)cnt[i] = pos[i] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)cnt[c[i]]++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)pos[i] = pos[i<span class="number">-1</span>] + cnt[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)sa_new[pos[c[sa[i]]]++] = sa[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)sa[i] = sa_new[i];</span><br><span class="line">		c_new[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">			c_new[sa[i]] = c_new[sa[i<span class="number">-1</span>]] + (c[sa[i]] != c[sa[i<span class="number">-1</span>]] <span class="keyword">or</span> c[(sa[i] + (<span class="number">1</span>&lt;&lt;k)) % n] != c[(sa[i<span class="number">-1</span>] + (<span class="number">1</span>&lt;&lt;k)) % n]);</span><br><span class="line">		&#125;</span><br><span class="line">		k++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)c[i] = c_new[i];</span><br><span class="line">	&#125;</span><br><span class="line">	k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> j = sa[c[i] - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">while</span>(s[i+k] == s[j+k])k++;</span><br><span class="line">		lcp[c[i]] = k;</span><br><span class="line">		<span class="keyword">if</span>(k)k--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> w,idx;</span><br><span class="line">	<span class="built_in">Node</span>(<span class="keyword">int</span> w = <span class="number">0</span>,<span class="keyword">int</span> idx = <span class="number">0</span>):<span class="built_in">w</span>(w),<span class="built_in">idx</span>(idx)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">deque&lt;Node&gt;qmin;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> K;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;K);</span><br><span class="line">	K--;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;s[i]);</span><br><span class="line">	s[n] = <span class="number">-1</span>;</span><br><span class="line">	n++;</span><br><span class="line">	<span class="built_in">SA</span>();</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">		Node u = <span class="built_in">Node</span>(lcp[i],i);</span><br><span class="line">		<span class="keyword">while</span>(qmin.<span class="built_in">size</span>() <span class="keyword">and</span> qmin.<span class="built_in">back</span>().w &gt; u.w)qmin.<span class="built_in">pop_back</span>();</span><br><span class="line">		qmin.<span class="built_in">push_back</span>(u);</span><br><span class="line">		<span class="keyword">while</span>(qmin.<span class="built_in">size</span>() <span class="keyword">and</span> qmin.<span class="built_in">front</span>().idx &lt; i - K + <span class="number">1</span>)qmin.<span class="built_in">pop_front</span>();</span><br><span class="line">		<span class="keyword">if</span>(i &gt;= K)ans = <span class="built_in">max</span>(ans,qmin.<span class="built_in">front</span>().w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="trie">Trie</h2>
<p>待补充.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> siz = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> nxt[maxn][<span class="number">30</span>];</span><br><span class="line">	<span class="keyword">int</span> vis[maxn];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">		siz = <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">memset</span>(nxt,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(nxt));</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x:s)&#123;</span><br><span class="line">			<span class="keyword">int</span> c = x - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">			<span class="keyword">if</span>(!nxt[u][c])&#123;</span><br><span class="line">				nxt[u][c] = siz++;</span><br><span class="line">			&#125;</span><br><span class="line">			u = nxt[u][c];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x:s)&#123;</span><br><span class="line">			<span class="keyword">int</span> c = x - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">			<span class="keyword">if</span>(!nxt[u][c])&#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;WRONG\n&quot;</span>;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			u = nxt[u][c];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(vis[u])cout &lt;&lt; <span class="string">&quot;REPEAT\n&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;OK\n&quot;</span>;</span><br><span class="line">			vis[u] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;trie;</span><br></pre></td></tr></table></figure>
<h1 id="暴力">暴力</h1>
<h2 id="分块">分块</h2>
<p>因为分块细节很多,这里只放几道例题.</p>
<h3 id="区间加法单点查询">区间加法,单点查询</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//LOJ6277 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZ = <span class="number">256</span>;</span><br><span class="line">vector&lt;ll&gt;block[maxn];</span><br><span class="line"><span class="keyword">int</span> bnt[maxn];</span><br><span class="line">ll add[maxn],raw[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(bnt[L] == bnt[R])&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = L;i &lt;= R;i++)raw[i] += w;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = L;i &lt;= bnt[L]*SIZ;i++)raw[i] += w;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = (bnt[R]<span class="number">-1</span>)*SIZ+<span class="number">1</span>;i &lt;= R;i++)raw[i] += w;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = bnt[L]+<span class="number">1</span>;i &lt; bnt[R];i++)add[i] += w;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> raw[x] + add[(x<span class="number">-1</span>)/SIZ+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; maxn;i++)bnt[i] = (i<span class="number">-1</span>)/SIZ+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)cin &gt;&gt; raw[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> o,l,r,w;</span><br><span class="line">		cin &gt;&gt; o &gt;&gt; l &gt;&gt; r &gt;&gt; w;</span><br><span class="line">		<span class="keyword">if</span>(o)cout &lt;&lt; <span class="built_in">query</span>(r) &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">update</span>(l,r,w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="动态逆序对">动态逆序对</h3>
<p>现在给出 1到n 的一个排列，按照某种顺序依次删除 m 个元素，你的任务是在每次删除一个元素<strong>之前</strong>统计整个序列的逆序对数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P3157 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZ = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> bnt[maxn],raw[maxn],A[maxn];</span><br><span class="line"><span class="keyword">int</span> BIT[maxn],n,m,maxb;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;Block[maxn];</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b&amp;-b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(index &lt;= n)&#123;</span><br><span class="line">		BIT[index] += d;</span><br><span class="line">		index += <span class="built_in">lowbit</span>(index);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t_ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(index)&#123;</span><br><span class="line">		t_ans += BIT[index];</span><br><span class="line">		index -= <span class="built_in">lowbit</span>(index);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t_ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;raw[i]);</span><br><span class="line">		bnt[i] = (i<span class="number">-1</span>)/SIZ+<span class="number">1</span>;</span><br><span class="line">		A[raw[i]] = i;</span><br><span class="line">		Block[bnt[i]].<span class="built_in">push_back</span>(raw[i]);</span><br><span class="line">		ans += (i<span class="number">-1</span>-<span class="built_in">sum</span>(raw[i]));</span><br><span class="line">		<span class="built_in">add</span>(raw[i],<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	maxb = (n<span class="number">-1</span>)/SIZ+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= maxb;i++)<span class="built_in">sort</span>(Block[i].<span class="built_in">begin</span>(),Block[i].<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> b = (A[x]<span class="number">-1</span>)/SIZ+<span class="number">1</span>,k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; b;i++)k += (Block[i].<span class="built_in">size</span>() - (<span class="built_in">lower_bound</span>(Block[i].<span class="built_in">begin</span>(),Block[i].<span class="built_in">end</span>(),x) - Block[i].<span class="built_in">begin</span>()));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = b+<span class="number">1</span>;i &lt;= maxb;i++)k += <span class="built_in">lower_bound</span>(Block[i].<span class="built_in">begin</span>(),Block[i].<span class="built_in">end</span>(),x) - Block[i].<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = (b<span class="number">-1</span>)*SIZ+<span class="number">1</span>;i &lt; A[x];i++)<span class="keyword">if</span>(raw[i] <span class="keyword">and</span> raw[i] &gt; x)k++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = A[x];i &lt;= b*SIZ;i++)<span class="keyword">if</span>(raw[i] <span class="keyword">and</span> raw[i] &lt; x)k++;</span><br><span class="line">	<span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> b = (A[x]<span class="number">-1</span>)/SIZ+<span class="number">1</span>;</span><br><span class="line">	raw[A[x]] = <span class="number">0</span>;</span><br><span class="line">	A[x] = <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> it = Block[b].<span class="built_in">begin</span>();it != Block[b].<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(*it == x)&#123;</span><br><span class="line">			Block[b].<span class="built_in">erase</span>(it);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="keyword">int</span> x;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">		ans -= <span class="built_in">query</span>(x);</span><br><span class="line">		<span class="built_in">del</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="莫队">莫队</h2>
<h3 id="基础莫队小b的询问luogu-p2709">基础莫队(小B的询问,Luogu P2709)</h3>
<p>求<span class="math inline">\(\sum_{i = 1}^kc_{i}^2\)</span></p>
<p><span class="math inline">\(c_i\)</span>为<span class="math inline">\(i\)</span>在<span class="math inline">\([L,R]\)</span>的出现次数</p>
<p>块大小取<span class="math inline">\(\sqrt{n}\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P2709</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZ = <span class="number">512</span>;</span><br><span class="line">ll cnt[maxn],res[maxn],raw[maxn],ans;</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> L,R,idx;</span><br><span class="line">	<span class="built_in">Node</span>(<span class="keyword">int</span> L = <span class="number">0</span>,<span class="keyword">int</span> R = <span class="number">0</span>,<span class="keyword">int</span> idx = <span class="number">0</span>):<span class="built_in">L</span>(L),<span class="built_in">R</span>(R),<span class="built_in">idx</span>(idx)&#123;&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp; x)<span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>((L<span class="number">-1</span>)/SIZ != (x.L<span class="number">-1</span>)/SIZ)<span class="keyword">return</span> (L<span class="number">-1</span>) &lt; (x.L<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> R &lt; x.R;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;query[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> v = raw[pos];</span><br><span class="line">	<span class="keyword">if</span>(x == <span class="number">1</span>)ans += cnt[v]*<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> ans += <span class="number">1</span> - cnt[v]*<span class="number">2</span>;</span><br><span class="line">	cnt[v] += x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)cin &gt;&gt; raw[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> L,R;</span><br><span class="line">		cin &gt;&gt; L &gt;&gt; R;</span><br><span class="line">		query[i] = <span class="built_in">Node</span>(L,R,i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(query+<span class="number">1</span>,query+m+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">1</span>,r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(l &gt; query[i].L)<span class="built_in">update</span>(--l,<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">while</span>(r &lt; query[i].R)<span class="built_in">update</span>(++r,<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">while</span>(l &lt; query[i].L)<span class="built_in">update</span>(l++,<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">while</span>(r &gt; query[i].R)<span class="built_in">update</span>(r--,<span class="number">-1</span>);</span><br><span class="line">		res[query[i].idx] = ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)cout &lt;&lt; res[i] &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>奇偶排序优化:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp; x)<span class="keyword">const</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>((l<span class="number">-1</span>)/SIZ != (x.l<span class="number">-1</span>)/SIZ)<span class="keyword">return</span> l &lt; x.l;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(((l<span class="number">-1</span>)/SIZ+<span class="number">1</span>)%<span class="number">2</span>)<span class="keyword">return</span> r &lt; x.r;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> r &gt; x.r; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="带修莫队">带修莫队</h3>
<p>分块大小取<span class="math inline">\(n^{\frac{2}{3}}\)</span></p>
<p>询问存当前区间(<span class="math inline">\(l,r\)</span>)和修改的时间(<span class="math inline">\(t\)</span>), 排序分别以<span class="math inline">\(l,r,t\)</span>为关键字.</p>
<p>修改时如果当前时间比询问时间小就暴力修改，否则暴力回退</p>
<p>注意: <strong>只有修改的位置在当前区间内才更新答案，但无论如何都要进行修改</strong></p>
<p>例题:P1903 [国家集训队]数颜色 / 维护队列</p>
<p>1、 Q L R代表询问你从第L支画笔到第R支画笔中共有几种不同颜色的画笔。</p>
<p>2、 R P Col 把第P支画笔替换为颜色Col。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P1903-Mo </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZ = <span class="number">2607</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> raw[maxn],cnt[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> l,r,idx,t,ans;</span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Query &amp; x) <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>((l<span class="number">-1</span>)/SIZ != (x.l<span class="number">-1</span>)/SIZ)<span class="keyword">return</span> l &lt; x.l;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>((r<span class="number">-1</span>)/SIZ != (x.r<span class="number">-1</span>)/SIZ)&#123;</span><br><span class="line">			<span class="keyword">if</span>(((l<span class="number">-1</span>)/SIZ)%<span class="number">2</span>)<span class="keyword">return</span> r &lt; x.r;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">return</span> r &gt; x.r;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> t &lt; x.t;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Query</span>(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> idx,<span class="keyword">int</span> t):<span class="built_in">l</span>(l),<span class="built_in">r</span>(r),<span class="built_in">idx</span>(idx),<span class="built_in">t</span>(t)&#123;&#125;</span><br><span class="line">	<span class="built_in">Query</span>(<span class="keyword">int</span> idx = <span class="number">0</span>,<span class="keyword">int</span> v = <span class="number">0</span>):<span class="built_in">idx</span>(idx),<span class="built_in">v</span>(v)&#123;&#125;</span><br><span class="line">&#125;query[maxn],op[maxn];</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!cnt[x])ans++;</span><br><span class="line">	cnt[x]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">1</span> == cnt[x])ans--;</span><br><span class="line">	cnt[x]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> tim,<span class="keyword">int</span> qidx)</span></span>&#123;</span><br><span class="line">	<span class="comment">//opt :1,re 0,add</span></span><br><span class="line">	<span class="keyword">int</span> l = query[qidx].l,r = query[qidx].r,x = op[tim].idx;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= x <span class="keyword">and</span> x &lt;= r)&#123;</span><br><span class="line">		<span class="built_in">del</span>(raw[x]);</span><br><span class="line">		<span class="built_in">add</span>(op[tim].v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">swap</span>(raw[x],op[tim].v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;raw[i]);</span><br><span class="line">	<span class="keyword">int</span> ocnt = <span class="number">0</span>,qcnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">		string opt;</span><br><span class="line">		<span class="keyword">int</span> l,r;</span><br><span class="line">		cin &gt;&gt; opt;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">		<span class="keyword">if</span>(opt == <span class="string">&quot;Q&quot;</span>)&#123;</span><br><span class="line">			qcnt++;</span><br><span class="line">			query[qcnt] = <span class="built_in">Query</span>(l,r,qcnt,ocnt);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> op[++ocnt] = <span class="built_in">Query</span>(l,r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(query+<span class="number">1</span>,query+qcnt+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">1</span>,r = <span class="number">0</span>,now = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= qcnt;i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(l &lt; query[i].l)<span class="built_in">del</span>(raw[l++]);</span><br><span class="line">		<span class="keyword">while</span>(l &gt; query[i].l)<span class="built_in">add</span>(raw[--l]);</span><br><span class="line">		<span class="keyword">while</span>(r &gt; query[i].r)<span class="built_in">del</span>(raw[r--]);</span><br><span class="line">		<span class="keyword">while</span>(r &lt; query[i].r)<span class="built_in">add</span>(raw[++r]);</span><br><span class="line">		<span class="keyword">while</span>(now &lt; query[i].t)<span class="built_in">change</span>(++now,i);</span><br><span class="line">		<span class="keyword">while</span>(now &gt; query[i].t)<span class="built_in">change</span>(now--,i);</span><br><span class="line">		query[i].ans = ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span> cmp = [](Query a,Query b) -&gt; <span class="keyword">bool</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a.idx &lt; b.idx;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">sort</span>(query+<span class="number">1</span>,query+qcnt+<span class="number">1</span>,cmp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= qcnt;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,query[i].ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="树上莫队">树上莫队</h3>
<h4 id="分块方式">分块方式</h4>
<p>将树分为大小在<span class="math inline">\([B,3B)\)</span>之间的块, 其中<span class="math inline">\(pa[i]\)</span>表示第<span class="math inline">\(i\)</span>个点所属的块编号, <span class="math inline">\(pivot[i]\)</span>表示<span class="math inline">\(i\)</span>号块对应的关键点. 关键点是满足<strong>该块内任意一点到关键点的简单路径上的所有点都在块内</strong>的点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">stack&lt;<span class="keyword">int</span>&gt;s;</span><br><span class="line"><span class="keyword">int</span> B;</span><br><span class="line"><span class="keyword">int</span> pa[maxn],pivot[maxn],acnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> siz = s.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">		<span class="keyword">if</span>(v == fa)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(v,u);</span><br><span class="line">		<span class="keyword">if</span>((<span class="keyword">int</span>)s.<span class="built_in">size</span>() - siz &gt;= B)&#123;</span><br><span class="line">			pivot[++acnt] = u;</span><br><span class="line">			<span class="keyword">while</span>((<span class="keyword">int</span>)s.<span class="built_in">size</span>() &gt; siz)&#123;</span><br><span class="line">				pa[s.<span class="built_in">top</span>()] = acnt;</span><br><span class="line">				s.<span class="built_in">pop</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	s.<span class="built_in">push</span>(u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用时:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">while</span>(s.<span class="built_in">size</span>())&#123;</span><br><span class="line">    pa[s.<span class="built_in">top</span>()] = acnt;</span><br><span class="line">    s.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="其他">其他</h1>
<h2 id="并查集">并查集</h2>
<p>路径压缩,无按秩合并 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> father[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)father[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findset</span><span class="params">(<span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> father[e] == e?e:father[e] = <span class="built_in">findset</span>(father[e]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">un</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	father[<span class="built_in">findset</span>(x)] = <span class="built_in">findset</span>(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>路径压缩, 按秩合并</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> fa[maxn],siz[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findset</span><span class="params">(<span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> fa[e] == e?e:fa[e] = <span class="built_in">findset</span>(fa[e]); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">un</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	a = <span class="built_in">findset</span>(a),b = <span class="built_in">findset</span>(b);</span><br><span class="line">	<span class="keyword">if</span>(siz[a] &gt; siz[b])<span class="built_in">swap</span>(a,b);</span><br><span class="line">	siz[b] += siz[a];</span><br><span class="line">	<span class="comment">// fa[a] = fa[b];</span></span><br><span class="line">	fa[a] = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">findset</span>(a) == <span class="built_in">findset</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="带权并查集">带权并查集</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> fa[maxn],siz[maxn],maxv[maxn],minv[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findset</span><span class="params">(<span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> fa[e] == e?e:fa[e] = <span class="built_in">findset</span>(fa[e]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">findset</span>(a) == <span class="built_in">findset</span>(b);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">un</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">check</span>(a,b))<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> &amp; v = fa[<span class="built_in">findset</span>(a)],u = <span class="built_in">findset</span>(b);</span><br><span class="line">	siz[u] += siz[v];</span><br><span class="line">	maxv[u] = <span class="built_in">max</span>(maxv[u],maxv[v]);</span><br><span class="line">	minv[u] = <span class="built_in">min</span>(minv[u],minv[v]);</span><br><span class="line">	v = u;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h2 id="二分">二分</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="keyword">int</span> &amp; A,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> L = <span class="number">0</span>,R = n,M;</span><br><span class="line">	<span class="keyword">while</span>(L &lt; R)&#123;</span><br><span class="line">		M = (L+R)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(A[M] &gt;= x)R = M;</span><br><span class="line">		<span class="keyword">else</span> L = M+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">upper_bound</span><span class="params">(<span class="keyword">int</span> &amp; A,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> L = <span class="number">0</span>,R = n,M;</span><br><span class="line">	<span class="keyword">while</span>(L &lt; R)&#123;</span><br><span class="line">		M = (L+R)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(A[M] &lt;= x)L = M+<span class="number">1</span>;<span class="comment">//区别在此</span></span><br><span class="line">		<span class="keyword">else</span> R = M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单调队列">单调队列</h2>
<p>保证双端队列里的值单调即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">	Node u = <span class="built_in">Node</span>(raw[i],i);</span><br><span class="line">	<span class="keyword">while</span>(qmin.<span class="built_in">size</span>() <span class="keyword">and</span> qmin.<span class="built_in">back</span>().w &gt; u.w)qmin.<span class="built_in">pop_back</span>();</span><br><span class="line">	qmin.<span class="built_in">push_back</span>(u);</span><br><span class="line">	<span class="keyword">while</span>(qmin.<span class="built_in">size</span>() <span class="keyword">and</span> qmin.<span class="built_in">front</span>().idx &lt; i - k + <span class="number">1</span>)qmin.<span class="built_in">pop_front</span>();</span><br><span class="line">	<span class="keyword">if</span>(i &gt;= k)cout &lt;&lt; qmin.<span class="built_in">front</span>().w &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]CF1561D/CF1560B-Up the Strip</title>
    <url>/2021/08/25/solution-CF1561D/</url>
    <content><![CDATA[<h2 id="题解">题解</h2>
<p>设<span class="math inline">\(f[i]\)</span>为从<span class="math inline">\(n\)</span>走到<span class="math inline">\(i\)</span>的方案数. 分减法和整除两种情况分别讨论: <span class="math display">\[
\begin{align}
减法:&amp;\\
f[i] &amp;= \sum_{j = i}^nf[j]\\
整除:&amp;\\
f[i] &amp;= \sum_{j = i}^{i*j&lt;= n}\sum_{\lfloor \frac{k}{j} \rfloor = i}f[k]\\
&amp;= \sum_{j = i}^{i*j&lt;= n}\sum_{k = i*j}^{(i+1)*j - 1}f[k]\\
&amp;= \sum_{j = i}^{i*j&lt;= n}suf[j] - suf[(i+1)*j]\\
其中&amp;suf[i] = \sum_{j = i}^n f[i]\\
\end{align}
\]</span></p>
<p>综上, 递推式为 <span class="math display">\[
\begin{align}
f[n] &amp;= suf[n] = 1\\
suf[i] &amp;=suf[i+1] + f[i]\\
f[i] &amp;= suf[i+1]+\sum_{j = 1}^{i*j &lt;= n}suf[j] - suf[(i+1)*j]
\end{align}
\]</span> 注意处理<span class="math inline">\((i+1)*j\)</span>越界的问题. 复杂度<span class="math inline">\(O(n\ln n)\)</span></p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="function">mt19937 <span class="title">Rand</span><span class="params">(chrono::steady_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4e6</span>+<span class="number">10</span>;<span class="comment">//CHANGE IT!</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = maxn*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> p;</span><br><span class="line"><span class="function">ll <span class="title">Pow</span><span class="params">(ll x,ll d)</span></span>&#123;ll ta=<span class="number">1</span>;<span class="keyword">if</span>(d==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>%p;ll a=<span class="built_in">Pow</span>(x,d/<span class="number">2</span>);ta=a*a%p;<span class="keyword">if</span>(d%<span class="number">2</span>)ta=ta*x%p;<span class="keyword">return</span> ta%p;&#125;</span><br><span class="line">ll f[maxn],pre[maxn];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">setf</span>(ios::fixed,ios::floatfield);</span><br><span class="line">	cout.<span class="built_in">precision</span>(<span class="number">12</span>);	 </span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; p;</span><br><span class="line">	f[n] = pre[n] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>;i &gt;= <span class="number">1</span>;i--)&#123;</span><br><span class="line">		f[i] = pre[i+<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>;i*j &lt;= n;j++)&#123;</span><br><span class="line">			f[i] = (f[i] + (pre[i*j] - ((i+<span class="number">1</span>)*(j) &gt; maxn?<span class="number">0</span>:pre[(i+<span class="number">1</span>)*(j)])))%p;</span><br><span class="line">		&#125;</span><br><span class="line">		pre[i] = (f[i] + pre[i+<span class="number">1</span>])%p;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; f[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>题解</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]-CF1567E Non-Decreasing Dilemma</title>
    <url>/2021/09/14/solution-CF1567E/</url>
    <content><![CDATA[<h2 id="题意">题意</h2>
<p>给出<span class="math inline">\(raw[]\)</span>和两种操作:</p>
<ol type="1">
<li><span class="math inline">\(x\space v\)</span>, 将<span class="math inline">\(raw[x]\)</span>修改为<span class="math inline">\(v\)</span></li>
<li><span class="math inline">\(l \space r\)</span>, 询问<span class="math inline">\(raw[l],raw[l+1],...,raw[r]\)</span>中有多少合法的数对<span class="math inline">\((i,j)\)</span>满足<span class="math inline">\(l \leq i \leq j \leq r\)</span>且<span class="math inline">\(raw[i]...raw[j]\)</span>单调不降</li>
</ol>
<p><span class="math inline">\(1 \leq n,q \leq 2\cdot10^5\)</span></p>
<h2 id="题解">题解</h2>
<p>线段树维护区间合并. 以下<span class="math inline">\(x\)</span>代表线段树节点标号, <span class="math inline">\(ls(x)\)</span>和<span class="math inline">\(rs(x)\)</span>分别代表左右儿子节点标号</p>
<p>容易发现对于每段长度为<span class="math inline">\(m\)</span>的单调不降子序列, 其对答案的贡献是<span class="math inline">\(\frac{m\cdot (m+1)}2\)</span></p>
<p>建一颗线段树, 维护如下信息:</p>
<p>​ <span class="math inline">\(prev[x]\)</span>: 自节点<span class="math inline">\(x\)</span>的最左端开始的最长单调不降子序列的长度</p>
<p>​ <span class="math inline">\(sufv[x]\)</span>: 自节点<span class="math inline">\(x\)</span>的最右端结束的最长单调不降子序列的长度</p>
<p>​ <span class="math inline">\(totv[x]\)</span>: 节点<span class="math inline">\(x\)</span>有多少合法数对<span class="math inline">\((i,j)\)</span>满足题意</p>
<p>有几点细节需要注意:</p>
<ol type="1">
<li><p>对于<span class="math inline">\(prev[x]\)</span>, 只有其左儿子的<span class="math inline">\(prev[ls(x)]\)</span>等于区间长度, 并且左儿子和右儿子的连接处不降(即<span class="math inline">\(raw[m-1] &lt;= raw[m])\)</span>时才有<span class="math inline">\(prev[x] = prev[ls(x)] + prev[rs(x)]\)</span>. <span class="math inline">\(sufv[]\)</span>的维护同理</p></li>
<li><p>对于<span class="math inline">\(totv[x]\)</span>, 显然有<span class="math inline">\(totv[x] += totv[ls(x)] + totv[rs(x)]\)</span>. 而当其左儿子和右儿子的连接处不降时, 还需加上<span class="math inline">\(sufv[ls(x)] \cdot prev[rs(x)]\)</span>, 即新增合法区间的左端点全部从左儿子中选, 右端点全部从右儿子中选.</p></li>
<li><p>在统计答案时, 需要处理当前节点区间比询问区间大的情况</p></li>
</ol>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="function">mt19937 <span class="title">Rand</span><span class="params">(chrono::steady_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">8e5</span>+<span class="number">10</span>;<span class="comment">//CHANGE IT!</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = maxn*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">1e9</span>+<span class="number">7</span>;<span class="comment">//CHANGE IT!</span></span><br><span class="line"><span class="keyword">int</span> raw[maxn];</span><br><span class="line"><span class="function">ll <span class="title">Pow</span><span class="params">(ll x,ll d,ll p)</span></span>&#123;ll ta=<span class="number">1</span>;<span class="keyword">if</span>(d==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>%p;x %= p;ll a=<span class="built_in">Pow</span>(x,d/<span class="number">2</span>,p);ta=a*a%p;<span class="keyword">if</span>(d%<span class="number">2</span>)ta=ta*x%p;<span class="keyword">return</span> ta%p;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segtree</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> siz = <span class="number">1</span>;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;prev,sufv,totv;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(siz &lt; n)siz *= <span class="number">2</span>;</span><br><span class="line">		prev.<span class="built_in">assign</span>(siz*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">		sufv.<span class="built_in">assign</span>(siz*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">		totv.<span class="built_in">assign</span>(siz*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x*(x+<span class="number">1</span>)/<span class="number">2</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> len = (rx - lx)/<span class="number">2</span>;</span><br><span class="line">		totv[x] = totv[<span class="built_in">ls</span>(x)] + totv[<span class="built_in">rs</span>(x)];</span><br><span class="line">		totv[x] += (raw[m<span class="number">-1</span>] &lt;= raw[m]?sufv[<span class="built_in">ls</span>(x)]*prev[<span class="built_in">rs</span>(x)]:<span class="number">0</span>);</span><br><span class="line">		prev[x] = <span class="built_in">max</span>(prev[<span class="built_in">ls</span>(x)],(prev[<span class="built_in">ls</span>(x)] == len <span class="keyword">and</span> raw[m<span class="number">-1</span>] &lt;= raw[m])?prev[<span class="built_in">ls</span>(x)] + prev[<span class="built_in">rs</span>(x)]:<span class="number">0</span>);</span><br><span class="line">		sufv[x] = <span class="built_in">max</span>(sufv[<span class="built_in">rs</span>(x)],(sufv[<span class="built_in">rs</span>(x)] == len <span class="keyword">and</span> raw[m<span class="number">-1</span>] &lt;= raw[m])?sufv[<span class="built_in">rs</span>(x)] + sufv[<span class="built_in">ls</span>(x)]:<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)&#123;</span><br><span class="line">			raw[idx] = v;</span><br><span class="line">			prev[x] = sufv[x] = totv[x] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(lx &lt;= idx <span class="keyword">and</span> idx &lt; m)<span class="built_in">Set</span>(idx,v,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">Set</span>(idx,v,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="built_in">pushup</span>(x,lx,rx);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		<span class="built_in">Set</span>(idx,v,<span class="number">0</span>,<span class="number">0</span>,siz);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">cal</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)<span class="keyword">return</span> totv[x];</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		ll s1 = <span class="built_in">cal</span>(l,r,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		ll s2 = <span class="built_in">cal</span>(l,r,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		ll ans = s1+s2;</span><br><span class="line">		<span class="keyword">if</span>(raw[m<span class="number">-1</span>] &lt;= raw[m])&#123;</span><br><span class="line">			ans += <span class="built_in">max</span>(<span class="built_in">min</span>(m - l,sufv[<span class="built_in">ls</span>(x)]),<span class="number">0LL</span>)*<span class="built_in">max</span>(<span class="built_in">min</span>(r - m,prev[<span class="built_in">rs</span>(x)]),<span class="number">0LL</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">cal</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		r++;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">cal</span>(l,r,<span class="number">0</span>,<span class="number">0</span>,siz);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">setf</span>(ios::fixed,ios::floatfield);</span><br><span class="line">	cout.<span class="built_in">precision</span>(<span class="number">12</span>);	 </span><br><span class="line">	<span class="keyword">int</span> n,q;</span><br><span class="line">	Segtree seg;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)raw[i] = <span class="number">0</span>;</span><br><span class="line">	seg.<span class="built_in">init</span>(n+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> v;</span><br><span class="line">		cin &gt;&gt; v;</span><br><span class="line">		seg.<span class="built_in">Set</span>(i,v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(q--)&#123;</span><br><span class="line">		<span class="keyword">int</span> opt,l,r;</span><br><span class="line">		cin &gt;&gt; opt &gt;&gt; l &gt;&gt; r;</span><br><span class="line">		<span class="keyword">if</span>(opt == <span class="number">1</span>)seg.<span class="built_in">Set</span>(l,r);</span><br><span class="line">		<span class="keyword">else</span> cout &lt;&lt; seg.<span class="built_in">cal</span>(l,r) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]HDU7059-Counting Stars</title>
    <url>/2021/09/16/solution-HDU7059/</url>
    <content><![CDATA[<h2 id="题意">题意</h2>
<p>本题是2021东北四省赛<a href="https://codeforces.com/gym/103145/problem/D">D-Lowbit</a> 的强化版.</p>
<p>给出一个长度为<span class="math inline">\(n\)</span>的数列<span class="math inline">\(raw[]\)</span>, 维护下列三种操作:</p>
<p><code>1 l r</code>查询<span class="math inline">\(raw[l] + raw[l+1] + ... + raw[r]\)</span>对<span class="math inline">\(998244353\)</span>取模的值</p>
<p><code>2 l r</code>对区间<span class="math inline">\([l,r]\)</span>里的每个值分别减去其lowbit</p>
<p><code>3 l r</code>对区间<span class="math inline">\([l,r]\)</span>里的每个值分别加上其最高位的值</p>
<p><span class="math inline">\(1 \leq n,q \leq 10^5\)</span></p>
<h2 id="题解">题解</h2>
<p>容易发现对于操作2, 每个数<span class="math inline">\(a_i\)</span>在减去最多<span class="math inline">\(\log a_i\)</span>次后就会变成0. 因而我们暴力模拟这个过程, 同时用<span class="math inline">\(full[x] = 1\)</span>表示该节点下的所有值全部为0, 在之后的操作2中将这种节点忽略即可.</p>
<p>对于操作3, 只需把最高位拆出来单独维护即可. 注意操作2会影响到拆出来的最高位.</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="function">mt19937 <span class="title">Rand</span><span class="params">(chrono::steady_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">10</span>;<span class="comment">//CHANGE IT!</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = maxn*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">998244353</span>;<span class="comment">//CHANGE IT!</span></span><br><span class="line"><span class="keyword">int</span> p2[maxn];</span><br><span class="line"><span class="function">ll <span class="title">Pow</span><span class="params">(ll x,ll d)</span></span>&#123;ll ta=<span class="number">1</span>;<span class="keyword">if</span>(d==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>%p;x %= p;ll a=<span class="built_in">Pow</span>(x,d/<span class="number">2</span>);ta=a*a%p;<span class="keyword">if</span>(d%<span class="number">2</span>)ta=ta*x%p;<span class="keyword">return</span> ta%p;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segtree</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> siz = <span class="number">1</span>;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;hbit,addv,subv,sumv;</span><br><span class="line">	vector&lt;<span class="keyword">bool</span>&gt;full;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(siz &lt; n)siz *= <span class="number">2</span>;</span><br><span class="line">		hbit.<span class="built_in">assign</span>(siz*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">		addv.<span class="built_in">assign</span>(siz*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">		sumv.<span class="built_in">assign</span>(siz*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">		full.<span class="built_in">assign</span>(siz*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">highbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">30</span>;i &gt;= <span class="number">0</span>;i--)<span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;i)&amp;x)<span class="keyword">return</span> (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(full[<span class="built_in">ls</span>(x)] <span class="keyword">and</span> full[<span class="built_in">rs</span>(x)])full[x] = <span class="number">1</span>;</span><br><span class="line">		sumv[x] = (sumv[<span class="built_in">ls</span>(x)] + sumv[<span class="built_in">rs</span>(x)])%p;</span><br><span class="line">		hbit[x] = (hbit[<span class="built_in">ls</span>(x)] + hbit[<span class="built_in">rs</span>(x)])%p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(addv[x])&#123;</span><br><span class="line">			<span class="keyword">int</span> &amp; v = addv[x];</span><br><span class="line">			addv[<span class="built_in">ls</span>(x)] += v,addv[<span class="built_in">rs</span>(x)] += v;</span><br><span class="line">			hbit[<span class="built_in">ls</span>(x)] = (hbit[<span class="built_in">ls</span>(x)] * p2[v])%p;</span><br><span class="line">			hbit[<span class="built_in">rs</span>(x)] = (hbit[<span class="built_in">rs</span>(x)] * p2[v])%p;</span><br><span class="line">			v = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp; in,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(lx &lt; (<span class="keyword">int</span>)in.<span class="built_in">size</span>())&#123;</span><br><span class="line">				<span class="keyword">int</span> h = <span class="built_in">highbit</span>(in[lx]);</span><br><span class="line">				hbit[x] = h;</span><br><span class="line">				in[lx] -= h;</span><br><span class="line">				sumv[x] = in[lx];</span><br><span class="line">				<span class="keyword">if</span>(!sumv[x] <span class="keyword">and</span> !hbit[x])full[x] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">build</span>(in,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="built_in">build</span>(in,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="built_in">pushup</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp; in)</span></span>&#123;</span><br><span class="line">		<span class="built_in">build</span>(in,<span class="number">0</span>,<span class="number">0</span>,siz);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx &gt; <span class="number">1</span>)<span class="built_in">pushdown</span>(x);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			hbit[x] = (hbit[x]*<span class="number">2</span>)%p;</span><br><span class="line">			addv[x]++;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">add</span>(l,r,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="built_in">add</span>(l,r,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="built_in">pushup</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		r++;</span><br><span class="line">		<span class="built_in">add</span>(l,r,<span class="number">0</span>,<span class="number">0</span>,siz);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx &gt; <span class="number">1</span>)<span class="built_in">pushdown</span>(x);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			<span class="keyword">if</span>(full[x])&#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(!sumv[x])&#123;</span><br><span class="line">					full[x] = <span class="number">1</span>;</span><br><span class="line">					hbit[x] = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				sumv[x] -= <span class="built_in">lowbit</span>(sumv[x]);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">sub</span>(l,r,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="built_in">sub</span>(l,r,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="built_in">pushup</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		r++;</span><br><span class="line">		<span class="built_in">sub</span>(l,r,<span class="number">0</span>,<span class="number">0</span>,siz);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx &gt; <span class="number">1</span>)<span class="built_in">pushdown</span>(x);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			<span class="keyword">return</span> (sumv[x] + hbit[x])%p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		ll s1 = <span class="built_in">sum</span>(l,r,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		ll s2 = <span class="built_in">sum</span>(l,r,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="keyword">return</span> (s1+s2)%p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		r++;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">sum</span>(l,r,<span class="number">0</span>,<span class="number">0</span>,siz);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">setf</span>(ios::fixed,ios::floatfield);</span><br><span class="line">	cout.<span class="built_in">precision</span>(<span class="number">12</span>);</span><br><span class="line">	p2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; maxn;i++)p2[i] = p2[i<span class="number">-1</span>]*<span class="number">2</span>%p;	 </span><br><span class="line">	<span class="keyword">int</span> __;</span><br><span class="line">	cin &gt;&gt; __;</span><br><span class="line">	<span class="keyword">while</span>(__--)&#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">in</span>(n+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)cin &gt;&gt; in[i];</span><br><span class="line">		Segtree seg;</span><br><span class="line">		seg.<span class="built_in">init</span>(n+<span class="number">10</span>);</span><br><span class="line">		seg.<span class="built_in">build</span>(in);</span><br><span class="line">		<span class="keyword">int</span> q;</span><br><span class="line">		cin &gt;&gt; q;</span><br><span class="line">		<span class="keyword">while</span>(q--)&#123;</span><br><span class="line">			<span class="keyword">int</span> opt,l,r;</span><br><span class="line">			cin &gt;&gt; opt &gt;&gt; l &gt;&gt; r;</span><br><span class="line">			<span class="keyword">if</span>(opt == <span class="number">1</span>)cout &lt;&lt; seg.<span class="built_in">sum</span>(l,r) &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">2</span>)seg.<span class="built_in">sub</span>(l,r);</span><br><span class="line">			<span class="keyword">else</span> seg.<span class="built_in">add</span>(l,r);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>solution-ABC213E</title>
    <url>/2021/10/17/solution-ABC213E/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>[题解]CF1610D-Not Quite Lee</title>
    <url>/2021/11/24/solution-CF1610D/</url>
    <content><![CDATA[<p>经典我是傻逼环节.</p>
<h2 id="题意">题意</h2>
<p>给出长度为<span class="math inline">\(n\)</span>的数组<span class="math inline">\(A = \{a_i\}\)</span>, <span class="math inline">\(1 \leq n \leq 2 \cdot 10^5,1 \leq a_i \leq 10^9\)</span>.</p>
<p>对于<span class="math inline">\(A\)</span>的任意长度为<span class="math inline">\(m\)</span>的非空子序列<span class="math inline">\(B = \{b_1,b_2,..,b_m\}\)</span>, 定义<span class="math inline">\(f(b_i,k_i) = \sum_{j = 0}^{b_i} (j + k_i)\)</span>, 其中<span class="math inline">\(k_i\)</span>为任意整数. 一个子序列<span class="math inline">\(B\)</span>合法当且仅当 $ {k_i} |_{i = 1}^mf(b_i,k_i) = 0$.</p>
<p>求<span class="math inline">\(A\)</span>中全部合法子序列数量模<span class="math inline">\(10^9+7\)</span>.</p>
<h2 id="题解">题解</h2>
<p>首先我们考虑如何判断某个序列是否合法. 有<span class="math inline">\(f(b_i,k_i) = \frac{b_i\cdot(b_i + 1)}{2} + k_i\cdot b_i\)</span>, 那么<span class="math inline">\(\sum_{i = 1}^mf(b_i,k_i) = 0\)</span>可以转化为<span class="math inline">\(\sum_{i = 0}^m{\frac{b_i\cdot (b_i + 1)}{2}} = \sum_{i = 0}^m k_i \cdot b_i\)</span>. 这是一个一次不定方程. 设<span class="math inline">\(g = gcd(b_1,b_2,...,b_m)\)</span>, 当且仅当<span class="math inline">\(g | \sum_{i = 0}^m \frac{b_i \cdot (b_i+1)}{2}\)</span>时有整数解.</p>
<p>手画一下几组样例可以看出, 当序列中存在奇数时必定合法. 当序列中存在至少一个奇数时, 显然<span class="math inline">\(g\)</span>也是奇数. 那么对于每个<span class="math inline">\(\frac{b_i \cdot (b_i + 1)}{2}\)</span>, 如果<span class="math inline">\(b_i\)</span>是偶数有<span class="math inline">\(g | \frac{b_i}{2}\)</span>, 否则有<span class="math inline">\(g|(b_i + 1)\)</span> 且<span class="math inline">\(\frac{b_i}{2}\)</span>为整数. 因而序列中存在奇数时必有<span class="math inline">\(g | \sum_{i = 0}^m \frac{b_i \cdot (b_i+1)}{2}\)</span>.</p>
<p>设<span class="math inline">\(A\)</span>中奇数个数为<span class="math inline">\(odd\)</span>, 这一部分对答案的贡献为<span class="math inline">\((2^{odd} - 1) \cdot 2^{n-odd}\)</span></p>
<p>现在考虑序列中全为偶数的情况. 设<span class="math inline">\(h\)</span>是最大的使得<span class="math inline">\(2^h | g\)</span>的非负整数. 我们可以把<span class="math inline">\(g\)</span>拆分为<span class="math inline">\(g&#39; \cdot 2^h\)</span>. 显然<span class="math inline">\(g&#39;\)</span>为奇数. 根据上一段的讨论, 有<span class="math inline">\(g&#39; | \sum_{i = 0}^m \frac{b_i \cdot (b_i + 1)}{2}\)</span>. <strong>因而全为偶数的序列是否合法取决于</strong><span class="math inline">\(2^h\)</span><strong>能否整除</strong><span class="math inline">\(\sum_{i = 0}^m \frac{b_i \cdot (b_i + 1)}{2}\)</span>. 对于每个<span class="math inline">\(b_i\)</span>, 设<span class="math inline">\(l\)</span>是最大的使得<span class="math inline">\(2^l|b_i\)</span>的非负整数. <span class="math inline">\(l\)</span>可以分三种情况来讨论:</p>
<ul>
<li><p><span class="math inline">\(l &gt; h\)</span>.</p>
<p>此时有<span class="math inline">\(2^h | \frac{b_i}{2}\)</span>, 所以<span class="math inline">\(2^h | \frac{b_i \cdot(b_i + 1)}{2}\)</span>.</p></li>
<li><p><span class="math inline">\(l = h\)</span>.</p>
<p>此时<span class="math inline">\(2^h \nmid \frac{b_i}{2}\)</span>且<span class="math inline">\(b_i + 1\)</span>是奇数, 因此<span class="math inline">\(2^h \nmid \frac{b_i \cdot(b_i + 1)}{2}\)</span>. 由于<span class="math inline">\(\frac{b_i \cdot(b_i + 1)}{2 \cdot g&#39;} \mod 2^h = 2^{h-1}\)</span>, 如果这种情况下的<span class="math inline">\(b_i\)</span>个数有偶数个, 那它们的和仍然可以被<span class="math inline">\(2^h\)</span>整除.</p></li>
<li><p><span class="math inline">\(l &lt; h\)</span>. 由于<span class="math inline">\(g \geq 2^h\)</span>, 不可能存在这种情况.</p></li>
</ul>
<p>综上可知, 当序列中全为偶数时, 按能被<span class="math inline">\(2^l\)</span>整除的最大<span class="math inline">\(l\)</span>来对<span class="math inline">\(b_i\)</span>分类, 当且仅当<span class="math inline">\(l\)</span>最小那组的个数为偶数时序列合法. 在统计时可以枚举最小的<span class="math inline">\(l\)</span>.</p>
<p>总时间复杂度<span class="math inline">\(n \log (\max\{a_i\})\)</span></p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="function">mt19937 <span class="title">Rand</span><span class="params">(chrono::steady_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">10</span>;<span class="comment">//CHANGE IT!</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = maxn*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">1e9</span>+<span class="number">7</span>;<span class="comment">//CHANGE IT!</span></span><br><span class="line">ll fac[maxn],cnt[maxn];</span><br><span class="line"><span class="function">ll <span class="title">Pow</span><span class="params">(ll x,ll d,ll p = p)</span></span>&#123;ll ta=<span class="number">1</span>;<span class="keyword">if</span>(d==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>%p;x %= p;ll a=<span class="built_in">Pow</span>(x,d/<span class="number">2</span>,p);ta=a*a%p;<span class="keyword">if</span>(d%<span class="number">2</span>)ta=ta*x%p;<span class="keyword">return</span> ta%p;&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n,ll m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(m &gt; n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> (fac[n]*<span class="built_in">Pow</span>(fac[m],p<span class="number">-2</span>)%p*<span class="built_in">Pow</span>(fac[n-m],p<span class="number">-2</span>)%p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">setf</span>(ios::fixed,ios::floatfield);</span><br><span class="line">	cout.<span class="built_in">precision</span>(<span class="number">12</span>);	 </span><br><span class="line">	fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; maxn;i++)fac[i] = fac[i<span class="number">-1</span>]*i%p;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">int</span> odd = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		<span class="keyword">if</span>(x&amp;<span class="number">1</span>)odd++;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">int</span> qwq = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(x%<span class="number">2</span> == <span class="number">0</span>)qwq++,x /= <span class="number">2</span>;</span><br><span class="line">			cnt[qwq+<span class="number">1</span>]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans = (<span class="built_in">Pow</span>(<span class="number">2</span>,odd) - <span class="number">1</span> + p)%p*(<span class="built_in">Pow</span>(<span class="number">2</span>,n - odd)) % p;</span><br><span class="line">	ll res = n - odd;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= <span class="number">32</span>;k++)<span class="keyword">if</span>(cnt[k])&#123;</span><br><span class="line">		ll tmp = <span class="number">0</span>;</span><br><span class="line">		res -= cnt[k];</span><br><span class="line">		ans = (ans + (<span class="built_in">Pow</span>(<span class="number">2</span>,cnt[k] - <span class="number">1</span>) - <span class="number">1</span> + p)%p * <span class="built_in">Pow</span>(<span class="number">2</span>,res) % p) % p;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>-题解</category>
      </categories>
      <tags>
        <tag>-数学 -构造 -题解</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]CF1625D-Binary Spiders</title>
    <url>/2022/01/13/solution-CF1625D/</url>
    <content><![CDATA[<h2 id="题意">题意</h2>
<p>给出<span class="math inline">\(n\)</span>个数<span class="math inline">\(a_i\)</span>, 和一个整数<span class="math inline">\(k\)</span>. 从这<span class="math inline">\(n\)</span>个数中选出尽可能多的数, 使得它们之间任意两者按位异或后大于等于<span class="math inline">\(k\)</span>. 输出数字的个数和下标, 如果不存在则输出<span class="math inline">\(-1\)</span>.</p>
<p><span class="math inline">\(2 \le n \le 3 \cdot 10^5, 0 \leq a_i,k \leq 2^{30} - 1\)</span></p>
<h2 id="题解">题解</h2>
<p>设<span class="math inline">\(k\)</span>的最高位是第<span class="math inline">\(h\)</span>位. 首先会很自然的想到——如果把每个数位数小于等于<span class="math inline">\(h\)</span>的部分变为0, 按此分类, 从每种里选出一个数字加入答案里一定合法. 因为任意两个数字异或后都至少有一个高于<span class="math inline">\(h\)</span>的位为<span class="math inline">\(1\)</span>. 以样例<span class="math inline">\(k = 8(1000)\)</span>为例:</p>
<table>
<thead>
<tr class="header">
<th>原始</th>
<th>2(10)</th>
<th>8(1000)</th>
<th>4(100)</th>
<th>16(10000)</th>
<th>10(1010)</th>
<th>14(1110)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>处理后组别</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>16(10000)</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>此时我们选择<span class="math inline">\(16\)</span>, 再从<span class="math inline">\(2,8,4,10,14\)</span>里任选一个都能组成一个解，但它不是最优的: 例如在<span class="math inline">\(0\)</span>这一组里选择<span class="math inline">\(2\)</span>和<span class="math inline">\(10\)</span>加入答案也是合法解.</p>
<p>进一步思考可以发现, 在每一组里有可能可以选择两个数字且最多只能选择两个. 如果选择了超过两个数字, 那么至少有两个数字在第<span class="math inline">\(h\)</span>位上是一样的, 这会导致异或后的结果小于<span class="math inline">\(k\)</span>. 使用Trie判断是否有解即可.</p>
<p>注意需要特判<span class="math inline">\(k = 0\)</span>的情况.</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="function">mt19937 <span class="title">Rand</span><span class="params">(chrono::steady_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e5</span>+<span class="number">10</span>;<span class="comment">//CHANGE IT!</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = maxn*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxc = <span class="number">1e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">1e9</span>+<span class="number">7</span>;<span class="comment">//CHANGE IT!</span></span><br><span class="line"><span class="function">ll <span class="title">Pow</span><span class="params">(ll x,ll d,ll p)</span></span>&#123;ll ta=<span class="number">1</span>;<span class="keyword">if</span>(d==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>%p;x %= p;ll a=<span class="built_in">Pow</span>(x,d/<span class="number">2</span>,p);ta=a*a%p;<span class="keyword">if</span>(d%<span class="number">2</span>)ta=ta*x%p;<span class="keyword">return</span> ta%p;&#125;</span><br><span class="line">ll raw[maxn],u[maxn],siz;</span><br><span class="line"><span class="keyword">int</span> nxt[maxc][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> w[maxc*<span class="number">2</span>];</span><br><span class="line">map&lt;<span class="keyword">int</span>,vector&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; &gt;hsh;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">30</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">int</span> c = ((s&gt;&gt;i)&amp;<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(nxt[u][c] == <span class="number">-1</span>)nxt[u][c] = ++siz;</span><br><span class="line">		u = nxt[u][c];</span><br><span class="line">	&#125;</span><br><span class="line">	w[u] = idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> u = <span class="number">0</span>,res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">30</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">int</span> c = ((x&gt;&gt;i)&amp;<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(nxt[u][c^<span class="number">1</span>] != <span class="number">-1</span>)&#123;</span><br><span class="line">			res += (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">			u = nxt[u][c^<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(nxt[u][c] != <span class="number">-1</span>)&#123;</span><br><span class="line">			u = nxt[u][c];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(res &lt; k)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> w[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= siz;i++)&#123;</span><br><span class="line">		nxt[i][<span class="number">0</span>] = nxt[i][<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">		w[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	siz = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(nxt,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(nxt));</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">setf</span>(ios::fixed,ios::floatfield);</span><br><span class="line">	cout.<span class="built_in">precision</span>(<span class="number">12</span>);	 </span><br><span class="line">	<span class="keyword">int</span> n,k;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="keyword">if</span>(!k)&#123;</span><br><span class="line">		cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">30</span>;i &gt;= <span class="number">0</span>;i--)<span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;i)&amp;k)&#123;</span><br><span class="line">		h = i;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	set&lt;<span class="keyword">int</span>&gt;great,res;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;gidx;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		cin &gt;&gt; raw[i];</span><br><span class="line">		u[i] = raw[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = h;j &gt;= <span class="number">0</span>;j--)<span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;j)&amp;u[i])u[i] -= (<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">		cerr &lt;&lt; u[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		hsh[u[i]].<span class="built_in">push_back</span>(&#123;raw[i],i&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;ans;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> it:hsh)&#123;</span><br><span class="line">		vector&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; &amp; r = it.second;</span><br><span class="line">		<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> it2:r)<span class="built_in">insert</span>(it2.first,it2.second);</span><br><span class="line">		<span class="keyword">bool</span> ok = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> it2:r)&#123;</span><br><span class="line">			<span class="keyword">int</span> x = <span class="built_in">query</span>(it2.first,k);</span><br><span class="line">			<span class="keyword">if</span>(x != <span class="number">-1</span>)&#123;</span><br><span class="line">				ans.<span class="built_in">push_back</span>(it2.second);</span><br><span class="line">				ans.<span class="built_in">push_back</span>(x);</span><br><span class="line">				ok = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!ok <span class="keyword">and</span> r.<span class="built_in">size</span>())ans.<span class="built_in">push_back</span>(r[<span class="number">0</span>].second);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ans.<span class="built_in">size</span>() &lt; <span class="number">2</span>)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x:ans)cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>Trie</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]-CF1626E Black and White Tree</title>
    <url>/2022/01/19/solution-CF1626E/</url>
    <content><![CDATA[<h2 id="题意">题意</h2>
<p>给出一个大小为<span class="math inline">\(n\)</span> <span class="math inline">\((n\leq 3 \cdot 10^5)\)</span>的树, 树上每个节点被染成白色或者黑色. 假设当前在点<span class="math inline">\(k\)</span>有一个棋子, 你每次可以选择一个黑点<span class="math inline">\(b\)</span>作为目标点, 将这个棋子向黑点按从<span class="math inline">\(k\)</span>到<span class="math inline">\(b\)</span>的最短路径移动一格(一条边). 连续两次操作选择的黑点不能相同. 对于所有的<span class="math inline">\(k = 1...n\)</span>, 判断该棋子是否能在有限步操作后移动到任意一个黑点. 能移动到则该点答案为<span class="math inline">\(1\)</span>否则为<span class="math inline">\(0\)</span>.</p>
<h2 id="题解">题解</h2>
<p>首先显然黑点和与黑点相邻的白点答案均为<span class="math inline">\(1\)</span>. 对于其它白点, 当且仅当它所在的某条链上有至少两个黑点时它才能移动到黑点上. 这种情况有一个特例:</p>
<figure>
<img src="https://raw.githubusercontent.com/LinkinPony/hexo_pic_bed/master/img/image-20220119220348299.png" alt="image-20220119220348299" /><figcaption aria-hidden="true">image-20220119220348299</figcaption>
</figure>
<p>如图, 尽管1不在任意一条有两个黑点的链上, 但它仍然能到达黑点5, 只要交替选择5, 7两个点即可.</p>
<p>为了解决这种特殊情况, 我们把黑点及与黑点相邻的白点缩成一个点(如果有两个相邻的黑点那么显然答案全为1. 如果不进行特判的话就需要把在同一联通分量里的黑点缩成一个点)</p>
<figure>
<img src="https://raw.githubusercontent.com/LinkinPony/hexo_pic_bed/master/img/image-20220119221543385.png" alt="image-20220119221543385" /><figcaption aria-hidden="true">image-20220119221543385</figcaption>
</figure>
<p>缩点之后如图. 这样1便在有两个黑点的链上了.</p>
<p>判断每个点是否在有不少于两个黑点的链上可以用换根dp求. 首先指定一个根<span class="math inline">\(r\)</span>, <span class="math inline">\(siz[u]\)</span>表示以<span class="math inline">\(u\)</span>为根的子树里拥有黑点数最大的链的黑点数目. 换根dp的具体细节见代码中<code>dfs2()</code>. 需要注意的是缩点之后可能不存在<span class="math inline">\(1\)</span>这个点.</p>
<p>时间复杂度<span class="math inline">\(O(n)\)</span>.</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="function">mt19937 <span class="title">Rand</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e5</span>+<span class="number">10</span>;<span class="comment">//CHANGE IT!</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = maxn*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">1e9</span>+<span class="number">7</span>;<span class="comment">//CHANGE IT!</span></span><br><span class="line"><span class="function">ll <span class="title">Pow</span><span class="params">(ll x,ll d,ll p)</span></span>&#123;ll ta=<span class="number">1</span>;<span class="keyword">if</span>(d==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>%p;x %= p;ll a=<span class="built_in">Pow</span>(x,d/<span class="number">2</span>,p);ta=a*a%p;<span class="keyword">if</span>(d%<span class="number">2</span>)ta=ta*x%p;<span class="keyword">return</span> ta%p;&#125;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;G[maxn],G2[maxn];</span><br><span class="line"><span class="keyword">int</span> cli[maxn],w[maxn],ans[maxn],siz[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	cli[u] = r;</span><br><span class="line">	ans[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(r != u)w[r] += w[u];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> v:G2[u])&#123;</span><br><span class="line">		<span class="keyword">if</span>(v == fa)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(w[u] <span class="keyword">and</span> !ans[v])<span class="built_in">pre</span>(v,u,r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> v:G[u])&#123;</span><br><span class="line">		<span class="keyword">if</span>(v == fa)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(v,u);</span><br><span class="line">		siz[u] = <span class="built_in">max</span>(siz[u],siz[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	siz[u] += w[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa,<span class="keyword">int</span> res)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tot = <span class="number">0</span>,mx1 = <span class="number">0</span>,mx2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> v:G[u])&#123;</span><br><span class="line">		<span class="keyword">if</span>(v == fa)<span class="keyword">continue</span>;</span><br><span class="line">		tot = <span class="built_in">max</span>(tot,siz[v]);</span><br><span class="line">		<span class="keyword">if</span>(siz[v] &gt;= mx1)&#123;</span><br><span class="line">			mx2 = mx1;</span><br><span class="line">			mx1 = siz[v];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(siz[v] &gt; mx2)mx2 = siz[v];</span><br><span class="line">	&#125;</span><br><span class="line">	tot = <span class="built_in">max</span>(tot,res) + w[u];</span><br><span class="line">	<span class="keyword">if</span>(res &gt;= mx1)&#123;</span><br><span class="line">		mx2 = mx1;</span><br><span class="line">		mx1 = res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(res &gt; mx2)mx2 = res;</span><br><span class="line">	<span class="keyword">if</span>(tot &gt; <span class="number">1</span>)ans[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> v:G[u])&#123;</span><br><span class="line">		<span class="keyword">if</span>(v == fa)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">int</span> rw = w[u] + (mx1 == siz[v]?mx2:mx1);</span><br><span class="line">		<span class="built_in">dfs2</span>(v,u,rw);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">setf</span>(ios::fixed,ios::floatfield);</span><br><span class="line">	cout.<span class="built_in">precision</span>(<span class="number">12</span>);	 </span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)cin &gt;&gt; w[i],cli[i] = i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> f,t;</span><br><span class="line">		cin &gt;&gt; f &gt;&gt; t;</span><br><span class="line">		G2[f].<span class="built_in">push_back</span>(t);</span><br><span class="line">		G2[t].<span class="built_in">push_back</span>(f);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)<span class="keyword">if</span>(w[i] <span class="keyword">and</span> cli[i] == i)<span class="built_in">pre</span>(i,<span class="number">-1</span>,i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">1</span>;u &lt;= n;u++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> v:G2[u])&#123;</span><br><span class="line">			<span class="keyword">if</span>(cli[u] == cli[v])<span class="keyword">continue</span>;</span><br><span class="line">			G[cli[u]].<span class="built_in">push_back</span>(cli[v]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(cli[i] == i)&#123;</span><br><span class="line">			<span class="built_in">dfs</span>(i,<span class="number">-1</span>);</span><br><span class="line">			<span class="built_in">dfs2</span>(i,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$$</p>
<p>$$</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>构造</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title>solution-CF1625E1</title>
    <url>/2022/01/22/solution-CF1625E1/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>[题解]Gym103495-H Reverse the String</title>
    <url>/2022/03/11/solution-Gym103495-H/</url>
    <content><![CDATA[<p>中规中矩的字符串题.</p>
<h2 id="题意">题意</h2>
<p>给出一个字符串<span class="math inline">\(s\)</span>, 你可以选取<span class="math inline">\(s\)</span>的任意子串将其翻转得到<span class="math inline">\(s&#39;\)</span>, 该操作最多进行一次. 求字典序最小的<span class="math inline">\(s&#39;\)</span>.</p>
<p><span class="math inline">\(|s| \leq 10^5, \sum |s| \leq 1.5 \cdot 10 ^ 6\)</span></p>
<h2 id="题解">题解</h2>
<p>以下字符串的下标均从<span class="math inline">\(0\)</span>开始. <span class="math inline">\(lcp(s,t)\)</span>代表<span class="math inline">\(s\)</span>和<span class="math inline">\(t\)</span>的最长公共前缀. <span class="math inline">\(rev(s)\)</span>表示将<span class="math inline">\(s\)</span>翻转后的字符串.</p>
<h3 id="part-1优化做法">part 1：优化做法</h3>
<p>设<span class="math inline">\(n = |s|\)</span>, 朴素的暴力需要至少<span class="math inline">\(O(n^2)\)</span>​来枚举翻转子串的两个端点<span class="math inline">\(L,R\)</span>. 我们需要想办法固定住其中的一个端点.</p>
<p>首先尝试放开限制, 把翻转变成任意排列. 这样将<span class="math inline">\(s\)</span>排序后得到的<span class="math inline">\(s&#39;\)</span>一定是最优的. 记这样的<span class="math inline">\(s&#39;\)</span>为<span class="math inline">\(t\)</span>.</p>
<p>回到原题, 容易看出, <span class="math inline">\(s\)</span>和<span class="math inline">\(t\)</span>的最长公共前缀部分无论我们如何操作都不可能再让字典序变小, 而在这之后的部分是有可能减小字典序的. 且因为字典序的性质(比较第一个不相同的字符), 我们必须尝试让<span class="math inline">\(s&#39;\)</span>和<span class="math inline">\(t\)</span>不同的第一个字符最小. 因此<span class="math inline">\(L = lcp(s,t)\)</span>.</p>
<h3 id="part-2快速比较两字符串大小">part 2：快速比较两字符串大小</h3>
<p>设当前的最优答案为<span class="math inline">\(ans\)</span>, 在固定了<span class="math inline">\(L\)</span>之后, 只需<span class="math inline">\(O(n)\)</span>枚举<span class="math inline">\(R\)</span>, 并快速比较<span class="math inline">\(ans\)</span>和<span class="math inline">\(s&#39;\)</span>的大小即可. 这里可以用<span class="math inline">\(lcp\)</span>来比较两个字符串的大小.</p>
<p>设需要比较<span class="math inline">\(A = s[a...b]\)</span>和<span class="math inline">\(B = s[c...d]\)</span>的关系. 若<span class="math inline">\(lcp(a,c) \ge \min(|A|,|B|)\)</span>,则<span class="math inline">\(A &lt; B\)</span>等价于<span class="math inline">\(|A| &lt; |B|\)</span> 否则, <span class="math inline">\(A &lt; B\)</span>等价于<span class="math inline">\(rank[a] &lt; rank[c]\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CompString</span><span class="params">(<span class="keyword">int</span> s1,<span class="keyword">int</span> len1,<span class="keyword">int</span> s2,<span class="keyword">int</span> len2)</span></span>&#123;</span><br><span class="line">    	<span class="comment">//s:子串起始位置 len:子串长度</span></span><br><span class="line">		<span class="keyword">int</span> tlcp = (s1 == s2?<span class="built_in">min</span>(len1,len2):<span class="built_in">LCP</span>(s1,s2));</span><br><span class="line">		<span class="keyword">if</span>(tlcp &gt;= <span class="built_in">min</span>(len1,len2))&#123;</span><br><span class="line">			<span class="keyword">return</span> len1 &lt; len2?<span class="number">-1</span>:(len1 == len2?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> c[s1] &lt; c[s2]?<span class="number">-1</span>:(c[s1] == c[s2]?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>注意: 可以只用<span class="math inline">\(lcp\)</span>来比较字符串大小(这样就可以用hash等方法来求<span class="math inline">\(lcp\)</span>而不用写SA). 只要把上面的第6行替换为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> s[s1 + tlcp] &lt; s[s2 + tlcp]?<span class="number">-1</span>:(s[s1 + tlcp] == s[s2 + tlcp]?<span class="number">0</span>:<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>即可.</p>
<h3 id="part-3-细节部分">part 3 ：细节部分</h3>
<p>首先将整个翻转后的<span class="math inline">\(s\)</span>拼接在原字符串后, 中间用特殊字符隔开, 例如<code>u = s + "$" + rev(s)</code>. 再使用后缀数组处理<span class="math inline">\(u\)</span>. 这样在原串中位置为<span class="math inline">\(i\)</span>的字符, 在反串中的位置就是<span class="math inline">\(2*n - i\)</span>.</p>
<p>假设当前枚举到<span class="math inline">\(R\)</span>, 最优答案为<span class="math inline">\(R&#39;\)</span>, 如下图:</p>
<p><img src="https://raw.githubusercontent.com/LinkinPony/hexo_pic_bed/master/img/image-20220318113847339.png" alt="image-20220318113847339" style="zoom:33%;" /></p>
<p>我们需要比较的是<span class="math inline">\(s[L,R&#39;-1] + rev(s[R&#39;,R])\)</span>和<span class="math inline">\(rev(s[L,R])\)</span>的大小, 如果后者更小则更新答案. 为了方便比较, 可以将每段字符划分成AB两段:</p>
<p><img src="https://raw.githubusercontent.com/LinkinPony/hexo_pic_bed/master/img/image-20220318114006215.png" alt="image-20220318114006215" style="zoom:33%;" /></p>
<p>现在需要比较的就是<span class="math inline">\(rev(A_1) + B_1\)</span>和<span class="math inline">\(rev(A_2) + rev(B_2)\)</span>的大小. 由于A, B长度分别相等, 可以用part2的方法分别比较<span class="math inline">\(rev(A_1)\)</span>与<span class="math inline">\(rev(A_2)\)</span>, <span class="math inline">\(B_1\)</span>与<span class="math inline">\(rev(B_2)\)</span>的大小</p>
<p>每段的(起始位置,长度)可以通过简单推导得到:</p>
<p><span class="math inline">\(rev(A_1)\)</span>: <span class="math inline">\((2*n - R&#39;,R&#39; - L + 1)\)</span></p>
<p><span class="math inline">\(rev(A2)\)</span>: <span class="math inline">\((2*n - R,R - L + 1)\)</span></p>
<p><span class="math inline">\(B_1\)</span>: <span class="math inline">\((R&#39; + 1,i - R&#39;)\)</span></p>
<p><span class="math inline">\(rev(B_2)\)</span>: <span class="math inline">\((2*n - R + R&#39; - L + 1,i - R&#39;)\)</span></p>
<p>其他细节见代码. 时间复杂度<span class="math inline">\(O(n \log n)\)</span>. jls好像有<span class="math inline">\(O(n)\)</span>做法, 有没有好哥哥教教QAQ</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">&quot;Ofast,unroll-loops&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC target(<span class="meta-string">&quot;avx,avx2,sse,sse2&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="function">mt19937 <span class="title">Rand</span><span class="params">(chrono::steady_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">10</span>;<span class="comment">//CHANGE IT!</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = maxn*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">1e9</span>+<span class="number">7</span>;<span class="comment">//CHANGE IT!</span></span><br><span class="line"><span class="function">ll <span class="title">Pow</span><span class="params">(ll x,ll d,ll p)</span></span>&#123;ll ta=<span class="number">1</span>;<span class="keyword">if</span>(d==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>%p;x %= p;ll a=<span class="built_in">Pow</span>(x,d/<span class="number">2</span>,p);ta=a*a%p;<span class="keyword">if</span>(d%<span class="number">2</span>)ta=ta*x%p;<span class="keyword">return</span> ta%p;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> a,b;</span><br><span class="line">	<span class="built_in">Node</span>(<span class="keyword">int</span> a = <span class="number">0</span>,<span class="keyword">int</span> b = <span class="number">0</span>):<span class="built_in">a</span>(a),<span class="built_in">b</span>(b)&#123;&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp; x)&#123;</span><br><span class="line">		<span class="keyword">return</span> a == x.a?b &lt; x.b:a &lt; x.a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">int</span> lcp[maxn],ST[maxn][<span class="number">20</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SA</span>&#123;</span></span><br><span class="line">	string s;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;sa,c;</span><br><span class="line">	<span class="built_in">SA</span>(string s = <span class="string">&quot;&quot;</span>):<span class="built_in">s</span>(s)&#123;</span><br><span class="line">		sa.<span class="built_in">clear</span>(),c.<span class="built_in">clear</span>();</span><br><span class="line">		s += <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">		n = s.<span class="built_in">size</span>();</span><br><span class="line">		sa.<span class="built_in">assign</span>(n,<span class="number">0</span>);</span><br><span class="line">		c.<span class="built_in">assign</span>(n,<span class="number">0</span>); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">count_sort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp; sa,vector&lt;<span class="keyword">int</span>&gt; &amp; c)</span></span>&#123;</span><br><span class="line">		vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">pos</span>(n),<span class="built_in">cnt</span>(n),<span class="built_in">sa_new</span>(n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x:c)cnt[x]++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)pos[i] = pos[i<span class="number">-1</span>] + cnt[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x:sa)&#123;</span><br><span class="line">			<span class="keyword">int</span> d = c[x];</span><br><span class="line">			sa_new[pos[d]] = x;</span><br><span class="line">			pos[d]++;</span><br><span class="line">		&#125;</span><br><span class="line">		sa = sa_new;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//init</span></span><br><span class="line">		&#123;</span><br><span class="line">			vector&lt;Node&gt;<span class="built_in">A</span>(n);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)A[i] = <span class="built_in">Node</span>(s[i],i);</span><br><span class="line">			<span class="built_in">sort</span>(A.<span class="built_in">begin</span>(),A.<span class="built_in">end</span>());</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)sa[i] = A[i].b;</span><br><span class="line">			c[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">				c[sa[i]] = c[sa[i<span class="number">-1</span>]] + (A[i].a != A[i<span class="number">-1</span>].a);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;k) &lt; n)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)sa[i] = (sa[i] - (<span class="number">1</span>&lt;&lt;k) + n)%n;</span><br><span class="line">			<span class="built_in">count_sort</span>(sa,c);</span><br><span class="line">			vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">c_new</span>(n);</span><br><span class="line">			c_new[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">				pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;now = &#123;c[sa[i]],c[(sa[i] + (<span class="number">1</span>&lt;&lt;k)) % n]&#125;;</span><br><span class="line">				pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;prev = &#123;c[sa[i<span class="number">-1</span>]],c[(sa[i<span class="number">-1</span>] + (<span class="number">1</span>&lt;&lt;k)) % n]&#125;;</span><br><span class="line">				c_new[sa[i]] = c_new[sa[i<span class="number">-1</span>]] + (now != prev);</span><br><span class="line">			&#125;</span><br><span class="line">			k++;</span><br><span class="line">			c = c_new;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ST_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)ST[i][<span class="number">0</span>] = lcp[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j) &lt;= n;j++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span>&lt;&lt;j) <span class="number">-1</span> &lt;= n;i++)</span><br><span class="line">				ST[i][j] = <span class="built_in">min</span>(ST[i][j - <span class="number">1</span>],ST[i + (<span class="number">1</span>&lt;&lt;(j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">LCP</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">		L = c[L],R = c[R];</span><br><span class="line">		<span class="keyword">if</span>(L &gt; R)<span class="built_in">swap</span>(L,R);</span><br><span class="line">		L++;</span><br><span class="line">		<span class="keyword">int</span> k = <span class="built_in">log2</span>(R - L + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">min</span>(ST[L][k],ST[R - (<span class="number">1</span>&lt;&lt;k) + <span class="number">1</span>][k]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getlcp</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> j = sa[c[i] - <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">while</span>(s[i+k] == s[j+k])k++;</span><br><span class="line">			lcp[c[i]] = k;</span><br><span class="line">			<span class="keyword">if</span>(k)k--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">ST_init</span>();</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">CompString</span><span class="params">(<span class="keyword">int</span> s1,<span class="keyword">int</span> len1,<span class="keyword">int</span> s2,<span class="keyword">int</span> len2)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> tlcp = (s1 == s2?<span class="built_in">min</span>(len1,len2):<span class="built_in">LCP</span>(s1,s2));</span><br><span class="line">		<span class="keyword">if</span>(tlcp &gt;= <span class="built_in">min</span>(len1,len2))&#123;</span><br><span class="line">			<span class="keyword">return</span> len1 &lt; len2?<span class="number">-1</span>:(len1 == len2?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> s[s1 + tlcp] &lt; s[s2 + tlcp]?<span class="number">-1</span>:(s[s1 + tlcp] == s[s2 + tlcp]?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;sa;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">setf</span>(ios::fixed,ios::floatfield);</span><br><span class="line">	cout.<span class="built_in">precision</span>(<span class="number">12</span>);	 </span><br><span class="line">	<span class="keyword">int</span> __;</span><br><span class="line">	cin &gt;&gt; __;</span><br><span class="line">	<span class="keyword">while</span>(__--)&#123;</span><br><span class="line">		string s;</span><br><span class="line">		cin &gt;&gt; s;</span><br><span class="line">		string u = s;</span><br><span class="line">		<span class="built_in">sort</span>(u.<span class="built_in">begin</span>(),u.<span class="built_in">end</span>());</span><br><span class="line">		<span class="keyword">int</span> L = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(s[i] != u[i])&#123;</span><br><span class="line">				L = i;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(L == <span class="number">-1</span>)&#123;</span><br><span class="line">			cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		u = s;</span><br><span class="line">		<span class="built_in">reverse</span>(u.<span class="built_in">begin</span>(),u.<span class="built_in">end</span>());</span><br><span class="line">		s = s + <span class="string">&quot;$&quot;</span> + u;</span><br><span class="line">		sa = <span class="built_in">SA</span>(s);</span><br><span class="line">		sa.<span class="built_in">cal</span>();</span><br><span class="line">		sa.<span class="built_in">getlcp</span>();</span><br><span class="line">		<span class="keyword">int</span> R = L;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = L;i &lt; n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(sa.<span class="built_in">CompString</span>(L,i - L + <span class="number">1</span>,<span class="number">2</span>*n - i,i - L + <span class="number">1</span>) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">int</span> x = sa.<span class="built_in">CompString</span>(<span class="number">2</span>*n - R,R - L + <span class="number">1</span>,<span class="number">2</span>*n - i,R - L + <span class="number">1</span>);</span><br><span class="line">				<span class="keyword">if</span>(x &gt; <span class="number">0</span>)&#123;</span><br><span class="line">					R = i;					</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="number">0</span> <span class="keyword">and</span> sa.<span class="built_in">CompString</span>(R + <span class="number">1</span>,i - R,<span class="number">2</span>*n - i + R - L + <span class="number">1</span>,i - R) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">					R = i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">reverse</span>(u.<span class="built_in">begin</span>(),u.<span class="built_in">end</span>());</span><br><span class="line">		<span class="built_in">reverse</span>(u.<span class="built_in">begin</span>() + L,u.<span class="built_in">begin</span>() + R + <span class="number">1</span>);</span><br><span class="line">		cout &lt;&lt; u &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]CF1642F - Two Arrays</title>
    <url>/2022/03/18/solution-CF1642F/</url>
    <content><![CDATA[<p>感觉这场F比E简单多了= =</p>
<h2 id="题意">题意</h2>
<p>给出一个<span class="math inline">\(n \times m\)</span>的数组 <span class="math inline">\((1 \leq n \leq 10^5,1 \leq m \leq 5)\)</span>. 数组的每一行元素均互不相同, 且每一行有一个权值<span class="math inline">\(w\)</span> <span class="math inline">\((1 \leq w \leq 10^9)\)</span>.</p>
<p>你需要找出不同的两行, 使得这两行在不存在重复元素的同时权值最小. 输出权值, 无解输出<code>-1</code>.</p>
<h2 id="题解">题解</h2>
<p>暴力做需要<span class="math inline">\(O(n^2m)\)</span>.</p>
<p>将行按权值排序, 把每一个元素对应的行用bitset存下来, 0代表非法1代表合法. 再在枚举每行的时候找到第一个不冲突的行更新答案就可以做到<span class="math inline">\(O(\frac{n^2m}{w})\)</span>, 其中<span class="math inline">\(w = 32\)</span>或<span class="math inline">\(64\)</span>​. 但是这样需要<span class="math inline">\(O(\frac{n^2m}{8})\)</span>的空间, 会MLE.</p>
<p>考虑分块. 设块大小为<span class="math inline">\(B\)</span>, 将每个元素按出现次数分类:</p>
<ul>
<li>出现次数大于<span class="math inline">\(B\)</span>, 这部分元素用bitset存下来, 在枚举每行时使用按位与来更新, 时间复杂度<span class="math inline">\(O(\frac{n^2m}{Bw})\)</span>, 空间复杂度<span class="math inline">\(O(\frac{n^2m}{8B})\)</span>.</li>
<li>出现次数小于<span class="math inline">\(B\)</span>, 这部分元素在枚举每行时直接更新, 时间复杂度<span class="math inline">\(O(B^2)\)</span>, 空间复杂度<span class="math inline">\(O(n)\)</span>.</li>
</ul>
<p>(感觉复杂度算的很不对劲啊- - 反正能过)</p>
<p>然后B选一个差不多的大小比如<span class="math inline">\(\sqrt{nm}\)</span>就能过了.</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALL(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT(___) for(auto ____:(___))&#123;cout &lt;&lt; ____ &lt;&lt; <span class="meta-string">&quot; &quot;</span>;&#125;cout &lt;&lt; endl;</span></span><br><span class="line"><span class="function">mt19937 <span class="title">Rand</span><span class="params">(chrono::steady_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="function">ll <span class="title">Pow</span><span class="params">(ll x,ll d,ll p)</span></span>&#123;ll ta=<span class="number">1</span>;<span class="keyword">if</span>(d==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>%p;x %= p;ll a=<span class="built_in">Pow</span>(x,d/<span class="number">2</span>,p);ta=a*a%p;<span class="keyword">if</span>(d%<span class="number">2</span>)ta=ta*x%p;<span class="keyword">return</span> ta%p;&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">10</span>;<span class="comment">//CHANGE IT!</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = maxn*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">1e9</span>+<span class="number">7</span>;<span class="comment">//CHANGE IT!</span></span><br><span class="line"><span class="keyword">int</span> raw[maxn],mp[maxn * <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxb = <span class="number">708</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxc = <span class="number">100006</span>;</span><br><span class="line">bitset&lt;maxc&gt;b[maxb + <span class="number">10</span>];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;ban[maxn * <span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;r;</span><br><span class="line">	<span class="keyword">int</span> w;</span><br><span class="line">	<span class="built_in">Node</span>(vector&lt;<span class="keyword">int</span>&gt; r = &#123;&#125;,<span class="keyword">int</span> w = <span class="number">0</span>):<span class="built_in">r</span>(r),<span class="built_in">w</span>(w)&#123;&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp; x)<span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> w &lt; x.w;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;node[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt[maxn * <span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">setf</span>(ios::fixed,ios::floatfield);</span><br><span class="line">	cout.<span class="built_in">precision</span>(<span class="number">12</span>);	 </span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;hsh;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">r</span>(m);</span><br><span class="line">		<span class="keyword">int</span> w;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++)&#123;</span><br><span class="line">			cin &gt;&gt; r[j];</span><br><span class="line">			hsh[r[j]]++;</span><br><span class="line">		&#125;</span><br><span class="line">		cin &gt;&gt; w;</span><br><span class="line">		node[i] = <span class="built_in">Node</span>(r,w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp; it:hsh)&#123;</span><br><span class="line">		cnt[tmp] = it.second;</span><br><span class="line">		it.second = tmp++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(node+<span class="number">1</span>,node+n+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">2e9</span> + <span class="number">10</span>,idx = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++)&#123;</span><br><span class="line">			<span class="keyword">int</span> &amp; v = node[i].r[j];</span><br><span class="line">			v = hsh[v];</span><br><span class="line">			<span class="keyword">if</span>(cnt[v] &gt; maxb)&#123;</span><br><span class="line">				<span class="keyword">if</span>(!mp[v])&#123;</span><br><span class="line">					b[idx].<span class="built_in">set</span>();</span><br><span class="line">					mp[v] = idx++;</span><br><span class="line">				&#125;</span><br><span class="line">				b[mp[v]].<span class="built_in">reset</span>(i);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> ban[v].<span class="built_in">push_back</span>(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		bitset&lt;maxc&gt;vai;</span><br><span class="line">		vai.<span class="built_in">set</span>();</span><br><span class="line">		vai.<span class="built_in">reset</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = node[i].r[j];</span><br><span class="line">			<span class="keyword">if</span>(cnt[v] &gt; maxb)&#123;</span><br><span class="line">				vai &amp;= b[mp[v]];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> x:ban[v])vai.<span class="built_in">reset</span>(x);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> x = vai._Find_first();</span><br><span class="line">		<span class="keyword">if</span>(x &lt;= n)ans = <span class="built_in">min</span>(ans,node[i].w + node[x].w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ans == <span class="number">2e9</span>+<span class="number">10</span>)ans = <span class="number">-1</span>;</span><br><span class="line">	cout &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>暴力</tag>
        <tag>bitset</tag>
      </tags>
  </entry>
  <entry>
    <title>[GAMES104]-作业2</title>
    <url>/2022/05/29/GAMES104-homework-2/</url>
    <content><![CDATA[<p>因为一直要赶一堆莫名其妙的ddl和考试 task3没做 日后再补_(:з」∠)_</p>
<h2 id="color-grading与lut">Color Grading与LUT</h2>
<p>调色是增强画面表现力的一种很有效的手段. 本次作业我们处理的颜色在sRGB空间内, 红、绿、蓝三个颜色分别用一个<span class="math inline">\([0,1]\)</span>的实数来表示. 将三原色分别用一个坐标轴来表示, 便构成了如图所示的色彩空间(图片来自<a href="https://defold.com/tutorials/grading/">defold.com</a>):</p>
<p><img src="https://defold.com/tutorials/images/grading/color_cube.png" alt="color cube" style="zoom:33%;" /></p>
<p>在进行调色时, 我们对渲染结果的每个像素进行处理, 根据像素原本的RGB值将其映射到一个新的色彩空间. 这种映射一般采用LUT(look up table)图来进行. LUT有1D和3D之分, Pilot Engine使用的是3D的LUT, 它看上去像这个样子:</p>
<p><img src="E:\Github\Pilot_Homework2\engine\asset\texture\lut\color_grading_LUT.jpg" /></p>
<p>这张图片的长为<span class="math inline">\(1024\)</span>个像素, 宽为<span class="math inline">\(32\)</span>个像素, 可以看出它由<span class="math inline">\(32\)</span>个小色块组成. 将这些小方块自上而下拼接在一起, 便组成了一个<span class="math inline">\(32 \times 32 \times 32\)</span>的色彩空间. 我们需要做的便是根据每个像素的RGB分量找到它在这张图上对应的像素. 具体来说, 原像素的<span class="math inline">\(G\)</span>分量指示了新像素在LUT上的纵坐标, <span class="math inline">\(B\)</span>分量指示了新像素所属的色块编号, <span class="math inline">\(R\)</span>分量指示了新像素在某个色块内部的横坐标.</p>
<h2 id="编写shader">编写Shader</h2>
<p>我们需要编写的Shader文件是<code>color_grading.frag</code>, 可以在<code>\engine\shader\glsl\</code>中找到.</p>
<p>这个shader已经提供了原像素的颜色<code>in_color</code>和LUT的2D采样器<code>color_grading_lut_texture_sampler</code>. 我们需要根据原像素的颜色计算出调色后的颜色并将其赋值给<code>out_color</code>作为输出.</p>
<p>在计算前, 需要获取像素的颜色值:</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">highp</span> <span class="type">vec4</span> color = subpassLoad(in_color).rgba;</span><br></pre></td></tr></table></figure>
<p>颜色值是一个四维向量, 四个维度分别代表R、G、B和alpha, 均为<span class="math inline">\([0,1]\)</span>的实数.</p>
<p>在计算出坐标后, 需要从LUT上获取对应的颜色:</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">highp</span> <span class="type">vec4</span> color_sampled = <span class="built_in">texture</span>(color_grading_lut_texture_sampler, uv);</span><br></pre></td></tr></table></figure>
<p>其中<code>color_grading_lut_texture_sampler</code>已经提供, <code>uv</code>是一个二维向量, <span class="math inline">\(u\)</span>代表横坐标, <span class="math inline">\(v\)</span>代表纵坐标, 坐标原点在图片的左上角, <span class="math inline">\(x\)</span>轴方向向右, <span class="math inline">\(y\)</span>轴方向向下. <span class="math inline">\(u,v\)</span>也是<span class="math inline">\([0,1]\)</span>上的实数.</p>
<p>我们还需要获取LUT的长宽:</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">highp</span> <span class="type">ivec2</span> lut_tex_size = <span class="built_in">textureSize</span>(color_grading_lut_texture_sampler, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>有了如上函数, 不难计算出每个像素在LUT上的对应位置. 设<span class="math inline">\(C\)</span>是LUT的宽, <span class="math inline">\(R,G,B\)</span>分别为像素的原颜色分量, 则有: <span class="math display">\[
u = \frac{\lfloor B \cdot C \rfloor + R}{C}\\
v = G
\]</span> 为了提高准确度和防止越界, 可以在LUT的边界上各留出0.5个像素, 将RGB值映射到<span class="math inline">\(C-1\)</span>个像素中去. 具体细节见代码:</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 310 es</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#extension GL_GOOGLE_include_directive : enable</span></span><br><span class="line"><span class="comment">//#extension GL_KHR_vulkan_glsl : enable</span></span><br><span class="line"><span class="meta">#include &quot;constants.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(input_attachment_index = <span class="number">0</span>, set = <span class="number">0</span>, <span class="keyword">binding</span> = <span class="number">0</span>) <span class="keyword">uniform</span> <span class="keyword">highp</span> subpassInput in_color;</span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(set = <span class="number">0</span>, <span class="keyword">binding</span> = <span class="number">1</span>) <span class="keyword">uniform</span> <span class="type">sampler2D</span> color_grading_lut_texture_sampler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> <span class="keyword">highp</span> <span class="type">vec4</span> out_color;</span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">highp</span> <span class="type">ivec2</span> lut_tex_size = <span class="built_in">textureSize</span>(color_grading_lut_texture_sampler, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">highp</span> <span class="type">float</span> COLORS       = <span class="type">float</span>(lut_tex_size.y);<span class="comment">//LUT的每一维的颜色数量</span></span><br><span class="line">    <span class="keyword">highp</span> <span class="type">vec4</span>  color        = subpassLoad(in_color).rgba;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">highp</span> <span class="type">float</span> max_color = COLORS - <span class="number">1.0</span>;<span class="comment">//允许使用的最大元素</span></span><br><span class="line">    <span class="keyword">highp</span> <span class="type">float</span> half_pix_u = <span class="number">0.5</span> / <span class="type">float</span>(lut_tex_size.x);<span class="comment">//预留出半个像素</span></span><br><span class="line">    <span class="keyword">highp</span> <span class="type">float</span> half_pix_v = <span class="number">0.5</span> / <span class="type">float</span>(lut_tex_size.y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">highp</span> <span class="type">float</span> part = <span class="built_in">floor</span>(color.b * max_color);<span class="comment">//根据B计算出该像素所属的色块编号</span></span><br><span class="line">    <span class="keyword">highp</span> <span class="type">float</span> threshold = max_color / COLORS;<span class="comment">//现在只有COLORS-1个颜色可用</span></span><br><span class="line">    <span class="keyword">highp</span> <span class="type">float</span> u = (half_pix_u + threshold * color.r + part) / COLORS;</span><br><span class="line">    <span class="keyword">highp</span> <span class="type">float</span> v = (half_pix_v + threshold * color.g);</span><br><span class="line">    <span class="comment">//预留出0.5像素的边界.例如假设COLORS = 32,在G = 0时v = 0.5/32,G = 1时v = 31.5/32</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">highp</span> <span class="type">vec2</span> uv = <span class="type">vec2</span>(u,v);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">highp</span> <span class="type">vec4</span> color_sampled = <span class="built_in">texture</span>(color_grading_lut_texture_sampler, uv);</span><br><span class="line"></span><br><span class="line">    out_color =  color_sampled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="效果展示与自定义lut">效果展示与自定义LUT</h2>
<p>在<code>\engine\asset\texture\lut</code>中存放着不同的LUT. 通过修改<code>\engine\asset\global\rendering.global.json</code>中<code>"color_grading_map"</code>项可以替换不同的LUT.</p>
<p>在不进行调色时的效果是这样的:</p>
<figure>
<img src="E:\Github\hexo\source_posts\GAMES104-homework-2.assets\image-20220529161702147.png" alt="image-20220529161702147" /><figcaption aria-hidden="true">image-20220529161702147</figcaption>
</figure>
<p>调色后的效果:</p>
<figure>
<img src="E:\Github\hexo\source_posts\GAMES104-homework-2.assets\image-20220529162809564.png" alt="image-20220529162809564" /><figcaption aria-hidden="true">image-20220529162809564</figcaption>
</figure>
<p>要创建自定义的LUT, 只需在GIMP或者PhotoShop等工具编辑原始LUT图像(可以附一张截图方便观察调色效果).</p>
<p>负片效果的LUT:</p>
<p><img src="E:\Github\Pilot_Homework2\engine\asset\texture\lut\LUT32_Invert.png" /></p>
<figure>
<img src="E:\Github\hexo\source_posts\GAMES104-homework-2.assets\image-20220529165605604.png" alt="image-20220529165605604" /><figcaption aria-hidden="true">image-20220529165605604</figcaption>
</figure>
<p>偏冷色调(好像太绿了):</p>
<p><img src="E:\Github\Pilot_Homework2\engine\asset\texture\lut\LUT32_qwq.png" /></p>
<figure>
<img src="E:\Github\hexo\source_posts\GAMES104-homework-2.assets\image-20220529165831153.png" alt="image-20220529165831153" /><figcaption aria-hidden="true">image-20220529165831153</figcaption>
</figure>
<p>PS:调色后会出现看上去很奇怪的色块, 目前还不知道如何解决</p>
<p><img src="E:\Github\hexo\source\_posts\GAMES104-homework-2.assets\image-20220529165922432.png" alt="image-20220529165922432" style="zoom:33%;" /></p>
<p><img src="E:\Github\hexo\source\_posts\GAMES104-homework-2.assets\image-20220529165936292.png" alt="image-20220529165936292" style="zoom:33%;" /></p>
]]></content>
      <categories>
        <category>GAMES104</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>游戏引擎</tag>
        <tag>GAMES104</tag>
      </tags>
  </entry>
  <entry>
    <title>[笔记]从0开始搓一个简单的render</title>
    <url>/2022/04/30/demo-render/</url>
    <content><![CDATA[<p>本文的主要内容是对Dmitry V. Sokolov的<a href="https://github.com/ssloy/tinyrenderer">tinyrender</a>课程的记录和补充.</p>
<h1 id="step-0环境搭建">Step 0：环境搭建</h1>
<p>我们需要<code>tgaimage.h</code>来操作TGA文件, <code>model.h</code>来操作模型. 头文件和实现可以在这里找到:</p>
<p>https://github.com/ssloy/tinyrenderer/tree/f6fecb7ad493264ecd15e230411bfb1cca539a12</p>
<p>可以用如下代码来测试:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tgaimage.h&quot;</span></span></span><br><span class="line"><span class="keyword">const</span> TGAColor white = <span class="built_in">TGAColor</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>);</span><br><span class="line"><span class="keyword">const</span> TGAColor red   = <span class="built_in">TGAColor</span>(<span class="number">255</span>, <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">255</span>);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">        <span class="function">TGAImage <span class="title">image</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>, TGAImage::RGB)</span></span>;</span><br><span class="line">        image.<span class="built_in">set</span>(<span class="number">52</span>, <span class="number">41</span>, red);</span><br><span class="line">        image.<span class="built_in">flip_vertically</span>(); <span class="comment">// i want to have the origin at the left bottom corner of the image</span></span><br><span class="line">        image.<span class="built_in">write_tga_file</span>(<span class="string">&quot;output.tga&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到一个有红点的TGA文件:</p>
<p><img src="demo-render.assets\image-20220430115033896.png" alt="image-20220430115033896" style="zoom:25%;" /></p>
<h1 id="step-1画一条直线">Step 1：画一条直线</h1>
<h2 id="朴素算法">朴素算法</h2>
<p>我们需要在二维位图上画一条从<span class="math inline">\((x_0,y_0)\)</span>到<span class="math inline">\((x_1,y_1)\)</span>的直线.</p>
<p>直线的两点式为: <span class="math display">\[
\frac{y - y_0}{y_1 - y_0} = \frac{x - x_0}{x_1 - x_0}
\]</span> 因而对任一点<span class="math inline">\(x\)</span>, 有 <span class="math display">\[
y = \frac{x - x_0}{x_1 - x_0} \cdot(y_1 - y_0) + y_0
\]</span> 我们只要枚举<span class="math inline">\(x\)</span>, 计算出每个<span class="math inline">\(x\)</span>对应的<span class="math inline">\(y\)</span>即可画出直线. 需要注意的是, 这个算法默认<span class="math inline">\((x_1,y_1)\)</span>在<span class="math inline">\((x_0,y_0)\)</span>的右上方, 并且绘制时需要枚举<span class="math inline">\(\Delta x,\Delta y\)</span>中较大的一方以保证线段不会断开.</p>
<p>代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Drawer::Line</span><span class="params">(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, TGAColor color)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> flip = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">abs</span>(x0 - x1) &lt; <span class="built_in">abs</span>(y0 - y1))&#123;</span><br><span class="line">        flip = <span class="number">1</span>;</span><br><span class="line">        std::<span class="built_in">swap</span>(x0,y0),std::<span class="built_in">swap</span>(x1,y1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x0 &gt; x1)&#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(x0,x1),std::<span class="built_in">swap</span>(y0,y1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = x0;x &lt;= x1;x++)&#123;</span><br><span class="line">        <span class="keyword">double</span> t = (<span class="keyword">double</span>)(x - x0)/(x1 - x0);</span><br><span class="line">        <span class="keyword">int</span> y = t * (y1 - y0) + y0;</span><br><span class="line">        <span class="keyword">if</span>(!flip)<span class="built_in">set</span>(x,y,color);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">set</span>(y,x,color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="bresenham直线算法">Bresenham直线算法</h2>
<p>朴素算法已经能够满足绘图需要, 但是使用了浮点乘法除法, 效率很低.</p>
<p>我们设直线的斜率<span class="math inline">\(k = \frac{y_1 - y_0}{x_1 - x_0}\)</span>, 有 <span class="math display">\[
y = (x - x_0) \cdot k + y_0
\]</span> 我们假设当前画笔所在位置的是<span class="math inline">\((x,y_c)\)</span>, 误差为<span class="math inline">\(E = y- y_c\)</span>. 当<span class="math inline">\(x\)</span>加<span class="math inline">\(1\)</span>时, <span class="math inline">\(E\)</span>增加<span class="math inline">\(k\)</span>. 当<span class="math inline">\(E \ge \frac{1}{2}\)</span>时, 我们需要将<span class="math inline">\(y_c\)</span>加或减<span class="math inline">\(1\)</span>同时<span class="math inline">\(E\)</span>减去<span class="math inline">\(1\)</span>. 这样便避免了每次都要进行的浮点除法运算.</p>
<p>具体来说, 我们只需将不等式的两边乘上<span class="math inline">\(2 \cdot (x_1 - x_0)\)</span>即可. 此时误差每次增加<span class="math inline">\(2 \cdot (y_1 - y_0)\)</span>. 当<span class="math inline">\(E \ge (x_1 - x_0)\)</span>时需要将<span class="math inline">\(y_c\)</span>加或减<span class="math inline">\(1\)</span>同时<span class="math inline">\(E\)</span>减去<span class="math inline">\(2 \cdot (x_1 - x_0)\)</span>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Drawer::Line</span><span class="params">(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, TGAColor color)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> flip = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">abs</span>(x0 - x1) &lt; <span class="built_in">abs</span>(y0 - y1))&#123;</span><br><span class="line">        flip = <span class="number">1</span>;</span><br><span class="line">        std::<span class="built_in">swap</span>(x0,y0),std::<span class="built_in">swap</span>(x1,y1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x0 &gt; x1)&#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(x0,x1),std::<span class="built_in">swap</span>(y0,y1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> dx = x1 - x0,dy = y1 - y0;</span><br><span class="line">    <span class="keyword">int</span> e = <span class="number">0</span>,de = <span class="number">2</span>*<span class="built_in">abs</span>(dy);</span><br><span class="line">    <span class="keyword">int</span> y = y0;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = x0;x &lt;= x1;x++)&#123;</span><br><span class="line">        e += de;</span><br><span class="line">        <span class="keyword">if</span>(e &gt;= dx) &#123;</span><br><span class="line">            e -= dx*<span class="number">2</span>;</span><br><span class="line">            y += (dy &gt; <span class="number">0</span>?<span class="number">1</span>:<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flip)<span class="built_in">set</span>(x,y,color);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">set</span>(y,x,color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="step-2画一个三角形">Step 2：画一个三角形</h1>
<h2 id="扫描线法">扫描线法</h2>
<p>我们先用一种十分古老的方法来画一个三角形: 用水平或者竖直的线一行一行地绘制.</p>
<p>在绘制前, 先对三角形的三个顶点按横坐标递增进行排序, 然后标号为<span class="math inline">\(P_0,P_1,P_2\)</span>(以下默认左下角为坐标原点). 同时将边<span class="math inline">\(P_0P_1\)</span>标为<span class="math inline">\(L_0\)</span>, <span class="math inline">\(P_1P_2\)</span>标为<span class="math inline">\(L_1\)</span>, <span class="math inline">\(P_2P_3\)</span>标为<span class="math inline">\(L_2\)</span>, 如图:</p>
<p><img src="demo-render.assets\image-20220501154945120.png" alt="image-20220501154945120" style="zoom:50%;" /></p>
<p>标号后的三角形可按<span class="math inline">\(x = x_1\)</span>​这条直线分割成两部分. 对两部分分别进行绘制即可. 注意处理一下斜率不存在时的细节.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Drawer::Triangle</span><span class="params">(Vec2i t0, Vec2i t1, Vec2i t2, TGAColor color)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x0,y0,x1,y1,x2,y2;</span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;top = &#123;&#123;t0.u,t0.v&#125;,&#123;t1.u,t1.v&#125;,&#123;t2.u,t2.v&#125;&#125;;</span><br><span class="line">    std::<span class="built_in">sort</span>(top.<span class="built_in">begin</span>(),top.<span class="built_in">end</span>());</span><br><span class="line">    std::<span class="built_in">tie</span>(x0,y0) = top[<span class="number">0</span>];</span><br><span class="line">    std::<span class="built_in">tie</span>(x1,y1) = top[<span class="number">1</span>];</span><br><span class="line">    std::<span class="built_in">tie</span>(x2,y2) = top[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> mx = std::<span class="built_in">max</span>(x1,x2);</span><br><span class="line">    <span class="keyword">double</span> k0 = (<span class="keyword">double</span>)(y1 - y0)/(x1 == x0?<span class="number">1</span>:x1 - x0);</span><br><span class="line">    <span class="keyword">double</span> k1 = (<span class="keyword">double</span>)(y2 - y1)/(x2 == x1?<span class="number">1</span>:x2 - x1);</span><br><span class="line">    <span class="keyword">double</span> k2 = (<span class="keyword">double</span>)(y2 - y0)/(x2 == x0?<span class="number">1</span>:x2 - x0);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = x0;x &lt;= x2;x++)&#123;</span><br><span class="line">        <span class="keyword">int</span> yc2 = (x - x0) * k2 + y0;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= x1)&#123;</span><br><span class="line">            <span class="keyword">int</span> yc0 = (x - x0) * k0 + y0;</span><br><span class="line">            <span class="built_in">Line</span>(x,yc0,x,yc2,color);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> yc1 = (x - x1) * k1 + y1;</span><br><span class="line">            <span class="built_in">Line</span>(x,yc1,x,yc2,color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重心坐标系">重心坐标系</h2>
<h3 id="一般定义">一般定义</h3>
<p>设<span class="math inline">\(V_1,...,V_n\)</span>是<span class="math inline">\(n\)</span>维向量空间<span class="math inline">\(V\)</span>中<a href="https://en.wikipedia.org/wiki/Simplex">单纯形</a>的顶点, 对于<span class="math inline">\(V\)</span>中任意一点<span class="math inline">\(P\)</span>, 有 <span class="math display">\[
(\sum_{i = 1}^n \lambda_i)\cdot P = \sum_{i = 1}^n \lambda_i \cdot V_i
\]</span> 则系数<span class="math inline">\(\lambda_1,...,\lambda_n\)</span>称为<span class="math inline">\(P\)</span>关于<span class="math inline">\(V_1,...V_n\)</span>的重心坐标. 一般规定<span class="math inline">\(\sum_{i = 1}^n \lambda_i = 1\)</span>, 此时称为<strong>正规化</strong>的重心坐标. 以下讨论的重心坐标均为正规化的.</p>
<h3 id="二维平面中的重心坐标系">二维平面中的重心坐标系</h3>
<h4 id="定义">定义</h4>
<p>二维平面上, 单纯形为三角形. 假设给出一三角形<span class="math inline">\(\Delta ABC\)</span>和三角形所在平面上的一点<span class="math inline">\(P\)</span>, 则<span class="math inline">\(P\)</span>可被如下重心坐标表示: <span class="math display">\[
P = \alpha A + \beta B + \gamma C
\]</span> 考虑<a href="https://zhuanlan.zhihu.com/p/144360079">下图(来源见链接)</a>:</p>
<p><img src="https://pic2.zhimg.com/80/v2-34f542500eb2b8b4679dc351609398ad_720w.jpg" alt="img" style="zoom: 50%;" /></p>
<p>将<span class="math inline">\(\vec{AB},\vec{AC}\)</span>作为坐标系, 可以得到 <span class="math display">\[
\begin{align}
P =&amp; A + \beta(\vec{AB}) + \gamma(\vec{AC})\\
=&amp; A + \beta(B - A) + \gamma(C - A)\\
=&amp; (1 - \beta - \gamma)A + \beta B + \gamma C
\end{align}
\]</span> 这样便可以从坐标系的角度来解释重心坐标, 同时能得到 <span class="math display">\[
\alpha = 1 - \beta - \gamma
\]</span></p>
<h4 id="求解解方程组">求解:解方程组</h4>
<p>将点带入重心坐标的定义, 可以得到: <span class="math display">\[
\left \{
\begin{array}{cccc} 
   x_p = (1 - \beta - \gamma) x_a + \beta x_b + \gamma x_c \\
   y_p = (1 - \beta - \gamma) y_a + \beta y_b + \gamma y_c
\end{array}
\right.
\]</span> 提取出<span class="math inline">\(\beta \space \gamma\)</span>: <span class="math display">\[
\left \{
\begin{array}{cccc}
x_p - x_a = \beta(x_b - x_a) + \gamma (x_c - x_a)\\
y_p - y_a = \beta(y_b - y_a) + \gamma (y_c - y_a)
\end{array}
\right.
\]</span> 转化为矩阵形式: <span class="math display">\[
\left[
\begin{array}{}
    x_b - x_a &amp; x_c - x_a\\
    y_b - y_a &amp; y_c - y_a
\end{array}
\right]
\left[
\begin{array}{}
\beta \\
\gamma
\end{array}
\right]
=
\left[
\begin{array}{}
x_p - x_a\\
y_p - y_a
\end{array}
\right]
\]</span> 这样便可求解出<span class="math inline">\(\beta \space \gamma\)</span>进而求出<span class="math inline">\(\alpha\)</span></p>
<h4 id="求解向量叉积">求解:向量叉积</h4>
<p>把坐标系的表达式变换一下: <span class="math display">\[
\beta \vec{AB} + \gamma \vec{AC} + \vec{PA} = 0
\]</span> 拆开后: <span class="math display">\[
\left \{
\begin{array}{cccc} 
\beta\vec{AB}_x + \gamma \vec{AC}_x + \vec{PA}_x = 0\\
\beta\vec{AB}_y + \gamma \vec{AC}_y + \vec{PA}_y = 0
\end{array}
\right.
\]</span> 转化为矩阵形式: <span class="math display">\[
\left[
\begin{array}{}
\beta &amp; \gamma &amp; 1
\end{array}
\right]
\left[
\begin{array}{}
\vec{AB}_x\\
\vec{AC}_x\\
\vec{PA}_x
\end{array}
\right] = 0\\
\left[
\begin{array}{}
\beta &amp; \gamma &amp; 1
\end{array}
\right]
\left[
\begin{array}{}
\vec{AB}_y\\
\vec{AC}_y\\
\vec{PA}_y
\end{array}
\right] = 0\\
\]</span> 从几何意义考虑, 这相当于<span class="math inline">\([\beta ,\gamma,1]\)</span>这个向量和后两个向量分别垂直. 因而我们求出后两个向量的叉积(假设结果为<span class="math inline">\([x,y,z]\)</span>), 则<span class="math inline">\([\frac{x}{z}, \frac{y}{z},1]\)</span>等于<span class="math inline">\([\beta,\gamma,1]\)</span>​.</p>
<p>需要注意<span class="math inline">\(z = 0\)</span>的特殊情况, 根据叉乘的定义, 此时有<span class="math inline">\(\vec{AB}_x \cdot \vec{AC}_y - \vec{AB}_y \cdot \vec{AC}_x = 0\)</span>, 即<span class="math inline">\(\vec{AB} \cdot \vec{AC} = 0\)</span>, 说明<span class="math inline">\(ABC\)</span>三点共线. 这时返回一个任意的负重心坐标即可.</p>
<h4 id="求解三角形面积">求解:三角形面积</h4>
<p><img src="demo-render.assets\image-20220502193646986.png" alt="image-20220502193646986" style="zoom:50%;" /></p>
<p>如图, 假设三角形面积分别为<span class="math inline">\(S_A,S_B,S_C\)</span>. 则 <span class="math display">\[
\alpha = \frac{S_A}{S_A+S_B+S_C}\\
\beta = \frac{S_B}{S_A+S_B+S_C}\\
\gamma = \frac{S_C}{S_A+S_B+S_C}
\]</span></p>
<h3 id="应用">应用</h3>
<p>重心坐标有很多应用, 在这里我们能用到的结论是: 若<span class="math inline">\(\alpha,\beta,\gamma\)</span>均大于<span class="math inline">\(0\)</span>, 则点<span class="math inline">\(P\)</span>在三角形<span class="math inline">\(\Delta ABC\)</span>的内部; 若<span class="math inline">\(\alpha,\beta,\gamma\)</span>有一个等于<span class="math inline">\(0\)</span>, 则点<span class="math inline">\(P\)</span>在三角形的边上; 若<span class="math inline">\(\alpha,\beta,\gamma\)</span>有两个等于<span class="math inline">\(0\)</span>, 则点<span class="math inline">\(P\)</span>在三角形的顶点上.</p>
<p>在绘图时, 用一个最小的矩形包围住三角形, 再枚举并判断每个点是否在三角形内部即可. 下面的代码采用了向量叉积法:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Vec3f <span class="title">Drawer::Barycentric</span><span class="params">(<span class="keyword">const</span> Vec2i (&amp;vertex)[<span class="number">3</span>],<span class="keyword">const</span> Vec2i &amp; P)</span></span>&#123;</span><br><span class="line">    Vec3f result =  <span class="comment">//cal cross</span></span><br><span class="line">            <span class="built_in">Vec3f</span>(vertex[<span class="number">1</span>].x - vertex[<span class="number">0</span>].x,vertex[<span class="number">2</span>].x - vertex[<span class="number">0</span>].x,vertex[<span class="number">0</span>].x - P.x) ^</span><br><span class="line">            <span class="built_in">Vec3f</span>(vertex[<span class="number">1</span>].y - vertex[<span class="number">0</span>].y,vertex[<span class="number">2</span>].y - vertex[<span class="number">0</span>].y,vertex[<span class="number">0</span>].y - P.y);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(result.z) &lt; <span class="number">1</span>)<span class="keyword">return</span> <span class="built_in">Vec3f</span>(<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    result.x /= result.z,result.y /= result.z;</span><br><span class="line">    <span class="keyword">return</span> &#123;(<span class="keyword">float</span>)<span class="number">1.0</span> - result.x - result.y,result.x,result.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Drawer::Triangle</span><span class="params">(<span class="keyword">const</span> Vec2i (&amp;vertex)[<span class="number">3</span>],<span class="keyword">const</span> TGAColor &amp; color)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lx = std::<span class="built_in">max</span>(std::<span class="built_in">min</span>(&#123;vertex[<span class="number">0</span>].x,vertex[<span class="number">1</span>].x,vertex[<span class="number">2</span>].x&#125;),<span class="number">0</span>),rx = std::<span class="built_in">min</span>(std::<span class="built_in">max</span>(&#123;vertex[<span class="number">0</span>].x,vertex[<span class="number">1</span>].x,vertex[<span class="number">2</span>].x&#125;),<span class="built_in">get_width</span>()<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> ly = std::<span class="built_in">max</span>(std::<span class="built_in">min</span>(&#123;vertex[<span class="number">0</span>].y,vertex[<span class="number">1</span>].y,vertex[<span class="number">2</span>].y&#125;),<span class="number">0</span>),ry = std::<span class="built_in">min</span>(std::<span class="built_in">max</span>(&#123;vertex[<span class="number">0</span>].y,vertex[<span class="number">1</span>].y,vertex[<span class="number">2</span>].y,&#125;),<span class="built_in">get_height</span>()<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = lx;x &lt;= rx;x++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y = ly;y &lt;= ry;y++)&#123;</span><br><span class="line">            Vec3f bary = <span class="built_in">Barycentric</span>(vertex,<span class="built_in">Vec2i</span>(x,y));</span><br><span class="line">            <span class="keyword">bool</span> out = (bary.x &lt; <span class="number">0</span> <span class="keyword">or</span> bary.y &lt; <span class="number">0</span> <span class="keyword">or</span> bary.z &lt; <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(!out)<span class="built_in">set</span>(x,y,color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<a href="https://github.com/ssloy/tinyrenderer/tree/024ad4619b824f9179c86dc144145e2b8b155f52">tinyrender提供的模型</a>来测试一下我们的三角形绘制程序(先给每个面一个随机颜色):</p>
<p><img src="demo-render.assets\image-20220502215053686.png" alt="image-20220502215053686" style="zoom:25%;" /></p>
<p>加上一点阴影并剔除背面的三角形:</p>
<p><img src="demo-render.assets\image-20220502215757516.png" alt="image-20220502215757516" style="zoom:25%;" /></p>
<h1 id="step-3-z-buffer">Step 3 ：z-buffer</h1>
<p>现在我们需要考虑剔除掉不能被我们看见的像素(Step 2通过Back-face culling剔除了一些面, 但是仍然不正确, 例如嘴部整个消失了). z-buffer的思想是维护一个像素点在待渲染平面上的一个距离buffer, 每次用离相机更近的点来剔除已经存在的点. z-buffer的实现非常简单, 下面主要讨论如何求每个点距相机的距离.</p>
<p>首先考虑一维的情形. 假设我们要绘制从<span class="math inline">\(A(x_0,y_0)\)</span>到<span class="math inline">\(B(x_1,y_1)\)</span>的一条线段, 当前绘制到点<span class="math inline">\(P(x,y)\)</span>, 摄像机的视角与<span class="math inline">\(y\)</span>轴的反方向相同:</p>
<p><img src="demo-render.assets\image-20220503101100866.png" alt="image-20220503101100866" style="zoom:50%;" /></p>
<p>在绘制时我们要通过<span class="math inline">\(x\)</span>坐标计算出<span class="math inline">\(y\)</span>来. 不难得到 <span class="math display">\[
\frac{y - y_0}{y1 - y_0} = \frac{x - x_0}{x_1 - x_0}
\]</span> 我们设<span class="math inline">\(\beta = \frac{x - x_0}{x_1 - x_0}\)</span>, 则有 <span class="math display">\[
y = (1 - \beta)y_0 + \beta y_1
\]</span> 是不是很熟悉? <span class="math inline">\(\alpha = 1 - \beta\)</span>和<span class="math inline">\(\beta\)</span>就是<span class="math inline">\(P\)</span>关于线段<span class="math inline">\(AB\)</span>的重心坐标(一维单纯形是线段). 我们将其推广到二维, 便能求出三角形每个点距离相机的距离<span class="math inline">\(z\)</span>: <span class="math display">\[
z = \alpha z_0+ \beta z_1 + \gamma z_2
\]</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Drawer::Triangle</span><span class="params">(<span class="keyword">const</span> Vec3i (&amp;vertex)[<span class="number">3</span>],<span class="keyword">const</span> TGAColor &amp; color,<span class="keyword">double</span> * zbuffer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">-1e-6</span>;<span class="comment">//防止三角形接合处有未绘制的点</span></span><br><span class="line">    <span class="keyword">int</span> lx = std::<span class="built_in">max</span>(std::<span class="built_in">min</span>(&#123;vertex[<span class="number">0</span>].x,vertex[<span class="number">1</span>].x,vertex[<span class="number">2</span>].x&#125;),<span class="number">0</span>),rx = std::<span class="built_in">min</span>(std::<span class="built_in">max</span>(&#123;vertex[<span class="number">0</span>].x,vertex[<span class="number">1</span>].x,vertex[<span class="number">2</span>].x&#125;),<span class="built_in">get_width</span>()<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> ly = std::<span class="built_in">max</span>(std::<span class="built_in">min</span>(&#123;vertex[<span class="number">0</span>].y,vertex[<span class="number">1</span>].y,vertex[<span class="number">2</span>].y&#125;),<span class="number">0</span>),ry = std::<span class="built_in">min</span>(std::<span class="built_in">max</span>(&#123;vertex[<span class="number">0</span>].y,vertex[<span class="number">1</span>].y,vertex[<span class="number">2</span>].y,&#125;),<span class="built_in">get_height</span>()<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = lx;x &lt;= rx;x++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y = ly;y &lt;= ry;y++)&#123;</span><br><span class="line">            Vec3f bary = <span class="built_in">Barycentric</span>(vertex,<span class="built_in">Vec2i</span>(x,y));</span><br><span class="line">            <span class="keyword">if</span>(bary.x &lt; eps <span class="keyword">or</span> bary.y &lt; eps <span class="keyword">or</span> bary.z &lt; eps)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> idx = x + y * <span class="built_in">get_width</span>();</span><br><span class="line">            <span class="keyword">double</span> z = bary.x * vertex[<span class="number">0</span>].z + bary.y * vertex[<span class="number">1</span>].z + bary.z * vertex[<span class="number">2</span>].z;</span><br><span class="line">            <span class="keyword">if</span>(zbuffer[idx] &lt; z)&#123;</span><br><span class="line">                zbuffer[idx] = z;</span><br><span class="line">                <span class="built_in">set</span>(x,y,color);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下:</p>
<p><img src="demo-render.assets\image-20220503104500854.png" alt="image-20220503104500854" style="zoom: 25%;" /></p>
<h1 id="step-4-透视投影wip">Step 4: 透视投影(WIP)</h1>
<p>这一部分tinyrender讲得很含糊而且不直观, 所以直接按照GAMES101的内容去实现. 本节只讲述实现. obj文件格式可以在https://en.wikipedia.org/wiki/Wavefront_.obj_file找到.</p>
<p>透视投影的实现似乎有问题, 先鸽了</p>
<h1 id="step-5相机">Step 5:相机</h1>
<p>写的不是很满意, 也鸽了</p>
]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>图形学</tag>
        <tag>C++</tag>
        <tag>render</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES101笔记</title>
    <url>/2021/04/04/GAMES101/</url>
    <content><![CDATA[<p>部分图片来自<a href="https://www.bilibili.com/video/BV1X7411F744">GAMES101</a></p>
<h1 id="向量">向量</h1>
<h2 id="基础">基础</h2>
<p>可以直接跳过这部分.</p>
<h3 id="定义">定义</h3>
<p>符号表示: <span class="math inline">\(\vec{a}\)</span> 或<span class="math inline">\(\boldsymbol{a}\)</span>, 或者写成<span class="math inline">\(\vec{AB}\)</span>, 表示从<span class="math inline">\(A\)</span>指向<span class="math inline">\(B\)</span>的向量(<span class="math inline">\(\vec{AB} = B - A\)</span>).</p>
<p>本文中向量均表示列向量, 即<span class="math inline">\(\vec{a} = \begin{pmatrix}x\\y\end{pmatrix}\)</span>. 行向量则<span class="math inline">\(\vec{a}^T = (x,y)\)</span></p>
<p>向量有方向和长度, 一般不指定起点.</p>
<h3 id="长度">长度</h3>
<p><span class="math inline">\(|\vec{a}|\)</span> 或<span class="math inline">\(\Vert\vec{a}\Vert\)</span>(二范数)表示向量的长度. 对于二维向量<span class="math inline">\(\vec{a} = \begin{pmatrix}x\\y\end{pmatrix}\)</span>, <span class="math inline">\(\vert a\vert = \sqrt{x^2 + y^2}\)</span>.</p>
<h3 id="单位向量">单位向量</h3>
<p><span class="math inline">\(\hat{a}\)</span>表示<span class="math inline">\(\vec{a}\)</span>的单位向量, 读作<code>a hat</code>. <span class="math display">\[
\hat{a} = \frac{\vec{a}}{\vert a \vert}
\]</span></p>
<p>一般用单位向量来表示方向</p>
<h2 id="基本运算">基本运算</h2>
<h3 id="加法">加法</h3>
<p><span class="math display">\[
\vec{a} = \begin{pmatrix}x_1\\y_1\end{pmatrix}, \vec{b} = \begin{pmatrix}x_2\\y_2\end{pmatrix}. \space \vec{a} + \vec{b} = \begin{pmatrix}x_1+x_2\\y_1+y_2\end{pmatrix}
\]</span></p>
<p>向量的加法遵循平行四边形法则或三角形法则(如下图)</p>
<p><img src="/.io//Github\hexo\source\_posts\GAMES101.assets\image-20220329112926492-16489935946861.png" alt="image-20220329112926492" style="zoom:33%;"></p>
<p>对于多个向量相加, 按三角形法则将它们依序首尾拼接即可.</p>
<h3 id="点积">点积</h3>
<p><span class="math display">\[
\vec{a} \cdot \vec{b} = \Vert\vec{a}\Vert\Vert\vec{b}\Vert\cos\theta
\]</span></p>
<p><span class="math display">\[
\vec{a} \cdot \vec{b} = \begin{pmatrix}x_1\\y_1\end{pmatrix} \cdot \begin{pmatrix}x_2\\y_2\end{pmatrix} = x_1\cdot x_2 + y_1 \cdot y_2
\]</span></p>
<p>可以写成矩阵形式: <span class="math display">\[
\vec a \cdot \vec b = \vec{a}^T\vec{b} \\
= \left(
\begin{array}{cccc} 
   x_1 &amp; y_1 &amp; z_1\\
\end{array}
\right)  \left(
\begin{array}{cccc} 
   x_2\\
   y_2\\
   z_2
\end{array}
\right)
\]</span> 点积运算符合交换、结合、分配率: <span class="math display">\[
\begin{align}
\vec{a} \cdot \vec{b} &amp;= \vec{b}\cdot\vec{a}\\
\vec{a} \cdot(\vec{b} + \vec{c}) &amp;= \vec{a} \cdot \vec{b} + \vec{a} \cdot \vec{c}\\
(k \vec{a}) \cdot \vec{b} &amp;= \vec{a} \cdot(k\vec{b}) = k(\vec{a}\cdot\vec{b})
\end{align}
\]</span></p>
<h4 id="两向量夹角">两向量夹角</h4>
<p><span class="math display">\[
\cos\theta = \frac{\vec{a}\cdot\vec{b}}{\Vert\vec{a}\Vert\Vert\vec{b}\Vert} = \hat{a}\cdot\hat{b}
\]</span></p>
<h4 id="投影">投影</h4>
<p><span class="math inline">\(\vec{b}\)</span> 在<span class="math inline">\(\vec a\)</span>上的<strong>投影</strong>记作<span class="math inline">\(\vec{b}_{\perp}\)</span>, 读作<code>b perp</code>:</p>
<p>(垂直: perpendicular)</p>
<p><img src="/.io//Github\hexo\source\_posts\GAMES101.assets\image-20220329115232862-16489935976142.png" alt="image-20220329115232862" style="zoom: 50%;"> <span class="math display">\[
\vec{b}_{\perp} = k\hat{a}
\]</span> 其中<span class="math inline">\(k = \Vert \vec{b}_{\perp}\Vert = \Vert \vec{b}\Vert \cos \theta\)</span></p>
<p>投影可以将向量<span class="math inline">\(\vec b\)</span>分解成平行于<span class="math inline">\(\vec a\)</span>(<span class="math inline">\(\vec{b}_{\perp}\)</span>)和垂直于<span class="math inline">\(\vec a\)</span>(<span class="math inline">\(\vec{b} - \vec{b}_{\perp}\)</span>)两部分, 如下图:</p>
<p><img src="/.io//Github\hexo\source\_posts\GAMES101.assets\image-20220329121632672-16489936041923.png" alt="image-20220329121632672" style="zoom:50%;"></p>
<h4 id="判断两向量方向">判断两向量方向</h4>
<p><img src="/.io//Github\hexo\source\_posts\GAMES101.assets\image-20220329121938192-16489936060574.png" alt="image-20220329121938192" style="zoom:50%;"></p>
<p>如图, 两向量的点积大于<span class="math inline">\(0\)</span>则相向, 小于<span class="math inline">\(0\)</span>则反向, 等于<span class="math inline">\(0\)</span>则互相垂直.</p>
<h3 id="叉积">叉积</h3>
<p><span class="math display">\[
\vec{a} = \begin{pmatrix}x_1\\y_1\\z_1\end{pmatrix},\vec{b} = \begin{pmatrix}x_2\\y_2\\z_2\end{pmatrix}
\]</span></p>
<p><span class="math inline">\(\vec{a} \times \vec{b}\)</span>可用如下矩阵的行列式来计算: <span class="math display">\[
\vec{a} \times \vec{b} =  \left|
\begin{array}{cccc} 
    \vec{i}  &amp;  \vec{j}   &amp; \vec{k} \\ 
   x_1  &amp;  y_1   &amp; z_1\\ 
    x_2  &amp;  y_2   &amp; z_2 
\end{array}
\right| \\= (y_1z_2 - y_2z_1) \vec{i} + (x_2z_1 - x_1z_2)\vec{j} + (x_1y_2 - x_2y_1)\vec{k}
\]</span></p>
<p>写成矩阵形式: <span class="math display">\[
\vec a \times \vec b = A^* \vec b =  \left(
\begin{array}{cccc} 
   0 &amp; -z_1 &amp; y_1\\
   z_1 &amp; 0 &amp; -x_1\\
   -y_1 &amp; x_1 &amp; 0
\end{array}
\right) \left(
\begin{array}{cccc} 
   x_2\\
   y_2\\
   z_2
\end{array}
\right)
\]</span> <span class="math inline">\(A^*\)</span>称为<code>dual martix</code>.</p>
<p><img src="/.io//Github\hexo\source\_posts\GAMES101.assets\image-20220329122335871-16489936088105.png" alt="image-20220329122335871" style="zoom:50%;"></p>
<p>两向量<span class="math inline">\(\vec a\)</span> <span class="math inline">\(\vec b\)</span> 叉积得到一个垂直于二者的向量.</p>
<p>该向量的方向可用<strong>右手螺旋定则</strong>判断: 伸出右手, 将四指按从<span class="math inline">\(\vec a\)</span>​扫向<span class="math inline">\(\vec b\)</span>​​​​的方向弯曲, 拇指的指向就是该向量的方向. 遵从该定则的坐标系称为<strong>右手系</strong>.</p>
<p>叉积的运算不满足交换律, 基本关系如下:</p>
<p><span class="math display">\[
\vec a \times \vec b = - \vec b \times \vec a\\
\vec a \times \vec a =  \vec 0\\
\vec a \times (\vec b + \vec c) = \vec a \times \vec b + \vec a \times \vec c\\
\vec a \times (k \vec b) = k (\vec a \times \vec b)
\]</span></p>
<h4 id="判断两向量左右关系">判断两向量左右关系</h4>
<p><img src="/.io//Github\hexo\source\_posts\GAMES101.assets\image-20220331101601190-16489936107926.png" alt="image-20220331101601190" style="zoom:33%;"></p>
<p>如图, 计算<span class="math inline">\(\vec{c} = \vec{a} \times \vec{b}\)</span>, 若<span class="math inline">\(\vec{c}\)</span>与<span class="math inline">\(z\)</span>轴同向(<span class="math inline">\(z\)</span>的系数为正)则<span class="math inline">\(\vec{b}\)</span>在<span class="math inline">\(\vec{a}\)</span>的左边, 否则<span class="math inline">\(\vec{b}\)</span>在<span class="math inline">\(\vec{a}\)</span>​的右边.</p>
<h4 id="判断点是否在凸多边形内部">判断点是否在凸多边形内部</h4>
<p><img src="/.io//Github\hexo\source\_posts\GAMES101.assets\image-20220331103128802-16489936123257.png" alt="image-20220331103128802" style="zoom:33%;"></p>
<p>将凸多边形的点逆时针/顺时针排列, 将待判断的点与每条边进行叉乘, 若点均在边的左侧/右侧则该点在凸多边形内部. (注意这是<span class="math inline">\(O(n)\)</span>的,<span class="math inline">\(O(\log n)\)</span>​的做法右转计算几何板子).</p>
<h2 id="正交坐标系">正交坐标系</h2>
<p>假设向量<span class="math inline">\(\vec{x},\vec{y},\vec{z}\)</span>满足 <span class="math display">\[
\Vert \vec{x} \Vert = \Vert \vec{y} \Vert = \Vert \vec{z} \Vert = 1\\
\vec{x} \cdot \vec{y} = \vec{x} \cdot \vec{z} = \vec{y} \cdot \vec{z} = 0\\
\vec{x} \times \vec{y} = \vec{z}
\]</span> 那么<span class="math inline">\(\vec{x},\vec{y},\vec{z}\)</span>​组成一个正交坐标系, 且是右手系.</p>
<p>对于任意向量<span class="math inline">\(\vec p\)</span>, 可通过投影将其分解为三个基底的和: <span class="math display">\[
\vec p = (\vec p \cdot \vec x)\vec x + (\vec p \cdot \vec y )\vec y + (\vec p \cdot \vec z)\vec z
\]</span></p>
<h1 id="矩阵">矩阵</h1>
<h2 id="矩阵乘法">矩阵乘法</h2>
<p>设<span class="math inline">\(A\)</span>是一个<span class="math inline">\(n \times m\)</span>的矩阵, <span class="math inline">\(B\)</span>是一个<span class="math inline">\(m \times k\)</span>的矩阵, 那么<span class="math inline">\(A \times B\)</span>得到一个<span class="math inline">\(n \times k\)</span>的矩阵<span class="math inline">\(C\)</span>, 其中 <span class="math display">\[
C_{i,j} = \sum_{k = 1}^m A_{i,k} \cdot B_{k,j}
\]</span> <strong>矩阵乘法不存在交换律</strong> <span class="math display">\[
AB(C) = A(BC)\\
A(B+C) = AB + AC\\
(A+B)C = AC + BC
\]</span></p>
<h2 id="转置">转置</h2>
<p>将行和列互换. 例如 <span class="math display">\[
 \left(
\begin{array}{cccc} 
   1 &amp; 2 &amp; 3\\
   4 &amp; 5 &amp; 6
\end{array}
\right)^T =  \left(
\begin{array}{cccc} 
   1 &amp; 4\\
   2 &amp; 5\\
   3 &amp; 6
\end{array}
\right)
\]</span></p>
<p><span class="math display">\[
(AB)^T = B^TA^T
\]</span></p>
<h2 id="单位矩阵">单位矩阵</h2>
<p>主对角线为<span class="math inline">\(1\)</span>, 其余元素为<span class="math inline">\(0\)</span>的方阵, 记为<span class="math inline">\(I_n\)</span> 例如 <span class="math display">\[
I_3 =  \left(
\begin{array}{cccc} 
   1 &amp; 0 &amp; 0\\
   0 &amp; 1 &amp; 0\\
   0 &amp; 0 &amp; 1
\end{array}
\right)
\]</span></p>
<p><span class="math display">\[
AI_m = I_nA = A
\]</span></p>
<p>可以用来定义矩阵的逆: <span class="math display">\[
AA^{-1} = I
\]</span></p>
<p><span class="math display">\[
(AB)^{-1} = B^{-1}A^{-1}
\]</span></p>
<h1 id="平面">平面</h1>
<p>三维平面的一般式方程: <span class="math display">\[
Ax + By + Cz + D = 0
\]</span> 其中平面法线为<span class="math inline">\(\vec n = (A,B,C)^T\)</span></p>
<p>对于任意一点<span class="math inline">\(P(x_0,y_0,z_0)\)</span>, 其到平面的距离为<span class="math inline">\(d = Ax_0 + By_0 + Cz_0 + D\)</span>. 可见<span class="math inline">\(D\)</span>为原点到平面的距离. 当<span class="math inline">\(d &gt; 0\)</span>时说明点<span class="math inline">\(P\)</span>在平面法线所指一侧.</p>
<p>若两点<span class="math inline">\(P_1,P_2\)</span>分列于平面两侧, 且它们到平面的距离为<span class="math inline">\(d_1,d_2\)</span>, 则两点连线与平面的交点可以插值得到: <span class="math display">\[
\lambda = \frac{|d_1|}{|d_1 + d_2|} = \frac{d_1}{d_1 - d_2}
\]</span> <span class="math display">\[
P_{inter} = \lambda P_2 + (1 - \lambda)P_1
\]</span></p>
<h1 id="变换基础知识">变换基础知识</h1>
<h2 id="线性变换">线性变换</h2>
<p>可以表示为<span class="math inline">\(\vec{x&#39;} = A\vec{x}\)</span>的变换均为线性变换.</p>
<h3 id="缩放scale">缩放(Scale)</h3>
<p><img src="/.io//Github\hexo\source\_posts\GAMES101.assets\image-20220401171106621-16489936162318.png" alt="image-20220401171106621" style="zoom:33%;"></p>
<p>将横纵坐标按比例缩放: <span class="math display">\[
x&#39; = sx\\
y&#39; = sy
\]</span> 写为矩阵形式: <span class="math display">\[
\left[
\begin{array}{cccc} 
   x&#39;\\
   y&#39;
\end{array}
\right] = \left[
\begin{array}{cccc} 
   s &amp; 0\\
   0 &amp; s
\end{array}
\right]\left[
\begin{array}{cccc} 
   x\\
   y
\end{array}
\right]
\]</span> <img src="/.io//Github\hexo\source\_posts\GAMES101.assets\image-20220401171133617-16489936178929.png" alt="image-20220401171133617" style="zoom:33%;"></p>
<p>横纵坐标按不同比例缩放: <span class="math display">\[
\left[
\begin{array}{cccc} 
   x&#39;\\
   y&#39;
\end{array}
\right] = \left[
\begin{array}{cccc} 
   s_x &amp; 0\\
   0 &amp; s_y
\end{array}
\right]\left[
\begin{array}{cccc} 
   x\\
   y
\end{array}
\right]
\]</span></p>
<h3 id="反射reflection">反射(Reflection)</h3>
<p><img src="/.io//Github\hexo\source\_posts\GAMES101.assets\image-20220401171501411-164899361945310.png" alt="image-20220401171501411" style="zoom:33%;"> <span class="math display">\[
\left[
\begin{array}{cccc} 
   x&#39;\\
   y&#39;
\end{array}
\right] = \left[
\begin{array}{cccc} 
   -1 &amp; 0\\
   0 &amp; 1
\end{array}
\right]\left[
\begin{array}{cccc} 
   x\\
   y
\end{array}
\right]
\]</span></p>
<h3 id="切变shear">切变(Shear)</h3>
<p><img src="/.io//Github\hexo\source\_posts\GAMES101.assets\image-20220401171722621-164899362109911.png" alt="image-20220401171722621" style="zoom:33%;"> <span class="math display">\[
x&#39; = x + ay\\
y&#39; = y
\]</span></p>
<p><span class="math display">\[
\left[
\begin{array}{cccc} 
   x&#39;\\
   y&#39;
\end{array}
\right] = \left[
\begin{array}{cccc} 
   1 &amp; a\\
   0 &amp; 1
\end{array}
\right]\left[
\begin{array}{cccc} 
   x\\
   y
\end{array}
\right]
\]</span></p>
<h3 id="旋转rotate">旋转(Rotate)</h3>
<p>默认为以<span class="math inline">\((0,0)\)</span>为中心逆时针旋转.</p>
<p><img src="/.io//Github\hexo\source\_posts\GAMES101.assets\image-20220401174056239-164899362270712.png" alt="image-20220401174056239" style="zoom:33%;"> <span class="math display">\[
R_\theta  = \left[
\begin{array}{cccc} 
   \cos\theta &amp; -\sin\theta\\
   \sin\theta &amp; \cos\theta
\end{array}
\right]
\]</span></p>
<p><span class="math display">\[
R_{-\theta}  = \left[
\begin{array}{cccc} 
   \cos\theta &amp; \sin\theta\\
   -\sin\theta &amp; \cos\theta
\end{array}
\right] = R_\theta^T = R_\theta^{-1}
\]</span></p>
<p>说明旋转矩阵是一个正交矩阵.</p>
<p>如果旋转的中心不在原点<span class="math inline">\((0,0)\)</span>, 需要先将中心点平移至原点后旋转, 旋转后再将中心点平移至原位置.</p>
<h2 id="平移translation">平移(Translation)</h2>
<p><img src="/.io//Github\hexo\source\_posts\GAMES101.assets\image-20220401180755821-164899362481713.png" alt="image-20220401180755821" style="zoom:33%;"> <span class="math display">\[
x&#39; = x + t_x\\
y&#39; = y + t_y
\]</span> 我们无法把它写成矩阵相乘的形式, 因此平移不是线性变换.</p>
<p>使用齐次坐标表示后(见下文), 平移也可表示为矩阵形式: <span class="math display">\[
\left(
\begin{array}{cccc} 
   x&#39;\\
   y&#39;\\
   w&#39;
\end{array}
\right) = \left(
\begin{array}{cccc} 
   1 &amp; 0 &amp; t_x\\
   0 &amp; 1 &amp; t_y\\
   0 &amp; 0 &amp; 1
\end{array}
\right)\cdot \left(
\begin{array}{cccc} 
   x\\
   y\\
   1
\end{array}
\right) = \left(
\begin{array}{cccc} 
   x + t_x\\
   y + t_y\\
   1
\end{array}
\right)
\]</span></p>
<h2 id="齐次坐标homogeneous-coordinates">齐次坐标(Homogeneous Coordinates)</h2>
<p>我们把二维的点和向量添加一维, 变成齐次坐标<span class="math inline">\((x,y,w)^T\)</span>. <span class="math display">\[
\tt{point} = \left(
\begin{array}{cccc} 
   x\\
   y\\
   1
\end{array}
\right)\tt{,vector = }\left(
\begin{array}{cccc} 
   x\\
   y\\
   0
\end{array}
\right)
\]</span> 对于<span class="math inline">\(w \neq 0\)</span>, <span class="math display">\[
\left(
\begin{array}{cccc} 
   x\\
   y\\
   w
\end{array}
\right) 表示点\left(
\begin{array}{cccc} 
   \frac{x}{w} \\
   \frac{y}{w} \\
   1
\end{array}
\right)
\]</span> 根据<span class="math inline">\(w\)</span>的值可以轻易地判断两个齐次坐标相加后的结果:</p>
<ul>
<li>点 + 向量 = 点</li>
<li>向量 + 向量 = 向量</li>
<li>点 - 点 = 向量</li>
<li>点 + 点在齐次坐标下表示两点的中点</li>
</ul>
<h2 id="仿射变换affine-transformation">仿射变换(Affine Transformation)</h2>
<p>对一个向量空间进行一次线性变换后再进行平移, 称为仿射变换. <span class="math display">\[
\left(
\begin{array}{cccc} 
   x&#39;\\
   y&#39;\\
\end{array}
\right) = \left(
\begin{array}{cccc} 
   a &amp; b\\
   c &amp; d\\
\end{array}
\right) \cdot \left(
\begin{array}{cccc} 
   x\\
   y\\
\end{array}
\right) + \left(
\begin{array}{cccc} 
   t_x\\
   t_y\\
\end{array}
\right)
\]</span> 写成齐次坐标形式: <span class="math display">\[
\left(
\begin{array}{cccc} 
   x&#39;\\
   y&#39;\\
   1
\end{array}
\right) = 
\left(
\begin{array}{cccc} 
   a &amp; b &amp; t_x\\
   c &amp; d &amp; t_y\\
   0 &amp; 0 &amp; 1
\end{array}
\right) \cdot 
\left(
\begin{array}{cccc} 
   x\\
   y\\
   1
\end{array}
\right)
\]</span></p>
<p>其中, 左上的2x2矩阵为原线性变换矩阵, <span class="math inline">\(t_x\)</span>, <span class="math inline">\(t_y\)</span>表示平移. 三维与其类似. 注意: 这个矩阵表示先进行线性变换, 再进行平移.</p>
<h2 id="逆变换inverse-transform">逆变换(Inverse Transform)</h2>
<p>求逆即可</p>
<h2 id="变换的组合">变换的组合</h2>
<p>假设对<span class="math inline">\(\vec x\)</span>依次应用变换<span class="math inline">\(M_1,M_2,...,M_n\)</span>, 那么有 <span class="math display">\[
\vec{x&#39;} = M_n \cdot M_{n-1} \cdots M_2 \cdot M_1 \cdot \vec{x}
\]</span></p>
<h2 id="变换的分解">变换的分解</h2>
<h3 id="例按某点旋转">例:按某点旋转</h3>
<p><img src="/.io//Github\hexo\source\_posts\GAMES101.assets\image-20220401185309912-164899362872814.png" alt="image-20220401185309912" style="zoom: 50%;"></p>
<p>假设我们要按点<span class="math inline">\(C\)</span>旋转<span class="math inline">\(\alpha\)</span>度, 可以先将点<span class="math inline">\(C\)</span>平移回原点<span class="math inline">\(T(-c)\)</span>, 进行旋转<span class="math inline">\(R(\alpha)\)</span>, 再将点<span class="math inline">\(C\)</span>移动回原位. <span class="math display">\[
\vec{x&#39;} = T(c) \cdot R(\alpha) \cdot T(-c) \cdot \vec{x}
\]</span></p>
<h2 id="三维变换">三维变换</h2>
<p>此处仅列出和二维有较大不同的部分.</p>
<h3 id="旋转">旋转</h3>
<h4 id="按坐标轴旋转">按坐标轴旋转</h4>
<ul>
<li><p>按<span class="math inline">\(x\)</span>轴旋转<span class="math inline">\(\alpha\)</span>度 <span class="math display">\[
  R_x(\alpha) = \left(
  \begin{array}{cccc} 
     1 &amp; 0 &amp; 0 &amp; 0\\
     0 &amp; \cos \alpha &amp; -\sin\alpha &amp; 0\\
     0 &amp; \sin\alpha &amp; \cos\alpha &amp; 0\\
     0 &amp; 0 &amp; 0 &amp; 1
  \end{array}
  \right)
  \]</span></p></li>
<li><p>按<span class="math inline">\(y\)</span>轴(注意和其它两个的区别, $ x z = -y$) <span class="math display">\[
  R_y(\alpha) = \left(
  \begin{array}{cccc} 
     \cos\alpha &amp; 0 &amp; \sin\alpha &amp; 0\\
     0 &amp; 1 &amp; 0 &amp; 1\\
     -\sin\alpha &amp; 0 &amp; \cos\alpha &amp; 0\\
     0 &amp; 0 &amp; 0 &amp; 1
  \end{array}
  \right)
  \]</span></p></li>
<li><p>按<span class="math inline">\(z\)</span>轴 <span class="math display">\[
  R_z(\alpha) = \left(
  \begin{array}{cccc} 
     \cos\alpha &amp; -\sin\alpha &amp; 0 &amp; 0 \\
     \sin\alpha &amp; \cos\alpha &amp; 0 &amp; 0\\
     0 &amp; 0 &amp; 1 &amp; 0\\
     0 &amp; 0 &amp; 0 &amp; 1
  \end{array}
  \right)
  \]</span></p></li>
</ul>
<h4 id="一般性的旋转">一般性的旋转</h4>
<p>我们用<span class="math inline">\(R_{xyz}(\alpha, \beta, \gamma)\)</span>表示绕<span class="math inline">\(x\)</span>轴旋转<span class="math inline">\(\alpha\)</span>, 绕<span class="math inline">\(y\)</span>轴旋转<span class="math inline">\(\beta\)</span>, 绕<span class="math inline">\(z\)</span>轴旋转<span class="math inline">\(\gamma\)</span>. <span class="math inline">\(\alpha\beta\gamma\)</span>也被叫做欧拉角. <span class="math display">\[
R_{xyz}(\alpha, \beta, \gamma) = R_x(\alpha)R_y(\beta)R_z(\gamma)
\]</span></p>
<h4 id="rodrigues旋转公式">Rodrigues旋转公式</h4>
<p><span class="math inline">\(R(\vec n,\alpha)\)</span>表示绕轴<span class="math inline">\(\vec n\)</span>(起点在原点)按右手方 m 向旋转角度为<span class="math inline">\(\alpha\)</span>的变换. <span class="math display">\[
R(\vec n,\alpha) = \cos(\alpha)\vec I + (1 - \cos(\alpha))\vec n \vec n^T + \sin(\alpha)\left(
\begin{array}{cccc} 
   0 &amp; -\vec{n}_{z} &amp; \vec{n}_y\\
   \vec{n}_z &amp; 0 &amp; -\vec{n}_x\\
   -\vec{n}_y &amp; \vec{n}_x &amp; 0\\
\end{array}
\right)
\]</span></p>
<h4 id="欧拉角">欧拉角</h4>
<h4 id="待补充四元数quaternion">(待补充)四元数(Quaternion)</h4>
<p>四元数是一种有三个虚部的复数: <span class="math display">\[
q = a + b i + c j + d k
\]</span> 其中有 <span class="math display">\[
i^2 = j^2 = k^2 = ijk = -1
\]</span> 四元数的加法只需把对应系数相加. 乘法每个虚部遵从如下乘法表:</p>
<figure>
<img src="/.io//image-20230217144100518.png" alt="image-20230217144100518"><figcaption aria-hidden="true">image-20230217144100518</figcaption>
</figure>
<p>和虚数的共轭类似, 有四元数<span class="math inline">\(q\)</span>的共轭<span class="math inline">\(q^*\)</span>: <span class="math display">\[
q^* = a - bi - cj - dk
\]</span> 注意: <span class="math inline">\((pq)^* = q^*p^*\)</span></p>
<p>一个四元数的绝对值<span class="math inline">\(|q|\)</span>定义为: <span class="math display">\[
|q| = \sqrt{q\cdot q^*} = \sqrt{a^2 + b^2 + c^2 + d^2}
\]</span> 其中绝对值为1的四元数称为单位四元数.</p>
<p>四元数的逆(乘逆)<span class="math inline">\(q^{-1}\)</span>: <span class="math display">\[
q^{-1} = \frac{q^*}{|q|^2}
\]</span></p>
<p>实部为0(<span class="math inline">\(a = 0\)</span>)的四元数称为纯四元数. 一个三维空间的坐标<span class="math inline">\((x,y,z)\)</span>可以用纯四元数<span class="math inline">\(xi + yj +zk\)</span>来表示.</p>
<h1 id="渲染过程中的各种变换">渲染过程中的各种变换</h1>
<p>推荐阅读:http://www.codinglabs.net/article_world_view_projection_matrix.aspx</p>
<p>假设我们要拍一张照片，需要以下三个步骤:</p>
<ol type="1">
<li>安排好要拍的人或物. 对应模型变换(model transformation), 即将物体坐标转换为世界坐标.</li>
<li>寻找一个放置相机的位置和角度. 对应视图变换(view transformation).</li>
<li>拍照. 对应投影变换(projection transformation).</li>
</ol>
<h2 id="模型变换model-transformation">模型变换(Model Transformation)</h2>
<p>这一步是将模型坐标转换为世界坐标的过程, 转换矩阵记为<span class="math inline">\(M_{model}\)</span></p>
<h2 id="视图变换view-transformation">视图变换(View Transformation)</h2>
<p>要进行视图变换, 我们首先需要定义相机的摆放:</p>
<ul>
<li>位置(Position)<span class="math inline">\(\vec e\)</span></li>
<li>视角(Look-at direction/gaze direction)<span class="math inline">\(\hat g\)</span></li>
<li>向上方向(Up direction)<span class="math inline">\(\hat t\)</span></li>
</ul>
<p>因为我们写的是一个渲染引擎而不是在现实世界，所以完全可以搞一个以相机为中心的世界. 约定相机永远位于原点，向上方向是<span class="math inline">\(\text Y\)</span>轴, 指向<span class="math inline">\(\text Z\)</span>轴的反方向. 再次提醒坐标系是右手系, 且<span class="math inline">\(\text Y\)</span>是纵坐标轴:</p>
<p><img src="/.io//Github\hexo\source\_posts\GAMES101.assets\image-20220621095653583.png" alt="image-20220621095653583" style="zoom:50%;"></p>
<p>那么对于一个给定的相机位置，需要进行一系列变换将其变成标准的相机位置. 我们把这个变换矩阵记作<span class="math inline">\(M_{view}\)</span>, 具体需要进行如下变换:</p>
<ol type="1">
<li>将<span class="math inline">\(\vec e\)</span>平移到原点</li>
<li>将<span class="math inline">\(\vec g\)</span>旋转到<span class="math inline">\(-\vec Z\)</span></li>
<li>将<span class="math inline">\(\hat t\)</span>旋转到<span class="math inline">\(\vec Y\)</span></li>
<li>将<span class="math inline">\(\hat g \times \hat t\)</span>旋转到<span class="math inline">\(\vec X\)</span></li>
</ol>
<p>根据前面的内容, 我们需要先平移(<span class="math inline">\(T_{view}\)</span>)再旋转<span class="math inline">\((R_{view})\)</span>, 即<span class="math inline">\(M_{view} = R_{view}T_{view}\)</span> <span class="math display">\[
T_{view} = \left(
\begin{array}{cccc} 
   1 &amp; 0 &amp; 0 &amp; -x_e\\
   0 &amp; 1 &amp; 0 &amp; -y_e\\
   0 &amp; 0 &amp; 1 &amp; -z_e\\
   0 &amp; 0 &amp; 0 &amp; 1
\end{array}
\right)
\]</span> 同样根据前面的内容, 我们有<span class="math inline">\(R_{-\theta} = R_\theta^{-1} = R_\theta^T\)</span>. 因此与其正向进行旋转, 不如先把<span class="math inline">\(X\space Y\space-Z\)</span>轴旋转到<span class="math inline">\(etg\)</span>, 再求它的逆矩阵. 因为我们要旋转的向量都很简单(比如<span class="math inline">\((1,0,0)^T\)</span>), 所以这个矩阵可以直接构造出来: <span class="math display">\[
R_{view}^{-1} = \left(
\begin{array}{cccc} 
   x_{\hat g \times \hat t} &amp; x_\hat t &amp; x_{-\hat g} &amp; 0\\
   y_{\hat g \times \hat t} &amp; y_\hat t &amp; y_{-\hat g} &amp; 0\\
   z_{\hat g \times \hat t} &amp; z_\hat t &amp; z_{-\hat g} &amp; 0\\
   0 &amp; 0 &amp; 0 &amp; 1
\end{array}
\right)
\]</span> 于是有 <span class="math display">\[
R_{view} = (R_{view}^{-1})^T \left(
\begin{array}{cccc} 
   x_{\hat g \times \hat t} &amp; y_{\hat g \times \hat t} &amp; z_{\hat g \times \hat t} &amp; 0\\
   x_\hat t &amp; y_\hat t &amp; z_\hat t &amp; 0\\
   x_{-\hat g} &amp; y_{-\hat g} &amp; z_{-\hat g} &amp; 0\\
   0 &amp; 0 &amp; 0 &amp; 1
\end{array}
\right)
\]</span></p>
<p>在实现时, 我们通常不指定视角<span class="math inline">\(\vec g\)</span>, 而是通过视角所指向的点(设为<span class="math inline">\(C\)</span>)和相机位置(<span class="math inline">\(E\)</span>)来确定<span class="math inline">\(\vec g\)</span>. 这时有: <span class="math display">\[
\vec g = \vec{EC}\\
\]</span> 有了<span class="math inline">\(\vec g,\vec t\)</span>, 便可以计算出相机坐标系: <span class="math display">\[
\vec w = -\frac{\vec g}{|\vec g|}\\
\vec u = \frac{\vec t \times \vec w}{|\vec t \times \vec w|}\\
\vec v = \vec w \times \vec u
\]</span> 这时<span class="math inline">\(R_{view}\)</span>为 <span class="math display">\[
R_{view} = (R_{view}^{-1})^T \left(
\begin{array}{cccc} 
   x_{\vec u} &amp; y_{\vec u} &amp; z_{\vec u} &amp; 0\\
   x_{\vec v} &amp; y_{\vec v} &amp; z_{\vec v} &amp; 0\\
   x_{\vec w} &amp; y_{\vec w} &amp; z_{\vec w} &amp; 0\\
   0 &amp; 0 &amp; 0 &amp; 1
\end{array}
\right)
\]</span></p>
<h3 id="lookat">LookAt</h3>
<h2 id="投影变换projection-transformation">投影变换(Projection Transformation)</h2>
<p>投影变换将3D的图形转换到2D上，分为正交投影(Orthographic Projection)和透视投影(Perspective Projection)</p>
<figure>
<img src="/.io//Github\hexo\source_posts\GAMES101.assets\image-20220621164915132.png" alt="image-20220621164915132"><figcaption aria-hidden="true">image-20220621164915132</figcaption>
</figure>
<h3 id="正交投影orthographic-projection">正交投影(Orthographic Projection)</h3>
<p>其实直接将所有的<span class="math inline">\(z\)</span>值忽略掉就可以获得正交投影. 但一般采用如下方法:</p>
<p>我们先定义一个<span class="math inline">\([l,r] \times [b,t] \times [f,n]\)</span>的立方体(left,right,bottom,top,far,near). (注意, <span class="math inline">\(z\)</span>值越小离相机越远, 因为相机的视线是-Z) 然后我们将这个立方体先平移再缩放, 得到中心位于原点, <span class="math inline">\([-1,1] \times[-1,1] \times [-1,1]\)</span>的标准立方体(canonical cube).</p>
<figure>
<img src="/.io//Github\hexo\source_posts\GAMES101.assets\image-20220622075400700.png" alt="image-20220622075400700"><figcaption aria-hidden="true">image-20220622075400700</figcaption>
</figure>
<p>可以很简单地写出变换矩阵: <span class="math display">\[
M_{ortho} = \left(
\begin{array}{cccc} 
   \frac{2}{r - l} &amp; 0 &amp; 0 &amp; 0\\
   0 &amp; \frac{2}{t - b} &amp; 0 &amp; 0\\
   0 &amp; 0 &amp; \frac{2}{n - f} &amp; 0\\
   0 &amp; 0 &amp; 0 &amp; 1
\end{array}
\right)\left(
\begin{array}{cccc} 
   1 &amp; 0 &amp; 0 &amp; -\frac{l+r}{2} \\
   0 &amp; 1 &amp; 0 &amp; -\frac{b+t}{2} \\
   0 &amp; 0 &amp; 1 &amp; -\frac{f+n}{2} \\
   0 &amp; 0 &amp; 0 &amp; 1
\end{array}
\right)
\]</span></p>
<p>相乘之后的结果:</p>
<figure>
<img src="/.io//image-20230211094736858.png" alt="image-20230211094736858"><figcaption aria-hidden="true">image-20230211094736858</figcaption>
</figure>
<h3 id="透视投影perspective-projection">透视投影(Perspective Projection)</h3>
<p>进行透视投影时, 我们假设相机是一个点, 而所有光线都汇聚到这个点上(或者从这个点发出):</p>
<p><img src="/.io//Github\hexo\source\_posts\GAMES101.assets\image-20220622080539039.png" alt="image-20220622080539039" style="zoom:50%;"></p>
<p>在三维空间上我们的视野便形成了一个四棱锥(因为你的电脑屏幕是长方形而不是圆形). 如果以待渲染的画面所在平面为顶将这个四棱锥的头截去, 便得到了一个截头四棱锥(frustum). 将这个四棱锥挤压成一个立方体, 再进行正交投影, 便能得到想要的画面:</p>
<p><img src="/.io//Github\hexo\source\_posts\GAMES101.assets\image-20220622080748026.png" alt="image-20220622080748026" style="zoom:50%;"></p>
<p>考虑在挤压时Frustum中每个点的<span class="math inline">\(x,y\)</span>会如何变化.</p>
<p><img src="/.io//Github\hexo\source\_posts\GAMES101.assets\image-20220622082005810.png" alt="image-20220622082005810" style="zoom:50%;"></p>
<p>上图可以看作Frustum的一个侧视图. 一个点的<span class="math inline">\(y\)</span>在挤压后变成了<span class="math inline">\(y&#39;\)</span>. 根据相似三角形很容易得出 <span class="math display">\[
y&#39; = \frac{n}{z}y
\]</span> 同样 <span class="math display">\[
x&#39; = \frac{n}{z}x
\]</span> 假设挤压过程对应的矩阵是<span class="math inline">\(M_{persp\to ortho}\)</span>. 此时我们还不知道<span class="math inline">\(z\)</span>坐标会如何变化(注意它不是不变).</p>
<p>注意：可以利用矩阵的最后一行对<span class="math inline">\(x,y,z\)</span>进行除法运算.</p>
<figure>
<img src="/.io//image-20230213093551705.png" alt="image-20230213093551705"><figcaption aria-hidden="true">image-20230213093551705</figcaption>
</figure>
<figure>
<img src="/.io//image-20230213093601539.png" alt="image-20230213093601539"><figcaption aria-hidden="true">image-20230213093601539</figcaption>
</figure>
<p>举例:</p>
<figure>
<img src="/.io//image-20230213093729117.png" alt="image-20230213093729117"><figcaption aria-hidden="true">image-20230213093729117</figcaption>
</figure>
<p>根据 <span class="math display">\[
M_{persp \to ortho} \cdot \left(
\begin{array}{cccc} 
   x \\
   y \\
   z \\
   1 
\end{array}
\right) =  \left(
\begin{array}{cccc} 
   \frac{n}{z}x \\
   \frac{n}{z}y \\
   ? \\
   1 
\end{array}
\right) =  \left(
\begin{array}{cccc} 
   nx \\
   ny \\
   ? \\
   z 
\end{array}
\right)
\]</span> 可以先填出矩阵的部分内容: <span class="math display">\[
M_{persp \to ortho} = \left(
\begin{array}{cccc} 
   n &amp; 0 &amp; 0 &amp; 0\\
   0 &amp; n &amp; 0 &amp; 0\\
   ? &amp; ? &amp; ? &amp; ?\\
   0 &amp; 0 &amp; 1 &amp; 0
\end{array}
\right)
\]</span> 这个矩阵的第三行需要进行一点推导. 尽管我们不知道每个点的<span class="math inline">\(z\)</span>坐标如何变换, 但我们知道, 在最前面平面(<span class="math inline">\(z = n\)</span>)上的点, 其<span class="math inline">\(z\)</span>坐标永远等于<span class="math inline">\(n\)</span>, 即: <span class="math display">\[
\left(
\begin{array}{cccc} 
   n &amp; 0 &amp; 0 &amp; 0\\
   0 &amp; n &amp; 0 &amp; 0\\
   ? &amp; ? &amp; ? &amp; ?\\
   0 &amp; 0 &amp; 1 &amp; 0
\end{array}
\right) \cdot \left(
\begin{array}{cccc} 
   x \\
   y \\
   n \\
   1 
\end{array}
\right) = \left(
\begin{array}{cccc} 
   x \\
   y \\
   n \\
   1 
\end{array}
\right)
= \left(
\begin{array}{cccc} 
   nx \\
   ny \\
   n^2 \\
   n 
\end{array}
\right)
\]</span> 可知<span class="math inline">\(M[2][0] = M[2][1] = 0\)</span>. 设<span class="math inline">\(M[2][2]\)</span>为<span class="math inline">\(A\)</span>, <span class="math inline">\(M[2][3]\)</span>为<span class="math inline">\(B\)</span>, 则 <span class="math display">\[
(0,0,A,B) \cdot \left(
\begin{array}{cccc} 
   x \\
   y \\
   n \\
   1 
\end{array}
\right) = n^2
\]</span></p>
<p><span class="math display">\[
An + B = n^2
\]</span></p>
<p>同理有 <span class="math display">\[
Af + B = f^2
\]</span> 解得 <span class="math display">\[
A = n + f\\
B = -nf
\]</span> 于是我们求出了整个矩阵: <span class="math display">\[
M_{persp \to ortho} = \left(
\begin{array}{cccc} 
   n &amp; 0 &amp; 0 &amp; 0\\
   0 &amp; n &amp; 0 &amp; 0\\
   0 &amp; 0 &amp; n+f &amp; -nf\\
   0 &amp; 0 &amp; 1 &amp; 0
\end{array}
\right)
\]</span> 整个透视投影的过程便是先挤压再正交投影的过程, 即 <span class="math display">\[
M_{persp} = M_{ortho}M_{persp\to ortho}
\]</span></p>
<p>做一下矩阵乘法, 这个矩阵的结果是: <span class="math display">\[
M_{persp } = \left(
\begin{array}{cccc} 
\frac{2n}{r - l} &amp; 0 &amp; \frac{l + r}{l - r} &amp; 0 \\
0 &amp; \frac{2n}{t - b} &amp; \frac{b + t}{b - t} &amp; 0 \\
0 &amp; 0 &amp; \frac{f+n}{n - f} &amp; -\frac{2 f n}{n - f} \\
0 &amp; 0 &amp; 1 &amp; 0
\end{array}
\right)
\]</span> 可以看到, 这个矩阵的最后一行是<span class="math inline">\([0,0,1,0]\)</span>. 也就是说, 一个点在进行透视投影后, 它的深度信息<span class="math inline">\(z\)</span>就是齐次坐标的<span class="math inline">\(w\)</span>.</p>
<p>上述矩阵还可以进行优化. 一般情况下, 我们的视锥是对称的(即<span class="math inline">\(l = -r, t = -b\)</span>). 这种情况下有: <span class="math display">\[
M_{persp } = \left(
\begin{array}{cccc} 
\frac{n}{r} &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; \frac{n}{t} &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; \frac{f+n}{n - f} &amp; -\frac{2 f n}{n - f} \\
0 &amp; 0 &amp; 1 &amp; 0
\end{array}
\right)
\]</span> 注意: 如果在OpenGL下使用上述矩阵, 需要进行转置.</p>
<h4 id="构造投影矩阵">构造投影矩阵</h4>
<p>来自作业1. 参考资料: https://zhuanlan.zhihu.com/p/361156478</p>
<p>https://en.wikipedia.org/wiki/Field_of_view_in_video_games</p>
<p><img src="/.io//image-20221219152229743.png" alt="image-20221219152229743" style="zoom: 67%;"></p>
<p>有些时候, 我们没有<span class="math inline">\(l,r,b,t,n,f\)</span>六个参数, 而是需要用以下四个参数，构造投影矩阵:</p>
<p><code>float eyefov</code>: (垂直)可视角度</p>
<p><code>float aspect_ratio</code>: 宽高比</p>
<p><code>float zNear</code>: 近平面的<span class="math inline">\(z\)</span>轴坐标</p>
<p><code>float zFar</code>: 远平面的<span class="math inline">\(z\)</span>轴坐标</p>
<figure>
<img src="/.io//image-20221219152445852.png" alt="image-20221219152445852"><figcaption aria-hidden="true">image-20221219152445852</figcaption>
</figure>
<p><img src="/.io//480px-FOV_in_video_games.svg.png" alt="480px-FOV_in_video_games.svg" style="zoom: 50%;"></p>
<p>如图, 约定<span class="math inline">\(V\)</span>代表垂直视角, <span class="math inline">\(H\)</span>代表水平视角.<span class="math inline">\(w\)</span>和<span class="math inline">\(h\)</span>代表显示器的宽度和高度. <span class="math inline">\(l,r,b,t,n,f\)</span>见投影变换部分. 在此假设所有角已经转换成弧度制. 易得: <span class="math display">\[
t = \tan(\frac{V}{2}) \cdot \text{zNear}\\
b = -t
\]</span> 因为<span class="math inline">\(\text{aspect\_ratio} = \frac{w}{h} = \frac{r}{t}\)</span>, 所以有 <span class="math display">\[
r = \text{aspect\_ratio} \cdot t\\
l = -r
\]</span> 这样便可构建出投影变换矩阵.</p>
<h3 id="裁剪坐标系clip-coordinate-system">裁剪坐标系(clip coordinate system)</h3>
<p>在经过<span class="math inline">\(M_{persp\to ortho}\)</span>的变换后, 每个顶点均位于裁剪坐标系中. 此时每个点仍然是以齐次坐标系<span class="math inline">\((x_c,y_c,z_c,w_c)\)</span>的形式表示的. 对每个点进行透视除法(即将<span class="math inline">\(xyz\)</span>分量都除以<span class="math inline">\(w\)</span>), 便可将其转换为标准化设备坐标系(normalized device coordinates). 但在进行透视除法前, 我们需要对顶点进行裁剪. 对于任意<span class="math inline">\(xyz\)</span>坐标, 如果其绝对值大于<span class="math inline">\(|w|\)</span>, 则这个顶点需要被裁剪.</p>
<p>在裁剪后并执行透视除法后, 每个点便被变换到了<span class="math inline">\([-1,1]^3\)</span>的空间中. 且这里的每个点都曾位于透视投影定义的截头锥体内.</p>
<h2 id="视口变换viewport-transformation">视口变换(Viewport Transformation)</h2>
<figure>
<img src="/.io//image-20221219153149597.png" alt="image-20221219153149597"><figcaption aria-hidden="true">image-20221219153149597</figcaption>
</figure>
<p>屏幕像素有一些约定, 见下图</p>
<figure>
<img src="/.io//image-20221219153222638.png" alt="image-20221219153222638"><figcaption aria-hidden="true">image-20221219153222638</figcaption>
</figure>
<figure>
<img src="/.io//image-20221219153232165.png" alt="image-20221219153232165"><figcaption aria-hidden="true">image-20221219153232165</figcaption>
</figure>
<p>视口变换是这一系列变换的最后一步, 它的作用是将上一步正交投影得到的<span class="math inline">\([-1,1] \times [-1,1]\)</span>的画面转换到显示器<span class="math inline">\([0,width] \times [0,height]\)</span>的画面. 由于像素<span class="math inline">\((x,y)\)</span>在屏幕上的实际坐标是<span class="math inline">\((x+0.5,y+0.5)\)</span>, 最终我们要将正交投影的矩阵转化为<span class="math inline">\([-0.5,width - 0.5] \times [-0.5,height - 0.5]\)</span> 易得转移矩阵如下: <span class="math display">\[
M_{viewport} = \left(
\begin{array}{cccc} 
   \frac{width}{2} &amp; 0 &amp; 0 &amp; \frac{width-1}{2} \\
   0 &amp; \frac{height}{2} &amp; 0 &amp; \frac{height-1}{2}\\
   0 &amp; 0 &amp; 1 &amp; 0\\
   0 &amp; 0 &amp; 0 &amp; 1
\end{array}
\right)
\]</span> 注意在上面的变换中, 我们保留了<span class="math inline">\(z\)</span>的值供z-buffer使用.</p>
<p>综上所述, 一个完整的变换矩阵为: <span class="math display">\[
M = M_{viewport}M_{persp}M_{view}M_{model}
\]</span></p>
<h1 id="光栅化rasterizing">光栅化(Rasterizing)</h1>
<p>光栅化时处理的一般是三角形, 因为它有如下优秀的性质:</p>
<figure>
<img src="/.io//image-20221219160050824.png" alt="image-20221219160050824"><figcaption aria-hidden="true">image-20221219160050824</figcaption>
</figure>
<p>将一个三角形变为屏幕上的像素便为光栅化:</p>
<figure>
<img src="/.io//image-20221219161426802.png" alt="image-20221219161426802"><figcaption aria-hidden="true">image-20221219161426802</figcaption>
</figure>
<figure>
<img src="/.io//image-20221219161502656.png" alt="image-20221219161502656"><figcaption aria-hidden="true">image-20221219161502656</figcaption>
</figure>
<p>在光栅化时, 先求出三角形的边界, 再遍历边界里的每个像素, 判断其是否在三角形的内部(可以用叉积或者重心坐标), 绘制所有在三角形内部的像素即可.</p>
<h3 id="抗锯齿antialiasing理论知识">抗锯齿(Antialiasing)理论知识</h3>
<p>本节相当多的内容引用自Wikipedia.</p>
<p><a href="https://zh.wikipedia.org/wiki/%E6%B7%B7%E7%96%8A">混叠</a>（英语：<strong>Aliasing</strong>），在<a href="https://zh.wikipedia.org/wiki/訊號">信号</a>频谱上可称作<strong>叠频</strong>；在<a href="https://zh.wikipedia.org/wiki/影像">影像</a>上可称作<strong>叠影</strong>，主要来自于对连续时间信号作<a href="https://zh.wikipedia.org/wiki/取樣">取样</a>以<a href="https://zh.wikipedia.org/wiki/數位化">数字化</a>时，取样频率低于两倍<a href="https://zh.wikipedia.org/wiki/奈奎斯特频率">奈奎斯特频率</a>。</p>
<p>在<a href="https://zh.wikipedia.org/wiki/統計">统计</a>、<a href="https://zh.wikipedia.org/wiki/訊號處理">信号处理</a>和相关领域中，<strong>混叠</strong>是指取样信号被还原成连续信号时产生彼此交叠而<strong>失真</strong>的现象。当混叠发生时，原始信号无法从取样信号还原。而混叠可能发生在时域上，称做<a href="https://zh.wikipedia.org/w/index.php?title=時間混疊&amp;action=edit&amp;redlink=1">时间混叠</a>，或是发生在频域上，被称作<a href="https://zh.wikipedia.org/w/index.php?title=空間混疊&amp;action=edit&amp;redlink=1">空间混叠</a>。</p>
<p>在视觉影像的<a href="https://zh.wikipedia.org/wiki/類比數位轉換">模拟数字转换</a>或<a href="https://zh.wikipedia.org/w/index.php?title=音樂訊號&amp;action=edit&amp;redlink=1">音乐信号</a>领域，混叠都是相当重要的议题。因为在做模拟-数字转换时若取样频率选取不当将造成高频信号和低频信号混叠在一起，因此无法完美地重建出原始的信号。为了避免此情形发生，取样前必须先做<a href="https://zh.wikipedia.org/wiki/滤波">滤波</a>的操作。</p>
<p><img src="/.io//image-20221219164657871.png" alt="image-20221219164657871" style="zoom:50%;"></p>
<p>先对原图像进行模糊处理(滤波), 再进行采样, 可以得到较好的抗锯齿效果:</p>
<p><img src="/.io//image-20221219164733184.png" alt="image-20221219164733184" style="zoom:50%;"></p>
<p>但是如果先采样再进行模糊, 只会得到模糊的锯齿:</p>
<p><img src="/.io//image-20221219164822465.png" alt="image-20221219164822465" style="zoom:50%;"></p>
<p>下面解释原因.(日后再补)</p>
<h4 id="频域frequency-domain">频域(Frequency Domain)</h4>
<p><strong>频率</strong>（frequency）又称<strong>周率</strong>，是<a href="https://zh.wikipedia.org/wiki/物理学">物理学</a>上描述某具规律周期性的现象或事件，在每单位<a href="https://zh.wikipedia.org/wiki/时间">时间</a>内（即每秒）重复发生的次数.</p>
<p>设<span class="math inline">\(\tau\)</span>时间内某事件重复发生<span class="math inline">\(n\)</span>次, 则该事件发生的频率<span class="math inline">\(f\)</span>为 <span class="math display">\[
f = \frac{n}{\tau} \text{Hz}
\]</span> 又因为<a href="https://zh.wikipedia.org/wiki/週期">周期</a>定义为重复事件发生的最小时间间隔，故频率也可以表示为周期（<span class="math inline">\(T\)</span>）的<a href="https://zh.wikipedia.org/wiki/倒数">倒数</a>： <span class="math display">\[
f = \frac{1}{T} \text{Hz}
\]</span></p>
<h3 id="msaa">MSAA</h3>
<figure>
<img src="/.io//image-20221221102839024.png" alt="image-20221221102839024"><figcaption aria-hidden="true">image-20221221102839024</figcaption>
</figure>
<figure>
<img src="/.io//image-20221221102907451.png" alt="image-20221221102907451"><figcaption aria-hidden="true">image-20221221102907451</figcaption>
</figure>
<figure>
<img src="/.io//image-20221221102920456.png" alt="image-20221221102920456"><figcaption aria-hidden="true">image-20221221102920456</figcaption>
</figure>
<p>MSAA先进行超采样, 即原来采样一次的单个像素, 现在采样<span class="math inline">\(n \times n\)</span>次得到<span class="math inline">\(n^2\)</span>个小像素. 超采样后, 将每个像素对应的在三角形内部的小像素进行平均(这一步相当于模糊操作), 即可得到最终的采样结果.</p>
<h3 id="z-buffer">Z-buffer</h3>
<h1 id="着色shading">着色(Shading)</h1>
<h2 id="bling-phong模型">Bling-Phong模型</h2>
<p><img src="/.io//image-20220628093826856.png" alt="image-20220628093826856" style="zoom:50%;"></p>
<p>如图, 现实世界中的光线可以分为三个部分:</p>
<ul>
<li>反射高光(Specular highlights)</li>
<li>漫反射(Diffuse reflection)</li>
<li>环境光(Ambient lighting)</li>
</ul>
<p>分别对这三种光进行模拟, 便可得到较为真实的效果.</p>
<p><img src="/.io//image-20220628102400032.png" alt="image-20220628102400032" style="zoom:67%;"></p>
<p>在计算光线反射时, 我们是对每个点(Shading point)进行单独计算的. 尽管待计算的点可能位于曲面上, 我们仍然认为极小的局部是一个平面. 待处理的输入参数有以下几个:</p>
<ul>
<li>观测方向<span class="math inline">\(\hat v\)</span>(Viewer direction)</li>
<li>平面法线<span class="math inline">\(\hat n\)</span>(Surface normal)</li>
<li>光线方向<span class="math inline">\(\hat l\)</span>(Light direction), 它从表面指向光源, 与光线的方向相反.</li>
<li>表面参数(Surface parameters), 包括颜色, 反射率等</li>
</ul>
<p>注意: 以上的向量均只表示方向, 为单位向量. 另外着色只考虑自身, 不会考虑其他物体的存在, 要将着色(Shading)和阴影(Shadow)进行区分.</p>
<h3 id="漫反射diffuse-reflection">漫反射(Diffuse reflection)</h3>
<p><img src="/.io//image-20220628103055157.png" alt="image-20220628103055157" style="zoom:50%;"></p>
<p>当一束光射向粗糙的物体表面时, 粗糙表面会把入射光向各个方向进行反射, 称为漫反射. 需要注意无论我们的视角角度如何, 漫反射的效果都是一样的. 因此漫反射的光照强度只和入射角、平面法线、平面距光源的距离有关.</p>
<p>首先来考虑入射角:</p>
<p><img src="/.io//image-20220630093119443.png" alt="image-20220630093119443" style="zoom:50%;"></p>
<p>设<span class="math inline">\(\theta\)</span>是<span class="math inline">\(\hat l\)</span>和<span class="math inline">\(\hat n\)</span>的夹角, 那么平面接收到的能量是与<span class="math inline">\(\cos \theta = \hat l \cdot \hat n\)</span>成正比的. 这被称为兰伯特余弦定律(Lambert's cosine law).</p>
<p>再考虑距离:</p>
<p><img src="/.io//image-20220630093855769.png" alt="image-20220630093855769" style="zoom:50%;"></p>
<p>能量与光源的距离成平方反比关系, 即距离光源<span class="math inline">\(r\)</span>的点接收到的光强是光源的<span class="math inline">\(\frac{1}{r^2}\)</span>. (半径为<span class="math inline">\(r\)</span>的球壳表面积为<span class="math inline">\(4\pi r^2\)</span>, 结合能量守恒即可推导出).</p>
<figure>
<img src="/.io//image-20220630094611616.png" alt="image-20220630094611616"><figcaption aria-hidden="true">image-20220630094611616</figcaption>
</figure>
<p>因此我们可以得出漫反射光强的计算公式, 其中<span class="math inline">\(k_d\)</span>为漫反射参数, 一般代表颜色, 可以定义成一个三维的RGB向量. <span class="math display">\[
L_d = k_d \cdot \frac{I}{r^2} \cdot \max(0,\hat n \cdot \hat l)
\]</span></p>
<h3 id="反射高光specular-highlights">反射高光(Specular highlights)</h3>
<figure>
<img src="/.io//image-20220630100922174.png" alt="image-20220630100922174"><figcaption aria-hidden="true">image-20220630100922174</figcaption>
</figure>
<p>反射高光的光强与我们的观察角度有很大关系. 对于一个比较光滑的物体, 它的反射高光只集中在反射向量(<span class="math inline">\(\hat R\)</span>)附近的一小块区域(图中黄色部分). 要进行计算, 我们就需要先计算出<span class="math inline">\(\hat R\)</span>. 而Bling-Phong模型使用半程向量(half vector)来进行近似计算, 避免了对<span class="math inline">\(\hat R\)</span>的计算:</p>
<p><img src="/.io//image-20220630101402464.png" alt="image-20220630101402464" style="zoom: 67%;"></p>
<p>半程向量<span class="math inline">\(\hat h\)</span>是位于<span class="math inline">\(\hat l\)</span>和<span class="math inline">\(\hat v\)</span>夹角的角平分线上的单位向量. <span class="math display">\[
\hat h = \frac{\hat v + \hat l}{|\hat v + \hat l|}
\]</span> 假设<span class="math inline">\(\hat h\)</span>与<span class="math inline">\(\hat n\)</span>的夹角<span class="math inline">\(\alpha\)</span>近似等于<span class="math inline">\(\hat R\)</span>与<span class="math inline">\(\hat v\)</span>的夹角, 便可以得出反射光的光强计算公式: <span class="math display">\[
L_s = k_s \cdot \frac{I}{r^2} \cdot \max(0,\hat n \cdot \hat h)^p
\]</span> 其中<span class="math inline">\(k_s\)</span>一般为白色, 也可取光源颜色. 指数<span class="math inline">\(p\)</span>可以加速高光的衰减, 让模型更加真实. 这个参数一般取<span class="math inline">\(100 \sim 200\)</span></p>
<figure>
<img src="/.io//image-20220630102119144.png" alt="image-20220630102119144"><figcaption aria-hidden="true">image-20220630102119144</figcaption>
</figure>
<figure>
<img src="/.io//image-20220630102229234.png" alt="image-20220630102229234"><figcaption aria-hidden="true">image-20220630102229234</figcaption>
</figure>
<h3 id="环境光ambient-lighting">环境光(Ambient lighting)</h3>
<p>环境光非常的简单粗暴: <span class="math display">\[
L_a = k_a \cdot I_a
\]</span> 把三种光全部加起来, 就能得到Bling-Phong模型的光照: <span class="math display">\[
L = L_d + L_s + L_a\\
= k_d \cdot \frac{I}{r^2} \cdot \max(0,\hat n \cdot \hat l) + k_s \cdot \frac{I}{r^2} \cdot \max(0,\hat n \cdot \hat h)^p + k_a \cdot I_a
\]</span></p>
<h2 id="着色频率待补全">着色频率(待补全)</h2>
<p>Bling-Phong模型只给出了着色方法, 但Shading Point是什么并没有给出定义. 本节便讨论不同着色频率的实现和效果.</p>
<p>着色频率可以分为平面着色(Flat shading), Gouraud shading和Phong shading.</p>
<p>在这里先看一下各种着色频率的区别:</p>
<p><img src="/.io//image-20220630104547245.png" alt="image-20220630104547245" style="zoom:50%;"></p>
<h3 id="平面着色flat-shading">平面着色(Flat Shading)</h3>
<p>平面着色对每个三角形面求出一个法线, 并据此求出整个三角形的shading结果.</p>
<figure>
<img src="/.io//image-20220630103725500.png" alt="image-20220630103725500"><figcaption aria-hidden="true">image-20220630103725500</figcaption>
</figure>
<h3 id="gouraud-shading">Gouraud Shading</h3>
<p>Gouraud着色先求出三角形每个顶点的法线, 计算出颜色, 再对三角形内部的每个点进行插值(interpolation).</p>
<figure>
<img src="/.io//image-20220630104005380.png" alt="image-20220630104005380"><figcaption aria-hidden="true">image-20220630104005380</figcaption>
</figure>
<p>在一般的obj模型中我们一般只能获得三角形的法线, 因而每个顶点的法线由与其相邻的三角形法线(加权)平均得来: <span class="math display">\[
\vec N_v =  \frac{\sum_{i}\vec N_i}{\sum_{i}|\vec N_i|}
\]</span> <img src="/.io//image-20220630105034275.png" alt="image-20220630105034275" style="zoom:33%;"></p>
<h3 id="phong-shading">Phong Shading</h3>
<p>Phong shading先插值计算出每个像素的法线, 再对每个像素进行shading.</p>
<p><img src="/.io//image-20221219091505338.png" alt="image-20221219091505338" style="zoom:50%;"></p>
<h2 id="渲染管线graphics-pipeline">渲染管线(Graphics Pipeline)</h2>
<figure>
<img src="/.io//image-20220630105709088.png" alt="image-20220630105709088"><figcaption aria-hidden="true">image-20220630105709088</figcaption>
</figure>
<h1 id="纹理映射texture-mapping">纹理映射(Texture Mapping)</h1>
<figure>
<img src="/.io//image-20221219095356275.png" alt="image-20221219095356275"><figcaption aria-hidden="true">image-20221219095356275</figcaption>
</figure>
<figure>
<img src="/.io//image-20221219095431898.png" alt="image-20221219095431898"><figcaption aria-hidden="true">image-20221219095431898</figcaption>
</figure>
<p>​ 一般默认<span class="math inline">\(u,v \in [0,1]\)</span></p>
<figure>
<img src="/.io//image-20221219095443482.png" alt="image-20221219095443482"><figcaption aria-hidden="true">image-20221219095443482</figcaption>
</figure>
<h2 id="重心坐标barycentric-coordinates">重心坐标(Barycentric coordinates)</h2>
<h3 id="一般定义">一般定义</h3>
<p>设<span class="math inline">\(V_1,...,V_n\)</span>是<span class="math inline">\(n\)</span>维向量空间<span class="math inline">\(V\)</span>中<a href="https://en.wikipedia.org/wiki/Simplex">单纯形</a>的顶点, 对于<span class="math inline">\(V\)</span>中任意一点<span class="math inline">\(P\)</span>, 有 <span class="math display">\[
(\sum_{i = 1}^n \lambda_i)\cdot P = \sum_{i = 1}^n \lambda_i \cdot V_i
\]</span> 则系数<span class="math inline">\(\lambda_1,...,\lambda_n\)</span>称为<span class="math inline">\(P\)</span>关于<span class="math inline">\(V_1,...V_n\)</span>的重心坐标. 一般规定<span class="math inline">\(\sum_{i = 1}^n \lambda_i = 1\)</span>, 此时称为<strong>正规化</strong>的重心坐标. 以下讨论的重心坐标均为正规化的.</p>
<h3 id="二维平面中的重心坐标系">二维平面中的重心坐标系</h3>
<h4 id="定义-1">定义</h4>
<p>二维平面上, 单纯形为三角形. 假设给出一三角形<span class="math inline">\(\Delta ABC\)</span>和三角形所在平面上的一点<span class="math inline">\(P\)</span>, 则<span class="math inline">\(P\)</span>可被如下重心坐标表示: <span class="math display">\[
P = \alpha A + \beta B + \gamma C
\]</span> <img src="/.io//image-20221219101132111.png" alt="image-20221219101132111" style="zoom:50%;"></p>
<p>考虑<a href="https://zhuanlan.zhihu.com/p/144360079">下图(来源见链接)</a>:</p>
<p><img src="https://pic2.zhimg.com/80/v2-34f542500eb2b8b4679dc351609398ad_720w.jpg" alt="img" style="zoom: 50%;"></p>
<p>将<span class="math inline">\(\vec{AB},\vec{AC}\)</span>作为坐标系, 可以得到 <span class="math display">\[
\begin{align}
P =&amp; A + \beta(\vec{AB}) + \gamma(\vec{AC})\\
=&amp; A + \beta(B - A) + \gamma(C - A)\\
=&amp; (1 - \beta - \gamma)A + \beta B + \gamma C
\end{align}
\]</span> 这样便可以从坐标系的角度来解释重心坐标, 同时能得到 <span class="math display">\[
\alpha = 1 - \beta - \gamma
\]</span></p>
<h4 id="求解解方程组">求解:解方程组</h4>
<p>将点带入重心坐标的定义, 可以得到: <span class="math display">\[
\left \{
\begin{array}{cccc} 
   x_p = (1 - \beta - \gamma) x_a + \beta x_b + \gamma x_c \\
   y_p = (1 - \beta - \gamma) y_a + \beta y_b + \gamma y_c
\end{array}
\right.
\]</span> 提取出<span class="math inline">\(\beta \space \gamma\)</span>: <span class="math display">\[
\left \{
\begin{array}{cccc}
x_p - x_a = \beta(x_b - x_a) + \gamma (x_c - x_a)\\
y_p - y_a = \beta(y_b - y_a) + \gamma (y_c - y_a)
\end{array}
\right.
\]</span> 转化为矩阵形式: <span class="math display">\[
\left[
\begin{array}{}
    x_b - x_a &amp; x_c - x_a\\
    y_b - y_a &amp; y_c - y_a
\end{array}
\right]
\left[
\begin{array}{}
\beta \\
\gamma
\end{array}
\right]
=
\left[
\begin{array}{}
x_p - x_a\\
y_p - y_a
\end{array}
\right]
\]</span> 这样便可求解出<span class="math inline">\(\beta \space \gamma\)</span>进而求出<span class="math inline">\(\alpha\)</span></p>
<h4 id="求解向量叉积">求解:向量叉积</h4>
<p>把坐标系的表达式变换一下: <span class="math display">\[
\beta \vec{AB} + \gamma \vec{AC} + \vec{PA} = 0
\]</span> 拆开后: <span class="math display">\[
\left \{
\begin{array}{cccc} 
\beta\vec{AB}_x + \gamma \vec{AC}_x + \vec{PA}_x = 0\\
\beta\vec{AB}_y + \gamma \vec{AC}_y + \vec{PA}_y = 0
\end{array}
\right.
\]</span> 转化为矩阵形式: <span class="math display">\[
\left[
\begin{array}{}
\beta &amp; \gamma &amp; 1
\end{array}
\right]
\left[
\begin{array}{}
\vec{AB}_x\\
\vec{AC}_x\\
\vec{PA}_x
\end{array}
\right] = 0\\
\left[
\begin{array}{}
\beta &amp; \gamma &amp; 1
\end{array}
\right]
\left[
\begin{array}{}
\vec{AB}_y\\
\vec{AC}_y\\
\vec{PA}_y
\end{array}
\right] = 0\\
\]</span> 从几何意义考虑, 这相当于<span class="math inline">\([\beta ,\gamma,1]\)</span>这个向量和后两个向量分别垂直. 因而我们求出后两个向量的叉积(假设结果为<span class="math inline">\([x,y,z]\)</span>), 则<span class="math inline">\([\frac{x}{z}, \frac{y}{z},1]\)</span>等于<span class="math inline">\([\beta,\gamma,1]\)</span>​.</p>
<p>需要注意<span class="math inline">\(z = 0\)</span>的特殊情况, 根据叉乘的定义, 此时有<span class="math inline">\(\vec{AB}_x \cdot \vec{AC}_y - \vec{AB}_y \cdot \vec{AC}_x = 0\)</span>, 即<span class="math inline">\(\vec{AB} \cdot \vec{AC} = 0\)</span>, 说明<span class="math inline">\(ABC\)</span>三点共线. 这时返回一个任意的负重心坐标即可.</p>
<h4 id="求解三角形面积">求解:三角形面积</h4>
<p><img src="/.io//image-20221219101504847.png" alt="image-20221219101504847" style="zoom: 67%;"></p>
<p>如图, 假设三角形面积分别为<span class="math inline">\(A_A,A_B,A_C\)</span>. 则 <span class="math display">\[
\alpha = \frac{A_A}{A_A+A_B+A_C}\\
\beta = \frac{A_B}{A_A+A_B+A_C}\\
\gamma = \frac{A_C}{A_A+A_B+A_C}
\]</span></p>
<h3 id="应用">应用</h3>
<h4 id="判断点与三角形的关系">判断点与三角形的关系</h4>
<p>重心坐标有很多应用, 在这里我们能用到的结论是: 若<span class="math inline">\(\alpha,\beta,\gamma\)</span>均大于<span class="math inline">\(0\)</span>, 则点<span class="math inline">\(P\)</span>在三角形<span class="math inline">\(\Delta ABC\)</span>的内部; 若<span class="math inline">\(\alpha,\beta,\gamma\)</span>有一个等于<span class="math inline">\(0\)</span>, 则点<span class="math inline">\(P\)</span>在三角形的边上; 若<span class="math inline">\(\alpha,\beta,\gamma\)</span>有两个等于<span class="math inline">\(0\)</span>, 则点<span class="math inline">\(P\)</span>在三角形的顶点上.</p>
<p>下面的代码采用了向量叉积法:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">insideTriangle</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">const</span> Vector3f* _v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> inside = <span class="literal">true</span>;</span><br><span class="line">    Vector3f result =  <span class="comment">//cal cross</span></span><br><span class="line">            <span class="built_in">Vector3f</span>(_v[<span class="number">1</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>(),_v[<span class="number">2</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>(),_v[<span class="number">0</span>].<span class="built_in">x</span>() - x)</span><br><span class="line">            .<span class="built_in">cross</span>(<span class="built_in">Vector3f</span>(_v[<span class="number">1</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>(),_v[<span class="number">2</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>(),_v[<span class="number">0</span>].<span class="built_in">y</span>() - y));</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(result.<span class="built_in">z</span>()) &lt; eps)inside = <span class="literal">false</span>;<span class="comment">//z == 0</span></span><br><span class="line">    result.<span class="built_in">x</span>() /= result.<span class="built_in">z</span>(),result.<span class="built_in">y</span>() /= result.<span class="built_in">z</span>();</span><br><span class="line">    <span class="keyword">float</span> alpha = <span class="number">1</span> - result.<span class="built_in">x</span>() - result.<span class="built_in">y</span>(),beta = result.<span class="built_in">x</span>(),gamma = result.<span class="built_in">y</span>();</span><br><span class="line">    <span class="keyword">if</span>(alpha &lt; eps <span class="keyword">or</span> beta &lt; eps <span class="keyword">or</span> gamma &lt; eps)inside = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> inside;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重心">重心</h4>
<figure>
<img src="/.io//image-20221219101838190.png" alt="image-20221219101838190"><figcaption aria-hidden="true">image-20221219101838190</figcaption>
</figure>
<h4 id="根据顶点进行线性插值">根据顶点进行线性插值</h4>
<figure>
<img src="/.io//image-20221219102046013.png" alt="image-20221219102046013"><figcaption aria-hidden="true">image-20221219102046013</figcaption>
</figure>
<p>​ 求出重心坐标后, 只需计算 <span class="math display">\[
V = \alpha V_A + \beta V_B + \gamma V_C
\]</span> 其中<span class="math inline">\(V\)</span>可以是任何想要插值的值. (注意投影会改变重心坐标, 在插值时需要先在三维计算重心坐标再投影到二维)</p>
<figure>
<img src="/.io//image-20221219103020986.png" alt="image-20221219103020986"><figcaption aria-hidden="true">image-20221219103020986</figcaption>
</figure>
<h4 id="透视矫正插值">透视矫正插值</h4>
<p>阅读资料: https://zhuanlan.zhihu.com/p/403259571</p>
<p>令 <span class="math display">\[
Z_n = \frac{1}{\alpha + \beta + \gamma}
\]</span> 顶点的<span class="math inline">\(z\)</span>坐标和纹理坐标在经过重心插值后, 还需乘上这个系数进行矫正.</p>
<h2 id="纹理放大texture-magnification">纹理放大(Texture Magnification)</h2>
<figure>
<img src="/.io//image-20221219103436527.png" alt="image-20221219103436527"><figcaption aria-hidden="true">image-20221219103436527</figcaption>
</figure>
<p>通常情况下我们希望像素(pixel)和纹理元素(texel)是一一对应的关系, 但当pixel数量多于/少于texel时, 便需要一种方法来将纹理进行变换.</p>
<h3 id="双线性插值bilinear-interpolation">双线性插值(Bilinear Interpolation)</h3>
<p>如下图, 假设我们需要采样红点处的texel值<span class="math inline">\(f(x,y)\)</span></p>
<p><img src="/.io//image-20221219103701756.png" alt="image-20221219103701756" style="zoom:50%;"></p>
<p>按如下方法选取红点临近的四个texel并将其标号(<span class="math inline">\(u\)</span>即该texel的值, 如颜色值, 深度等等)</p>
<p><img src="/.io//image-20221219104000472.png" alt="image-20221219104000472" style="zoom:50%;"></p>
<p>并记红点到<span class="math inline">\(u_{00}\)</span>的中心点的距离为<span class="math inline">\(s,t\)</span>. 这里假设<span class="math inline">\(s,t \in [0,1]\)</span></p>
<figure>
<img src="/.io//image-20221219104123598.png" alt="image-20221219104123598"><figcaption aria-hidden="true">image-20221219104123598</figcaption>
</figure>
<p>我们按如下方法定义一维的线性插值: <span class="math display">\[
\text{lerp}(x,v_0,v_1) = v_0 + x (v_1 - v_0)
\]</span> <img src="/.io//image-20221219104952425.png" alt="image-20221219104952425"></p>
<p>首先从一个方向(这里是水平)进行插值: <span class="math display">\[
u_0 = \text{lerp}(s,u_{00},u_{10})\\
u_1 = \text{lerp}(s,u_{01},u_{11})
\]</span> 再从另一个方向(竖直)插值即可得到<span class="math inline">\(f(x,y)\)</span>: <span class="math display">\[
f(x,y) = lerp(t,u_0,u_1)
\]</span> 这样一个pixel便综合考虑了它临近的四个texel的值.</p>
<h3 id="当纹理过大时">当纹理过大时</h3>
<figure>
<img src="/.io//image-20221219112706797.png" alt="image-20221219112706797"><figcaption aria-hidden="true">image-20221219112706797</figcaption>
</figure>
<figure>
<img src="/.io//image-20221219112924865.png" alt="image-20221219112924865"><figcaption aria-hidden="true">image-20221219112924865</figcaption>
</figure>
<p>如图，当一个pixel覆盖了很多个texel时(地平线处的格子), 仍然直接进行插值便会出现很严重的问题. 在之前的反走样部分, 通过超采样(例如MSAA)可以解决这一问题. 但超采样对性能的消耗很高. 为了解决性能问题, 我们直接求每个pixel覆盖的texel的平均值.</p>
<h4 id="mipmap">Mipmap</h4>
<figure>
<img src="/.io//image-20221221163827485.png" alt="image-20221221163827485"><figcaption aria-hidden="true">image-20221221163827485</figcaption>
</figure>
<figure>
<img src="/.io//image-20221221164045467.png" alt="image-20221221164045467"><figcaption aria-hidden="true">image-20221221164045467</figcaption>
</figure>
<p>如上图, mipmap从第<span class="math inline">\(0\)</span>层(原图)开始, 每次将图像的边长缩小一半, 形成新的一层(记为<span class="math inline">\(D\)</span>), 直到不能缩小为止. 这样每一层都存储了一个方形区域texel平均值的近似值. 查询时, 只要根据pixel的坐标和覆盖大小, 在mipmap中找到对应位置, 便可快速求出平均值, 容易计算这样只会占用<span class="math inline">\(\frac{1}{3}\)</span>的额外存储空间.</p>
<figure>
<img src="/.io//image-20221221165133886.png" alt="image-20221221165133886"><figcaption aria-hidden="true">image-20221221165133886</figcaption>
</figure>
<p>在计算<span class="math inline">\(D\)</span>时, 我们取当前待求点所在的一个正方形(上图红色部分), 将其投影到纹理空间中. 令<span class="math inline">\(L\)</span>为当前点到相邻两个点在纹理空间中距离的最大值, 则<span class="math inline">\(D = \log_2L\)</span></p>
<figure>
<img src="/.io//image-20221221170102301.png" alt="image-20221221170102301"><figcaption aria-hidden="true">image-20221221170102301</figcaption>
</figure>
<p>用这样的方法求出来的<span class="math inline">\(D\)</span>将其取整到整数后, 有很大的问题: 不连续(图中的色块).</p>
<figure>
<img src="/.io//image-20221221170355687.png" alt="image-20221221170355687"><figcaption aria-hidden="true">image-20221221170355687</figcaption>
</figure>
<p>三线性插值(Trilinear Interpolation)可以解决这个问题. 我们先对<span class="math inline">\(D\)</span>和<span class="math inline">\(D+1\)</span>层分别做一次双线性插值, 再根据取整之前<span class="math inline">\(D\)</span>的值再做一次线性插值, 便能得到不错的结果:</p>
<figure>
<img src="/.io//image-20221221170533925.png" alt="image-20221221170533925"><figcaption aria-hidden="true">image-20221221170533925</figcaption>
</figure>
<h4 id="各项异性过滤anisotropic-filtering">各项异性过滤(Anisotropic Filtering)</h4>
<figure>
<img src="/.io//image-20221221170902803.png" alt="image-20221221170902803"><figcaption aria-hidden="true">image-20221221170902803</figcaption>
</figure>
<figure>
<img src="/.io//image-20221221170913408.png" alt="image-20221221170913408"><figcaption aria-hidden="true">image-20221221170913408</figcaption>
</figure>
<figure>
<img src="/.io//image-20221221171236905.png" alt="image-20221221171236905"><figcaption aria-hidden="true">image-20221221171236905</figcaption>
</figure>
<p>如上图.屏幕空间到纹理空间的映射过程中, 并不是每个像素都对应一个理想的正方形, 有的会被拉伸成细长的矩形. Mipmap在处理这样的像素时, 因为平均范围过大变得过度模糊而失去了细节.</p>
<figure>
<img src="/.io//image-20221221171522167.png" alt="image-20221221171522167"><figcaption aria-hidden="true">image-20221221171522167</figcaption>
</figure>
<p>各向异性过滤在Mipmap的基础上, 计算了不同长度宽度的组合(Mipmap只计算了上图中对角线部分). 这样在查询时, 对于细长的、近似水平或竖直的矩形可以得到更好的效果, 但仍然难处理细长的斜向矩形.</p>
<h2 id="立方体贴图cube-map">立方体贴图(Cube Map)</h2>
<figure>
<img src="/.io//image-20221230193850676.png" alt="image-20221230193850676"><figcaption aria-hidden="true">image-20221230193850676</figcaption>
</figure>
<figure>
<img src="/.io//image-20221230193903585.png" alt="image-20221230193903585"><figcaption aria-hidden="true">image-20221230193903585</figcaption>
</figure>
<p>在记录环境光时, 可以用一个光滑的金属球, 记录其表面的反射光, 再将其展开成一个平面. 但这样有一个问题: 展开图的上部和下部会发生比较严重的变形. 立方体贴图便是解决这种问题的方法.</p>
<figure>
<img src="/.io//image-20221230194258226.png" alt="image-20221230194258226"><figcaption aria-hidden="true">image-20221230194258226</figcaption>
</figure>
<figure>
<img src="/.io//image-20221230194504922.png" alt="image-20221230194504922"><figcaption aria-hidden="true">image-20221230194504922</figcaption>
</figure>
<p>如图, 我们用一个包围盒把球围起来. 从球心出发向外的每一条光线最终会打在这个包围盒上. 记录这些打在包围盒上的光线, 再将包围盒展开, 便得到了立方体贴图. 立方体贴图的变形明显更少, 但是需要计算一下每个方向对应的面.</p>
<h2 id="凹凸法线贴图bumpnormal-mapping">凹凸/法线贴图(Bump/Normal Mapping)</h2>
<p>推荐阅读: https://zhuanlan.zhihu.com/p/412555049</p>
<figure>
<img src="/.io//image-20221230201203530.png" alt="image-20221230201203530"><figcaption aria-hidden="true">image-20221230201203530</figcaption>
</figure>
<p>在之前的Bling Phong模型中, 我们利用了顶点的法线数据来插值得到每个像素的法线. 这种方式计算量大, 却不能在模型面数较少时取得较好的效果. 凹凸贴图/法线贴图也是材质的一种, 它让我们可以用贴图的信息来计算每个顶点的法线. 右图便是一个简单的球形应用了法线贴图后的效果. 可以看出,凹凸/法线贴图可以在不增加三角形面的前提下提升表现细节.</p>
<h3 id="凹凸贴图">凹凸贴图</h3>
<figure>
<img src="/.io//image-20221231100908188.png" alt="image-20221231100908188"><figcaption aria-hidden="true">image-20221231100908188</figcaption>
</figure>
<p>凹凸贴图是一张二维的黑白图片, 一般越白的部分表示高度越高. 它通过重新定义(或者说扰动)高度的方法, 来让我们能计算新的法线. 在上图中, 物体本身的法线为<span class="math inline">\(\vec{p}\)</span>, 经过凹凸贴图扰动后(橙色曲线)计算出的新法线为<span class="math inline">\(\vec{n}\)</span>.</p>
<figure>
<img src="/.io//image-20221231102657626.png" alt="image-20221231102657626"><figcaption aria-hidden="true">image-20221231102657626</figcaption>
</figure>
<p>先考虑如何在一维求扰动后的法线. 假设原物体是一条和<span class="math inline">\(x\)</span>轴平行的直线, 这样它的法线<span class="math inline">\(\vec{n} = (0,1)\)</span>. 蓝色曲线是被凹凸贴图扰动后的结果. 我们先近似求出蓝色点切线的斜率<span class="math inline">\(dp\)</span>. 因为凹凸贴图也是一种材质, 能细分的最小单位是一个像素, 所以<span class="math inline">\(dp\)</span>可以简单的用相邻两点间高度<span class="math inline">\(h\)</span>的差值得到(其中系数<span class="math inline">\(c\)</span>定义了凹凸贴图的影响有多大): <span class="math display">\[
dp = c(h(p+1) - h(p))
\]</span> 这样切线便是<span class="math inline">\((1,dp)\)</span>. 将其旋转90°可得法线<span class="math inline">\(\vec{n} = (-dp,1)\text{.normalized()}\)</span>. 时刻注意表示方向的向量必须归一化.</p>
<figure>
<img src="/.io//image-20221231104248459.png" alt="image-20221231104248459"><figcaption aria-hidden="true">image-20221231104248459</figcaption>
</figure>
<p>三维情况下, 我们假设最初的法线是<span class="math inline">\((0,0,1)\)</span>. 类比(这里有较为复杂的推导步骤, 在这里省略)一维情况, 分别求出<span class="math inline">\(u,v\)</span>两个方向上的斜率, 可得法线: <span class="math display">\[
\vec{n} = (-du,-dv,1)\text{.normalized()}
\]</span> 注意: 上述坐标是在假设法线为<span class="math inline">\((0,0,1)\)</span>, 且构成坐标系的一个轴的前提下计算的. 要真正使用凹凸贴图定义的法线, 还需将其变换回世界坐标.</p>
<h3 id="法线贴图">法线贴图</h3>
<p>凹凸贴图存储了每个像素扰动后的高度, 在使用时仍需进行计算来得到每个像素的法线. 而法线贴图则帮我们完成了这一步, 它直接将法线信息存储在材质中. 材质的<span class="math inline">\(R,G,B\)</span>三维便对应了法线的<span class="math inline">\(x,y,z\)</span>. 需要注意的是, RGB分量是无符号值, 而法线是有符号的. 因此我们在写入(<span class="math inline">\(\text{normal} \to \text{color}\)</span>)和读取(<span class="math inline">\(\text{color} \to \text{normal}\)</span>)时要进行一定的转换: <span class="math display">\[
\text{color} = \frac{\text{normal}}{2} + 0.5\\
\text{normal} = 2 \cdot (\text{color} - 0.5)
\]</span> 另外值得注意的一点是, 大多数法线贴图看上去都是蓝色的, 这是因为默认法线是<span class="math inline">\((0,0,1)\)</span>, 编码成颜色信息后是<span class="math inline">\(\text{RGB}(0.5,0.5,1)\)</span>. 蓝色部分说明对法线信息没有太大改动.</p>
<h3 id="tbn矩阵待补充">TBN矩阵(待补充)</h3>
<p>在使用凹凸贴图/法线贴图时, 我们均假设了法线指向<span class="math inline">\((0,0,1)\)</span></p>
<p>(等学到光线追踪再补)</p>
<h2 id="位移贴图displacement-mapping">位移贴图(Displacement Mapping)</h2>
<figure>
<img src="/.io//image-20221231163142098.png" alt="image-20221231163142098"><figcaption aria-hidden="true">image-20221231163142098</figcaption>
</figure>
<h2 id="阴影贴图shadow-mapping">阴影贴图(Shadow mapping)</h2>
<figure>
<img src="/.io//image-20230102162421668.png" alt="image-20230102162421668"><figcaption aria-hidden="true">image-20230102162421668</figcaption>
</figure>
<figure>
<img src="/.io//image-20230102162429547.png" alt="image-20230102162429547"><figcaption aria-hidden="true">image-20230102162429547</figcaption>
</figure>
<figure>
<img src="/.io//image-20230102162437931.png" alt="image-20230102162437931"><figcaption aria-hidden="true">image-20230102162437931</figcaption>
</figure>
<figure>
<img src="/.io//image-20230102162455204.png" alt="image-20230102162455204"><figcaption aria-hidden="true">image-20230102162455204</figcaption>
</figure>
<figure>
<img src="/.io//image-20230102162502379.png" alt="image-20230102162502379"><figcaption aria-hidden="true">image-20230102162502379</figcaption>
</figure>
<p>阴影贴图的工作流程如下:</p>
<ol type="1">
<li>从光源出发(将光源当作相机), 生成一张物体的深度图</li>
<li>从相机出发，对于看到的每一个点, 将其投影回上一步的深度图对应的位置. 如果该点的实际深度与深度图记录的相同, 那么这个点就是可见的, 否则不可见.</li>
</ol>
<p>Shadow Mapping也会存在一些问题:</p>
<ul>
<li>硬阴影，且只支持点光源</li>
<li>质量与深度图的分辨率有关</li>
<li>存在数值精度问题 <a href="https://en.wikipedia.org/wiki/Z-fighting">Z-fighting</a></li>
</ul>
<h1 id="几何geometry">几何(Geometry)</h1>
<h2 id="基本表示方法">基本表示方法</h2>
<h3 id="隐式表述">隐式表述</h3>
<h4 id="普通方程">普通方程</h4>
<figure>
<img src="/.io//image-20230101085836806.png" alt="image-20230101085836806"><figcaption aria-hidden="true">image-20230101085836806</figcaption>
</figure>
<p>普通方程直接给出<span class="math inline">\(x,y,z\)</span>之间的关系, 例如<span class="math inline">\(f(x,y,z) = 0\)</span>. 观察上图的公式, 很难直接看出普通方程对应的图形是什么, 即普通方程的采样十分困难. 但判断某个点在普通方程定义的几何体的内部/外部非常简单: 将该点的坐标带入<span class="math inline">\(f\)</span>, 与等式右边的值比较即可. 同时, 隐式表述的几何体很容易做光线和几何的交.</p>
<h4 id="构造实体几何constructive-solid-geometry">构造实体几何(Constructive Solid Geometry)</h4>
<figure>
<img src="/.io//image-20230101090758941.png" alt="image-20230101090758941"><figcaption aria-hidden="true">image-20230101090758941</figcaption>
</figure>
<p>构造实体几何(CSG)使用逻辑运算来将简单的几何体组合成复杂的形体.</p>
<h4 id="距离函数distance-functions">距离函数(Distance Functions)</h4>
<figure>
<img src="/.io//image-20230101091219298.png" alt="image-20230101091219298"><figcaption aria-hidden="true">image-20230101091219298</figcaption>
</figure>
<figure>
<img src="/.io//image-20230101091901164.png" alt="image-20230101091901164"><figcaption aria-hidden="true">image-20230101091901164</figcaption>
</figure>
<figure>
<img src="/.io//image-20230101091907809.png" alt="image-20230101091907809"><figcaption aria-hidden="true">image-20230101091907809</figcaption>
</figure>
<figure>
<img src="/.io//image-20230101092000903.png" alt="image-20230101092000903"><figcaption aria-hidden="true">image-20230101092000903</figcaption>
</figure>
<h4 id="水平集方法level-set-methods">水平集方法(Level Set Methods)</h4>
<figure>
<img src="/.io//image-20230101093158811.png" alt="image-20230101093158811"><figcaption aria-hidden="true">image-20230101093158811</figcaption>
</figure>
<h4 id="分形fractals">分形(Fractals)</h4>
<figure>
<img src="/.io//image-20230101093458135.png" alt="image-20230101093458135"><figcaption aria-hidden="true">image-20230101093458135</figcaption>
</figure>
<h3 id="显式表述">显式表述</h3>
<h4 id="参数方程">参数方程</h4>
<figure>
<img src="/.io//image-20230101090125770.png" alt="image-20230101090125770"><figcaption aria-hidden="true">image-20230101090125770</figcaption>
</figure>
<figure>
<img src="/.io//image-20230101090228895.png" alt="image-20230101090228895"><figcaption aria-hidden="true">image-20230101090228895</figcaption>
</figure>
<p>显式表述的参数方程直接定义一个从一个坐标向另一个坐标转换的方式. 它采样起来十分简单: 只需将原坐标的值代入<span class="math inline">\(f\)</span>就能得到新坐标的值. 但它判断某个点在几何体的内部/外部十分困难.</p>
<h4 id="点云point-cloud">点云(Point Cloud)</h4>
<figure>
<img src="/.io//image-20230101161856992.png" alt="image-20230101161856992"><figcaption aria-hidden="true">image-20230101161856992</figcaption>
</figure>
<h4 id="多边形面polygon-mesh">多边形面(Polygon Mesh)</h4>
<figure>
<img src="/.io//image-20230101162104438.png" alt="image-20230101162104438"><figcaption aria-hidden="true">image-20230101162104438</figcaption>
</figure>
<h4 id="贝塞尔曲线">贝塞尔曲线</h4>
<p>见曲线章节</p>
<h2 id="曲线">曲线</h2>
<h3 id="贝塞尔曲线bézier-curves">贝塞尔曲线(Bézier Curves)</h3>
<p>贝塞尔曲线是一种由<strong>控制点</strong>来确定形状的曲线. <span class="math inline">\(n\)</span>个控制点描述了一个<span class="math inline">\(n-1\)</span>阶的贝塞尔曲线. 下面是正在绘制的不同阶贝塞尔曲线的一些例子:</p>
<figure>
<img src="/.io//image-20230101191607647.png" alt="image-20230101191607647"><figcaption aria-hidden="true">image-20230101191607647</figcaption>
</figure>
<p>注意图中的<span class="math inline">\(t = 0.49\)</span>. 遍历<span class="math inline">\(t \in[0,1]\)</span>, 计算并绘制某一点的运动轨迹(图中红点), 这条轨迹便是贝塞尔曲线. 从上图可以看出, <span class="math inline">\(k\)</span>阶贝塞尔曲线可以从<span class="math inline">\(k-1\)</span>阶递推得到. 这一递推算法称作德卡斯特里奥算法(De Casteljau's algorithm).</p>
<p>在解释这一算法之前, 我们先来看一下一阶贝塞尔曲线的表达式: <span class="math display">\[
B_1(t) = P_0 + (P_1 - P_0)t
\]</span> 很显然, 这是一个线性插值. 观察一阶贝塞尔曲线的图像, 可以看出它就是一条直线.</p>
<figure>
<img src="/.io//image-20230101192935349.png" alt="image-20230101192935349"><figcaption aria-hidden="true">image-20230101192935349</figcaption>
</figure>
<p>在时刻为<span class="math inline">\(t\)</span>时, 图中红色部分与整个线段的长度比为<span class="math inline">\(t:1\)</span>. 现在我们扩展到二阶贝塞尔曲线:</p>
<figure>
<img src="/.io//image-20230101193200797.png" alt="image-20230101193200797"><figcaption aria-hidden="true">image-20230101193200797</figcaption>
</figure>
<p>可以看到, 我们对<span class="math inline">\(\vec{b_0b_1}\)</span>和<span class="math inline">\(\vec{b_1b_2}\)</span>分别进行线性插值(简称lerp)得到了<span class="math inline">\(b_0^1\)</span>和<span class="math inline">\(b_0^2\)</span>两个点, 这两个点可以作为一个新的一阶贝塞尔曲线的控制点. 再对其进行线性插值, 便得到了要绘制的点<span class="math inline">\(b_0^2\)</span>.</p>
<figure>
<img src="/.io//image-20230101194348767.png" alt="image-20230101194348767"><figcaption aria-hidden="true">image-20230101194348767</figcaption>
</figure>
<p>三阶曲线也类似. 这样, 对于<span class="math inline">\(n\)</span>阶的贝塞尔曲线, 每插值一轮, 其阶数便减<span class="math inline">\(1\)</span>, 直到阶数等于<span class="math inline">\(1\)</span>. 这便是德卡斯特里奥算法的核心思想.</p>
<p>贝塞尔曲线也有非递推的公式(<span class="math inline">\(P_i\)</span>为控制点): <span class="math display">\[
b^n(t) = \sum_{i = 0}^nP_i \cdot B_i^n(t), t\in[0,1]
\]</span> 这个方法更快, 但数值稳定性不如递推算法高. 其中<span class="math inline">\(B_i^n(t)\)</span>称为伯恩施坦多项式 (Bernstein polynomial) <span class="math display">\[
B_i^n(t) = \binom{n}{i}t^i(1-t)^{n-i}
\]</span> <img src="/.io//image-20230101203944181.png" alt="image-20230101203944181"></p>
<p>伯恩施坦多项式有一个概率意义上的解释: 某独立事件发生一次的概率为<span class="math inline">\(p\)</span>, 那么进行<span class="math inline">\(n\)</span>次事件, 恰好发生<span class="math inline">\(i\)</span>次的概率为<span class="math inline">\(B_i^n(p)\)</span>. 既然我们能将其解释为概率, 那么同一阶伯恩施坦多项式在任何时间下的和必为<span class="math inline">\(1\)</span>, 即<span class="math inline">\(\sum_{i = 0}^nB_i^n(t) = 1\)</span>.</p>
<p>贝塞尔曲线有如下性质:</p>
<ul>
<li>一条贝塞尔曲线一定从第一个控制点开始, 在最后一个控制点结束. 需要注意的是贝塞尔曲线不必经过全部控制点.</li>
<li>对于三阶贝塞尔曲线, 其插值得到的两个二阶曲线为: <span class="math inline">\(b&#39;(0) = 3(P_1 - P_0),b&#39;(1) = 3(P_3 - P_2)\)</span>.</li>
<li>对控制点做仿射变换等价于对贝塞尔曲线做仿射变换, 但对投影变换不满足.</li>
<li>贝塞尔曲线一定位于控制点构成的凸包内.</li>
</ul>
<h4 id="分段贝塞尔曲线piecewise-bézier-curves">分段贝塞尔曲线(Piecewise Bézier Curves)</h4>
<figure>
<img src="/.io//image-20230101205249527.png" alt="image-20230101205249527"><figcaption aria-hidden="true">image-20230101205249527</figcaption>
</figure>
<p>高阶的贝塞尔曲线看上去很不直观, 也很难再用控制点来控制它的形状.</p>
<figure>
<img src="/.io//image-20230101205455090.png" alt="image-20230101205455090"><figcaption aria-hidden="true">image-20230101205455090</figcaption>
</figure>
<p>将控制点每<span class="math inline">\(k\)</span>个点(比如每四个)分段, 便是分段贝塞尔曲线. 但直接进行分段可能会出现尖锐的部分(如上图). 对贝塞尔曲线的连通性有如下定义:</p>
<figure>
<img src="/.io//image-20230101210542727.png" alt="image-20230101210542727"><figcaption aria-hidden="true">image-20230101210542727</figcaption>
</figure>
<figure>
<img src="/.io//image-20230101210843747.png" alt="image-20230101210843747"><figcaption aria-hidden="true">image-20230101210843747</figcaption>
</figure>
<figure>
<img src="/.io//image-20230101210935095.png" alt="image-20230101210935095"><figcaption aria-hidden="true">image-20230101210935095</figcaption>
</figure>
<p><span class="math inline">\(C^0\)</span>连续性: 第一段曲线的终点和第二段曲线的起点相同.</p>
<p><span class="math inline">\(C^1\)</span>连续性: 两曲线的交点及其相邻的左右两个点共线, 且交点是这一线段的中点.</p>
<h3 id="样条splines">样条(splines)</h3>
<h4 id="b样条待补充">B样条(待补充)</h4>
<h2 id="曲面">曲面</h2>
<h3 id="贝塞尔曲面bézier-surfaces">贝塞尔曲面(Bézier Surfaces)</h3>
<figure>
<img src="/.io//image-20230101212424816.png" alt="image-20230101212424816"><figcaption aria-hidden="true">image-20230101212424816</figcaption>
</figure>
<figure>
<img src="/.io//image-20230101212550919.png" alt="image-20230101212550919"><figcaption aria-hidden="true">image-20230101212550919</figcaption>
</figure>
<p>我们用类似双线性插值的思想, 将<span class="math inline">\(4\times 4\)</span>个控制点分成四组, 每组四个点, 求出每一组在时间<span class="math inline">\(t_1\)</span>时所绘制的点. 再将这四个点作为一条新的贝塞尔曲线的控制点, 遍历<span class="math inline">\(t_2\)</span>. 这样在<span class="math inline">\(t_1 \cdot t_2\)</span>时间内, 绘制的点便能形成一个贝塞尔曲面.</p>
<h2 id="对网格面的几何操作">对网格面的几何操作</h2>
<h3 id="曲面细分mesh-subdivision">曲面细分(Mesh subdivision)</h3>
<figure>
<img src="/.io//image-20230102102512465.png" alt="image-20230102102512465"><figcaption aria-hidden="true">image-20230102102512465</figcaption>
</figure>
<p>表面细分做了两件事: 1. 增加三角形数量 2. 调整三角形的位置</p>
<h4 id="loop细分loop-subdivision">Loop细分(Loop Subdivision)</h4>
<p>注意这里的Loop和循环没关系, Loop是发明者的姓.</p>
<figure>
<img src="/.io//image-20230102102743279.png" alt="image-20230102102743279"><figcaption aria-hidden="true">image-20230102102743279</figcaption>
</figure>
<p>Loop细分只能处理三角形网格. 它将一个三角形分成四个, 在划分的过程中会产生新的点. 我们需要将新生成的点和原先存在的点区分进行处理:</p>
<figure>
<img src="/.io//image-20230102103149087.png" alt="image-20230102103149087"><figcaption aria-hidden="true">image-20230102103149087</figcaption>
</figure>
<p>对于新生成的每个点, 记这个点所在的三角形边上两个顶点为<span class="math inline">\(A,B\)</span>. 这条边相对的顶点为<span class="math inline">\(C,D\)</span>. 则新生成的顶点<span class="math inline">\(P_{new}\)</span>位置调整到: <span class="math display">\[
P_{new} = \frac{3}{8} \cdot(A + B) + \frac{1}{8} \cdot (C + D)
\]</span> <img src="/.io//image-20230102103449651.png" alt="image-20230102103449651"></p>
<p>对于旧顶点, 按下式更新: <span class="math display">\[
P_{old} = (1 - n\cdot u) \cdot P_{origin} + u\cdot \sum P_{neighbor}
\]</span> 其中:</p>
<ul>
<li><span class="math inline">\(P_{origin}\)</span>: 该点原先的位置</li>
<li><span class="math inline">\(\sum P_{neighbor}\)</span>: 该点相邻点的和</li>
<li><span class="math inline">\(n\)</span>: 该点的度数(相邻点的数量)</li>
<li><span class="math inline">\(u = \frac{3}{8n}\)</span>. 若<span class="math inline">\(n = 3, u = \frac{3}{16}\)</span></li>
</ul>
<h4 id="catmull-clark-subdivision-general-mesh">Catmull-Clark Subdivision (General Mesh)</h4>
<figure>
<img src="/.io//image-20230102104257086.png" alt="image-20230102104257086"><figcaption aria-hidden="true">image-20230102104257086</figcaption>
</figure>
<p>Catmull-Clark Subdivision可以处理一般化的网格. 它将每个面分为四边形面和非四边形面两部分. 将点按度数分类: 所有度数不是<span class="math inline">\(4\)</span>的点为奇异点(Extraordinary vertex).</p>
<figure>
<img src="/.io//image-20230102104653238.png" alt="image-20230102104653238"><figcaption aria-hidden="true">image-20230102104653238</figcaption>
</figure>
<p>在细分时, 我们在每个面内选取一个点, 再将其和每条边的中点相连. 可以看出, 做了一次细分之后, 新增的奇异点个数等于原来非四边形面的个数, 且这些非四边形面都会变成四边形面. 也就是说, 奇异点个数仅可能在第一次细分时增加.</p>
<figure>
<img src="/.io//image-20230102104956880.png" alt="image-20230102104956880"><figcaption aria-hidden="true">image-20230102104956880</figcaption>
</figure>
<p>计算方式见上图(待详细补充).</p>
<figure>
<img src="/.io//image-20230102105202170.png" alt="image-20230102105202170"><figcaption aria-hidden="true">image-20230102105202170</figcaption>
</figure>
<h3 id="曲面简化mesh-simplification">曲面简化(Mesh Simplification)</h3>
<figure>
<img src="/.io//image-20230102110207321.png" alt="image-20230102110207321"><figcaption aria-hidden="true">image-20230102110207321</figcaption>
</figure>
<figure>
<img src="/.io//image-20230102160417599.png" alt="image-20230102160417599"><figcaption aria-hidden="true">image-20230102160417599</figcaption>
</figure>
<h4 id="二次误差度量quadric-error-metrics">二次误差度量(Quadric Error Metrics)</h4>
<p>(待补充)</p>
<figure>
<img src="/.io//image-20230102160632054.png" alt="image-20230102160632054"><figcaption aria-hidden="true">image-20230102160632054</figcaption>
</figure>
<p>我们在删掉一个顶点之后, 需要调整其他顶点的位置来让简化后的模型与原模型误差尽量的小. 这个误差可以用二次误差度量来表示.</p>
<figure>
<img src="/.io//image-20230102161104395.png" alt="image-20230102161104395"><figcaption aria-hidden="true">image-20230102161104395</figcaption>
</figure>
<figure>
<img src="/.io//image-20230102161115053.png" alt="image-20230102161115053"><figcaption aria-hidden="true">image-20230102161115053</figcaption>
</figure>
<h1 id="光线追踪ray-tracing">光线追踪(Ray Tracing)</h1>
<figure>
<img src="/.io//image-20230102165148477.png" alt="image-20230102165148477"><figcaption aria-hidden="true">image-20230102165148477</figcaption>
</figure>
<p>我们对光线做如下假设:</p>
<ul>
<li>光线沿直线传播</li>
<li>光线不会发生碰撞</li>
<li>光线从光源出发, 经过一系列折射反射等后, 进入观察者的眼睛, 这个过程可逆.(reciprocity)</li>
</ul>
<h2 id="光线投射算法ray-casting">光线投射算法(Ray Casting)</h2>
<p><img src="/.io//image-20230102172147726.png" alt="image-20230102172147726" style="zoom:50%;"></p>
<p><img src="/.io//image-20230103085159189.png" alt="image-20230103085159189" style="zoom: 67%;"></p>
<p><img src="/.io//image-20230103085207993.png" alt="image-20230103085207993" style="zoom: 67%;"></p>
<h2 id="recursive-whitted-style-ray-tracing">Recursive (Whitted-Style) Ray Tracing</h2>
<p><img src="/.io//image-20230103090059354.png" alt="image-20230103090059354" style="zoom: 67%;"></p>
<p>如上图. 对于每个像素, 从观测点发出一条光线. 这一条光线可以经过多次反射、折射、吸收, 在多个地方与多个物体有交点. 我们对这每一个交点将其与光源连线, 判断可见性并着色, 再将着色结果全部加回到像素中. 这便是Recursive (Whitted-Style) Ray Tracing的基本思想.</p>
<h2 id="光线与表面求交ray-surface-intersection">光线与表面求交(Ray-Surface Intersection)</h2>
<h3 id="光线定义">光线定义</h3>
<p><img src="/.io//image-20230103090856184.png" alt="image-20230103090856184" style="zoom:50%;"></p>
<h3 id="与隐式表面求交">与隐式表面求交</h3>
<p>先看如何与球求交</p>
<p>球的定义: <span class="math display">\[
\bold p : (\bold p - \bold c)^2 - R^2 = 0
\]</span> <img src="/.io//image-20230103091156776.png" alt="image-20230103091156776" style="zoom:50%;"></p>
<p>上图<span class="math inline">\(\bold o\)</span>为光源位置, <span class="math inline">\(\bold d\)</span>为光线方向. <span class="math inline">\(\bold p\)</span>为光线与球的交点, <span class="math inline">\(\bold c\)</span>为球心, <span class="math inline">\(R\)</span>为球的半径.</p>
<p>若光线与球相交, 则交点必须满足光线和球的表达式(即<span class="math inline">\(\bold p = \bold o + t\bold d\)</span>). 代入得: <span class="math display">\[
(\bold o + t \bold d - \bold c)^2 - R^2 = 0
\]</span> <img src="/.io//image-20230103091627336.png" alt="image-20230103091627336" style="zoom: 50%;"></p>
<p>直接展开求解即可. 注意<span class="math inline">\(t\)</span>必须为非负实数才有意义.</p>
<p>隐式表面: <span class="math display">\[
\bold p: f(\bold p) = 0
\]</span> 则光线与隐式表面求交: <span class="math display">\[
f(\bold o + t\bold d) = 0
\]</span> 求根即可.</p>
<h3 id="与三角面显式表面求交">与三角面(显式表面)求交</h3>
<p><img src="/.io//image-20230103092945358.png" alt="image-20230103092945358" style="zoom:67%;"></p>
<p><img src="/.io//image-20230103093000914.png" alt="image-20230103093000914" style="zoom: 67%;"></p>
<p>可以将光线与三角形求交拆成两步:</p>
<ol type="1">
<li>求光线与三角形所在平面的交点</li>
<li>判断交点是否在三角形内部</li>
</ol>
<p><img src="/.io//image-20230103093149661.png" alt="image-20230103093149661" style="zoom:67%;"></p>
<p>平面可以由一条法线<span class="math inline">\(\vec n\)</span>和屏幕上一点<span class="math inline">\(\bold{p&#39;}\)</span>来定义. <span class="math display">\[
\bold p : (\bold p - \bold p&#39;) \cdot \vec n = 0
\]</span> 展开为<span class="math inline">\(ax + by + cz + d = 0\)</span>的形式.</p>
<p>将光线定义代入:</p>
<p><img src="/.io//image-20230103093543226.png" alt="image-20230103093543226" style="zoom:50%;"></p>
<p>求出<span class="math inline">\(t\)</span>后判断是否在三角形内部即可.</p>
<h4 id="möller-trumbore-algorithm">Möller Trumbore Algorithm</h4>
<p>回忆一下我们用重心坐标判断点与三角形关系的过程: 若<span class="math inline">\(\alpha,\beta,\gamma\)</span>均大于<span class="math inline">\(0\)</span>, 则点<span class="math inline">\(P\)</span>在三角形<span class="math inline">\(\Delta ABC\)</span>的内部. 那么可以写出如下式子: <span class="math display">\[
\bold o + t\bold d = (1 - b_1 - b_2)\bold{P_0} + b_1 \bold{P_1} + b_2 \bold{P_2}
\]</span> <img src="/.io//image-20230103100315630.png" alt="image-20230103100315630" style="zoom:67%;"></p>
<p>这是一个有三个变量<span class="math inline">\((t,b_1,b_2)\)</span>三个方程的线性方程组. 很容易求解.</p>
<h5 id="作业5待补充">作业5(待补充)</h5>
<p>参考: https://zhuanlan.zhihu.com/p/431092843</p>
<ul>
<li>生成每个像素对应的光线</li>
</ul>
<h2 id="求交过程中的加速">求交过程中的加速</h2>
<h3 id="包围盒bounding-volumes">包围盒(Bounding Volumes)</h3>
<p><img src="/.io//image-20230103100829200.png" alt="image-20230103100829200" style="zoom:67%;"></p>
<p>在之前的算法中, 我们对每个像素发出的光线都要和全部三角形面求交. 使用包围盒后, 便可以先和包围盒求交. 如果二者不相交, 包围盒内的所有三角形都可以忽略不计.</p>
<p><img src="/.io//image-20230103101135974.png" alt="image-20230103101135974" style="zoom:67%;"></p>
<p>我们可以把包围盒理解为三对平面的交集. 这三对平面一般和坐标轴构成的平面平行. 下面主要讨论如何与轴对齐包围盒求交:</p>
<p><img src="/.io//image-20230103101759942.png" alt="image-20230103101759942" style="zoom:67%;"></p>
<p>先考虑二维的情况. 先将光线与<span class="math inline">\(x\)</span>面求交, 可以得到光线进入和射出的时间(这两个时间可以求出一条线段), <span class="math inline">\(y\)</span>面同理. 将这两个线段求交(即<span class="math inline">\(t_{min}\)</span>取<span class="math inline">\(\text{max}\)</span>,<span class="math inline">\(t_{max}\)</span>取<span class="math inline">\(\text{min}\)</span>), 即可求出光线在包围盒内的部分. 可以看出, 光线在包围盒内当且仅当光线进入矩形的所有对面(<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>). 光线离开包围盒只需满足离开任意对面.</p>
<p>现在推广到三维情况: 我们对三组对面分别求出它们的<span class="math inline">\(t_{min}\)</span>和<span class="math inline">\(t_{max}\)</span>.</p>
<p>可得进入时间: <span class="math inline">\(t_{enter} = \max(t_{min})\)</span></p>
<p>离开时间: <span class="math inline">\(t_{exit} = \min(t_{max})\)</span></p>
<p>当<span class="math inline">\(t_{enter} \leq t_{exit}\)</span>且<span class="math inline">\(t_{exit} \ge 0\)</span>时, 光线与包围盒相交.</p>
<p>对于AABB, 求交十分简单</p>
<h3 id="空间分割uniform-spatial-partitions-grids">空间分割(Uniform Spatial Partitions (Grids))</h3>
<p>在之前的优化中, 我们通过包围盒来避免了每条光线与每个三角面进行求交. 空间分割是对每个包围盒内部的判断进行进一步优化.</p>
<p><img src="/.io//image-20230103153852733.png" alt="image-20230103153852733" style="zoom:67%;"></p>
<p><img src="/.io//image-20230103154036499.png" alt="image-20230103154036499" style="zoom:67%;"></p>
<p>在一个包围盒内(图中最外层的边界即为包围盒), 将这个包围盒分成<span class="math inline">\(n \times n\)</span>个小格子. 如果一个格子包含了物体的表面, 就将其进行标记. 对于一条打进包围盒内部的光线, 我们首先计算它的行进路径上经过了哪些格子(Bresenham直线算法), 再对经过的格子中被标记的格子进行光线与物体的求交. 这样便避免了将光线与包围盒内的每个物体进行求交运算. 在三维空间中, 格子的个数一般取<span class="math inline">\(27 \times 物体个数\)</span></p>
<p>这种方法适合物体较均匀分布的场景.</p>
<h3 id="空间划分spatial-partitions">空间划分(Spatial Partitions)</h3>
<figure>
<img src="/.io//image-20230103154814447.png" alt="image-20230103154814447"><figcaption aria-hidden="true">image-20230103154814447</figcaption>
</figure>
<h4 id="k-d-tree">K-D Tree</h4>
<p>https://oi-wiki.org/ds/kdt/</p>
<p><img src="/.io//image-20230103160349287.png" alt="image-20230103160349287" style="zoom:67%;"></p>
<p><img src="/.io//image-20230103160356874.png" alt="image-20230103160356874" style="zoom:67%;"></p>
<p>K-D Tree有一些问题. 其一是物体与包围盒之间的关系很难进行判断(例如包围盒被三角形完全包围的情况). 其二是一个物体可能会同时存在于多个叶子节点中. 目前实践上已经很少使用K-D Tree, 而是改用BVH.</p>
<h3 id="物体划分与包围盒层次结构object-partitions-bounding-volume-hierarchy-bvh">物体划分与包围盒层次结构(Object Partitions &amp; Bounding Volume Hierarchy (BVH))</h3>
<p>PPT的信息已经足够充分, 这里不做过多解释. 详细实现留在作业6中.</p>
<p><img src="/.io//image-20230103161342545.png" alt="image-20230103161342545" style="zoom:67%;"></p>
<p><img src="/.io//image-20230103161405827.png" alt="image-20230103161405827" style="zoom:67%;"></p>
<p><img src="/.io//image-20230104092006753.png" alt="image-20230104092006753" style="zoom:67%;"></p>
<p><img src="/.io//image-20230104092638796.png" alt="image-20230104092638796" style="zoom:67%;"></p>
<p><img src="/.io//image-20230104093048787.png" alt="image-20230104093048787" style="zoom:67%;"></p>
<p><img src="/.io//image-20230104093112224.png" alt="image-20230104093112224" style="zoom:67%;"></p>
<h2 id="辐射度量学radiometry">辐射度量学(Radiometry)</h2>
<h3 id="基础-1">基础</h3>
<p><img src="/.io//image-20230104094036626.png" alt="image-20230104094036626" style="zoom:67%;"></p>
<p><img src="/.io//image-20230104094044139.png" alt="image-20230104094044139" style="zoom:67%;"></p>
<h4 id="辐射能和通量radiant-energy-and-flux-power">辐射能和通量(Radiant Energy and Flux (Power))</h4>
<p>辐射能即电磁辐射的能量, 用字母<span class="math inline">\(Q\)</span>表示. 单位是焦耳(<span class="math inline">\(J\)</span>,Joule). <span class="math display">\[
Q [\text J = \text{Joule}]
\]</span></p>
<p>辐射通量(Radiant flux), 也称作辐射功率(Radiant power), 是单位时间内发射/反射/传送/接受等等的能量. 用符号<span class="math inline">\(\Phi\)</span>表示. 单位是瓦或者流明. <span class="math display">\[
\Phi \equiv \frac{\text dQ}{\text d t}[\text{W = Watt}][\text{lm = lumen}]
\]</span></p>
<p><img src="/.io//image-20230119154805971.png" alt="image-20230119154805971" style="zoom:67%;"></p>
<p>上面是衡量光线的几种概念.</p>
<p>Radiant Intensity: 辐射强度</p>
<p>irradiance: 辐照度</p>
<p>radiance: 辐射</p>
<p>(中文译名不重要)</p>
<h4 id="辐射强度radiant-intensityi">辐射强度(Radiant Intensity,I)</h4>
<p><span class="math display">\[
I(\omega) = \frac{\text d \Phi}{\text d \omega} [\text{candela}]
\]</span></p>
<ul>
<li>立体角(Solid Angles)</li>
</ul>
<p><img src="/.io//image-20230105103912704.png" alt="image-20230105103912704" style="zoom:67%;"></p>
<p>在二维平面上, 角度<span class="math inline">\(\theta\)</span>被定义为扇形对应弧长<span class="math inline">\(l\)</span>与半径<span class="math inline">\(r\)</span>的比值. 在三维空间上, 令锥体所对的球面面积为<span class="math inline">\(A\)</span>, 则立体角: <span class="math display">\[
\Omega = \frac{A}{r^2}
\]</span> 单位是球面度(steradians). 注意立体角和角度一样, 也是无量纲量. 球的弧面度是<span class="math inline">\(4\pi\)</span></p>
<p><img src="/.io//image-20230105105000475.png" alt="image-20230105105000475" style="zoom:67%;"></p>
<p><img src="/.io//image-20230119155738314.png" alt="image-20230119155738314" style="zoom:67%;"></p>
<p><img src="/.io//image-20230119155039976.png" alt="image-20230119155039976" style="zoom:67%;"></p>
<p>如图, Radiant Intensity是单位立体角上的辐射通量(辐射功率), 单位是candela.</p>
<p><img src="/.io//image-20230119155946806.png" alt="image-20230119155946806" style="zoom:67%;"></p>
<p>约定使用<span class="math inline">\(\omega\)</span>来表示球坐标下的方向向量.</p>
<h4 id="辐照度irradiancee">辐照度(Irradiance,E)</h4>
<p><span class="math display">\[
E(\bold x) = \frac{\text d \Phi(\bold x)}{\text d A} [lux]
\]</span></p>
<p><img src="/.io//image-20230119163217212.png" alt="image-20230119163217212" style="zoom:67%;"></p>
<p>irradiance(辐照度)是入射到表面点上的单位面积的功率. 注意它和辐射强度(单位立体角上的功率)的区别. 注意这里需要入射光和平面垂直.</p>
<p><img src="/.io//image-20230119163932417.png" alt="image-20230119163932417" style="zoom:67%;"></p>
<p>回忆一下Bling-Phong模型里的兰伯特余弦定理. Irradiance的计算与它相同，计算的是投影面积.</p>
<p><img src="/.io//image-20230119164250275.png" alt="image-20230119164250275" style="zoom:67%;"></p>
<p>对于Bling-Phong模型中的能量衰减，这里也有更好的解释: irradiance随距离的平方反比衰减.</p>
<h4 id="辐亮度radiancel">辐亮度(Radiance,L)</h4>
<p><span class="math display">\[
L(p,\omega) = \frac{\text d ^2\Phi(\bold p,\omega)}{\text d \omega \text d A\cos\theta}
\]</span></p>
<p><img src="/.io//image-20230119164455940.png" alt="image-20230119164455940" style="zoom:67%;"></p>
<p><img src="/.io//image-20230119164653064.png" alt="image-20230119164653064" style="zoom:67%;"></p>
<p>Radiance(辐亮度)是在每单位立体角和单位投影面积上，表面接受/反射/发射的能量. 单位是尼特(nit).</p>
<p><img src="/.io//image-20230119165724982.png" alt="image-20230119165724982" style="zoom:67%;"></p>
<p><img src="/.io//image-20230119170732140.png" alt="image-20230119170732140" style="zoom:67%;"></p>
<p><img src="/.io//image-20230119170741047.png" alt="image-20230119170741047" style="zoom:67%;"></p>
<p><img src="/.io//image-20230119170751306.png" alt="image-20230119170751306" style="zoom:67%;"></p>
<h3 id="brdfbidirectional-reflectance-distribution-function">BRDF(Bidirectional Reflectance Distribution Function)</h3>
<p><img src="/.io//image-20230126134706238.png" alt="image-20230126134706238" style="zoom:67%;"></p>
<p><img src="/.io//image-20230126134715824.png" alt="image-20230126134715824" style="zoom:67%;"></p>
<p><img src="/.io//image-20230201081746064.png" alt="image-20230201081746064" style="zoom:80%;"></p>
<p><img src="/.io//image-20230201083352297.png" alt="image-20230201083352297" style="zoom:80%;"></p>
<h3 id="渲染方程">渲染方程</h3>
<figure>
<img src="/.io//image-20230201083709425.png" alt="image-20230201083709425"><figcaption aria-hidden="true">image-20230201083709425</figcaption>
</figure>
<p>其中<span class="math inline">\(\Omega ^ +\)</span>和<span class="math inline">\(H^2\)</span>都表示半球. 下半球的贡献为0, 不作计算. <span class="math inline">\(L_e\)</span>为物体的自发光.</p>
<figure>
<img src="/.io//image-20230201084514147.png" alt="image-20230201084514147"><figcaption aria-hidden="true">image-20230201084514147</figcaption>
</figure>
<figure>
<img src="/.io//image-20230201084542706.png" alt="image-20230201084542706"><figcaption aria-hidden="true">image-20230201084542706</figcaption>
</figure>
<figure>
<img src="/.io//image-20230201084559031.png" alt="image-20230201084559031"><figcaption aria-hidden="true">image-20230201084559031</figcaption>
</figure>
<figure>
<img src="/.io//image-20230201084817636.png" alt="image-20230201084817636"><figcaption aria-hidden="true">image-20230201084817636</figcaption>
</figure>
<figure>
<img src="/.io//image-20230201085404576.png" alt="image-20230201085404576"><figcaption aria-hidden="true">image-20230201085404576</figcaption>
</figure>
<figure>
<img src="/.io//image-20230201085409915.png" alt="image-20230201085409915"><figcaption aria-hidden="true">image-20230201085409915</figcaption>
</figure>
<figure>
<img src="/.io//image-20230201085821416.png" alt="image-20230201085821416"><figcaption aria-hidden="true">image-20230201085821416</figcaption>
</figure>
<h3 id="蒙特卡罗积分monte-carlo-integration">蒙特卡罗积分(Monte Carlo Integration)</h3>
<p><img src="/.io//image-20230203091155356.png" alt="image-20230203091155356" style="zoom:67%;"></p>
<p>均匀分布的情况下:</p>
<p><img src="/.io//image-20230203091631419.png" alt="image-20230203091631419" style="zoom:67%;"></p>
<p><img src="/.io//image-20230203091640676.png" alt="image-20230203091640676" style="zoom:67%;"></p>
<h2 id="路径追踪path-tracing">路径追踪(Path Tracing)</h2>
<p><img src="/.io//image-20230203095135065.png" alt="image-20230203095135065" style="zoom:67%;"></p>
<p><img src="/.io//image-20230203095152862.png" alt="image-20230203095152862" style="zoom:67%;"></p>
<p><img src="/.io//image-20230203095329690.png" alt="image-20230203095329690" style="zoom:80%;"></p>
<p>根据上面的公式，可以写出如下伪代码:</p>
<p><img src="/.io//image-20230203100854467.png" alt="image-20230203100854467" style="zoom:67%;"></p>
<p>但是这个做法有很大问题: 这个算法是递归的, 同时对于每根打到物体上的光线都需要重新做一次shade, 假设每次shade有<span class="math inline">\(n\)</span>条光线, 一共反射了<span class="math inline">\(k\)</span>次, 总光线数将是<span class="math inline">\(O(n^k)\)</span>级别. 要避免指数爆炸, 必须有<span class="math inline">\(n = 1\)</span>:</p>
<p><img src="/.io//image-20230203101046378.png" alt="image-20230203101046378" style="zoom:67%;"></p>
<p><span class="math inline">\(n = 1\)</span>又带来了另一个问题: 在蒙特卡洛方法里, 采样越少噪声越大. 路径追踪中只采样一次, 会产生十分巨大的噪声. 为此我们需要对一个像素做多次路径追踪并取均值.</p>
<p><img src="/.io//image-20230203101623438.png" alt="image-20230203101623438" style="zoom:67%;"></p>
<p>现在光线数量指数爆炸的问题解决了. 但这是一个递归算法, 我们还缺少一个终止条件. 如果简单地设置一个递归深度, 会导致能量损失, 我们需要一种更合理的解决方法, 设一个概率, 每条光线在继续采样时有概率终止:</p>
<p><img src="/.io//image-20230203101956422.png" alt="image-20230203101956422" style="zoom:67%;"></p>
<p><img src="/.io//image-20230203102510766.png" alt="image-20230203102510766" style="zoom:67%;"></p>
<p><img src="/.io//image-20230203103151011.png" alt="image-20230203103151011" style="zoom:67%;"></p>
<p>至此, 路径追踪的正确算法已经得出, 下面的内容是性能优化.</p>
<p><img src="/.io//image-20230203103629972.png" alt="image-20230203103629972" style="zoom:67%;"></p>
<p><img src="/.io//image-20230203103642748.png" alt="image-20230203103642748" style="zoom:67%;"></p>
<p>为了避免浪费，我们改为对光源采样. 为此我们需要得到<span class="math inline">\(\text d \omega\)</span>(立体角, 对像素点对应的半球采样)和<span class="math inline">\(\text d A\)</span>(面积, 对光源采样)之间的关系:</p>
<p><img src="/.io//image-20230206143614599.png" alt="image-20230206143614599" style="zoom:67%;"></p>
<p><img src="/.io//image-20230206143843085.png" alt="image-20230206143843085" style="zoom:67%;"></p>
<p>这样便可以重写渲染方程:</p>
<p><img src="/.io//image-20230206144106059.png" alt="image-20230206144106059" style="zoom:67%;"></p>
<p><img src="/.io//image-20230206144231758.png" alt="image-20230206144231758" style="zoom:67%;"></p>
<p><img src="/.io//image-20230206144359534.png" alt="image-20230206144359534" style="zoom:67%;"></p>
<p><img src="/.io//image-20230206144757574.png" alt="image-20230206144757574" style="zoom:67%;"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>图形学</tag>
        <tag>GAMES101</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 18.01 单变量微积分</title>
    <url>/2023/01/05/MIT-18-01/</url>
    <content><![CDATA[<h1 id="常用公式">常用公式</h1>
<h2 id="三角函数">三角函数</h2>
<p><span class="math display">\[
\sin^2x + \cos ^ 2 x = 1\\
\]</span></p>
<h2 id="求导">求导</h2>
<h3 id="三角函数求导">三角函数求导</h3>
<p><span class="math display">\[
\sin&#39;x = \cos x\\
\cos&#39;x = - \sin x\\
\tan&#39;x = \frac{1}{\cos^2x} = \sec^2x\\
\arctan&#39; x = \frac{1}{1+x^2}\\
\]</span></p>
<h3 id="指数函数和对数函数">指数函数和对数函数</h3>
<p><span class="math display">\[
\frac{\text d}{\text d x}\ln x = \frac{1}{x}\\
\frac{\text d}{\text d x}e^x = e^x\\
\frac{\text d}{\text dx}a^x = \ln a \cdot a^x\\
\frac{\text d}{\text d x} \ln u = \frac{1}{u}\frac{\text d u}{\text d x}
\]</span></p>
<h1 id="导数derivative">导数（derivative)</h1>
<h2 id="lecture1-导数的几何解释">Lecture1: 导数的几何解释</h2>
<p><img src="/.io//image-20230105165932729.png" alt="image-20230105165932729" style="zoom:67%;"></p>
<p>如图, <span class="math inline">\(P\)</span>点的导数便是过<span class="math inline">\(P\)</span>点的切线(tangent line)的斜率, 记作<span class="math inline">\(f&#39;(P)\)</span>.</p>
<p>什么样子的线是切线? 我们先看由点<span class="math inline">\(PQ\)</span>构成的割线(secant line). 当<span class="math inline">\(PQ\)</span>两点的距离趋于<span class="math inline">\(0\)</span>时, 割线与切线便无限接近.</p>
<p><img src="/.io//image-20230106095142833.png" alt="image-20230106095142833" style="zoom:67%;"></p>
<p>如图. 可得 <span class="math display">\[
f&#39;(x) = \lim_{\Delta x \to 0} \frac{f(x_0 + \Delta x) - f(x_0)}{\Delta x}
\]</span></p>
<h3 id="一些符号">一些符号</h3>
<p><img src="/.io//image-20230106102935887.png" alt="image-20230106102935887" style="zoom:67%;"></p>
<p>导数(牛顿记法): <span class="math inline">\(f&#39;\)</span></p>
<p>导数(莱布尼兹记法): <span class="math inline">\(\frac{\text df}{\text dx},\frac{\text dy}{\text d x},\frac{\text d}{\text dx}f,\frac{\text d}{\text dx}y\)</span></p>
<p>一个有用的公式(推导见手写笔记): <span class="math display">\[
\frac{\text d}{\text d x}x^n = n \cdot x^{n-1}
\]</span></p>
<h2 id="lecture2-极限-连续性和三角函数的极限">Lecture2: 极限, 连续性和三角函数的极限</h2>
<p><img src="/.io//image-20230106105337764.png" alt="image-20230106105337764" style="zoom:67%;"></p>
<p>我们用<span class="math inline">\(\frac{\Delta y}{\Delta x}\)</span>来计量某个函数在一段时间内的平均变化率. 当<span class="math inline">\(\Delta x \to 0\)</span>时, 这便变成了瞬时变化率.</p>
<p><img src="/.io//image-20230106110147320.png" alt="image-20230106110147320" style="zoom:50%;"></p>
<p><img src="/.io//image-20230106110459943.png" alt="image-20230106110459943" style="zoom:67%;"></p>
<p><img src="/.io//image-20230106110512348.png" alt="image-20230106110512348" style="zoom:50%;"></p>
<h3 id="limits-and-continuity">Limits and Continuity</h3>
<p>简单的极限可以直接带入运算:</p>
<p><img src="/.io//image-20230106111047720.png" alt="image-20230106111047720" style="zoom: 67%;"></p>
<p>但是对于 <span class="math display">\[
\lim_{\Delta x \to 0}\frac{\Delta f}{\Delta x}
\]</span> 它不是一个简单极限. 因为我们不能将<span class="math inline">\(\Delta x = 0\)</span>代入运算, 这样永远会得到<span class="math inline">\(\frac{0}{0}\)</span>. <strong>注意</strong>: <span class="math display">\[
\lim_{x \to x_0}
\]</span> 暗示了<span class="math inline">\(x \neq x_0\)</span>.</p>
<h4 id="左右极限left-and-right-limt">左右极限(Left and Right Limt)</h4>
<p>我们用以下两个记号来表示左极限和右极限: <span class="math display">\[
\lim_{x\to x_0^-} (左极限, 此时x &lt; x_0)\\
\lim_{x\to x_0^+} (右极限, 此时x &gt; x_0)\\
\]</span></p>
<h3 id="连续性continuity">连续性(Continuity)</h3>
<p>我们称<span class="math inline">\(f(x)\)</span>在<span class="math inline">\(x_0\)</span>连续, 当且仅当 <span class="math display">\[
\lim_{x \to x_0}f(x) = f(x_0)
\]</span> 这意味着:</p>
<ol type="1">
<li><span class="math inline">\(f(x)\)</span>在点<span class="math inline">\(x_0\)</span>的极限必须存在, 且左右极限相等</li>
<li><span class="math inline">\(f(x_0)\)</span>是有定义的</li>
<li><span class="math inline">\(\lim_{x\to x_0}f(x)\)</span>与<span class="math inline">\(f(x_0)\)</span>相等</li>
</ol>
<p><img src="/.io//image-20230106142515063.png" alt="image-20230106142515063" style="zoom:50%;"></p>
<p>如图, <span class="math inline">\(\lim_{x \to 0^+}f(x) = 1\)</span>, 但是<span class="math inline">\(f(0) = 0\)</span>. 因此该函数在点<span class="math inline">\(0\)</span>不连续.</p>
<p>以下是不连续的几种情况:</p>
<ol type="1">
<li>Removable Discontinuity</li>
</ol>
<p><img src="/.io//image-20230106143147259.png" alt="image-20230106143147259" style="zoom:50%;"></p>
<p>该点的左右极限存在且相等, 但与该点的函数值不等(或该点的函数值未定义)</p>
<ol start="2" type="1">
<li>Jump Discontinuity</li>
</ol>
<p>​ <img src="/.io//image-20230106142937484.png" alt="image-20230106142937484" style="zoom:50%;"></p>
<p>左右极限均存在, 但不相等.</p>
<ol start="3" type="1">
<li>Infinite Discontinuity</li>
</ol>
<p><img src="/.io//image-20230106143422550.png" alt="image-20230106143422550" style="zoom:50%;"></p>
<p><span class="math inline">\(x = 0\)</span>时, 左极限为负无穷, 右极限为正无穷.</p>
<ol start="4" type="1">
<li>Other (ugly) discontinuities</li>
</ol>
<p><img src="/.io//image-20230106144002234.png" alt="image-20230106144002234" style="zoom:50%;"></p>
<h3 id="导数的图像picturing-the-derivative">导数的图像(Picturing the derivative)</h3>
<p><img src="/.io//image-20230106144101961.png" alt="image-20230106144101961" style="zoom:50%;"></p>
<p>注意导数的图像和原函数的图像没有什么相关性. 而且对一个奇函数求导, 它的导数一定是一个偶函数.</p>
<h3 id="定理-可导必连续theorem-differentiable-implies-continuous">定理: 可导必连续(Theorem: Differentiable Implies Continuous)</h3>
<p><span class="math display">\[
如果f在x_0处可导, 那么f必定在x_0处连续.
\]</span></p>
<p><img src="/.io//image-20230106150417303.png" alt="image-20230106150417303" style="zoom: 80%;"></p>
<h2 id="lecture-3-导数的四则运算及三角函数">Lecture 3: 导数的四则运算及三角函数</h2>
<h3 id="求导公式derivative-formulas">求导公式(Derivative Formulas)</h3>
<p><img src="/.io//image-20230106153822818.png" alt="image-20230106153822818" style="zoom:67%;"></p>
<h3 id="特殊求导公式">特殊求导公式</h3>
<p><span class="math display">\[
\lim_{\theta \to 0}\frac{\sin\theta}{\theta} = 1\\
\lim_{\theta\to0}\frac{1 - cos\theta}{\theta} = 0
\]</span></p>
<p>证明:</p>
<p><img src="/.io//image-20230106160612420.png" alt="image-20230106160612420" style="zoom:67%;"></p>
<p><img src="/.io//image-20230106160652701.png" alt="image-20230106160652701" style="zoom:67%;"></p>
<h4 id="sin-cos">sin, cos</h4>
<p><span class="math display">\[
\frac{\text d}{\text d x}\sin x = \cos x\\
\frac{\text d}{\text d x}\cos x = -\sin x\\
\]</span></p>
<p>推导过程:</p>
<p><img src="/.io//image-20230106154306445.png" alt="image-20230106154306445" style="zoom:67%;"></p>
<h3 id="一般求导公式">一般求导公式</h3>
<ul>
<li><p>加法法则 <span class="math display">\[
  (u+v)&#39; = u&#39; + v&#39;
  \]</span></p></li>
<li><p>乘积法则</p></li>
</ul>
<p><span class="math display">\[
(uv)&#39; = u&#39;v + uv&#39;
\]</span></p>
<ul>
<li><p>除法法则(quotient rule) <span class="math display">\[
  (\frac{u}{v})&#39; = \frac{u&#39;v - uv&#39;}{v^2}(v \neq 0)
  \]</span></p></li>
<li><p>证明: 加法法则</p>
<p><img src="/.io//image-20230111103645235.png" alt="image-20230111103645235" style="zoom:67%;"></p></li>
<li><p>证明: 乘法法则</p></li>
</ul>
<p><img src="/.io//image-20230111103618880.png" alt="image-20230111103618880" style="zoom:67%;"></p>
<p><img src="/.io//image-20230111105348577.png" alt="image-20230111105348577" style="zoom:67%;"></p>
<p>几何上的理解: <span class="math inline">\((uv)&#39; \cdot \Delta x = (u + \Delta u)(v + \Delta v) - uv\)</span>, 即图中粉色, 白色, 黄色部分之和. 又因为<span class="math inline">\(\Delta u \cdot \Delta v \approx 0\)</span>, 所以有 <span class="math display">\[
(uv)&#39; \approx \frac{u \Delta v + v \Delta u}{\Delta x} \\
= uv’ +u&#39;v
\]</span></p>
<ul>
<li>证明: 除法法则</li>
</ul>
<p><img src="/.io//image-20230111111834201.png" alt="image-20230111111834201" style="zoom:67%;"></p>
<h2 id="lecture-4链式法则和高阶导数">Lecture 4:链式法则和高阶导数</h2>
<h3 id="链式法则chain-rule">链式法则(Chain Rule)</h3>
<p><span class="math display">\[
\frac{\text{d}y}{\text{d}t} = \frac{\text{d} y}{\text{d}x} \cdot \frac{\text{d}x}{\text{d}t}
\]</span></p>
<p><img src="/.io//image-20230115092644053.png" alt="image-20230115092644053" style="zoom:67%;"></p>
<p><img src="/.io//image-20230115092735531.png" alt="image-20230115092735531" style="zoom: 67%;"></p>
<h3 id="高阶导数higher-derivatives">高阶导数(Higher Derivatives)</h3>
<p><img src="/.io//image-20230115093300221.png" alt="image-20230115093300221" style="zoom:67%;"></p>
<h2 id="lecture-5-隐函数微分及逆函数导数">Lecture 5 隐函数微分及逆函数导数</h2>
<h3 id="隐函数微分implicit-differentiation">隐函数微分(Implicit Differentiation)</h3>
<p>有些函数(例如<span class="math inline">\(x^2 + y^2 = 1\)</span>)不具有明显的<span class="math inline">\(y = f(x)\)</span>形式, 但是能通过变形得到(本例可得<span class="math inline">\(y = \sqrt{1 - x^2}\)</span>). 这样的函数称为隐函数. 对隐函数求导, 可在方程两边同时对<span class="math inline">\(x\)</span>求导, 得到一个包含<span class="math inline">\(\frac{\text{d}y}{\text{d}x}\)</span>的式子, 再求解<span class="math inline">\(\frac{\text{d}y}{\text{d}x}\)</span>即可.</p>
<p><img src="/.io//image-20230115095829432.png" alt="image-20230115095829432" style="zoom:67%;"></p>
<p><img src="/.io//image-20230115095838093.png" alt="image-20230115095838093" style="zoom:67%;"></p>
<p><img src="/.io//image-20230115100903420.png" alt="image-20230115100903420" style="zoom:67%;"></p>
<h3 id="反函数inverse-function">反函数(Inverse Function)</h3>
<p>若<span class="math inline">\(y = f(x),g(x) = y\)</span>, 则<span class="math inline">\(g\)</span>是<span class="math inline">\(f\)</span>的反函数, 记作<span class="math inline">\(f^{-1}\)</span>. 函数和它的反函数关于<span class="math inline">\(y = x\)</span>对称.</p>
<p><img src="/.io//image-20230115104051068.png" alt="image-20230115104051068" style="zoom:67%;"></p>
<p><img src="/.io//image-20230115101543407.png" alt="image-20230115101543407" style="zoom:67%;"></p>
<p><img src="/.io//image-20230115103931577.png" alt="image-20230115103931577" style="zoom:67%;"></p>
<p><img src="/.io//image-20230115103954784.png" alt="image-20230115103954784" style="zoom:50%;"></p>
<p><img src="/.io//image-20230115104005007.png" alt="image-20230115104005007" style="zoom:67%;"></p>
<p><img src="/.io//image-20230115104013455.png" alt="image-20230115104013455" style="zoom:67%;"></p>
<h2 id="lecture-6-指数函数与对数函数对数微分双曲线函数">Lecture 6 指数函数与对数函数，对数微分，双曲线函数</h2>
<h3 id="指数函数对数函数和自然对数">指数函数，对数函数和自然对数</h3>
<p>见课程pdf和手写笔记</p>
<p>### 对数微分(Logarithmic Differentiation)</p>
<p><img src="/.io//image-20230118095423689.png" alt="image-20230118095423689" style="zoom:67%;"></p>
<p><img src="/.io//image-20230118095433488.png" alt="image-20230118095433488" style="zoom:67%;"></p>
<p><img src="/.io//image-20230118101022744.png" alt="image-20230118101022744" style="zoom:67%;"></p>
<p><img src="/.io//image-20230118101033927.png" alt="image-20230118101033927" style="zoom:67%;"></p>
<figure>
<img src="/.io//image-20230118101203685.png" alt="image-20230118101203685"><figcaption aria-hidden="true">image-20230118101203685</figcaption>
</figure>
<h2 id="lecture-7-连续性和第一次考试复习">Lecture 7 连续性和第一次考试复习</h2>
<h3 id="导数伪装的极限">导数伪装的极限</h3>
<p>(普林斯顿微积分读本修订版，人民邮电出版社，ISBN: 978-7-115-43559-0, P101)</p>
<h2 id="leture-9-线性和二阶近似">Leture 9 线性和二阶近似</h2>
<h3 id="线性近似linear-approximation">线性近似(Linear Approximation)</h3>
<p><span class="math display">\[
f(x) \approx f(x_0) + f&#39;(x_0)(x - x_0)
\]</span> <img src="/.io//image-20230130153834142.png" alt="image-20230130153834142" style="zoom:67%;"></p>
<p><img src="/.io//image-20230130154812720.png" alt="image-20230130154812720" style="zoom: 67%;"></p>
<p>注意上表近似符号左边和右边的函数. 如果<span class="math inline">\(f(x_0) + f&#39;(x)(x - x_0)\)</span>比<span class="math inline">\(f(x)\)</span>更容易计算, 便可以用线性近似来加速计算.</p>
<p><img src="/.io//image-20230130162129715.png" alt="image-20230130162129715" style="zoom:67%;"></p>
<p><img src="/.io//image-20230130162139973.png" alt="image-20230130162139973" style="zoom:67%;"></p>
<h3 id="二阶近似quadratic-approximations">二阶近似(Quadratic Approximations)</h3>
<p>一阶(线性)近似可能精度不够, 这时便需要二阶或更高阶的近似. <span class="math display">\[
f(x) \approx f(x_0) + f&#39;(x_0)(x - x_0) + \frac{f&#39;&#39;(x_0)}{2}(x-x_0)^2
\]</span></p>
<p>关于为什么二阶导的系数是<span class="math inline">\(\frac{1}{2}\)</span>:</p>
<figure>
<img src="/.io//image-20230201094512497.png" alt="image-20230201094512497"><figcaption aria-hidden="true">image-20230201094512497</figcaption>
</figure>
<p>可以看出, 二阶近似的效果更好:</p>
<p><img src="/.io//image-20230130163838707.png" alt="image-20230130163838707" style="zoom:67%;"></p>
<p>基础的结论:</p>
<p><img src="/.io//image-20230201094623798.png" alt="image-20230201094623798" style="zoom:67%;"></p>
<p><img src="/.io//image-20230201100855010.png" alt="image-20230201100855010" style="zoom:67%;"></p>
<h2 id="lecture-10-曲线构图">Lecture 10: 曲线构图</h2>
<p>Lecture 10: Curve Sketching</p>
<p>利用<span class="math inline">\(f&#39;\)</span>和<span class="math inline">\(f&#39;&#39;\)</span>的符号来画出<span class="math inline">\(f\)</span>的近似图像</p>
<ul>
<li><span class="math inline">\(f&#39; &gt; 0\)</span>, <span class="math inline">\(f\)</span>递增. 反之亦然</li>
<li><span class="math inline">\(f&#39;&#39; &gt; 0\)</span>, <span class="math inline">\(f&#39;\)</span>递增, 反之亦然</li>
</ul>
<p>画图的一般步骤:</p>
<p><img src="/.io//image-20230201101459064.png" alt="image-20230201101459064" style="zoom:67%;"></p>
<p>当<span class="math inline">\(f&#39;(x_0) = 0\)</span>时, 点<span class="math inline">\(x_0\)</span>称为驻点(临界点, critical points).</p>
<p>当<span class="math inline">\(f&#39;&#39;(x_0) = 0\)</span>时, 点<span class="math inline">\(x_0\)</span>称为拐点(inflection point).</p>
<p><img src="/.io//image-20230201101611151.png" alt="image-20230201101611151" style="zoom:67%;"></p>
<p><img src="/.io//image-20230201101621823.png" alt="image-20230201101621823" style="zoom:67%;"></p>
<figure>
<img src="/.io//image-20230201101928665.png" alt="image-20230201101928665"><figcaption aria-hidden="true">image-20230201101928665</figcaption>
</figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>微积分</tag>
        <tag>MIT 18.01</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES-202</title>
    <url>/2023/01/06/GAMES-202/</url>
    <content><![CDATA[<h1 id="导论">导论</h1>
<h2 id="graphics-hardware-pipeline">Graphics (Hardware) Pipeline</h2>
<figure>
<img src="/.io//image-20230106184441259.png" alt="image-20230106184441259"><figcaption aria-hidden="true">image-20230106184441259</figcaption>
</figure>
<h2 id="opengl">OpenGL</h2>
<p><img src="/.io//image-20230118102300199.png" alt="image-20230118102300199" style="zoom:67%;"></p>
<h3 id="a.-place-objectsmodels">A. Place objects/models</h3>
<p><img src="/.io//image-20230118102922245.png" alt="image-20230118102922245" style="zoom:67%;"></p>
<h3 id="b.-set-up-an-easel">B. Set up an easel</h3>
<p><img src="/.io//image-20230118103116098.png" alt="image-20230118103116098" style="zoom:67%;"></p>
<h3 id="c.-attach-a-canvas-to-the-ease">C. Attach a canvas to the ease</h3>
<p><img src="/.io//image-20230118103323789.png" alt="image-20230118103323789" style="zoom:67%;"></p>
<h3 id="d.-paint-to-the-canvas">D. Paint to the canvas</h3>
<p><img src="/.io//image-20230118104037026.png" alt="image-20230118104037026" style="zoom:67%;"></p>
<p><img src="/.io//image-20230118104438290.png" alt="image-20230118104438290" style="zoom:67%;"></p>
<p><img src="/.io//image-20230118104618634.png" alt="image-20230118104618634" style="zoom:67%;"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>GAMES202</tag>
      </tags>
  </entry>
  <entry>
    <title>solution-CF1715E</title>
    <url>/2022/08/22/solution-CF1715E/</url>
    <content><![CDATA[<h2 id="题意">题意</h2>
<h2 id="做法">做法</h2>
<p>斜率优化可以解决如下问题:</p>
<p>给出一组直线<span class="math inline">\(y_i = k_i x_ + b_i\)</span>. 对于任意<span class="math inline">\(x\)</span>, 求<span class="math inline">\(y_i\)</span>的极大/极小值.</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT-18.06</title>
    <url>/2023/01/26/MIT-18-06/</url>
    <content><![CDATA[<h2 id="lec-4-a-lu">Lec 4 A = LU</h2>
<p><span class="math display">\[
(AB)^{-1} = B^{-1}A^{-1} \\
(A^{T})^{-1} = (A^{-1})^{T}\\
\]</span></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
</search>
