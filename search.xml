<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>[题解]CF1350C-Orac and LCM</title>
    <url>/2020/05/13/solution-CF1350C/</url>
    <content><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>​        给定集合${a_1,a_2,…,a_n}$,求$gcd({lcm({a_i,a_j})|i&lt;j})$  </p>
<p>​        $2 \leq n \leq 1e5 $ , $1 \leq a_i \leq 2e5$</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>​        考虑唯一分解定理:</p>
<p>​                $a = \prod^{n}_{1}p_i^{k_i}$ </p>
<p>​                $b = \prod^{n}_{1}p_i^{g_i}$</p>
<p>​        对于 $gcd$ 和 $lcm$ ,我们有:</p>
<p>​                $gcd(a,b) = \prod^{n}_{1}p_i^{min(k_i,g_i)}$</p>
<p>​                $lcm(a,b) = \prod^{n}_{1}p_i^{max(k_i,g_i)}$</p>
<p>​        观察易得,对于答案中的每个质因子$p_i$,它的指数$k_i$为${a_1,…,a_n}$中 $p_i$ <strong>第二小</strong> 的指数$k$</p>
<p>​        我们预处理出$i$的所有质因数$p[i]$,将$a_i$分解,用$d[i][j]$表示$a_j$的质因子$i$的指数,排序后扫一遍$d[i]$即可得到答案</p>
<p>​        具体来说</p>
<script type="math/tex; mode=display">
ans *= \left\{
\begin{array}{lcl}
i^{d[i][0]}&& {d[i].size() == n-1} \\
i^{d[i][1]} && {d[i].size()  \geq n-1 }\\
1 && otherwise
\end{array}
\right.</script><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> raw[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="function">ll <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">	ll tans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(d == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	ll a = Pow(x,d/<span class="number">2</span>);</span><br><span class="line">	tans = a*a;</span><br><span class="line">	<span class="keyword">if</span>(d%<span class="number">2</span>)tans = tans*x; </span><br><span class="line">	<span class="keyword">return</span> tans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> n_prime[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;p[maxn],d[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;maxn;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!n_prime[i])&#123;</span><br><span class="line">			p[i].push_back(i); </span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = i*<span class="number">2</span>;j &lt; maxn;j += i)&#123;</span><br><span class="line">				n_prime[j] = <span class="number">1</span>;</span><br><span class="line">				p[j].push_back(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	n_prime[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	prime();</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)<span class="built_in">cin</span> &gt;&gt; raw[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> u = raw[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x:p[u])&#123;</span><br><span class="line">			<span class="keyword">int</span> yay = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(u%x == <span class="number">0</span>)&#123;</span><br><span class="line">				yay++;</span><br><span class="line">				u /= x;</span><br><span class="line">			&#125;</span><br><span class="line">			d[x].push_back(yay);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; maxn;i++)&#123;</span><br><span class="line">		sort(d[i].begin(),d[i].end());</span><br><span class="line">		<span class="keyword">if</span>(d[i].size() == n<span class="number">-1</span>)&#123;</span><br><span class="line">			ans *= Pow(i,d[i][<span class="number">0</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(d[i].size() &gt; n<span class="number">-1</span>)ans *= Pow(i,d[i][<span class="number">1</span>]); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>math-misc</title>
    <url>/2020/05/11/math-misc/</url>
    <content><![CDATA[<ul>
<li>本篇仅记录一些杂乱的知识点留作日后整理,更多是作Markdown和$L_{A}T^{E}X$的练习用</li>
</ul>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>[模板]计算几何</title>
    <url>/2020/05/09/template-geometry/</url>
    <content><![CDATA[<p><del>不存在的</del></p>
<h1 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h1><h2 id="起手式-待补充"><a href="#起手式-待补充" class="headerlink" title="起手式(待补充):"></a>起手式(待补充):</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.14159265358979</span>; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">	<span class="keyword">double</span> x,y;</span><br><span class="line">	Point(<span class="keyword">double</span> x = <span class="number">0</span>,<span class="keyword">double</span> y = <span class="number">0</span>):x(x),y(y)&#123;&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Point &amp; A) <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x == A.x?y &lt; A.y:x &lt; A.x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;raw[maxn],hull[maxn];</span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">torad</span><span class="params">(<span class="keyword">double</span> deg)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> deg*(PI/<span class="number">180</span>);</span><br><span class="line">&#125;</span><br><span class="line">Vector <span class="keyword">operator</span> + (Vector A,Vector B)&#123;</span><br><span class="line">	<span class="keyword">return</span> Vector(A.x+B.x,A.y+B.y);</span><br><span class="line">&#125;</span><br><span class="line">Vector <span class="keyword">operator</span> - (Vector A,Vector B)&#123;</span><br><span class="line">	<span class="keyword">return</span> Vector(A.x-B.x,A.y-B.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Cross</span><span class="params">(Vector A,Vector B)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> A.x*B.y - A.y*B.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Dist</span><span class="params">(Point A,Point B)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(A.x-B.x,<span class="number">2</span>)+<span class="built_in">pow</span>(A.y-B.y,<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Vector <span class="title">Rotate</span><span class="params">(Vector A,<span class="keyword">double</span> rad)</span></span>&#123;<span class="comment">//逆时针 </span></span><br><span class="line">	<span class="keyword">return</span> Vector(A.x*<span class="built_in">cos</span>(rad) - A.y*<span class="built_in">sin</span>(rad),A.x*<span class="built_in">sin</span>(rad) + A.y*<span class="built_in">cos</span>(rad));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="凸包"><a href="#凸包" class="headerlink" title="凸包:"></a>凸包:</h2><p>ConvexHull输入顶点个数,返回凸包上点的个数.raw为原顶点数组,hull为凸包顶点数组</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ConvexHull</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	sort(raw+<span class="number">1</span>,raw+n+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> idx = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(idx &gt; <span class="number">2</span> <span class="keyword">and</span> Cross(hull[idx<span class="number">-1</span>] - hull[idx<span class="number">-2</span>],raw[i] - hull[idx<span class="number">-2</span>]) &lt;= <span class="number">0</span>)idx--;</span><br><span class="line">		hull[idx++] = raw[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> k = idx;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>;i &gt;= <span class="number">1</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">while</span>(idx &gt; k <span class="keyword">and</span> Cross(hull[idx<span class="number">-1</span>] - hull[idx<span class="number">-2</span>],raw[i] - hull[idx<span class="number">-2</span>]) &lt;= <span class="number">0</span>)idx--;</span><br><span class="line">		hull[idx++] = raw[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> idx<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## 多边形面积:</span><br><span class="line"></span><br><span class="line">_Point为多边形点集,n为顶点数</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">PolyArea</span><span class="params">(Point * _Point,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> area = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; n;i++)&#123;</span><br><span class="line">		area += Cross(_Point[i] - _Point[<span class="number">1</span>],_Point[i+<span class="number">1</span>] - _Point[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> area/<span class="number">2</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三维"><a href="#三维" class="headerlink" title="三维"></a>三维</h1><h2 id="起手式"><a href="#起手式" class="headerlink" title="起手式:"></a>起手式:</h2><p>鸽子biss</p>
]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>[模板]数学</title>
    <url>/2020/05/09/template-math/</url>
    <content><![CDATA[<p>212370440130137957</p>
<p>(↑这是一个很大的质数)</p>
<p>19260817</p>
<p>(↑这是一颗很大的子弹)</p>
<hr>
<h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>计算$x^d \mod p$</p>
<p>注意$a^b % p = ((a % p)^b) % p$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">	ll tans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(d == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	ll a = Pow(x,d/<span class="number">2</span>);</span><br><span class="line">	tans = a*a%p;</span><br><span class="line">	<span class="keyword">if</span>(d%<span class="number">2</span>)tans = tans*x%p; </span><br><span class="line">	<span class="keyword">return</span> tans%p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="GCD-amp-exGCD"><a href="#GCD-amp-exGCD" class="headerlink" title="GCD &amp; exGCD"></a>GCD &amp; exGCD</h2><p>x,y,d为全局变量.求x和y使得 $ax + by = d$ 且 $|x| + |y|$最小.</p>
<p>其中 $d = gcd(a,b)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b?gcd(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gcd</span><span class="params">(ll a,ll b,ll &amp; d,ll &amp; x,ll &amp; y)</span></span>&#123;</span><br><span class="line">	<span class="comment">//notice d = gcd(a,b)</span></span><br><span class="line">	<span class="keyword">if</span>(!b)d = a,x = <span class="number">1</span>,y = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		gcd(b,a%b,d,y,x);</span><br><span class="line">		y -= x*(a/b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h2><p>返回模p下a的逆.不存在则返回-1.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a,ll p)</span></span>&#123;</span><br><span class="line">	ll d,x,y;</span><br><span class="line">	gcd(a,p,d,x,y);</span><br><span class="line">	<span class="keyword">return</span> d == <span class="number">1</span>?(x+p)%p:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线性筛逆元"><a href="#线性筛逆元" class="headerlink" title="线性筛逆元:"></a>线性筛逆元:</h3><p>返回模p下1…n的逆.保存在invs里</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_inv</span><span class="params">()</span></span>&#123;</span><br><span class="line">	invs[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		invs[i] = (ll)(p - p/i)*invs[p%i]%p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Eratosthenes筛"><a href="#Eratosthenes筛" class="headerlink" title="Eratosthenes筛"></a>Eratosthenes筛</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!n_prime[i])&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = i*<span class="number">2</span>;j &lt;= n;j += i)n_prime[j] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	n_prime[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="欧拉函数-φ-x"><a href="#欧拉函数-φ-x" class="headerlink" title="欧拉函数$φ(x)$"></a>欧拉函数$φ(x)$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">cal_phi</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m = (ll)<span class="built_in">sqrt</span>(x+<span class="number">0.5</span>);</span><br><span class="line">	ll tans = x;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= m;i++)<span class="keyword">if</span>(!(x%i))&#123;</span><br><span class="line">		tans = tans/i*(i<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">while</span>(!(x%i))x /= i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x &gt; <span class="number">1</span>)tans = tans / x * (x<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> tans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线性筛-φ-x"><a href="#线性筛-φ-x" class="headerlink" title="线性筛$φ(x)$"></a>线性筛$φ(x)$</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve_phi</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)<span class="keyword">if</span>(!phi[i])</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt;= n;j += i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!phi[j])phi[j] = j;</span><br><span class="line">			phi[j] = phi[j]/i * (i<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="有理数取模"><a href="#有理数取模" class="headerlink" title="有理数取模"></a>有理数取模</h2><p>求$a/b$ % $p$ （p为质数)</p>
<p>由费马小定理$b^{p-1} ≡ 1 \pmod p$ 可得 $b^{p-2} ≡ b^{-1} \pmod p$</p>
<p>故只需求$a*b^{p-2} \bmod p$</p>
<p>a,b过大则先膜一下</p>
<h2 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h2><p>若$a,p$互质,则有</p>
<p>$a^{φ(p)} ≡ 1 \pmod p$</p>
<h3 id="扩展欧拉定理-无需a-p互质"><a href="#扩展欧拉定理-无需a-p互质" class="headerlink" title="扩展欧拉定理(无需a,p互质)"></a>扩展欧拉定理(无需a,p互质)</h3><p>$b ≥ φ(p)$时:</p>
<p>$a^b ≡ a^{b \bmod φ(p) +φ(p)} \pmod p$</p>
<h2 id="拉格朗日插值"><a href="#拉格朗日插值" class="headerlink" title="拉格朗日插值"></a>拉格朗日插值</h2><p>px,py为点坐标,p为模数,k是L(k)那个k<br>inv为逆元</p>
<p>返回L(k)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">lagrange</span><span class="params">(ll n,ll k)</span></span>&#123;</span><br><span class="line">	ll tans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		ll f = <span class="number">1</span>,g = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)<span class="keyword">if</span>(i != j)&#123;</span><br><span class="line">			f = f*(k - px[j]+p)%p;</span><br><span class="line">			g = g*(px[i] - px[j]+p)%p;</span><br><span class="line">		&#125;</span><br><span class="line">		ll lota = py[i]*f%p*inv(g,p)%p;</span><br><span class="line">		tans = (tans+lota)%p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tans; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线性求-sum-i-0-n-i-k"><a href="#线性求-sum-i-0-n-i-k" class="headerlink" title="线性求$\sum_{i = 0}^{n}i^k$"></a>线性求$\sum_{i = 0}^{n}i^k$</h3><pre><code>(返回L(k)的值,多项式次数为n.按需更改yi的值,复杂度$O(n)$)

(注意求$\sum_{i = 0}^{n}i^k$需要调用line_lagrange(k+2,n) )
</code></pre><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">line_lagrange</span><span class="params">(ll n,ll k)</span></span>&#123;</span><br><span class="line">	ll tans = <span class="number">0</span>;</span><br><span class="line">	get_inv();</span><br><span class="line">	pre[<span class="number">0</span>] = suf[n+<span class="number">1</span>] = ifac[<span class="number">0</span>] =  <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		pre[i] = pre[i<span class="number">-1</span>]*(k-i)%mod;</span><br><span class="line">		ifac[i] = ifac[i<span class="number">-1</span>]*invs[i]%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n;i &gt;= <span class="number">0</span>;i--)suf[i] = suf[i+<span class="number">1</span>]*(k-i)%mod;</span><br><span class="line">	ll yi = <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		yi = (yi+pow_mod(i,n<span class="number">-2</span>))%mod;</span><br><span class="line">		ll a = pre[i<span class="number">-1</span>]*suf[i+<span class="number">1</span>]%mod*yi%mod*ifac[i<span class="number">-1</span>]%mod*ifac[n-i]%mod;</span><br><span class="line">		<span class="keyword">if</span>((n-i)%<span class="number">2</span>)a = mod-a; </span><br><span class="line">		tans = (tans+a+mod)%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="卢卡斯定理"><a href="#卢卡斯定理" class="headerlink" title="卢卡斯定理"></a>卢卡斯定理</h2><p>Lucas(n,m) = C(n%p,m%p)*Lucas(n/p,m/p)%p</p>
<p>p需为素数,fac[]为预处理的阶乘,时间复杂度大约是$O(p)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n,ll m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(m &gt; n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> (fac[n]*Pow(fac[m],p<span class="number">-2</span>)%p*Pow(fac[n-m],p<span class="number">-2</span>)%p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">Lucas</span><span class="params">(ll n,ll m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!m)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> C(n%p,m%p)*Lucas(n/p,m/p)%p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="线性基"><a href="#线性基" class="headerlink" title="线性基"></a>线性基</h2><p>maxbit取值域位数</p>
<p>insert返回0则说明现有基可以表示x</p>
<p>qmax返回异或最大值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinerBasis</span>&#123;</span></span><br><span class="line">	ll base[maxbit+<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">bool</span> vis[maxbit+<span class="number">4</span>];</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = maxbit;~i;i--)&#123;</span><br><span class="line">			<span class="keyword">if</span>(x&amp;(<span class="number">1L</span>L&lt;&lt;i))&#123;</span><br><span class="line">				<span class="keyword">if</span>(!base[i])&#123;</span><br><span class="line">					base[i] = x;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> x ^= base[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">qmax</span><span class="params">()</span></span>&#123;</span><br><span class="line">		ll ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = maxbit;~i;i--)ans = max(ans,ans^base[i]);</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;yay;</span><br></pre></td></tr></table></figure>
<h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><h2 id="杂乱的知识点"><a href="#杂乱的知识点" class="headerlink" title="杂乱的知识点"></a>杂乱的知识点</h2><ul>
<li>$\lfloor \frac{a}{bc} \rfloor = \lfloor \frac{\lfloor \frac{a}{b} \rfloor}{c} \rfloor$</li>
</ul>
<h2 id="图兰定理"><a href="#图兰定理" class="headerlink" title="图兰定理"></a>图兰定理</h2><p>对于一个有 $n$个点的无向图，若其中不存在三个点的环，则边数不超过 $n^2/4$</p>
<h2 id="Pick定理"><a href="#Pick定理" class="headerlink" title="Pick定理"></a>Pick定理</h2><p>给定一个顶点均为整点(坐标为整数的点)的简单多边形,其面积$A$和内部格点数$I$,边上格点数$B$的关系是: $A = I+B/2 - 1$</p>
<h2 id="Cayley公式"><a href="#Cayley公式" class="headerlink" title="Cayley公式"></a>Cayley公式</h2><p>一个有$n$个节点的完全图有$n^{n-2}$种不同的生成树</p>
<h2 id="Polya定理1"><a href="#Polya定理1" class="headerlink" title="Polya定理1"></a>Polya定理1</h2><pre><code>-仅旋转,染色数和顶点数均为n.欧拉函数优化(抄自Lskkkno1的题解qwq)
</code></pre><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">polya</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	ll tans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i*i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n%i)<span class="keyword">continue</span>;</span><br><span class="line">		tans += (cal_phi(n/i)*pow_mod(n,i<span class="number">-1</span>))%MOD;</span><br><span class="line">		<span class="keyword">if</span>(i*i != n)tans += cal_phi(i)*pow_mod(n,n/i<span class="number">-1</span>)%MOD;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tans%MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="LaTeX测试"><a href="#LaTeX测试" class="headerlink" title="$LaTeX测试$"></a>$LaTeX测试$</h1><script type="math/tex; mode=display">
\begin{aligned}
f_Y(y) & = f_X[h(y)]|h'(y)| \\[2ex]
& = f_X[h(y)]h'(y) \\[2ex]
& = \frac{1}{\theta}e^{-\frac{x}{\theta}}[\frac{dx}{dy}(-\frac{\theta}{ln(1-y)})] \\[2ex]
& = \frac{1}{\theta}e^{-\frac{-\frac{\theta}{ln(1-y)}}{\theta}}\frac{\theta}{1-y} \\[2ex]
& = \frac{1}{\theta}e^{ln(1-y)}\frac{\theta}{1-y} \\[2ex]
& = \frac{1-y}{\theta}\frac{\theta}{1-y} \\[2ex]
& = 1
\end{aligned}
\tag{1}</script>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>[模板]数据结构</title>
    <url>/2020/05/09/template-data-structure/</url>
    <content><![CDATA[<h1 id="RMQ问题"><a href="#RMQ问题" class="headerlink" title="RMQ问题"></a>RMQ问题</h1><h2 id="ST表"><a href="#ST表" class="headerlink" title="ST表"></a>ST表</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">STable</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> ST[<span class="number">50005</span>][<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">bool</span> ismax;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ST_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">memset</span>(ST,<span class="number">0</span>,<span class="keyword">sizeof</span>(ST));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)ST[i][<span class="number">0</span>] = inital[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j) &lt;= n;j++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i +(<span class="number">1</span>&lt;&lt;j) - <span class="number">1</span>&lt;= n;i++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(ismax)ST[i][j] = max(ST[i][j - <span class="number">1</span>],ST[i + (<span class="number">1</span>&lt;&lt;(j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">				<span class="keyword">else</span> ST[i][j] = min(ST[i][j - <span class="number">1</span>],ST[i + (<span class="number">1</span>&lt;&lt;(j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> k = log2(r-l+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(ismax)<span class="keyword">return</span> max(ST[l][k],ST[r - (<span class="number">1</span>&lt;&lt;k) + <span class="number">1</span>][k]);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> min(ST[l][k],ST[r - (<span class="number">1</span>&lt;&lt;k) + <span class="number">1</span>][k]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Fenwick树"><a href="#Fenwick树" class="headerlink" title="Fenwick树"></a>Fenwick树</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int BIT[5000005],n,m;</span><br><span class="line">inline int lowbit(int x)&#123;</span><br><span class="line">	return x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line">int sum(int index)&#123;</span><br><span class="line">	int tmp &#x3D; 0;</span><br><span class="line">	while(index &gt; 0)&#123;</span><br><span class="line">		tmp +&#x3D; BIT[index];</span><br><span class="line">		index -&#x3D; lowbit(index);</span><br><span class="line">	&#125;</span><br><span class="line">	return tmp;</span><br><span class="line">&#125;</span><br><span class="line">void add(int index,int x)&#123;</span><br><span class="line">	while(index &lt;&#x3D; n)&#123;</span><br><span class="line">		BIT[index] +&#x3D; x;</span><br><span class="line">		index +&#x3D; lowbit(index); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求k小值"><a href="#求k小值" class="headerlink" title="求k小值:"></a>求k小值:</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tans = <span class="number">0</span>,tcnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = log2(n);i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">		tans += (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">		<span class="keyword">if</span>(tans &gt;= n <span class="keyword">or</span> tcnt + BIT[tans] &gt;= k)tans -= (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">		<span class="keyword">else</span> tcnt += BIT[tans];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tans+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>区间修改单点查询见<a href="https://www.luogu.org/problemnew/show/P3368" target="_blank" rel="noopener">P3368</a>(懒到爆炸</p>
<h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><p><strong>需要重构</strong></p>
<p>而且这玩意你扔一堆板子在这也没用啊kora</p>
<h2 id="单点修改-区间查询"><a href="#单点修改-区间查询" class="headerlink" title="单点修改,区间查询"></a>单点修改,区间查询</h2><p>记得初始化N<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//segTree-µ¥µãÐÞ¸Ä Çø¼ä²éÑ¯</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segTree</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x&lt;&lt;<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> minv[maxn*<span class="number">2</span>],maxv[maxn*<span class="number">2</span>],ql,qr,p,v,N;</span><br><span class="line">	<span class="keyword">int</span> _query_min(<span class="keyword">int</span> o,<span class="keyword">int</span> L,<span class="keyword">int</span> R)&#123;</span><br><span class="line">		<span class="keyword">int</span> M = L + (R - L)/<span class="number">2</span>,ans = INF;</span><br><span class="line">		<span class="keyword">if</span>(ql &lt;= L <span class="keyword">and</span> R &lt;= qr)<span class="keyword">return</span> minv[o];</span><br><span class="line">		<span class="keyword">if</span>(ql &lt;= M)ans = min(ans,_query_min(ls(o),L,M));</span><br><span class="line">		<span class="keyword">if</span>(M &lt; qr)ans = min(ans,_query_min(rs(o),M+<span class="number">1</span>,R));</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">query_min</span><span class="params">(<span class="keyword">int</span> q_l,<span class="keyword">int</span> q_r)</span></span>&#123;</span><br><span class="line">		ql = q_l,qr = q_r;</span><br><span class="line">		<span class="keyword">return</span> _query_min(<span class="number">1</span>,<span class="number">1</span>,N);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">void</span> _update_min(<span class="keyword">int</span> o,<span class="keyword">int</span> L,<span class="keyword">int</span> R)&#123;</span><br><span class="line">		<span class="keyword">if</span>(L &gt; R)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">int</span> M = L + (R - L)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(L == R)minv[o] = v;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(p &lt;= M)_update_min(ls(o),L,M);</span><br><span class="line">			<span class="keyword">else</span> _update_min(rs(o),M+<span class="number">1</span>,R);</span><br><span class="line">			minv[o] = min(minv[ls(o)],minv[rs(o)]);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		cout &lt;&lt; o &lt;&lt; "CNT" &lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//		cout &lt;&lt; "idx:" &lt;&lt; p &lt;&lt;" value:" &lt;&lt; v &lt;&lt; endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> _query_max(<span class="keyword">int</span> o,<span class="keyword">int</span> L,<span class="keyword">int</span> R)&#123;</span><br><span class="line">		<span class="keyword">int</span> M = L + (R - L)/<span class="number">2</span>,ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(ql &lt;= L <span class="keyword">and</span> R &lt;= qr)<span class="keyword">return</span> maxv[o];</span><br><span class="line">		<span class="keyword">if</span>(ql &lt;= M)ans = max(ans,_query_max(ls(o),L,M));</span><br><span class="line">		<span class="keyword">if</span>(M &lt; qr)ans = max(ans,_query_max(rs(o),M+<span class="number">1</span>,R));</span><br><span class="line"><span class="comment">//		cout &lt;&lt; "ql:" &lt;&lt; ql &lt;&lt; " qr:" &lt;&lt; qr &lt;&lt; endl;</span></span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">query_max</span><span class="params">(<span class="keyword">int</span> q_l,<span class="keyword">int</span> q_r)</span></span>&#123;</span><br><span class="line">		ql = q_l,qr = q_r;</span><br><span class="line"><span class="comment">//		cout &lt;&lt; q_l &lt;&lt; " " &lt;&lt; q_r &lt;&lt;"WTF" &lt;&lt;endl;</span></span><br><span class="line">		<span class="keyword">return</span> _query_max(<span class="number">1</span>,<span class="number">1</span>,N);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">void</span> _update_max(<span class="keyword">int</span> o,<span class="keyword">int</span> L,<span class="keyword">int</span> R)&#123;</span><br><span class="line">		<span class="keyword">if</span>(L &gt; R)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">int</span> M = L + (R - L)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(L == R)maxv[o] = v;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(p &lt;= M)_update_max(ls(o),L,M);</span><br><span class="line">			<span class="keyword">else</span> _update_max(rs(o),M+<span class="number">1</span>,R);</span><br><span class="line">			maxv[o] = max(maxv[ls(o)],maxv[rs(o)]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;p = idx,<span class="keyword">this</span>-&gt;v = value;</span><br><span class="line">		_update_min(<span class="number">1</span>,<span class="number">1</span>,N);</span><br><span class="line">		_update_max(<span class="number">1</span>,<span class="number">1</span>,N);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">segTree tree;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">readint</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;tmp);</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="区间加"><a href="#区间加" class="headerlink" title="区间加"></a>区间加</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segTree</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&lt;&lt;<span class="number">1</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;&#125;</span><br><span class="line">	ll addv[maxn],minv[maxn],maxv[maxn],sumv[maxn];</span><br><span class="line">	ll ql,qr,p,v,N,_min,_max,_sum;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(R &lt; L)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">int</span> lc = ls(o),rc = rs(o);</span><br><span class="line">		sumv[o] = minv[o] = maxv[o] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(R &gt; L)&#123;</span><br><span class="line">			minv[o] = min(minv[lc],minv[rc]);</span><br><span class="line">			maxv[o] = max(maxv[lc],maxv[rc]);</span><br><span class="line">			sumv[o] = sumv[lc] + sumv[rc];</span><br><span class="line">		&#125;</span><br><span class="line">		sumv[o] += addv[o]*(R-L+<span class="number">1</span>);</span><br><span class="line">		minv[o] += addv[o];</span><br><span class="line">		maxv[o] += addv[o];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">void</span> _update(<span class="keyword">int</span> o,<span class="keyword">int</span> L,<span class="keyword">int</span> R)&#123;</span><br><span class="line">		<span class="keyword">if</span>(ql &lt;= L <span class="keyword">and</span> qr &gt;= R)addv[o] += v;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">int</span> M = L + (R - L)/<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>(ql &lt;= M)_update(ls(o),L,M);</span><br><span class="line">			<span class="keyword">if</span>(M &lt; qr)_update(rs(o),M+<span class="number">1</span>,R);</span><br><span class="line">		&#125;</span><br><span class="line">		maintain(o,L,R);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> idxL,<span class="keyword">int</span> idxR,ll value)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;ql = idxL;<span class="keyword">this</span>-&gt;qr = idxR;<span class="keyword">this</span>-&gt;v = value;</span><br><span class="line">		_update(<span class="number">1</span>,<span class="number">1</span>,N);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">void</span> _query(<span class="keyword">int</span> o,<span class="keyword">int</span> L,<span class="keyword">int</span> R,ll adds)&#123;</span><br><span class="line">		<span class="keyword">if</span>(ql &lt;= L <span class="keyword">and</span> qr &gt;= R)&#123;</span><br><span class="line">			_sum += sumv[o]+adds*(R-L+<span class="number">1</span>);</span><br><span class="line">			_min = min(_min,minv[o] + adds);</span><br><span class="line">			_max = max(_max,maxv[o] + adds); </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">int</span> M = L + (R - L)/<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>(ql &lt;= M)_query(ls(o),L,M,adds+addv[o]);</span><br><span class="line">			<span class="keyword">if</span>(M &lt; qr)_query(rs(o),M+<span class="number">1</span>,R,adds+addv[o]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> q_l,<span class="keyword">int</span> q_r)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;ql = q_l;<span class="keyword">this</span>-&gt;qr = q_r;</span><br><span class="line">		_sum = _max = <span class="number">0</span>;_min = INF;</span><br><span class="line">		_query(<span class="number">1</span>,<span class="number">1</span>,N,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="区间加-区间赋值-区间查询"><a href="#区间加-区间赋值-区间查询" class="headerlink" title="区间加 区间赋值 区间查询"></a>区间加 区间赋值 区间查询</h2><p>切记初始化里的<strong>isset[1] = 1;</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segTree</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&lt;&lt;<span class="number">1</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;&#125;</span><br><span class="line">	<span class="keyword">int</span> p,v,N,ql,qr,tag,_min,_max,_sum;</span><br><span class="line">	<span class="keyword">int</span> sumv[maxn],minv[maxn],maxv[maxn],addv[maxn],setv[maxn];</span><br><span class="line">	<span class="keyword">bool</span> isset[maxn];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">initer</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">memset</span>(sumv,<span class="number">0</span>,<span class="keyword">sizeof</span>(sumv));</span><br><span class="line">		<span class="built_in">memset</span>(minv,<span class="number">0</span>,<span class="keyword">sizeof</span>(minv));</span><br><span class="line">		<span class="built_in">memset</span>(maxv,<span class="number">0</span>,<span class="keyword">sizeof</span>(maxv));</span><br><span class="line">		<span class="built_in">memset</span>(addv,<span class="number">0</span>,<span class="keyword">sizeof</span>(addv));</span><br><span class="line">		<span class="built_in">memset</span>(setv,<span class="number">0</span>,<span class="keyword">sizeof</span>(setv));</span><br><span class="line">		<span class="built_in">memset</span>(isset,<span class="number">0</span>,<span class="keyword">sizeof</span>(isset));</span><br><span class="line">		isset[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(L &gt; R)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">int</span> lc = ls(o),rc = rs(o);</span><br><span class="line">		<span class="keyword">if</span>(R &gt; L)&#123;</span><br><span class="line">			sumv[o] = sumv[lc] + sumv[rc];</span><br><span class="line">			minv[o] = min(minv[lc],minv[rc]);</span><br><span class="line">			maxv[o] = max(maxv[lc],maxv[rc]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(isset[o])&#123;</span><br><span class="line">			minv[o] = maxv[o] = setv[o];</span><br><span class="line">			sumv[o] = setv[o]*(R-L+<span class="number">1</span>);</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">if</span>(addv[o])&#123;</span><br><span class="line">			minv[o] += addv[o];</span><br><span class="line">			maxv[o] += addv[o];</span><br><span class="line">			sumv[o] += addv[o]*(R-L+<span class="number">1</span>); </span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> o)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> lc = ls(o),rc = rs(o);</span><br><span class="line">		<span class="keyword">if</span>(isset[o])&#123;</span><br><span class="line">			setv[lc] = setv[rc] = setv[o];</span><br><span class="line">			addv[lc] = addv[rc] = <span class="number">0</span>;</span><br><span class="line">			isset[lc] = isset[rc] = <span class="number">1</span>;</span><br><span class="line">			isset[o] = setv[o] = <span class="number">0</span>; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(addv[o])&#123;</span><br><span class="line">			addv[lc] += addv[o];</span><br><span class="line">			addv[rc] += addv[o];</span><br><span class="line">			addv[o] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">void</span> _update(<span class="keyword">int</span> o,<span class="keyword">int</span> L,<span class="keyword">int</span> R)&#123;</span><br><span class="line">		<span class="comment">//tag-0-set;tag-1-add</span></span><br><span class="line">		<span class="keyword">if</span>(ql &lt;= L <span class="keyword">and</span> qr &gt;= R)&#123;</span><br><span class="line">			<span class="keyword">if</span>(tag == <span class="number">0</span>)&#123;</span><br><span class="line">				setv[o] = v;</span><br><span class="line">				isset[o] = <span class="number">1</span>;</span><br><span class="line">				addv[o] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> addv[o] += v;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			pushdown(o);</span><br><span class="line">			<span class="keyword">int</span> M = L + (R - L)/<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>(ql &lt;= M)_update(ls(o),L,M);<span class="keyword">else</span> maintain(ls(o),L,M);</span><br><span class="line">			<span class="keyword">if</span>(M &lt; qr)_update(rs(o),M+<span class="number">1</span>,R);<span class="keyword">else</span> maintain(rs(o),M+<span class="number">1</span>,R);</span><br><span class="line">		&#125;</span><br><span class="line">		maintain(o,L,R);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> q_l,<span class="keyword">int</span> q_r,<span class="keyword">int</span> v,<span class="keyword">int</span> op)</span></span>&#123;</span><br><span class="line">		<span class="comment">//tag-0-set;tag-1-add</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;ql = q_l,<span class="keyword">this</span>-&gt;qr = q_r,<span class="keyword">this</span>-&gt;v = v,<span class="keyword">this</span>-&gt;tag = op;</span><br><span class="line">		_update(<span class="number">1</span>,<span class="number">1</span>,N);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">void</span> _query(<span class="keyword">int</span> o,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> adds)&#123;</span><br><span class="line">		<span class="keyword">if</span>(isset[o])&#123;</span><br><span class="line">			<span class="keyword">int</span> tmpv = setv[o] + adds + addv[o];</span><br><span class="line">			_sum += tmpv*(min(R,qr) - max(L,ql) + <span class="number">1</span>);</span><br><span class="line">			_min = min(_min,tmpv);</span><br><span class="line">			_max = max(_max,tmpv);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ql &lt;= L <span class="keyword">and</span> qr &gt;= R)&#123;</span><br><span class="line">			_sum += sumv[o]+adds*(R-L+<span class="number">1</span>);</span><br><span class="line">			_min = min(_min,minv[o]+adds);</span><br><span class="line">			_max = max(_max,maxv[o]+adds);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">int</span> M = L + (R - L)/<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>(ql &lt;= M)_query(ls(o),L,M,adds+addv[o]);</span><br><span class="line">			<span class="keyword">if</span>(M &lt; qr)_query(rs(o),M+<span class="number">1</span>,R,adds+addv[o]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> q_l,<span class="keyword">int</span> q_r)</span></span>&#123;</span><br><span class="line">		ql = q_l,qr = q_r,_min = INF,_max = -INF,_sum = <span class="number">0</span>;</span><br><span class="line">		_query(<span class="number">1</span>,<span class="number">1</span>,N,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="区间取反"><a href="#区间取反" class="headerlink" title="区间取反"></a>区间取反</h2><p>注意取反与加的微妙的不同——取反无论是0变为1还是1变为0都要修改值,故这里的maintain函数不再负责处理inv标记</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SegTraining K - Light Switching </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segTree</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&lt;&lt;<span class="number">1</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;&#125;</span><br><span class="line">	<span class="keyword">int</span> p,v,N,ql,qr,tag,_min,_max,_sum;</span><br><span class="line">	<span class="keyword">int</span> sumv[maxn],inv[maxn];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">initer</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">memset</span>(sumv,<span class="number">0</span>,<span class="keyword">sizeof</span>(sumv));</span><br><span class="line">		<span class="built_in">memset</span>(inv,<span class="number">0</span>,<span class="keyword">sizeof</span>(inv));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(R &gt; L)sumv[o] = sumv[ls(o)]+sumv[rs(o)];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> lc = ls(o),rc = rs(o);</span><br><span class="line">		<span class="keyword">int</span> M = L + (R - L)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(inv[o])&#123;</span><br><span class="line">			inv[lc] ^= <span class="number">1</span>;</span><br><span class="line">			inv[rc] ^= <span class="number">1</span>;</span><br><span class="line">			sumv[lc] = M - L + <span class="number">1</span> - sumv[lc];</span><br><span class="line">			sumv[rc] = R - M - sumv[rc]; </span><br><span class="line">			inv[o] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">void</span> _update(<span class="keyword">int</span> o,<span class="keyword">int</span> L,<span class="keyword">int</span> R)&#123;</span><br><span class="line">		<span class="comment">//tag-0-set;tag-1-add</span></span><br><span class="line">		<span class="keyword">if</span>(ql &lt;= L <span class="keyword">and</span> qr &gt;= R)&#123;</span><br><span class="line">			inv[o] ^= <span class="number">1</span>;</span><br><span class="line">			sumv[o] = R - L + <span class="number">1</span> - sumv[o];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			pushdown(o,L,R);</span><br><span class="line">			<span class="keyword">int</span> M = L + (R - L)/<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>(ql &lt;= M)_update(ls(o),L,M);</span><br><span class="line">			<span class="keyword">if</span>(M &lt; qr)_update(rs(o),M+<span class="number">1</span>,R);</span><br><span class="line">			maintain(o,L,R);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> q_l,<span class="keyword">int</span> q_r)</span></span>&#123;</span><br><span class="line">		<span class="comment">//tag-0-set;tag-1-add</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;ql = q_l,<span class="keyword">this</span>-&gt;qr = q_r;</span><br><span class="line">		_update(<span class="number">1</span>,<span class="number">1</span>,N);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">void</span> _query(<span class="keyword">int</span> o,<span class="keyword">int</span> L,<span class="keyword">int</span> R)&#123;</span><br><span class="line"><span class="comment">//		pushdown(o,L,R);</span></span><br><span class="line">		<span class="keyword">if</span>(ql &lt;= L <span class="keyword">and</span> qr &gt;= R)&#123;</span><br><span class="line">			_sum += sumv[o];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			pushdown(o,L,R);</span><br><span class="line">			<span class="keyword">int</span> M = L + (R - L)/<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>(ql &lt;= M)_query(ls(o),L,M);</span><br><span class="line">			<span class="keyword">if</span>(M &lt; qr)_query(rs(o),M+<span class="number">1</span>,R);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> q_l,<span class="keyword">int</span> q_r)</span></span>&#123;</span><br><span class="line">		ql = q_l,qr = q_r,_min = INF,_max = -INF,_sum = <span class="number">0</span>;</span><br><span class="line">		_query(<span class="number">1</span>,<span class="number">1</span>,N);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">segTree tree;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("P2846.txt","w",stdout);</span></span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">	tree.N = n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> opt,L,R;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;opt,&amp;L,&amp;R);</span><br><span class="line">		<span class="keyword">if</span>(opt == <span class="number">0</span>)tree.update(L,R);</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			tree.query(L,R);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,tree._sum);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查询区间第一个大于x的值的下标"><a href="#查询区间第一个大于x的值的下标" class="headerlink" title="查询区间第一个大于x的值的下标"></a>查询区间第一个大于x的值的下标</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> d)</span></span>&#123;<span class="comment">//调用时now为根节点,i,j为查询区间左右端点,d为需查询的值</span></span><br><span class="line">   	 	<span class="keyword">if</span>(L==R)&#123;</span><br><span class="line">        	<span class="keyword">if</span>(maxv[now]&gt;=d)<span class="keyword">return</span> L;<span class="comment">//小于则改为minv[now] &lt;= d</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   		 &#125;</span><br><span class="line">   		<span class="keyword">if</span>(i&lt;=L &amp;&amp; R&lt;=j)<span class="keyword">if</span>(maxv[now] &lt; d) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//小于则改为minv[now] &gt; d	</span></span><br><span class="line">    	<span class="keyword">int</span> m=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">if</span>(j&lt;=m)<span class="keyword">return</span> query(ls(now),L,m,i,j,d);</span><br><span class="line">    	<span class="keyword">if</span>(i&gt;=m+<span class="number">1</span>)<span class="keyword">return</span> query(rs(now),m+<span class="number">1</span>,R,i,j,d); </span><br><span class="line">    	<span class="keyword">int</span> t1=query(ls(now),L,m,i,j,d); </span><br><span class="line">    	<span class="keyword">if</span>(t1!=<span class="number">-1</span>)<span class="keyword">return</span> t1;</span><br><span class="line">    	<span class="keyword">return</span> query(rs(now),m+<span class="number">1</span>,R,i,j,d);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h1><h2 id="Treap"><a href="#Treap" class="headerlink" title="Treap"></a>Treap</h2><hr>
<p>平衡树1-Treap</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> cnt,size,v,r;</span><br><span class="line">	Node * ch[<span class="number">2</span>];</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(x == v)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">return</span> x&lt;v?<span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Node()&#123;<span class="comment">//null,plz use newnode(x);</span></span><br><span class="line">		ch[<span class="number">0</span>] = ch[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">		cnt = size = v = r = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">()</span></span>&#123;</span><br><span class="line">		size = ch[<span class="number">0</span>]-&gt;size +ch[<span class="number">1</span>]-&gt;size + cnt;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;;</span><br><span class="line">Node * null = <span class="keyword">new</span> Node();</span><br><span class="line"><span class="function">Node * <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	Node * tmp = <span class="keyword">new</span> Node();</span><br><span class="line">	tmp-&gt;ch[<span class="number">0</span>] = tmp-&gt;ch[<span class="number">1</span>] = null;</span><br><span class="line">	tmp-&gt;v = x;</span><br><span class="line">	tmp-&gt;r = rand();</span><br><span class="line">	tmp-&gt;size = tmp-&gt;cnt = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node * <span class="title">find</span><span class="params">(Node * o,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(o != null)&#123;</span><br><span class="line">		<span class="keyword">int</span> d = o-&gt;cmp(x);</span><br><span class="line">		<span class="keyword">if</span>(d == <span class="number">-1</span>)<span class="keyword">return</span> o;</span><br><span class="line">		<span class="keyword">else</span> o = o-&gt;ch[d];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> null;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(Node *&amp; o,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">	Node * k = o-&gt;ch[d^<span class="number">1</span>];</span><br><span class="line">	o-&gt;ch[d^<span class="number">1</span>] = k-&gt;ch[d];</span><br><span class="line">	k-&gt;ch[d] = o;</span><br><span class="line">	o-&gt;maintain();k-&gt;maintain();</span><br><span class="line">	o = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node *&amp; o,<span class="keyword">int</span> x,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(o == null)o = newnode(x);</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> d = o-&gt;cmp(x);</span><br><span class="line">		<span class="keyword">if</span>(d == <span class="number">-1</span>)o-&gt;cnt+=c;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			insert(o-&gt;ch[d],x,c);</span><br><span class="line">			<span class="keyword">if</span>(o-&gt;ch[d]-&gt;r &gt; o-&gt;r)rotate(o,d^<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	o-&gt;maintain();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node *&amp; o,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(find(o,x) == null)<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> d = o-&gt;cmp(x);</span><br><span class="line">	<span class="keyword">if</span>(d == <span class="number">-1</span>)&#123;</span><br><span class="line">		Node * u = o;</span><br><span class="line">		<span class="keyword">if</span>(o-&gt;cnt &gt; <span class="number">1</span>)&#123;</span><br><span class="line">			o-&gt;cnt--;</span><br><span class="line">			o-&gt;size--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(o-&gt;ch[<span class="number">0</span>] != null <span class="keyword">and</span> o-&gt;ch[<span class="number">1</span>] != null)&#123;</span><br><span class="line">			<span class="keyword">int</span> d2 = o-&gt;ch[<span class="number">0</span>]-&gt;r &gt; o-&gt;ch[<span class="number">1</span>]-&gt;r ?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">			rotate(o,d2);</span><br><span class="line">			remove(o-&gt;ch[d2],x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(o-&gt;ch[<span class="number">0</span>] == null)o = o-&gt;ch[<span class="number">1</span>];<span class="keyword">else</span> o = o-&gt;ch[<span class="number">0</span>];</span><br><span class="line">			<span class="keyword">delete</span> u;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> remove(o-&gt;ch[d],x);</span><br><span class="line">	<span class="keyword">if</span>(o != null)o-&gt;maintain();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(Node * o,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="comment">//min</span></span><br><span class="line">	<span class="keyword">int</span> k1 = k;</span><br><span class="line">	<span class="keyword">while</span>(o != null)&#123;</span><br><span class="line">		<span class="keyword">int</span> s = o-&gt;ch[<span class="number">0</span>]-&gt;size;</span><br><span class="line">		<span class="keyword">if</span>(k1 &gt; s <span class="keyword">and</span> k1 &lt;= s + o-&gt;cnt)<span class="keyword">return</span> o-&gt;v;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(k1 &lt;= s) o = o-&gt;ch[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			k1 = k1 - s - o-&gt;cnt;</span><br><span class="line">			o = o-&gt;ch[<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Rank</span><span class="params">(Node * o,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans_ = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(find(o,x) == null)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(o != null)&#123;</span><br><span class="line">		<span class="keyword">if</span>(o-&gt;v == x)&#123;</span><br><span class="line">			ans_ += <span class="number">1</span> + o-&gt;ch[<span class="number">0</span>]-&gt;size;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(o-&gt;v &gt; x)o = o-&gt;ch[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			ans_ += o-&gt;ch[<span class="number">0</span>]-&gt;size + o-&gt;cnt;</span><br><span class="line">			o = o-&gt;ch[<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(Node * o,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans_ = -INF;</span><br><span class="line">	<span class="keyword">while</span>(o != null)&#123;</span><br><span class="line">		<span class="keyword">if</span>(ans_ &lt;= o-&gt;v <span class="keyword">and</span> o-&gt;v &lt; x)&#123;</span><br><span class="line">			ans_ = o-&gt;v;</span><br><span class="line">			o = o-&gt;ch[<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> o = o-&gt;ch[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">upper_bound</span><span class="params">(Node * o,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans_ = INF;</span><br><span class="line">	<span class="keyword">while</span>(o != null)&#123;</span><br><span class="line">		<span class="keyword">if</span>(x &lt; o-&gt;v <span class="keyword">and</span> o-&gt;v &lt; ans_)&#123;</span><br><span class="line">			ans_ = o-&gt;v;</span><br><span class="line">			o = o-&gt;ch[<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> o = o-&gt;ch[<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deltree</span><span class="params">(Node *&amp; o)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(o-&gt;ch[<span class="number">0</span>] != null)deltree(o-&gt;ch[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">if</span>(o-&gt;ch[<span class="number">1</span>] != null)deltree(o-&gt;ch[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">delete</span> o;</span><br><span class="line">	o = null;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(Node *&amp; src,Node *&amp; dest)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(src-&gt;ch[<span class="number">0</span>] != null)merge(src-&gt;ch[<span class="number">0</span>],dest);</span><br><span class="line">	<span class="keyword">if</span>(src-&gt;ch[<span class="number">1</span>] != null)merge(src-&gt;ch[<span class="number">1</span>],dest);</span><br><span class="line">	insert(dest,src-&gt;v,src-&gt;cnt);</span><br><span class="line">	<span class="keyword">delete</span> src;</span><br><span class="line">	src = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p>$Next[i]$表示自$i$结束(不包括$i$)的子串中前后缀相同的长度</p>
<p>例如：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">i</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
<th style="text-align:center">10</th>
<th style="text-align:center">11</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$s[i]$</td>
<td style="text-align:center">A</td>
<td style="text-align:center">B</td>
<td style="text-align:center">R</td>
<td style="text-align:center">A</td>
<td style="text-align:center">C</td>
<td style="text-align:center">A</td>
<td style="text-align:center">D</td>
<td style="text-align:center">A</td>
<td style="text-align:center">B</td>
<td style="text-align:center">R</td>
<td style="text-align:center">A</td>
<td style="text-align:center">\</td>
</tr>
<tr>
<td style="text-align:center">$Next[i]$</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
</tr>
</tbody>
</table>
</div>
<p>可以看出$[i - Next[i],i - 1]$这一段的前后缀是相同的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> Next[<span class="number">1000010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFail</span><span class="params">(<span class="built_in">string</span> P)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p_size = P.size();</span><br><span class="line">	Next[<span class="number">0</span>] = Next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; p_size;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> j = Next[i];</span><br><span class="line">		<span class="keyword">while</span>(j <span class="keyword">and</span> P[i] != P[j])j = Next[j];</span><br><span class="line">		Next[i+<span class="number">1</span>] = (P[j] == P[i]?j+<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KMP</span><span class="params">(<span class="built_in">string</span> T,<span class="built_in">string</span> P)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t_size = T.size(),p_size = P.size();</span><br><span class="line">	getFail(P);</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; t_size;i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(j <span class="keyword">and</span> P[j] != T[i])j = Next[j];</span><br><span class="line">		<span class="keyword">if</span>(P[j] == T[i])j++;</span><br><span class="line">		<span class="keyword">if</span>(j == p_size)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i - p_size + <span class="number">2</span>);</span><br><span class="line">			j = Next[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Manacher"><a href="#Manacher" class="headerlink" title="Manacher"></a>Manacher</h2><p>最长连续回文子串</p>
<p>$len[i] - 1$表示以i为中心的最长回文串一半的长度(不包括中心)</p>
<p>返回最长连续回文子串的长度</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Manacher</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> len[maxn];</span><br><span class="line">	<span class="built_in">string</span> raw = <span class="string">"~"</span>;</span><br><span class="line">	<span class="keyword">int</span> ic = <span class="number">0</span>,im = <span class="number">0</span>,ir = <span class="number">0</span>,ans = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="built_in">string</span> s = <span class="string">""</span>)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.size();i++)&#123;</span><br><span class="line">			raw += <span class="string">'|'</span>;</span><br><span class="line">			raw += s[i];</span><br><span class="line">		&#125;</span><br><span class="line">		raw += <span class="string">"|!"</span>;</span><br><span class="line"><span class="comment">//		cout &lt;&lt; raw &lt;&lt; endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> l = raw.size();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; l;i++)&#123;</span><br><span class="line">			len[i] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(i &lt; ir)&#123;</span><br><span class="line">				im = <span class="number">2</span>*ic-i;</span><br><span class="line">				len[i] = min(ir-i,len[im]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span>(raw[i-len[i]] == raw[i+len[i]])len[i]++;</span><br><span class="line">			<span class="keyword">if</span>(i + len[i] &gt; ir)ic = i,ir = i + len[i];</span><br><span class="line">			<span class="keyword">if</span>(len[i] &gt; len[ic])ic = i;</span><br><span class="line">			ans = max(len[i],ans);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">char</span> x:raw)<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		<span class="keyword">return</span> ans<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;yay;</span><br></pre></td></tr></table></figure>
<h2 id="字符串hash"><a href="#字符串hash" class="headerlink" title="字符串hash"></a>字符串hash</h2><p>​    $H[x]$为hash值,$xp[d]$为$x^d$,$x$为模数(随便取一个就行),$s$为字符串.</p>
<p>​    递推式:$H[i] = H[i-i] \cdot x + (s[i] - ‘a’)$</p>
<p>​    查询以$i$开始长度为$L$的字符串的hash:$Hash(i,L) = H[i - L + 1] - H[i-1] \cdot xp[L] $</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ull xp[maxn],H[maxn];</span><br><span class="line"><span class="comment">//预处理x的幂</span></span><br><span class="line">xp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; maxn;i++)xp[i] = xp[i<span class="number">-1</span>]*x; </span><br><span class="line"><span class="comment">//预处理hash</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)H[i] = H[i<span class="number">-1</span>]*x + s[i<span class="number">-1</span>] - <span class="string">'a'</span>;</span><br><span class="line"><span class="comment">//Hash(i,L)</span></span><br><span class="line"><span class="function">ull <span class="title">Hash</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> L)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> H[x+L<span class="number">-1</span>] - H[x<span class="number">-1</span>]*xp[L];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>路径压缩,无按秩合并</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int father[maxn];</span><br><span class="line">void init()&#123;</span><br><span class="line">	for(int i &#x3D; 1;i &lt;&#x3D; n;i++)father[i] &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line">int findset(int e)&#123;</span><br><span class="line">	return fahter[e] &#x3D;&#x3D; e?e:father[e] &#x3D; findset(father[e]);</span><br><span class="line">&#125;</span><br><span class="line">inline void un(int x,int y)&#123;</span><br><span class="line">	father[findset(x)] &#x3D; findset(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>[模板]图论</title>
    <url>/2020/05/09/template-graph-theory/</url>
    <content><![CDATA[<h1 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h1><h2 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)dis[i] = INF;</span><br><span class="line">    q.push(s);</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        vis[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];i;i = edge[i].next)&#123;</span><br><span class="line">        	<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dis[v] &gt; dis[u] + edge[i].w)&#123;</span><br><span class="line">                dis[v] = dis[u] + edge[i].w;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">                    vis[v] = <span class="number">1</span>;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> pair &lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; node;</span><br><span class="line">	priority_queue&lt;node,<span class="built_in">vector</span>&lt;node&gt;,greater&lt;node&gt; &gt;q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;=n;i++)dis[i] = INF;</span><br><span class="line">	dis[s] = <span class="number">0</span>;</span><br><span class="line">	q.push(make_pair(dis[s],s));</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		node tmp = q.top();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">int</span> u = tmp.second;</span><br><span class="line">		<span class="keyword">if</span>(vis[u])<span class="keyword">continue</span>;<span class="comment">//</span></span><br><span class="line">		vis[u] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">			<span class="keyword">if</span>(dis[v] &gt; dis[u] + edge[i].w)&#123;</span><br><span class="line">				dis[v] = dis[u] + edge[i].w;</span><br><span class="line">				<span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">					<span class="comment">//</span></span><br><span class="line">					q.push(make_pair(dis[v],v));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h1><h2 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h2><h3 id="Edmonds-Karp"><a href="#Edmonds-Karp" class="headerlink" title="Edmonds-Karp"></a>Edmonds-Karp</h3><p>(慎用)<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn],parent[maxn],approve[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> from,to,next,w,cap,flow;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="keyword">int</span> n,m,start,to,cnt,ans;<span class="comment">//cnt = 0 so we can calculate "backedge" easily</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">int</span> cap,<span class="keyword">int</span> flow)</span></span>&#123;</span><br><span class="line">	edge[cnt].cap = cap;</span><br><span class="line">	edge[cnt].flow = flow;</span><br><span class="line">	edge[cnt].to = to;</span><br><span class="line">	edge[cnt].from = from;</span><br><span class="line">	edge[cnt].next = head[from];</span><br><span class="line">	head[from] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">	<span class="built_in">memset</span>(approve,<span class="number">0</span>,<span class="keyword">sizeof</span>(approve)); </span><br><span class="line">	q.push(s);</span><br><span class="line">	approve[s] = INF;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		<span class="keyword">int</span> u = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">			<span class="keyword">if</span>(!approve[v] <span class="keyword">and</span> edge[i].cap &gt; edge[i].flow)&#123;</span><br><span class="line">				parent[v] = i;</span><br><span class="line">				approve[v] = min(approve[u],edge[i].cap - edge[i].flow);</span><br><span class="line">				q.push(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(approve[t])<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> approve[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EK</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">int</span> delta = BFS(s,t);</span><br><span class="line">		<span class="keyword">if</span>(!delta)<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> u = t;u != s;u = edge[parent[u]].from)&#123;</span><br><span class="line">			<span class="keyword">int</span> curp = parent[u];</span><br><span class="line">			edge[curp].flow += delta;</span><br><span class="line">			edge[curp^<span class="number">1</span>].flow -= delta;</span><br><span class="line">		&#125;</span><br><span class="line">		flow += delta;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Dinic"><a href="#Dinic" class="headerlink" title="Dinic"></a>Dinic</h3><p>记得加上流量为0的反向弧=-=<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> from,to,next,w,cap,flow;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="keyword">int</span> head[maxn],deep[maxn],vis[maxn],cur[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m,start,to,cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">int</span> cap,<span class="keyword">int</span> flow)</span></span>&#123;</span><br><span class="line">	edge[cnt].from = from;</span><br><span class="line">	edge[cnt].to = to;</span><br><span class="line">	edge[cnt].cap = cap;</span><br><span class="line">	edge[cnt].flow = flow;</span><br><span class="line">	edge[cnt].next = head[from];</span><br><span class="line">	head[from] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)cur[i] = head[i];</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">	q.push(s);</span><br><span class="line">	vis[s] = <span class="number">1</span>;</span><br><span class="line">	deep[s] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		<span class="keyword">int</span> u = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">			<span class="keyword">if</span>(!vis[v] <span class="keyword">and</span> edge[i].cap &gt; edge[i].flow)&#123;</span><br><span class="line">				vis[v] = <span class="number">1</span>;</span><br><span class="line">				deep[v] = deep[u] + <span class="number">1</span>;</span><br><span class="line">				q.push(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> t,<span class="keyword">int</span> approve)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(u == t <span class="keyword">or</span> approve == <span class="number">0</span>)<span class="keyword">return</span> approve;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>,delta = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = cur[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		cur[u] = i;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(deep[u] + <span class="number">1</span> == deep[v] <span class="keyword">and</span> (delta = DFS(v,t,min(approve,edge[i].cap - edge[i].flow))) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			edge[i].flow += delta;</span><br><span class="line">			edge[i^<span class="number">1</span>].flow -= delta;</span><br><span class="line">			flow += delta;approve -= delta;</span><br><span class="line">			<span class="keyword">if</span>(!approve)<span class="keyword">break</span>; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(BFS(s,t))&#123;</span><br><span class="line">		flow += DFS(s,t,INF);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="最小费用最大流"><a href="#最小费用最大流" class="headerlink" title="最小费用最大流"></a>最小费用最大流</h2><p>全局变量flow为最大流,cost为最小费用</p>
<p>记得反向边容量为0费用为负=-=<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn],parent[maxn],approve[maxn],dis[maxn],vis[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> from,to,next,w,cap,flow,cost;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="keyword">int</span> n,m,start,to,cnt,ans,flow,cost;<span class="comment">//cnt = 0 so we can calculate "backedge" easily</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">int</span> cap,<span class="keyword">int</span> flow,<span class="keyword">int</span> cost)</span></span>&#123;</span><br><span class="line">	edge[cnt].cap = cap;</span><br><span class="line">	edge[cnt].cost = cost;</span><br><span class="line">	edge[cnt].flow = flow;</span><br><span class="line">	edge[cnt].to = to;</span><br><span class="line">	edge[cnt].from = from;</span><br><span class="line">	edge[cnt].next = head[from];</span><br><span class="line">	head[from] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)dis[i] = INF;</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">	<span class="built_in">memset</span>(approve,<span class="number">0</span>,<span class="keyword">sizeof</span>(approve)); </span><br><span class="line">	q.push(s);</span><br><span class="line">	approve[s] = INF;</span><br><span class="line">	dis[s] = <span class="number">0</span>;</span><br><span class="line">	vis[s] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		<span class="keyword">int</span> u = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		vis[u] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">			<span class="keyword">if</span>(dis[v] &gt; dis[u] + edge[i].cost <span class="keyword">and</span> edge[i].cap &gt; edge[i].flow)&#123;</span><br><span class="line">				parent[v] = i;</span><br><span class="line">				approve[v] = min(approve[u],edge[i].cap - edge[i].flow);</span><br><span class="line">				dis[v] = dis[u] + edge[i].cost;</span><br><span class="line">				<span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">					vis[v] = <span class="number">1</span>;</span><br><span class="line">					q.push(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		if(approve[t])break;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> approve[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EK</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line"><span class="comment">//	int flow = 0;</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">int</span> delta = spfa(s,t);</span><br><span class="line">		<span class="keyword">if</span>(!delta)<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> u = t;u != s;u = edge[parent[u]].from)&#123;</span><br><span class="line">			<span class="keyword">int</span> curp = parent[u];</span><br><span class="line">			edge[curp].flow += delta;</span><br><span class="line">			edge[curp^<span class="number">1</span>].flow -= delta;</span><br><span class="line">		&#125;</span><br><span class="line">		flow += delta;</span><br><span class="line">		cost += dis[t]*delta;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="连通性与环"><a href="#连通性与环" class="headerlink" title="连通性与环"></a>连通性与环</h1><h2 id="割点"><a href="#割点" class="headerlink" title="割点"></a>割点</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dfn[u])<span class="keyword">return</span>;</span><br><span class="line">	dfn[u] = low[u] = dfsclock++;</span><br><span class="line">	<span class="keyword">int</span> child = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">			Tarjan(v,fa);</span><br><span class="line">			low[u] = min(low[v],low[u]);</span><br><span class="line">			<span class="keyword">if</span>(u == fa)child++;</span><br><span class="line">			<span class="keyword">if</span>(low[v] &gt;= dfn[u] <span class="keyword">and</span> u != fa)iscut[u] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		low[u] = min(low[u],dfn[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(fa == u <span class="keyword">and</span> child &gt; <span class="number">1</span>)iscut[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SCC-强连通分量"><a href="#SCC-强连通分量" class="headerlink" title="SCC/强连通分量"></a>SCC/强连通分量</h2><h3 id="Kosaraju"><a href="#Kosaraju" class="headerlink" title="Kosaraju"></a>Kosaraju</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> next,to,w;</span><br><span class="line"> &#125;edge[maxn],edgeT[maxn],edgeD[maxn];</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">     edge[cnt].to = to;</span><br><span class="line">     edge[cnt].next = head[from];</span><br><span class="line">     head[from] = cnt++;</span><br><span class="line">     edgeT[cntT].to = from;</span><br><span class="line">     edgeT[cntT].next = headT[to];</span><br><span class="line">     headT[to] = cntT++;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">     edgeD[cntD].to = to;</span><br><span class="line">     edgeD[cntD].w = w;</span><br><span class="line">     edgeD[cntD].next = headD[from];</span><br><span class="line">     headD[from] = cntD++;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">DFS1</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(vis[s])<span class="keyword">return</span>;</span><br><span class="line">	vis[s] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[s];~i;i = edge[i].next)DFS1(edge[i].to);</span><br><span class="line">	r_topo.push_back(s);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS2</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(sccno[s])<span class="keyword">return</span>;</span><br><span class="line">	sccno[s] = scccnt;</span><br><span class="line">	sccmin[scccnt] = min(sccmin[scccnt],pointw[s]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = headT[s];~i;i = edgeT[i].next)DFS2(edgeT[i].to);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findscc</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &amp;lt;= n;i++)DFS1(i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!sccno[r_topo[i]])&#123;</span><br><span class="line">			scccnt++;</span><br><span class="line">			DFS2(r_topo[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildmap</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">1</span>;u &amp;lt;= n;u++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">			<span class="keyword">if</span>(sccno[u] != sccno[v])&#123;</span><br><span class="line">				<span class="keyword">if</span>(!dup[pair&amp;lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(sccno[u],sccno[v])])&#123;</span><br><span class="line">					addedge(sccno[u],sccno[v],<span class="number">1</span>);</span><br><span class="line">					dup[pair&amp;lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(sccno[u],sccno[v])] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="桥"><a href="#桥" class="headerlink" title="桥"></a>桥</h2><p>一种比较好理解的求桥的方法 <strong>(注意无法用来求割顶</strong></p>
<p>$dp[u]$表示跨过$u$的反向边的数量.如果$dp[u] == 0$则$<fa,u>$为桥($fa$是$u$的父亲)</p>
<p>调用时需初始化$dep[root] = 1$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cal_bri</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	dp[u] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">		<span class="keyword">if</span>(v == fa)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(!dep[v])&#123;</span><br><span class="line">			dep[v] = dep[u]+<span class="number">1</span>;</span><br><span class="line">			Cal_bri(v,u);</span><br><span class="line">			dp[u] += dp[v];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(dep[v] &gt; dep[u])dp[u]--;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(dep[v] &lt; dep[u])&#123;</span><br><span class="line">				dp[u]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!dp[u] <span class="keyword">and</span> dep[u] &gt; <span class="number">1</span>)ok = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="仙人掌"><a href="#仙人掌" class="headerlink" title="仙人掌"></a>仙人掌</h2><p>(接上文)点仙人掌中求环并缩点</p>
<p>$backcnt$为全局变量,初始化为$n+1$(点的个数+1)</p>
<p>$phash[u]$返回环的标号,从$n+1$开始.若不在环内则$phash[u] == u$</p>
<p>调用时初始化$dep[root] = 1$,注意缩点后需要重新寻找根节点(缩点代码未给出)</p>
<p>原理参见<a href="https://codeforces.com/blog/entry/68138" target="_blank" rel="noopener">https://codeforces.com/blog/entry/68138</a> 这个东西应该找简单环都可以用(?<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cal_bri</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	dp[u] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">bool</span> ok = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = rhead[u];~i;i = redge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = redge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(v == fa)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(!dep[v])&#123;</span><br><span class="line">			dep[v] = dep[u]+<span class="number">1</span>;</span><br><span class="line">			Cal_bri(v,u);</span><br><span class="line">			dp[u] += dp[v];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(dep[v] &gt; dep[u])dp[u]--;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(dep[v] &lt; dep[u])&#123;</span><br><span class="line">				in[v]++;</span><br><span class="line">				dp[u]++;</span><br><span class="line">				ok = <span class="number">1</span>;</span><br><span class="line">				redge[i].cnt = ++backcnt;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ok)phash[u] = backcnt;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		phash[u] = u;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = rhead[u];~i;i = redge[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = redge[i].to;</span><br><span class="line">			<span class="keyword">if</span>(v == fa)<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(phash[v] != v <span class="keyword">and</span> !in[v])&#123;</span><br><span class="line">				phash[u] = phash[v];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="BFS求最小环"><a href="#BFS求最小环" class="headerlink" title="BFS求最小环"></a>BFS求最小环</h2><p>见代码=-=可以画个BFS树或者手模感悟一下</p>
<p>记得得枚举1…n的所有起点,所以复杂度是$O(n^2)$<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">	dis[s] = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;q;</span><br><span class="line">	q.push(make_pair(s,<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		<span class="keyword">auto</span> now = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">int</span> u = now.first,fa = now.second;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">			<span class="keyword">if</span>(v == fa)<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(dis[v] == <span class="number">-1</span>)&#123;</span><br><span class="line">				dis[v] = dis[u]+<span class="number">1</span>;</span><br><span class="line">				q.push(make_pair(v,u));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				ans = min(ans,dis[v]+dis[u]+<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="2-SAT"><a href="#2-SAT" class="headerlink" title="2-SAT"></a>2-SAT</h1><p>参数a,x,b,y代表$x_a$为x或$x_b$为y x,y是bool<br>是的我知道这个变量起的很弱智<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P4782</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">4E6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> from,to,next;</span><br><span class="line">&#125;edge[maxm],edgeT[maxm];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;r_topo;</span><br><span class="line"><span class="keyword">int</span> scc_no[maxn],scc_cnt;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span>,cntT = <span class="number">1</span>,head[maxn],headT[maxn],n,m,q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	edge[cnt].from = f;</span><br><span class="line">	edge[cnt].to = t;</span><br><span class="line">	edge[cnt].next = head[f];</span><br><span class="line">	head[f] = cnt++;</span><br><span class="line">	edgeT[cntT].from = t;</span><br><span class="line">	edgeT[cntT].to = f;</span><br><span class="line">	edgeT[cntT].next = headT[t];</span><br><span class="line">	headT[t] = cntT++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS1</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(vis[u])<span class="keyword">return</span>;</span><br><span class="line">	vis[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">		DFS1(edge[i].to);</span><br><span class="line">	&#125;</span><br><span class="line">	r_topo.push_back(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS2</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(scc_no[u])<span class="keyword">return</span>;</span><br><span class="line">	scc_no[u] = scc_cnt;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = headT[u];~i;i = edgeT[i].next)DFS2(edgeT[i].to);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findscc</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">2</span>*n;i++)DFS1(i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>*n<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!scc_no[r_topo[i]])&#123;</span><br><span class="line">			scc_cnt++;</span><br><span class="line">			DFS2(r_topo[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("P4782.in","r",stdin);</span></span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">	<span class="built_in">memset</span>(headT,<span class="number">-1</span>,<span class="keyword">sizeof</span>(headT));</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> a,b,x,y;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;a,&amp;x,&amp;b,&amp;y);</span><br><span class="line">		addedge(a+n*(x&amp;<span class="number">1</span>),b+n*(y^<span class="number">1</span>));</span><br><span class="line">		addedge(b+n*(y&amp;<span class="number">1</span>),a+n*(x^<span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	findscc();</span><br><span class="line">	<span class="keyword">bool</span> ok = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)<span class="keyword">if</span>(scc_no[i] == scc_no[i+n])&#123;</span><br><span class="line">		ok = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!ok)<span class="built_in">printf</span>(<span class="string">"IMPOSSIBLE"</span>);</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"POSSIBLE\n"</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)<span class="built_in">printf</span>(<span class="string">"%d "</span>,scc_no[i] &gt; scc_no[i+n]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解] CF906D-Power Tower</title>
    <url>/2020/05/13/solution-CF906D/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给定序列$w_1,w_2,…,w_n$和$q$组询问,对于每组询问,求<img src="../images/CF906D_1.png" alt="img1"></p>
<p>当然,需要对这个值膜$m$ </p>
<p>(hexo渲染多重幂有问题,只好放原题图片了)</p>
<p>$1 \leq n \leq 1e5$, $1 \leq m \leq 1e9$, $1 \leq q \leq 1e5$</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>很显然我们可以递归求解这个式子,但是这样每组询问复杂度为$O(n)$,不够优秀  </p>
<p>考虑扩展欧拉定理:</p>
<script type="math/tex; mode=display">
a^b = \left\{
\begin{array}{lcl}
a^b && {b < φ(p)} \\
a^{b \bmod φ(p) + φ(p) } && {b \geq φ(p)}\\
\end{array}
\right.</script><p>由于$p \geq 2$时$φ(p)$为偶数,故$p = φ(p)$的下降速度是log级别的,换句话说经过最多$log(p)$次迭代之后$p$便会变为1.由于$x \bmod 1 == 0$,我们在$l == r$或者$p == 1$时便可跳出递归,单组询问的复杂度降为$O(logp)$,可以接受</p>
<p>在具体实现时,应预处理出$p,φ(p),φ(φ(p)),…,1$来减少时间开销,同时修改快速幂来适应扩欧定理(upd函数),细节见代码</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CF906D </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line">ll raw[maxn],n,mod;</span><br><span class="line"><span class="built_in">map</span>&lt;ll,ll&gt;vis;</span><br><span class="line"><span class="function">ll <span class="title">phi</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m = (ll)<span class="built_in">sqrt</span>(x+<span class="number">0.5</span>);</span><br><span class="line">	ll tans = x;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= m;i++)<span class="keyword">if</span>(!(x%i))&#123;</span><br><span class="line">		tans = tans/i*(i<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">while</span>(!(x%i))x /= i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x &gt; <span class="number">1</span>)tans = tans / x * (x<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> tans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">upd</span><span class="params">(ll x,ll p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x&lt;p?x:x%p+p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">Pow</span><span class="params">(ll x,ll d,ll p)</span></span>&#123;</span><br><span class="line">	ll tans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(d == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	ll a = Pow(x,d/<span class="number">2</span>,p);</span><br><span class="line">	tans = upd(a*a,p);</span><br><span class="line">	<span class="keyword">if</span>(d%<span class="number">2</span>)tans = upd(tans*x,p); </span><br><span class="line">	<span class="keyword">return</span> upd(tans,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">cal</span><span class="params">(ll l,ll r,ll p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l == r <span class="keyword">or</span> p == <span class="number">1</span>)<span class="keyword">return</span> upd(raw[l],p);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> Pow(raw[l],cal(l+<span class="number">1</span>,r,vis[p]),p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; mod;</span><br><span class="line">	ll qwq = mod;</span><br><span class="line">	<span class="keyword">while</span>(qwq != <span class="number">1</span>)&#123;</span><br><span class="line">		vis[qwq] = phi(qwq);</span><br><span class="line">		qwq = vis[qwq];</span><br><span class="line">	&#125;</span><br><span class="line">	vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)<span class="built_in">cin</span> &gt;&gt; raw[i];</span><br><span class="line">	<span class="keyword">int</span> q;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">	<span class="keyword">while</span>(q--)&#123;</span><br><span class="line">		<span class="keyword">int</span> l,r;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; cal(l,r,mod)%mod &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>Mobius-Transformation</title>
    <url>/2020/05/13/Mobius-Transformation/</url>
    <content><![CDATA[<p>这个菜鸡现在还什么都不会&gt;_&gt;慢慢更新吧</p>
<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="整除分块"><a href="#整除分块" class="headerlink" title="整除分块"></a>整除分块</h2><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>设$f(x) = \lfloor \frac{k}{x} \rfloor$</p>
<p>$f(x)$分布呈块状,对于任意一个$i$,有最大的$j = \lfloor \frac{k}{\lfloor \frac{k}{i} \rfloor} \rfloor$,使得$f(i) == f(i+1) == … = f(j)$</p>
<p>对于类似$\sum_{i = 1}^{n}\lfloor \frac{k}{i} \rfloor$的式子,可分块在$O(\sqrt{n})$时间内计算完毕</p>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>;l &lt;= n;l = r+<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(k/l)r = min(n,k/(k/l));</span><br><span class="line">		<span class="keyword">else</span> r = n;</span><br><span class="line">		ans += (r-l+<span class="number">1</span>)*(k/l);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h3><p>不会</p>
<ul>
<li><p>引理1: $\forall a,b,c \in \mathbb{Z},\lfloor \frac{ab}{c} \rfloor = \lfloor \frac{\lfloor \frac{a}{b} \rfloor}{c} \rfloor$</p>
<p>  证明:</p>
<p>  $\frac{a}{b} = \lfloor \frac{a}{b} \rfloor + r (0 \leq r &lt; 1)$</p>
</li>
</ul>
<h3 id="复杂度证明"><a href="#复杂度证明" class="headerlink" title="复杂度证明"></a>复杂度证明</h3><p>不会</p>
<p>这个菜鸡只会这些 摸了</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>笔记</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]CF1325E-Ehab&#39;s REAL Number Theory Problem</title>
    <url>/2020/05/15/solution-CF1325E/</url>
    <content><![CDATA[<p>一道有意思的<del>毒瘤</del>题</p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>​    给出数列${a_1,a_2,…,a_n}$,其中每个$a_i$最多只有7个因子.求乘积为完全平方数的最短子序列</p>
<p>​    $1 \leq n \leq 1e5$,$1 \leq a_i \leq 1e6$</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>​    首先条件里”最多只有7个因子”是很有意思的一个提示,它实际上是指每个数<strong>最多只有2个素因子</strong></p>
<p>证明:</p>
<p>​        我们考虑因子个数定理:</p>
<p>​        以$d(N)$表示$N$的因子个数,且$N = Σ<em>{i=1}^{n}p</em>{i}^{k_i}$</p>
<p>​        则有$d(N) = \prod_{i = 1}^{n}(k_i+1)$ </p>
<p>​        容易看出当$N$有3个素因子时,$d(N) \geq 8$.故N最多只有两个素因子.</p>
<p>​    如此可以分解每个$a_i$为$a_i = p^{k_1}q^{k_2}$的形式.因为我们需要求完全平方数,$k_1,k_2$可以直接模2.之后有如下三种情况:</p>
<ol>
<li>$a_i = 1$</li>
<li>$a_i = 1*p_i$</li>
<li>$a_i = p_i*q_i$<br>我们要做的就是保证子序列里每个$p_i,q_i$的指数为偶数,同时使这个序列最短.</li>
</ol>
<hr>
<p>​    如何高效求解这个问题?上面的因子分解得到了$p,q$两个因子,让人联想到图的连边.不妨如此建模:将因子作为点,向$a_i$的两个因子$p_i,q_i$连一条无向无权边,则问题转化为求这个图里的最小环.(因为一个简单环里每个点的度数都为2,满足每个因子的指数都为偶数这一要求).</p>
<p>​    对于无向无权图图求最小环我们可以简单地对每个点做BFS.对于一条未访问的边$u,v$ ,如果$v$已访问过,那么该图存在一个长度为$dis[u]+dis[v]+1$的环(请自己画图验证).但是这样复杂度为$O(n^2)$</p>
<p>​    考虑这个图的特殊性质:任意正整数$N$最多只有一个大于$\sqrt{N}$的素因子,换句话说这个图里每条边都至少有一个点标号小于$\sqrt{max{a_i}}$.只需枚举这些点即可.</p>
<p>​    总复杂度:$O(\sqrt{max{a_i}}n)$</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CF1325E</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> f,t,next;</span><br><span class="line">	Edge(<span class="keyword">int</span> f = <span class="number">0</span>,<span class="keyword">int</span> t = <span class="number">0</span>,<span class="keyword">int</span> next = <span class="number">0</span>):f(f),t(t),next(next)&#123;&#125;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt,head[maxn],dis[maxn],ans = <span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	edge[cnt] = Edge(f,t,head[f]);</span><br><span class="line">	head[f] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	addedge(f,t);</span><br><span class="line">	addedge(t,f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> visp[maxn],vis[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;P,d[maxn];</span><br><span class="line"><span class="keyword">int</span> n,raw[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	visp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; maxn;i++)<span class="keyword">if</span>(!visp[i])&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i*<span class="number">2</span>;j &lt; maxn;j+=i)visp[j] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; maxn;i++)<span class="keyword">if</span>(!visp[i])&#123;</span><br><span class="line">		P.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; raw[i];</span><br><span class="line">		<span class="keyword">int</span> cur = raw[i];</span><br><span class="line">		<span class="keyword">if</span>(!visp[cur])&#123;</span><br><span class="line">			d[i].push_back(cur);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>;j*j &lt;= raw[i];j++)&#123;</span><br><span class="line">			<span class="keyword">int</span> cnt2 = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(cur%j == <span class="number">0</span>)&#123;</span><br><span class="line">				cur /= j;cnt2++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(cnt2%<span class="number">2</span>)d[i].push_back(j);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(cur &gt; <span class="number">1</span>)d[i].push_back(cur);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!d[i].size())&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(d[i].size() == <span class="number">1</span>)&#123;</span><br><span class="line">			add(<span class="number">1</span>,d[i][<span class="number">0</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> add(d[i][<span class="number">0</span>],d[i][<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">	dis[s] = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;q;</span><br><span class="line">	q.push(make_pair(s,<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		<span class="keyword">auto</span> now = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">int</span> u = now.first,fa = now.second;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i;i = edge[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = edge[i].t;</span><br><span class="line">			<span class="keyword">if</span>(v == fa)<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(dis[v] == <span class="number">-1</span>)&#123;</span><br><span class="line">				dis[v] = dis[u]+<span class="number">1</span>;</span><br><span class="line">				q.push(make_pair(v,u));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				ans = min(ans,dis[v]+dis[u]+<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">	init();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">1010</span>;i++)BFS(i);</span><br><span class="line">	<span class="keyword">if</span>(ans == <span class="number">1e9</span>)ans = <span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$2^{2n-1}+2^{2n-2}-2^n$</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]CF1355C-Count Triangles</title>
    <url>/2020/05/16/solution-CF1355C/</url>
    <content><![CDATA[<p>写这个不是因为这题多难或者有意思,纯粹是纪念一下自己有多傻逼=-=</p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给出$A,B,C,D$求满足$A \leq x \leq B \leq y \leq C \leq z \leq D$,的$x,y,z$能组成的三角形个数</p>
<p>$1 \leq A \leq B \leq C \leq D \leq 5e5$</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>很显然只要满足$z &lt; x+y$且$C \leq z \leq D$就行=-=</p>
<p>那么枚举$x$,把$[x+B,x+C]$加1(用前缀和维护一下就行),再枚举$z$统计满足$z &lt; x+y$的个数就行=-=</p>
<p>复杂度$O(C)$</p>
<p><strong>就这玩意都做不出来,我是傻逼</strong></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ll a,b,c,d,ans = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = a;i &lt;= b;i++)pre[i+b]++,pre[i+c+<span class="number">1</span>]--;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; maxn;i++)pre[i] += pre[i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; maxn;i++)ans += pre[i]*max(<span class="number">0l</span>l,min(d,(ll)(i<span class="number">-1</span>)) - c + <span class="number">1</span>); </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>我是sb</tag>
      </tags>
  </entry>
  <entry>
    <title>高数笔记</title>
    <url>/2020/05/22/calculus/</url>
    <content><![CDATA[<p>=-=老年人记录一些自己会忘的东西</p>
<p>页码以Thomas’s Calculus中文版第十版(高等教育出版社)为准</p>
<h1 id="5-积分的应用"><a href="#5-积分的应用" class="headerlink" title="[5]积分的应用"></a>[5]积分的应用</h1><h2 id="5-3-平面曲线的长度"><a href="#5-3-平面曲线的长度" class="headerlink" title="[5.3]平面曲线的长度"></a>[5.3]平面曲线的长度</h2><script type="math/tex; mode=display">
L = \int_a^b \sqrt{1+(\frac{dx}{dy})^2}dy</script><p>极坐标下:</p>
<script type="math/tex; mode=display">
L = \int_a^b\sqrt{r^2+(\frac{dr}{dθ})^2}dθ</script><h1 id="9-平面向量和极坐标函数"><a href="#9-平面向量和极坐标函数" class="headerlink" title="[9]平面向量和极坐标函数"></a>[9]平面向量和极坐标函数</h1><h2 id="9-2-点积"><a href="#9-2-点积" class="headerlink" title="[9.2]点积"></a>[9.2]点积</h2><h3 id="向量投影"><a href="#向量投影" class="headerlink" title="向量投影"></a>向量投影</h3><p>$\textbf{u}$在$\textbf{v}$上的向量投影:</p>
<script type="math/tex; mode=display">
proj_{\textbf{v}}\textbf{u} = (|\textbf{u}|cosθ)\frac{\textbf{v}}{\textbf{|v|}}=(\frac{\textbf{u} \cdot \textbf{v}}{|\textbf{v}|^2})\textbf{v}</script><p>$\textbf{u}$在$\textbf{v}$方向上的数值分量:</p>
<script type="math/tex; mode=display">
|\textbf{u}|cosθ = \frac{\textbf{u} \cdot \textbf{v}}{|\textbf{v}|}</script><h3 id="向量正交化"><a href="#向量正交化" class="headerlink" title="向量正交化"></a>向量正交化</h3><p>把$\textbf{u}$改写为平行于$\textbf{v}$加与$\textbf{v}$正交的向量:</p>
<script type="math/tex; mode=display">
\textbf{u} = proj_\textbf{v}\textbf{u} + (\textbf{u} - proj_\textbf{v}\textbf{u})</script><h2 id="9-6-极坐标曲线的微积分"><a href="#9-6-极坐标曲线的微积分" class="headerlink" title="[9.6] 极坐标曲线的微积分"></a>[9.6] 极坐标曲线的微积分</h2><h3 id="极坐标中的面积"><a href="#极坐标中的面积" class="headerlink" title="极坐标中的面积"></a>极坐标中的面积</h3><p>介于原点和曲线$r = f(θ)$,$α \leq θ \leq β$之间的区域的<strong>面积</strong>A为:</p>
<script type="math/tex; mode=display">
A =  \int_α^β\frac{1}{2}r^2dθ</script><p>面积微分:</p>
<script type="math/tex; mode=display">
dA = \frac{1}{2}r^2dθ</script><h3 id="极坐标曲线之间的面积"><a href="#极坐标曲线之间的面积" class="headerlink" title="极坐标曲线之间的面积"></a>极坐标曲线之间的面积</h3><p>区域$0 \leq r_1(θ) \leq r_2(θ)$,$α \leq θ \leq β$的面积A为:</p>
<script type="math/tex; mode=display">
A = \int_α^β\frac{1}{2}(r_2^2 - r_1^2)dθ</script><h3 id="极坐标曲线的长度"><a href="#极坐标曲线的长度" class="headerlink" title="极坐标曲线的长度"></a>极坐标曲线的长度</h3><script type="math/tex; mode=display">
L = \int_a^b\sqrt{r^2+(\frac{dr}{dθ})^2}dθ$</script><h1 id="10-空间中的向量和运动"><a href="#10-空间中的向量和运动" class="headerlink" title="[10]空间中的向量和运动"></a>[10]空间中的向量和运动</h1><h2 id="10-2-点积和叉积"><a href="#10-2-点积和叉积" class="headerlink" title="[10.2]点积和叉积"></a>[10.2]点积和叉积</h2><h3 id="叉积"><a href="#叉积" class="headerlink" title="叉积"></a>叉积</h3><p>行列式计算叉积:</p>
<script type="math/tex; mode=display">
若\textbf{u} = u_1\textbf{i} + u_2\textbf{j} + u_3\textbf{k},\textbf{v} = v_1\textbf{i} + v_2\textbf{j} + v_3\textbf{k},则
\\
\textbf{u} \times \textbf{v} = \ 
\left|\begin{array}{cccc} 
    \textbf{i} &    \textbf{j}    & \textbf{k} \\ 
    u_1        &    u_2             & u_3           \\ 
    v_1           &     v_2              & v_3 
\end{array}\right|</script><p>其中$|\textbf{u} \times \textbf{v}| = |\textbf{u}||\textbf{v}|sinθ$为$\textbf{u}$和$\textbf{v}$确定的平行四边形的<strong>有向</strong>面积</p>
<h3 id="箱积-三元数量积"><a href="#箱积-三元数量积" class="headerlink" title="箱积(三元数量积)"></a>箱积(三元数量积)</h3><p>积$(\textbf{u} \times \textbf{v}) \cdot \textbf{w}$称为$\textbf{u},\textbf{v}$和$\textbf{w}$(注意次序)的<strong>三元数量积</strong></p>
<p>由$|(\textbf{u} \times \textbf{v}) \cdot \textbf{w}| = |\textbf{u} \cdot \textbf{v}||\textbf{w}|cosθ$可以看出其几何意义为$\textbf{u},\textbf{v}$和$\textbf{w}$确定的平行六面体的<strong>有向</strong>体积</p>
<p>计算:</p>
<script type="math/tex; mode=display">
(\textbf{u} \times \textbf{v}) \cdot \textbf{w}  = \ 
\left|\begin{array}{cccc} 
    u_1        &    u_2             & u_3           \\ 
    v_1           &     v_2              & v_3         \\
    w_1        &    w_2              & w_3
\end{array}\right|</script><h2 id="10-3-空间中的直线与曲面"><a href="#10-3-空间中的直线与曲面" class="headerlink" title="[10.3]空间中的直线与曲面"></a>[10.3]空间中的直线与曲面</h2><h3 id="直线"><a href="#直线" class="headerlink" title="直线"></a>直线</h3><p>空间中的直线由一个点和给出直线方向的一个向量确定.</p>
<p>过点$P_0(x_0,y_0,z_0)$平行于$\textbf{v} = v_1\textbf{i} + v_2\textbf{j} + v_3\textbf{k}$的直线的</p>
<p><strong>向量方程</strong>:</p>
<script type="math/tex; mode=display">
\textbf{r}(t) = \textbf{r}_0 + t\textbf{v}</script><p><strong>参数方程</strong>:</p>
<script type="math/tex; mode=display">
x = x_0 + tv_1 \\
y = y_0 + tv_2 \\
z = z_0 + tv_3</script><p><strong>点到直线距离</strong>:</p>
<p>点$S$到过点$P$,方向为$\textbf{v}$的直线的距离:</p>
<script type="math/tex; mode=display">
d = |\overrightarrow{PS}|sinθ = \frac{|\overrightarrow{PS} \times \textbf{v}|}{|\textbf{v}|}</script><h3 id="平面"><a href="#平面" class="headerlink" title="平面"></a>平面</h3><p>空间中的平面由它上面的一个点和它的”倾斜”或方位确定.</p>
<p>过点$P_0(x_0,y_0,z_0)$且垂直于$\textbf{n} = A\textbf{i}+ B\textbf{j} + C\textbf{k}$的平面有:</p>
<p><strong>向量方程</strong>:</p>
<script type="math/tex; mode=display">
\textbf{n} \cdot \overrightarrow{P_0P} = 0</script><p><strong>分量方程</strong>:</p>
<script type="math/tex; mode=display">
A(x - x_0) + B(y - y_0) + C(z - z_0) = 0</script><p><strong>简化分量方程</strong>:</p>
<script type="math/tex; mode=display">
Ax + By + Cz = D\\
D = Ax_0 + By_0 + Cz_0</script><p>其中$x,y,z$缺少哪一变量便平行于哪一轴.</p>
<p><strong>点到平面距离</strong>:</p>
<p>点$S$到平面$Ax+By+C=D$的距离:</p>
<script type="math/tex; mode=display">
d = |\overrightarrow{PS} \cdot \frac{\textbf{n}}{|\textbf{n}|}|</script><p><strong>两平面夹角</strong>:</p>
<script type="math/tex; mode=display">
cosθ = \frac{\textbf{n}_1 \cdot \textbf{n}_2}{|\textbf{n}_1||\textbf{n}_2|}</script><p>$\textbf{n}_1 \cdot \textbf{n}_2 = 0$时,两平面垂直. $\textbf{n}_1 // \textbf{n}_2$时,两平面平行</p>
<script type="math/tex; mode=display">
I = \int dI 
\\= \int_0^R 2πr^3h \cdot \frac{m}{πR^2h} \cdot dr 
\\ = \int_0^R 2mr^3 \cdot \frac{1}{R^2}
\\ = \frac{m}{R^2}\int_0^R2r^3
\\ = \frac{1}{2}mR^2</script><script type="math/tex; mode=display">
E(k) = Σ_{i = 1}^k\frac{n}{i}</script>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>笔记</tag>
        <tag>微积分</tag>
      </tags>
  </entry>
</search>
