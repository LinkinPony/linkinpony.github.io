<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"linkinpony.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.7.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="I always love dashie">
<meta property="og:url" content="http://linkinpony.github.io/page/2/index.html">
<meta property="og:site_name" content="I always love dashie">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="LinkinPony">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://linkinpony.github.io/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>I always love dashie</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">I always love dashie</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">LinkinPony</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">51</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">51</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LinkinPony" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LinkinPony" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://codeforces.com/profile/LinkinPony" title="CodeForces → https:&#x2F;&#x2F;codeforces.com&#x2F;profile&#x2F;LinkinPony" rel="noopener" target="_blank"><i class="code fa-fw"></i>CodeForces</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://acker.fun/" title="https:&#x2F;&#x2F;acker.fun&#x2F;" rel="noopener" target="_blank">Acker</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://kmguan-528.github.io/" title="https:&#x2F;&#x2F;kmguan-528.github.io&#x2F;" rel="noopener" target="_blank">KMGuan</a>
        </li>
    </ul>
  </div>

          </div>
        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://linkinpony.github.io/2022/01/19/solution-CF1626E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LinkinPony">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="I always love dashie">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/01/19/solution-CF1626E/" class="post-title-link" itemprop="url">[题解]-CF1626E Black and White Tree</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-01-19 21:44:29" itemprop="dateCreated datePublished" datetime="2022-01-19T21:44:29+08:00">2022-01-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-02-15 10:40:19" itemprop="dateModified" datetime="2022-02-15T10:40:19+08:00">2022-02-15</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%A2%98%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">题解</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="题意">题意</h2>
<p>给出一个大小为<span class="math inline">\(n\)</span> <span class="math inline">\((n\leq 3 \cdot 10^5)\)</span>的树, 树上每个节点被染成白色或者黑色. 假设当前在点<span class="math inline">\(k\)</span>有一个棋子, 你每次可以选择一个黑点<span class="math inline">\(b\)</span>作为目标点, 将这个棋子向黑点按从<span class="math inline">\(k\)</span>到<span class="math inline">\(b\)</span>的最短路径移动一格(一条边). 连续两次操作选择的黑点不能相同. 对于所有的<span class="math inline">\(k = 1...n\)</span>, 判断该棋子是否能在有限步操作后移动到任意一个黑点. 能移动到则该点答案为<span class="math inline">\(1\)</span>否则为<span class="math inline">\(0\)</span>.</p>
<h2 id="题解">题解</h2>
<p>首先显然黑点和与黑点相邻的白点答案均为<span class="math inline">\(1\)</span>. 对于其它白点, 当且仅当它所在的某条链上有至少两个黑点时它才能移动到黑点上. 这种情况有一个特例:</p>
<figure>
<img src="https://raw.githubusercontent.com/LinkinPony/hexo_pic_bed/master/img/image-20220119220348299.png" alt="image-20220119220348299" /><figcaption aria-hidden="true">image-20220119220348299</figcaption>
</figure>
<p>如图, 尽管1不在任意一条有两个黑点的链上, 但它仍然能到达黑点5, 只要交替选择5, 7两个点即可.</p>
<p>为了解决这种特殊情况, 我们把黑点及与黑点相邻的白点缩成一个点(如果有两个相邻的黑点那么显然答案全为1. 如果不进行特判的话就需要把在同一联通分量里的黑点缩成一个点)</p>
<figure>
<img src="https://raw.githubusercontent.com/LinkinPony/hexo_pic_bed/master/img/image-20220119221543385.png" alt="image-20220119221543385" /><figcaption aria-hidden="true">image-20220119221543385</figcaption>
</figure>
<p>缩点之后如图. 这样1便在有两个黑点的链上了.</p>
<p>判断每个点是否在有不少于两个黑点的链上可以用换根dp求. 首先指定一个根<span class="math inline">\(r\)</span>, <span class="math inline">\(siz[u]\)</span>表示以<span class="math inline">\(u\)</span>为根的子树里拥有黑点数最大的链的黑点数目. 换根dp的具体细节见代码中<code>dfs2()</code>. 需要注意的是缩点之后可能不存在<span class="math inline">\(1\)</span>这个点.</p>
<p>时间复杂度<span class="math inline">\(O(n)\)</span>.</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="function">mt19937 <span class="title">Rand</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e5</span>+<span class="number">10</span>;<span class="comment">//CHANGE IT!</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = maxn*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">1e9</span>+<span class="number">7</span>;<span class="comment">//CHANGE IT!</span></span><br><span class="line"><span class="function">ll <span class="title">Pow</span><span class="params">(ll x,ll d,ll p)</span></span>&#123;ll ta=<span class="number">1</span>;<span class="keyword">if</span>(d==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>%p;x %= p;ll a=<span class="built_in">Pow</span>(x,d/<span class="number">2</span>,p);ta=a*a%p;<span class="keyword">if</span>(d%<span class="number">2</span>)ta=ta*x%p;<span class="keyword">return</span> ta%p;&#125;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;G[maxn],G2[maxn];</span><br><span class="line"><span class="keyword">int</span> cli[maxn],w[maxn],ans[maxn],siz[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	cli[u] = r;</span><br><span class="line">	ans[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(r != u)w[r] += w[u];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> v:G2[u])&#123;</span><br><span class="line">		<span class="keyword">if</span>(v == fa)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(w[u] <span class="keyword">and</span> !ans[v])<span class="built_in">pre</span>(v,u,r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> v:G[u])&#123;</span><br><span class="line">		<span class="keyword">if</span>(v == fa)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(v,u);</span><br><span class="line">		siz[u] = <span class="built_in">max</span>(siz[u],siz[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	siz[u] += w[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa,<span class="keyword">int</span> res)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tot = <span class="number">0</span>,mx1 = <span class="number">0</span>,mx2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> v:G[u])&#123;</span><br><span class="line">		<span class="keyword">if</span>(v == fa)<span class="keyword">continue</span>;</span><br><span class="line">		tot = <span class="built_in">max</span>(tot,siz[v]);</span><br><span class="line">		<span class="keyword">if</span>(siz[v] &gt;= mx1)&#123;</span><br><span class="line">			mx2 = mx1;</span><br><span class="line">			mx1 = siz[v];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(siz[v] &gt; mx2)mx2 = siz[v];</span><br><span class="line">	&#125;</span><br><span class="line">	tot = <span class="built_in">max</span>(tot,res) + w[u];</span><br><span class="line">	<span class="keyword">if</span>(res &gt;= mx1)&#123;</span><br><span class="line">		mx2 = mx1;</span><br><span class="line">		mx1 = res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(res &gt; mx2)mx2 = res;</span><br><span class="line">	<span class="keyword">if</span>(tot &gt; <span class="number">1</span>)ans[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> v:G[u])&#123;</span><br><span class="line">		<span class="keyword">if</span>(v == fa)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">int</span> rw = w[u] + (mx1 == siz[v]?mx2:mx1);</span><br><span class="line">		<span class="built_in">dfs2</span>(v,u,rw);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">setf</span>(ios::fixed,ios::floatfield);</span><br><span class="line">	cout.<span class="built_in">precision</span>(<span class="number">12</span>);	 </span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)cin &gt;&gt; w[i],cli[i] = i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> f,t;</span><br><span class="line">		cin &gt;&gt; f &gt;&gt; t;</span><br><span class="line">		G2[f].<span class="built_in">push_back</span>(t);</span><br><span class="line">		G2[t].<span class="built_in">push_back</span>(f);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)<span class="keyword">if</span>(w[i] <span class="keyword">and</span> cli[i] == i)<span class="built_in">pre</span>(i,<span class="number">-1</span>,i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">1</span>;u &lt;= n;u++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> v:G2[u])&#123;</span><br><span class="line">			<span class="keyword">if</span>(cli[u] == cli[v])<span class="keyword">continue</span>;</span><br><span class="line">			G[cli[u]].<span class="built_in">push_back</span>(cli[v]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(cli[i] == i)&#123;</span><br><span class="line">			<span class="built_in">dfs</span>(i,<span class="number">-1</span>);</span><br><span class="line">			<span class="built_in">dfs2</span>(i,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$$</p>
<p>$$</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://linkinpony.github.io/2022/01/13/solution-CF1625D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LinkinPony">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="I always love dashie">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/01/13/solution-CF1625D/" class="post-title-link" itemprop="url">[题解]CF1625D-Binary Spiders</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-01-13 14:44:54 / Modified: 19:34:26" itemprop="dateCreated datePublished" datetime="2022-01-13T14:44:54+08:00">2022-01-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%A2%98%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">题解</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="题意">题意</h2>
<p>给出<span class="math inline">\(n\)</span>个数<span class="math inline">\(a_i\)</span>, 和一个整数<span class="math inline">\(k\)</span>. 从这<span class="math inline">\(n\)</span>个数中选出尽可能多的数, 使得它们之间任意两者按位异或后大于等于<span class="math inline">\(k\)</span>. 输出数字的个数和下标, 如果不存在则输出<span class="math inline">\(-1\)</span>.</p>
<p><span class="math inline">\(2 \le n \le 3 \cdot 10^5, 0 \leq a_i,k \leq 2^{30} - 1\)</span></p>
<h2 id="题解">题解</h2>
<p>设<span class="math inline">\(k\)</span>的最高位是第<span class="math inline">\(h\)</span>位. 首先会很自然的想到——如果把每个数位数小于等于<span class="math inline">\(h\)</span>的部分变为0, 按此分类, 从每种里选出一个数字加入答案里一定合法. 因为任意两个数字异或后都至少有一个高于<span class="math inline">\(h\)</span>的位为<span class="math inline">\(1\)</span>. 以样例<span class="math inline">\(k = 8(1000)\)</span>为例:</p>
<table>
<thead>
<tr class="header">
<th>原始</th>
<th>2(10)</th>
<th>8(1000)</th>
<th>4(100)</th>
<th>16(10000)</th>
<th>10(1010)</th>
<th>14(1110)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>处理后组别</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>16(10000)</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>此时我们选择<span class="math inline">\(16\)</span>, 再从<span class="math inline">\(2,8,4,10,14\)</span>里任选一个都能组成一个解，但它不是最优的: 例如在<span class="math inline">\(0\)</span>这一组里选择<span class="math inline">\(2\)</span>和<span class="math inline">\(10\)</span>加入答案也是合法解.</p>
<p>进一步思考可以发现, 在每一组里有可能可以选择两个数字且最多只能选择两个. 如果选择了超过两个数字, 那么至少有两个数字在第<span class="math inline">\(h\)</span>位上是一样的, 这会导致异或后的结果小于<span class="math inline">\(k\)</span>. 使用Trie判断是否有解即可.</p>
<p>注意需要特判<span class="math inline">\(k = 0\)</span>的情况.</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="function">mt19937 <span class="title">Rand</span><span class="params">(chrono::steady_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e5</span>+<span class="number">10</span>;<span class="comment">//CHANGE IT!</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = maxn*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxc = <span class="number">1e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">1e9</span>+<span class="number">7</span>;<span class="comment">//CHANGE IT!</span></span><br><span class="line"><span class="function">ll <span class="title">Pow</span><span class="params">(ll x,ll d,ll p)</span></span>&#123;ll ta=<span class="number">1</span>;<span class="keyword">if</span>(d==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>%p;x %= p;ll a=<span class="built_in">Pow</span>(x,d/<span class="number">2</span>,p);ta=a*a%p;<span class="keyword">if</span>(d%<span class="number">2</span>)ta=ta*x%p;<span class="keyword">return</span> ta%p;&#125;</span><br><span class="line">ll raw[maxn],u[maxn],siz;</span><br><span class="line"><span class="keyword">int</span> nxt[maxc][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> w[maxc*<span class="number">2</span>];</span><br><span class="line">map&lt;<span class="keyword">int</span>,vector&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; &gt;hsh;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">30</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">int</span> c = ((s&gt;&gt;i)&amp;<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(nxt[u][c] == <span class="number">-1</span>)nxt[u][c] = ++siz;</span><br><span class="line">		u = nxt[u][c];</span><br><span class="line">	&#125;</span><br><span class="line">	w[u] = idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> u = <span class="number">0</span>,res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">30</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">int</span> c = ((x&gt;&gt;i)&amp;<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(nxt[u][c^<span class="number">1</span>] != <span class="number">-1</span>)&#123;</span><br><span class="line">			res += (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">			u = nxt[u][c^<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(nxt[u][c] != <span class="number">-1</span>)&#123;</span><br><span class="line">			u = nxt[u][c];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(res &lt; k)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> w[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= siz;i++)&#123;</span><br><span class="line">		nxt[i][<span class="number">0</span>] = nxt[i][<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">		w[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	siz = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(nxt,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(nxt));</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">setf</span>(ios::fixed,ios::floatfield);</span><br><span class="line">	cout.<span class="built_in">precision</span>(<span class="number">12</span>);	 </span><br><span class="line">	<span class="keyword">int</span> n,k;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="keyword">if</span>(!k)&#123;</span><br><span class="line">		cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">30</span>;i &gt;= <span class="number">0</span>;i--)<span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;i)&amp;k)&#123;</span><br><span class="line">		h = i;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	set&lt;<span class="keyword">int</span>&gt;great,res;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;gidx;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		cin &gt;&gt; raw[i];</span><br><span class="line">		u[i] = raw[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = h;j &gt;= <span class="number">0</span>;j--)<span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;j)&amp;u[i])u[i] -= (<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">		cerr &lt;&lt; u[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		hsh[u[i]].<span class="built_in">push_back</span>(&#123;raw[i],i&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;ans;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> it:hsh)&#123;</span><br><span class="line">		vector&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; &amp; r = it.second;</span><br><span class="line">		<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> it2:r)<span class="built_in">insert</span>(it2.first,it2.second);</span><br><span class="line">		<span class="keyword">bool</span> ok = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> it2:r)&#123;</span><br><span class="line">			<span class="keyword">int</span> x = <span class="built_in">query</span>(it2.first,k);</span><br><span class="line">			<span class="keyword">if</span>(x != <span class="number">-1</span>)&#123;</span><br><span class="line">				ans.<span class="built_in">push_back</span>(it2.second);</span><br><span class="line">				ans.<span class="built_in">push_back</span>(x);</span><br><span class="line">				ok = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!ok <span class="keyword">and</span> r.<span class="built_in">size</span>())ans.<span class="built_in">push_back</span>(r[<span class="number">0</span>].second);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ans.<span class="built_in">size</span>() &lt; <span class="number">2</span>)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x:ans)cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://linkinpony.github.io/2021/11/24/solution-CF1610D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LinkinPony">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="I always love dashie">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/24/solution-CF1610D/" class="post-title-link" itemprop="url">[题解]CF1610D-Not Quite Lee</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-11-24 01:47:29" itemprop="dateCreated datePublished" datetime="2021-11-24T01:47:29+08:00">2021-11-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-01-13 14:44:30" itemprop="dateModified" datetime="2022-01-13T14:44:30+08:00">2022-01-13</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%A2%98%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">-题解</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>经典我是傻逼环节.</p>
<h2 id="题意">题意</h2>
<p>给出长度为<span class="math inline">\(n\)</span>的数组<span class="math inline">\(A = \{a_i\}\)</span>, <span class="math inline">\(1 \leq n \leq 2 \cdot 10^5,1 \leq a_i \leq 10^9\)</span>.</p>
<p>对于<span class="math inline">\(A\)</span>的任意长度为<span class="math inline">\(m\)</span>的非空子序列<span class="math inline">\(B = \{b_1,b_2,..,b_m\}\)</span>, 定义<span class="math inline">\(f(b_i,k_i) = \sum_{j = 0}^{b_i} (j + k_i)\)</span>, 其中<span class="math inline">\(k_i\)</span>为任意整数. 一个子序列<span class="math inline">\(B\)</span>合法当且仅当 $ {k_i} |_{i = 1}^mf(b_i,k_i) = 0$.</p>
<p>求<span class="math inline">\(A\)</span>中全部合法子序列数量模<span class="math inline">\(10^9+7\)</span>.</p>
<h2 id="题解">题解</h2>
<p>首先我们考虑如何判断某个序列是否合法. 有<span class="math inline">\(f(b_i,k_i) = \frac{b_i\cdot(b_i + 1)}{2} + k_i\cdot b_i\)</span>, 那么<span class="math inline">\(\sum_{i = 1}^mf(b_i,k_i) = 0\)</span>可以转化为<span class="math inline">\(\sum_{i = 0}^m{\frac{b_i\cdot (b_i + 1)}{2}} = \sum_{i = 0}^m k_i \cdot b_i\)</span>. 这是一个一次不定方程. 设<span class="math inline">\(g = gcd(b_1,b_2,...,b_m)\)</span>, 当且仅当<span class="math inline">\(g | \sum_{i = 0}^m \frac{b_i \cdot (b_i+1)}{2}\)</span>时有整数解.</p>
<p>手画一下几组样例可以看出, 当序列中存在奇数时必定合法. 当序列中存在至少一个奇数时, 显然<span class="math inline">\(g\)</span>也是奇数. 那么对于每个<span class="math inline">\(\frac{b_i \cdot (b_i + 1)}{2}\)</span>, 如果<span class="math inline">\(b_i\)</span>是偶数有<span class="math inline">\(g | \frac{b_i}{2}\)</span>, 否则有<span class="math inline">\(g|(b_i + 1)\)</span> 且<span class="math inline">\(\frac{b_i}{2}\)</span>为整数. 因而序列中存在奇数时必有<span class="math inline">\(g | \sum_{i = 0}^m \frac{b_i \cdot (b_i+1)}{2}\)</span>.</p>
<p>设<span class="math inline">\(A\)</span>中奇数个数为<span class="math inline">\(odd\)</span>, 这一部分对答案的贡献为<span class="math inline">\((2^{odd} - 1) \cdot 2^{n-odd}\)</span></p>
<p>现在考虑序列中全为偶数的情况. 设<span class="math inline">\(h\)</span>是最大的使得<span class="math inline">\(2^h | g\)</span>的非负整数. 我们可以把<span class="math inline">\(g\)</span>拆分为<span class="math inline">\(g&#39; \cdot 2^h\)</span>. 显然<span class="math inline">\(g&#39;\)</span>为奇数. 根据上一段的讨论, 有<span class="math inline">\(g&#39; | \sum_{i = 0}^m \frac{b_i \cdot (b_i + 1)}{2}\)</span>. <strong>因而全为偶数的序列是否合法取决于</strong><span class="math inline">\(2^h\)</span><strong>能否整除</strong><span class="math inline">\(\sum_{i = 0}^m \frac{b_i \cdot (b_i + 1)}{2}\)</span>. 对于每个<span class="math inline">\(b_i\)</span>, 设<span class="math inline">\(l\)</span>是最大的使得<span class="math inline">\(2^l|b_i\)</span>的非负整数. <span class="math inline">\(l\)</span>可以分三种情况来讨论:</p>
<ul>
<li><p><span class="math inline">\(l &gt; h\)</span>.</p>
<p>此时有<span class="math inline">\(2^h | \frac{b_i}{2}\)</span>, 所以<span class="math inline">\(2^h | \frac{b_i \cdot(b_i + 1)}{2}\)</span>.</p></li>
<li><p><span class="math inline">\(l = h\)</span>.</p>
<p>此时<span class="math inline">\(2^h \nmid \frac{b_i}{2}\)</span>且<span class="math inline">\(b_i + 1\)</span>是奇数, 因此<span class="math inline">\(2^h \nmid \frac{b_i \cdot(b_i + 1)}{2}\)</span>. 由于<span class="math inline">\(\frac{b_i \cdot(b_i + 1)}{2 \cdot g&#39;} \mod 2^h = 2^{h-1}\)</span>, 如果这种情况下的<span class="math inline">\(b_i\)</span>个数有偶数个, 那它们的和仍然可以被<span class="math inline">\(2^h\)</span>整除.</p></li>
<li><p><span class="math inline">\(l &lt; h\)</span>. 由于<span class="math inline">\(g \geq 2^h\)</span>, 不可能存在这种情况.</p></li>
</ul>
<p>综上可知, 当序列中全为偶数时, 按能被<span class="math inline">\(2^l\)</span>整除的最大<span class="math inline">\(l\)</span>来对<span class="math inline">\(b_i\)</span>分类, 当且仅当<span class="math inline">\(l\)</span>最小那组的个数为偶数时序列合法. 在统计时可以枚举最小的<span class="math inline">\(l\)</span>.</p>
<p>总时间复杂度<span class="math inline">\(n \log (\max\{a_i\})\)</span></p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="function">mt19937 <span class="title">Rand</span><span class="params">(chrono::steady_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">10</span>;<span class="comment">//CHANGE IT!</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = maxn*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">1e9</span>+<span class="number">7</span>;<span class="comment">//CHANGE IT!</span></span><br><span class="line">ll fac[maxn],cnt[maxn];</span><br><span class="line"><span class="function">ll <span class="title">Pow</span><span class="params">(ll x,ll d,ll p = p)</span></span>&#123;ll ta=<span class="number">1</span>;<span class="keyword">if</span>(d==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>%p;x %= p;ll a=<span class="built_in">Pow</span>(x,d/<span class="number">2</span>,p);ta=a*a%p;<span class="keyword">if</span>(d%<span class="number">2</span>)ta=ta*x%p;<span class="keyword">return</span> ta%p;&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n,ll m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(m &gt; n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> (fac[n]*<span class="built_in">Pow</span>(fac[m],p<span class="number">-2</span>)%p*<span class="built_in">Pow</span>(fac[n-m],p<span class="number">-2</span>)%p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">setf</span>(ios::fixed,ios::floatfield);</span><br><span class="line">	cout.<span class="built_in">precision</span>(<span class="number">12</span>);	 </span><br><span class="line">	fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; maxn;i++)fac[i] = fac[i<span class="number">-1</span>]*i%p;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">int</span> odd = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		<span class="keyword">if</span>(x&amp;<span class="number">1</span>)odd++;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">int</span> qwq = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(x%<span class="number">2</span> == <span class="number">0</span>)qwq++,x /= <span class="number">2</span>;</span><br><span class="line">			cnt[qwq+<span class="number">1</span>]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans = (<span class="built_in">Pow</span>(<span class="number">2</span>,odd) - <span class="number">1</span> + p)%p*(<span class="built_in">Pow</span>(<span class="number">2</span>,n - odd)) % p;</span><br><span class="line">	ll res = n - odd;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= <span class="number">32</span>;k++)<span class="keyword">if</span>(cnt[k])&#123;</span><br><span class="line">		ll tmp = <span class="number">0</span>;</span><br><span class="line">		res -= cnt[k];</span><br><span class="line">		ans = (ans + (<span class="built_in">Pow</span>(<span class="number">2</span>,cnt[k] - <span class="number">1</span>) - <span class="number">1</span> + p)%p * <span class="built_in">Pow</span>(<span class="number">2</span>,res) % p) % p;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://linkinpony.github.io/2021/10/17/solution-ABC213E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LinkinPony">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="I always love dashie">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/10/17/solution-ABC213E/" class="post-title-link" itemprop="url">solution-ABC213E</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-10-17 16:17:31" itemprop="dateCreated datePublished" datetime="2021-10-17T16:17:31+08:00">2021-10-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://linkinpony.github.io/2021/09/16/solution-HDU7059/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LinkinPony">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="I always love dashie">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/16/solution-HDU7059/" class="post-title-link" itemprop="url">[题解]HDU7059-Counting Stars</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-09-16 19:53:14 / Modified: 20:03:48" itemprop="dateCreated datePublished" datetime="2021-09-16T19:53:14+08:00">2021-09-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%A2%98%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">题解</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="题意">题意</h2>
<p>本题是2021东北四省赛<a target="_blank" rel="noopener" href="https://codeforces.com/gym/103145/problem/D">D-Lowbit</a> 的强化版.</p>
<p>给出一个长度为<span class="math inline">\(n\)</span>的数列<span class="math inline">\(raw[]\)</span>, 维护下列三种操作:</p>
<p><code>1 l r</code>查询<span class="math inline">\(raw[l] + raw[l+1] + ... + raw[r]\)</span>对<span class="math inline">\(998244353\)</span>取模的值</p>
<p><code>2 l r</code>对区间<span class="math inline">\([l,r]\)</span>里的每个值分别减去其lowbit</p>
<p><code>3 l r</code>对区间<span class="math inline">\([l,r]\)</span>里的每个值分别加上其最高位的值</p>
<p><span class="math inline">\(1 \leq n,q \leq 10^5\)</span></p>
<h2 id="题解">题解</h2>
<p>容易发现对于操作2, 每个数<span class="math inline">\(a_i\)</span>在减去最多<span class="math inline">\(\log a_i\)</span>次后就会变成0. 因而我们暴力模拟这个过程, 同时用<span class="math inline">\(full[x] = 1\)</span>表示该节点下的所有值全部为0, 在之后的操作2中将这种节点忽略即可.</p>
<p>对于操作3, 只需把最高位拆出来单独维护即可. 注意操作2会影响到拆出来的最高位.</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="function">mt19937 <span class="title">Rand</span><span class="params">(chrono::steady_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">10</span>;<span class="comment">//CHANGE IT!</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = maxn*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">998244353</span>;<span class="comment">//CHANGE IT!</span></span><br><span class="line"><span class="keyword">int</span> p2[maxn];</span><br><span class="line"><span class="function">ll <span class="title">Pow</span><span class="params">(ll x,ll d)</span></span>&#123;ll ta=<span class="number">1</span>;<span class="keyword">if</span>(d==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>%p;x %= p;ll a=<span class="built_in">Pow</span>(x,d/<span class="number">2</span>);ta=a*a%p;<span class="keyword">if</span>(d%<span class="number">2</span>)ta=ta*x%p;<span class="keyword">return</span> ta%p;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segtree</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> siz = <span class="number">1</span>;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;hbit,addv,subv,sumv;</span><br><span class="line">	vector&lt;<span class="keyword">bool</span>&gt;full;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(siz &lt; n)siz *= <span class="number">2</span>;</span><br><span class="line">		hbit.<span class="built_in">assign</span>(siz*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">		addv.<span class="built_in">assign</span>(siz*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">		sumv.<span class="built_in">assign</span>(siz*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">		full.<span class="built_in">assign</span>(siz*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">highbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">30</span>;i &gt;= <span class="number">0</span>;i--)<span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;i)&amp;x)<span class="keyword">return</span> (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(full[<span class="built_in">ls</span>(x)] <span class="keyword">and</span> full[<span class="built_in">rs</span>(x)])full[x] = <span class="number">1</span>;</span><br><span class="line">		sumv[x] = (sumv[<span class="built_in">ls</span>(x)] + sumv[<span class="built_in">rs</span>(x)])%p;</span><br><span class="line">		hbit[x] = (hbit[<span class="built_in">ls</span>(x)] + hbit[<span class="built_in">rs</span>(x)])%p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(addv[x])&#123;</span><br><span class="line">			<span class="keyword">int</span> &amp; v = addv[x];</span><br><span class="line">			addv[<span class="built_in">ls</span>(x)] += v,addv[<span class="built_in">rs</span>(x)] += v;</span><br><span class="line">			hbit[<span class="built_in">ls</span>(x)] = (hbit[<span class="built_in">ls</span>(x)] * p2[v])%p;</span><br><span class="line">			hbit[<span class="built_in">rs</span>(x)] = (hbit[<span class="built_in">rs</span>(x)] * p2[v])%p;</span><br><span class="line">			v = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp; in,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(lx &lt; (<span class="keyword">int</span>)in.<span class="built_in">size</span>())&#123;</span><br><span class="line">				<span class="keyword">int</span> h = <span class="built_in">highbit</span>(in[lx]);</span><br><span class="line">				hbit[x] = h;</span><br><span class="line">				in[lx] -= h;</span><br><span class="line">				sumv[x] = in[lx];</span><br><span class="line">				<span class="keyword">if</span>(!sumv[x] <span class="keyword">and</span> !hbit[x])full[x] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">build</span>(in,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="built_in">build</span>(in,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="built_in">pushup</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp; in)</span></span>&#123;</span><br><span class="line">		<span class="built_in">build</span>(in,<span class="number">0</span>,<span class="number">0</span>,siz);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx &gt; <span class="number">1</span>)<span class="built_in">pushdown</span>(x);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			hbit[x] = (hbit[x]*<span class="number">2</span>)%p;</span><br><span class="line">			addv[x]++;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">add</span>(l,r,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="built_in">add</span>(l,r,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="built_in">pushup</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		r++;</span><br><span class="line">		<span class="built_in">add</span>(l,r,<span class="number">0</span>,<span class="number">0</span>,siz);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx &gt; <span class="number">1</span>)<span class="built_in">pushdown</span>(x);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			<span class="keyword">if</span>(full[x])&#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(!sumv[x])&#123;</span><br><span class="line">					full[x] = <span class="number">1</span>;</span><br><span class="line">					hbit[x] = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				sumv[x] -= <span class="built_in">lowbit</span>(sumv[x]);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">sub</span>(l,r,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="built_in">sub</span>(l,r,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="built_in">pushup</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		r++;</span><br><span class="line">		<span class="built_in">sub</span>(l,r,<span class="number">0</span>,<span class="number">0</span>,siz);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx &gt; <span class="number">1</span>)<span class="built_in">pushdown</span>(x);</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)&#123;</span><br><span class="line">			<span class="keyword">return</span> (sumv[x] + hbit[x])%p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		ll s1 = <span class="built_in">sum</span>(l,r,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		ll s2 = <span class="built_in">sum</span>(l,r,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="keyword">return</span> (s1+s2)%p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		r++;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">sum</span>(l,r,<span class="number">0</span>,<span class="number">0</span>,siz);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">setf</span>(ios::fixed,ios::floatfield);</span><br><span class="line">	cout.<span class="built_in">precision</span>(<span class="number">12</span>);</span><br><span class="line">	p2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; maxn;i++)p2[i] = p2[i<span class="number">-1</span>]*<span class="number">2</span>%p;	 </span><br><span class="line">	<span class="keyword">int</span> __;</span><br><span class="line">	cin &gt;&gt; __;</span><br><span class="line">	<span class="keyword">while</span>(__--)&#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">in</span>(n+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)cin &gt;&gt; in[i];</span><br><span class="line">		Segtree seg;</span><br><span class="line">		seg.<span class="built_in">init</span>(n+<span class="number">10</span>);</span><br><span class="line">		seg.<span class="built_in">build</span>(in);</span><br><span class="line">		<span class="keyword">int</span> q;</span><br><span class="line">		cin &gt;&gt; q;</span><br><span class="line">		<span class="keyword">while</span>(q--)&#123;</span><br><span class="line">			<span class="keyword">int</span> opt,l,r;</span><br><span class="line">			cin &gt;&gt; opt &gt;&gt; l &gt;&gt; r;</span><br><span class="line">			<span class="keyword">if</span>(opt == <span class="number">1</span>)cout &lt;&lt; seg.<span class="built_in">sum</span>(l,r) &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">2</span>)seg.<span class="built_in">sub</span>(l,r);</span><br><span class="line">			<span class="keyword">else</span> seg.<span class="built_in">add</span>(l,r);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://linkinpony.github.io/2021/09/14/solution-CF1567E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LinkinPony">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="I always love dashie">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/14/solution-CF1567E/" class="post-title-link" itemprop="url">[题解]-CF1567E Non-Decreasing Dilemma</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-09-14 21:40:50" itemprop="dateCreated datePublished" datetime="2021-09-14T21:40:50+08:00">2021-09-14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-09-16 19:51:37" itemprop="dateModified" datetime="2021-09-16T19:51:37+08:00">2021-09-16</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BA%BF%E6%AE%B5%E6%A0%91/" itemprop="url" rel="index"><span itemprop="name">线段树</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="题意">题意</h2>
<p>给出<span class="math inline">\(raw[]\)</span>和两种操作:</p>
<ol type="1">
<li><span class="math inline">\(x\space v\)</span>, 将<span class="math inline">\(raw[x]\)</span>修改为<span class="math inline">\(v\)</span></li>
<li><span class="math inline">\(l \space r\)</span>, 询问<span class="math inline">\(raw[l],raw[l+1],...,raw[r]\)</span>中有多少合法的数对<span class="math inline">\((i,j)\)</span>满足<span class="math inline">\(l \leq i \leq j \leq r\)</span>且<span class="math inline">\(raw[i]...raw[j]\)</span>单调不降</li>
</ol>
<p><span class="math inline">\(1 \leq n,q \leq 2\cdot10^5\)</span></p>
<h2 id="题解">题解</h2>
<p>线段树维护区间合并. 以下<span class="math inline">\(x\)</span>代表线段树节点标号, <span class="math inline">\(ls(x)\)</span>和<span class="math inline">\(rs(x)\)</span>分别代表左右儿子节点标号</p>
<p>容易发现对于每段长度为<span class="math inline">\(m\)</span>的单调不降子序列, 其对答案的贡献是<span class="math inline">\(\frac{m\cdot (m+1)}2\)</span></p>
<p>建一颗线段树, 维护如下信息:</p>
<p>​ <span class="math inline">\(prev[x]\)</span>: 自节点<span class="math inline">\(x\)</span>的最左端开始的最长单调不降子序列的长度</p>
<p>​ <span class="math inline">\(sufv[x]\)</span>: 自节点<span class="math inline">\(x\)</span>的最右端结束的最长单调不降子序列的长度</p>
<p>​ <span class="math inline">\(totv[x]\)</span>: 节点<span class="math inline">\(x\)</span>有多少合法数对<span class="math inline">\((i,j)\)</span>满足题意</p>
<p>有几点细节需要注意:</p>
<ol type="1">
<li><p>对于<span class="math inline">\(prev[x]\)</span>, 只有其左儿子的<span class="math inline">\(prev[ls(x)]\)</span>等于区间长度, 并且左儿子和右儿子的连接处不降(即<span class="math inline">\(raw[m-1] &lt;= raw[m])\)</span>时才有<span class="math inline">\(prev[x] = prev[ls(x)] + prev[rs(x)]\)</span>. <span class="math inline">\(sufv[]\)</span>的维护同理</p></li>
<li><p>对于<span class="math inline">\(totv[x]\)</span>, 显然有<span class="math inline">\(totv[x] += totv[ls(x)] + totv[rs(x)]\)</span>. 而当其左儿子和右儿子的连接处不降时, 还需加上<span class="math inline">\(sufv[ls(x)] \cdot prev[rs(x)]\)</span>, 即新增合法区间的左端点全部从左儿子中选, 右端点全部从右儿子中选.</p></li>
<li><p>在统计答案时, 需要处理当前节点区间比询问区间大的情况</p></li>
</ol>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="function">mt19937 <span class="title">Rand</span><span class="params">(chrono::steady_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">8e5</span>+<span class="number">10</span>;<span class="comment">//CHANGE IT!</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = maxn*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">1e9</span>+<span class="number">7</span>;<span class="comment">//CHANGE IT!</span></span><br><span class="line"><span class="keyword">int</span> raw[maxn];</span><br><span class="line"><span class="function">ll <span class="title">Pow</span><span class="params">(ll x,ll d,ll p)</span></span>&#123;ll ta=<span class="number">1</span>;<span class="keyword">if</span>(d==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>%p;x %= p;ll a=<span class="built_in">Pow</span>(x,d/<span class="number">2</span>,p);ta=a*a%p;<span class="keyword">if</span>(d%<span class="number">2</span>)ta=ta*x%p;<span class="keyword">return</span> ta%p;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segtree</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> siz = <span class="number">1</span>;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;prev,sufv,totv;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(siz &lt; n)siz *= <span class="number">2</span>;</span><br><span class="line">		prev.<span class="built_in">assign</span>(siz*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">		sufv.<span class="built_in">assign</span>(siz*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">		totv.<span class="built_in">assign</span>(siz*<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x*(x+<span class="number">1</span>)/<span class="number">2</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> len = (rx - lx)/<span class="number">2</span>;</span><br><span class="line">		totv[x] = totv[<span class="built_in">ls</span>(x)] + totv[<span class="built_in">rs</span>(x)];</span><br><span class="line">		totv[x] += (raw[m<span class="number">-1</span>] &lt;= raw[m]?sufv[<span class="built_in">ls</span>(x)]*prev[<span class="built_in">rs</span>(x)]:<span class="number">0</span>);</span><br><span class="line">		prev[x] = <span class="built_in">max</span>(prev[<span class="built_in">ls</span>(x)],(prev[<span class="built_in">ls</span>(x)] == len <span class="keyword">and</span> raw[m<span class="number">-1</span>] &lt;= raw[m])?prev[<span class="built_in">ls</span>(x)] + prev[<span class="built_in">rs</span>(x)]:<span class="number">0</span>);</span><br><span class="line">		sufv[x] = <span class="built_in">max</span>(sufv[<span class="built_in">rs</span>(x)],(sufv[<span class="built_in">rs</span>(x)] == len <span class="keyword">and</span> raw[m<span class="number">-1</span>] &lt;= raw[m])?sufv[<span class="built_in">rs</span>(x)] + sufv[<span class="built_in">ls</span>(x)]:<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> v,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(rx - lx == <span class="number">1</span>)&#123;</span><br><span class="line">			raw[idx] = v;</span><br><span class="line">			prev[x] = sufv[x] = totv[x] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(lx &lt;= idx <span class="keyword">and</span> idx &lt; m)<span class="built_in">Set</span>(idx,v,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">Set</span>(idx,v,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		<span class="built_in">pushup</span>(x,lx,rx);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		<span class="built_in">Set</span>(idx,v,<span class="number">0</span>,<span class="number">0</span>,siz);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">cal</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> lx,<span class="keyword">int</span> rx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l &gt;= rx <span class="keyword">or</span> lx &gt;= r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(l &lt;= lx <span class="keyword">and</span> rx &lt;= r)<span class="keyword">return</span> totv[x];</span><br><span class="line">		<span class="keyword">int</span> m = (lx+rx)/<span class="number">2</span>;</span><br><span class="line">		ll s1 = <span class="built_in">cal</span>(l,r,<span class="built_in">ls</span>(x),lx,m);</span><br><span class="line">		ll s2 = <span class="built_in">cal</span>(l,r,<span class="built_in">rs</span>(x),m,rx);</span><br><span class="line">		ll ans = s1+s2;</span><br><span class="line">		<span class="keyword">if</span>(raw[m<span class="number">-1</span>] &lt;= raw[m])&#123;</span><br><span class="line">			ans += <span class="built_in">max</span>(<span class="built_in">min</span>(m - l,sufv[<span class="built_in">ls</span>(x)]),<span class="number">0LL</span>)*<span class="built_in">max</span>(<span class="built_in">min</span>(r - m,prev[<span class="built_in">rs</span>(x)]),<span class="number">0LL</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">cal</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		r++;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">cal</span>(l,r,<span class="number">0</span>,<span class="number">0</span>,siz);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">setf</span>(ios::fixed,ios::floatfield);</span><br><span class="line">	cout.<span class="built_in">precision</span>(<span class="number">12</span>);	 </span><br><span class="line">	<span class="keyword">int</span> n,q;</span><br><span class="line">	Segtree seg;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)raw[i] = <span class="number">0</span>;</span><br><span class="line">	seg.<span class="built_in">init</span>(n+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> v;</span><br><span class="line">		cin &gt;&gt; v;</span><br><span class="line">		seg.<span class="built_in">Set</span>(i,v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(q--)&#123;</span><br><span class="line">		<span class="keyword">int</span> opt,l,r;</span><br><span class="line">		cin &gt;&gt; opt &gt;&gt; l &gt;&gt; r;</span><br><span class="line">		<span class="keyword">if</span>(opt == <span class="number">1</span>)seg.<span class="built_in">Set</span>(l,r);</span><br><span class="line">		<span class="keyword">else</span> cout &lt;&lt; seg.<span class="built_in">cal</span>(l,r) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://linkinpony.github.io/2021/08/25/solution-CF1561D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LinkinPony">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="I always love dashie">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/25/solution-CF1561D/" class="post-title-link" itemprop="url">[题解]CF1561D/CF1560B-Up the Strip</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-08-25 01:24:50 / Modified: 02:06:41" itemprop="dateCreated datePublished" datetime="2021-08-25T01:24:50+08:00">2021-08-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%A2%98%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">题解</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="题解">题解</h2>
<p>设<span class="math inline">\(f[i]\)</span>为从<span class="math inline">\(n\)</span>走到<span class="math inline">\(i\)</span>的方案数. 分减法和整除两种情况分别讨论: <span class="math display">\[
\begin{align}
减法:&amp;\\
f[i] &amp;= \sum_{j = i}^nf[j]\\
整除:&amp;\\
f[i] &amp;= \sum_{j = i}^{i*j&lt;= n}\sum_{\lfloor \frac{k}{j} \rfloor = i}f[k]\\
&amp;= \sum_{j = i}^{i*j&lt;= n}\sum_{k = i*j}^{(i+1)*j - 1}f[k]\\
&amp;= \sum_{j = i}^{i*j&lt;= n}suf[j] - suf[(i+1)*j]\\
其中&amp;suf[i] = \sum_{j = i}^n f[i]\\
\end{align}
\]</span></p>
<p>综上, 递推式为 <span class="math display">\[
\begin{align}
f[n] &amp;= suf[n] = 1\\
suf[i] &amp;=suf[i+1] + f[i]\\
f[i] &amp;= suf[i+1]+\sum_{j = 1}^{i*j &lt;= n}suf[j] - suf[(i+1)*j]
\end{align}
\]</span> 注意处理<span class="math inline">\((i+1)*j\)</span>越界的问题. 复杂度<span class="math inline">\(O(n\ln n)\)</span></p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="function">mt19937 <span class="title">Rand</span><span class="params">(chrono::steady_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4e6</span>+<span class="number">10</span>;<span class="comment">//CHANGE IT!</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = maxn*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> p;</span><br><span class="line"><span class="function">ll <span class="title">Pow</span><span class="params">(ll x,ll d)</span></span>&#123;ll ta=<span class="number">1</span>;<span class="keyword">if</span>(d==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>%p;ll a=<span class="built_in">Pow</span>(x,d/<span class="number">2</span>);ta=a*a%p;<span class="keyword">if</span>(d%<span class="number">2</span>)ta=ta*x%p;<span class="keyword">return</span> ta%p;&#125;</span><br><span class="line">ll f[maxn],pre[maxn];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">setf</span>(ios::fixed,ios::floatfield);</span><br><span class="line">	cout.<span class="built_in">precision</span>(<span class="number">12</span>);	 </span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; p;</span><br><span class="line">	f[n] = pre[n] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>;i &gt;= <span class="number">1</span>;i--)&#123;</span><br><span class="line">		f[i] = pre[i+<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>;i*j &lt;= n;j++)&#123;</span><br><span class="line">			f[i] = (f[i] + (pre[i*j] - ((i+<span class="number">1</span>)*(j) &gt; maxn?<span class="number">0</span>:pre[(i+<span class="number">1</span>)*(j)])))%p;</span><br><span class="line">		&#125;</span><br><span class="line">		pre[i] = (f[i] + pre[i+<span class="number">1</span>])%p;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; f[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://linkinpony.github.io/2021/08/11/solution-HDU7047/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LinkinPony">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="I always love dashie">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/11/solution-HDU7047/" class="post-title-link" itemprop="url">[题解]HDU7047-Link with Balls</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-11 09:33:08" itemprop="dateCreated datePublished" datetime="2021-08-11T09:33:08+08:00">2021-08-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-08-16 23:02:15" itemprop="dateModified" datetime="2021-08-16T23:02:15+08:00">2021-08-16</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%A2%98%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">题解</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="题意">题意</h2>
<p>给你两类盒子, 每类<span class="math inline">\(n\)</span>个, 编号分别从<span class="math inline">\(1\)</span>到<span class="math inline">\(n\)</span>.</p>
<p>​ 第一类: 可以从第<span class="math inline">\(i\)</span>个盒子里拿出<span class="math inline">\(i\)</span>的任意非负整数倍数个小球</p>
<p>​ 第二类: 可以从第<span class="math inline">\(i\)</span>个盒子里拿出最少<span class="math inline">\(0\)</span>个最多<span class="math inline">\(i\)</span>个小球.</p>
<p>多组数据<span class="math inline">\((1 \leq t \leq 10^5)\)</span>, 每组数据给出<span class="math inline">\(1 \leq n,m \leq 10^6\)</span>, 求从这<span class="math inline">\(2n\)</span>个盒子里拿出<span class="math inline">\(m\)</span>个小球的方案数模<span class="math inline">\(1e9+7\)</span>.</p>
<h2 id="题解">题解</h2>
<p>懒得从组合意义的角度考虑, 可以用生成函数去做.</p>
<p>第一类第<span class="math inline">\(i\)</span>个盒子对应的生成函数是 <span class="math display">\[
\sum_{j = 0}^{∞}x^{i\cdot j}
\]</span></p>
<p>第二类对应的是 <span class="math display">\[
\sum_{j = 0}^ix^i
\]</span></p>
<p>那么答案即为: <span class="math display">\[
[m](\prod_{i = 1}^{n}\sum_{j = 0}^{∞}x^{i\cdot j})\cdot(\prod_{i = 1}^{n}\sum_{j = 0}^ix^i) \\
=[m](\prod_{i = 1}^{n}\frac{1}{1 - x^i})\cdot(\prod_{i = 1}^{n}\frac{1-x^{i+1}}{1-x})\\
=[m]\frac{1-x^{n+1}}{(1-x)^{n+1}}\\
=[m](1-x^{n+1})\cdot \sum_{i = 0}^{∞}C_{n+i}^ix^i\\
= C_{n+m}^m - C_{m-1}^{n}
\]</span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://linkinpony.github.io/2021/04/04/solution-CF958F3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LinkinPony">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="I always love dashie">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/04/solution-CF958F3/" class="post-title-link" itemprop="url">[题解]CF958F3 Lightsabers (hard)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-04 15:49:17" itemprop="dateCreated datePublished" datetime="2021-04-04T15:49:17+08:00">2021-04-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-04-05 12:30:47" itemprop="dateModified" datetime="2021-04-05T12:30:47+08:00">2021-04-05</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%A2%98%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">题解</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="题意">题意</h2>
<p>给出<span class="math inline">\(m\)</span>个集合, 第<span class="math inline">\(i\)</span>个集合有<span class="math inline">\(c_i\)</span>种颜色为<span class="math inline">\(i\)</span>的小球, 保证<span class="math inline">\(\sum_{i = 1}^m c_i = n\)</span>. 现从这些集合中取出<span class="math inline">\(k\)</span>个小球, 问这些小球构成的集合有多少种. 答案模<span class="math inline">\(1009\)</span>.</p>
<p><span class="math inline">\(1 \leq m,k \leq n \leq 2\cdot 10^5\)</span></p>
<h2 id="题解">题解</h2>
<p>普通型生成函数裸题.</p>
<p>设<span class="math inline">\(G(x) = \prod_{i = 1}^m(\sum_{j = 0}^{c_i}x^j)\)</span></p>
<p>那么<span class="math inline">\(G(x)[k]\)</span>即为答案. 问题转换为<span class="math inline">\(m\)</span>个多项式相乘. 使用分治法可在<span class="math inline">\(O(n\log^2n)\)</span>时间内用FFT求解.</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">1009</span>;</span><br><span class="line"><span class="keyword">int</span> raw[maxn],cnt[maxn];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="keyword">int</span>&gt; Poly;</span><br><span class="line"><span class="keyword">const</span> ld PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">int</span> rev[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Comp</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    <span class="built_in">Comp</span> (<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>):<span class="built_in">x</span>(x),<span class="built_in">y</span>(y)&#123;&#125;</span><br><span class="line">    Comp <span class="keyword">operator</span> * (Comp B)&#123;</span><br><span class="line">   		<span class="keyword">return</span> <span class="built_in">Comp</span>(x*B.x - y*B.y,x*B.y + y*B.x);</span><br><span class="line">	&#125;</span><br><span class="line">	Comp <span class="keyword">operator</span> + (Comp B)&#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="built_in">Comp</span>(x + B.x,y + B.y);</span><br><span class="line">	&#125;</span><br><span class="line">	Comp <span class="keyword">operator</span> - (Comp B)&#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="built_in">Comp</span>(x - B.x,y - B.y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Comp F1[maxn],F2[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Comp * A,<span class="keyword">int</span> siz,<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = siz;</span><br><span class="line">	<span class="keyword">int</span> S = <span class="built_in">log2</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)rev[i] = (rev[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (S - <span class="number">1</span>));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)<span class="keyword">if</span>(i &lt; rev[i])<span class="built_in">swap</span>(A[i],A[rev[i]]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i *= <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="function">Comp <span class="title">Wn</span><span class="params">(cos(PI/i),type*sin(PI/i))</span></span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j += i*<span class="number">2</span>)&#123;</span><br><span class="line">			<span class="function">Comp <span class="title">W</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; i;k++)&#123;</span><br><span class="line">				Comp facx = A[j+k],facy = W*A[j+k+i];</span><br><span class="line">				A[j+k] = facx + facy;</span><br><span class="line">				A[j+k+i] = facx - facy;</span><br><span class="line">				W = W*Wn;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>(type == <span class="number">-1</span>)<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)A[i].x = ((A[i].x/n + <span class="number">0.5</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Poly <span class="title">mul</span><span class="params">(Poly A,Poly B)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = A.<span class="built_in">size</span>(),m = B.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">int</span> siz = n + m - <span class="number">1</span>;</span><br><span class="line">	<span class="function">Poly <span class="title">C</span><span class="params">(siz)</span></span>;</span><br><span class="line">	<span class="keyword">if</span>(siz &lt; <span class="number">64</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++)C[i+j] = (C[i+j] + <span class="number">1LL</span>*A[i]*B[j])%p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> C;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> fsiz = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(fsiz &lt;= siz)fsiz *= <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; fsiz;i++)F1[i] = F2[i] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)F1[i] = A[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)F2[i] = B[i];</span><br><span class="line">	<span class="built_in">FFT</span>(F1,fsiz,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">FFT</span>(F2,fsiz,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; fsiz;i++)F1[i] = F1[i]*F2[i];</span><br><span class="line">	<span class="built_in">FFT</span>(F1,fsiz,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; siz;i++)&#123;</span><br><span class="line">		C[i] = ((ll)F1[i].x)%p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Poly <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Poly</span>(cnt[l]+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> m = (l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">mul</span>(<span class="built_in">solve</span>(l,m),<span class="built_in">solve</span>(m+<span class="number">1</span>,r));</span><br><span class="line">&#125;</span><br><span class="line">Poly ans;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n,m,k;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		cnt[x]++;</span><br><span class="line">	&#125;</span><br><span class="line">	Poly ans = <span class="built_in">solve</span>(<span class="number">1</span>,m);</span><br><span class="line">	cout &lt;&lt; ans[k] &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://linkinpony.github.io/2021/04/04/GAMES101/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LinkinPony">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="I always love dashie">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/04/GAMES101/" class="post-title-link" itemprop="url">GAMES101笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-04 15:49:17" itemprop="dateCreated datePublished" datetime="2021-04-04T15:49:17+08:00">2021-04-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2023-02-26 15:52:18" itemprop="dateModified" datetime="2023-02-26T15:52:18+08:00">2023-02-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>部分图片来自<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1X7411F744">GAMES101</a></p>
<h1 id="向量">向量</h1>
<h2 id="基础">基础</h2>
<p>可以直接跳过这部分.</p>
<h3 id="定义">定义</h3>
<p>符号表示: <span class="math inline">\(\vec{a}\)</span> 或<span class="math inline">\(\boldsymbol{a}\)</span>, 或者写成<span class="math inline">\(\vec{AB}\)</span>, 表示从<span class="math inline">\(A\)</span>指向<span class="math inline">\(B\)</span>的向量(<span class="math inline">\(\vec{AB} = B - A\)</span>).</p>
<p>本文中向量均表示列向量, 即<span class="math inline">\(\vec{a} = \begin{pmatrix}x\\y\end{pmatrix}\)</span>. 行向量则<span class="math inline">\(\vec{a}^T = (x,y)\)</span></p>
<p>向量有方向和长度, 一般不指定起点.</p>
<h3 id="长度">长度</h3>
<p><span class="math inline">\(|\vec{a}|\)</span> 或<span class="math inline">\(\Vert\vec{a}\Vert\)</span>(二范数)表示向量的长度. 对于二维向量<span class="math inline">\(\vec{a} = \begin{pmatrix}x\\y\end{pmatrix}\)</span>, <span class="math inline">\(\vert a\vert = \sqrt{x^2 + y^2}\)</span>.</p>
<h3 id="单位向量">单位向量</h3>
<p><span class="math inline">\(\hat{a}\)</span>表示<span class="math inline">\(\vec{a}\)</span>的单位向量, 读作<code>a hat</code>. <span class="math display">\[
\hat{a} = \frac{\vec{a}}{\vert a \vert}
\]</span></p>
<p>一般用单位向量来表示方向</p>
<h2 id="基本运算">基本运算</h2>
<h3 id="加法">加法</h3>
<p><span class="math display">\[
\vec{a} = \begin{pmatrix}x_1\\y_1\end{pmatrix}, \vec{b} = \begin{pmatrix}x_2\\y_2\end{pmatrix}. \space \vec{a} + \vec{b} = \begin{pmatrix}x_1+x_2\\y_1+y_2\end{pmatrix}
\]</span></p>
<p>向量的加法遵循平行四边形法则或三角形法则(如下图)</p>
<p><img src="/.io//Github\hexo\source\_posts\GAMES101.assets\image-20220329112926492-16489935946861.png" alt="image-20220329112926492" style="zoom:33%;"></p>
<p>对于多个向量相加, 按三角形法则将它们依序首尾拼接即可.</p>
<h3 id="点积">点积</h3>
<p><span class="math display">\[
\vec{a} \cdot \vec{b} = \Vert\vec{a}\Vert\Vert\vec{b}\Vert\cos\theta
\]</span></p>
<p><span class="math display">\[
\vec{a} \cdot \vec{b} = \begin{pmatrix}x_1\\y_1\end{pmatrix} \cdot \begin{pmatrix}x_2\\y_2\end{pmatrix} = x_1\cdot x_2 + y_1 \cdot y_2
\]</span></p>
<p>可以写成矩阵形式: <span class="math display">\[
\vec a \cdot \vec b = \vec{a}^T\vec{b} \\
= \left(
\begin{array}{cccc} 
   x_1 &amp; y_1 &amp; z_1\\
\end{array}
\right)  \left(
\begin{array}{cccc} 
   x_2\\
   y_2\\
   z_2
\end{array}
\right)
\]</span> 点积运算符合交换、结合、分配率: <span class="math display">\[
\begin{align}
\vec{a} \cdot \vec{b} &amp;= \vec{b}\cdot\vec{a}\\
\vec{a} \cdot(\vec{b} + \vec{c}) &amp;= \vec{a} \cdot \vec{b} + \vec{a} \cdot \vec{c}\\
(k \vec{a}) \cdot \vec{b} &amp;= \vec{a} \cdot(k\vec{b}) = k(\vec{a}\cdot\vec{b})
\end{align}
\]</span></p>
<h4 id="两向量夹角">两向量夹角</h4>
<p><span class="math display">\[
\cos\theta = \frac{\vec{a}\cdot\vec{b}}{\Vert\vec{a}\Vert\Vert\vec{b}\Vert} = \hat{a}\cdot\hat{b}
\]</span></p>
<h4 id="投影">投影</h4>
<p><span class="math inline">\(\vec{b}\)</span> 在<span class="math inline">\(\vec a\)</span>上的<strong>投影</strong>记作<span class="math inline">\(\vec{b}_{\perp}\)</span>, 读作<code>b perp</code>:</p>
<p>(垂直: perpendicular)</p>
<p><img src="/.io//Github\hexo\source\_posts\GAMES101.assets\image-20220329115232862-16489935976142.png" alt="image-20220329115232862" style="zoom: 50%;"> <span class="math display">\[
\vec{b}_{\perp} = k\hat{a}
\]</span> 其中<span class="math inline">\(k = \Vert \vec{b}_{\perp}\Vert = \Vert \vec{b}\Vert \cos \theta\)</span></p>
<p>投影可以将向量<span class="math inline">\(\vec b\)</span>分解成平行于<span class="math inline">\(\vec a\)</span>(<span class="math inline">\(\vec{b}_{\perp}\)</span>)和垂直于<span class="math inline">\(\vec a\)</span>(<span class="math inline">\(\vec{b} - \vec{b}_{\perp}\)</span>)两部分, 如下图:</p>
<p><img src="/.io//Github\hexo\source\_posts\GAMES101.assets\image-20220329121632672-16489936041923.png" alt="image-20220329121632672" style="zoom:50%;"></p>
<h4 id="判断两向量方向">判断两向量方向</h4>
<p><img src="/.io//Github\hexo\source\_posts\GAMES101.assets\image-20220329121938192-16489936060574.png" alt="image-20220329121938192" style="zoom:50%;"></p>
<p>如图, 两向量的点积大于<span class="math inline">\(0\)</span>则相向, 小于<span class="math inline">\(0\)</span>则反向, 等于<span class="math inline">\(0\)</span>则互相垂直.</p>
<h3 id="叉积">叉积</h3>
<p><span class="math display">\[
\vec{a} = \begin{pmatrix}x_1\\y_1\\z_1\end{pmatrix},\vec{b} = \begin{pmatrix}x_2\\y_2\\z_2\end{pmatrix}
\]</span></p>
<p><span class="math inline">\(\vec{a} \times \vec{b}\)</span>可用如下矩阵的行列式来计算: <span class="math display">\[
\vec{a} \times \vec{b} =  \left|
\begin{array}{cccc} 
    \vec{i}  &amp;  \vec{j}   &amp; \vec{k} \\ 
   x_1  &amp;  y_1   &amp; z_1\\ 
    x_2  &amp;  y_2   &amp; z_2 
\end{array}
\right| \\= (y_1z_2 - y_2z_1) \vec{i} + (x_2z_1 - x_1z_2)\vec{j} + (x_1y_2 - x_2y_1)\vec{k}
\]</span></p>
<p>写成矩阵形式: <span class="math display">\[
\vec a \times \vec b = A^* \vec b =  \left(
\begin{array}{cccc} 
   0 &amp; -z_1 &amp; y_1\\
   z_1 &amp; 0 &amp; -x_1\\
   -y_1 &amp; x_1 &amp; 0
\end{array}
\right) \left(
\begin{array}{cccc} 
   x_2\\
   y_2\\
   z_2
\end{array}
\right)
\]</span> <span class="math inline">\(A^*\)</span>称为<code>dual martix</code>.</p>
<p><img src="/.io//Github\hexo\source\_posts\GAMES101.assets\image-20220329122335871-16489936088105.png" alt="image-20220329122335871" style="zoom:50%;"></p>
<p>两向量<span class="math inline">\(\vec a\)</span> <span class="math inline">\(\vec b\)</span> 叉积得到一个垂直于二者的向量.</p>
<p>该向量的方向可用<strong>右手螺旋定则</strong>判断: 伸出右手, 将四指按从<span class="math inline">\(\vec a\)</span>​扫向<span class="math inline">\(\vec b\)</span>​​​​的方向弯曲, 拇指的指向就是该向量的方向. 遵从该定则的坐标系称为<strong>右手系</strong>.</p>
<p>叉积的运算不满足交换律, 基本关系如下:</p>
<p><span class="math display">\[
\vec a \times \vec b = - \vec b \times \vec a\\
\vec a \times \vec a =  \vec 0\\
\vec a \times (\vec b + \vec c) = \vec a \times \vec b + \vec a \times \vec c\\
\vec a \times (k \vec b) = k (\vec a \times \vec b)
\]</span></p>
<h4 id="判断两向量左右关系">判断两向量左右关系</h4>
<p><img src="/.io//Github\hexo\source\_posts\GAMES101.assets\image-20220331101601190-16489936107926.png" alt="image-20220331101601190" style="zoom:33%;"></p>
<p>如图, 计算<span class="math inline">\(\vec{c} = \vec{a} \times \vec{b}\)</span>, 若<span class="math inline">\(\vec{c}\)</span>与<span class="math inline">\(z\)</span>轴同向(<span class="math inline">\(z\)</span>的系数为正)则<span class="math inline">\(\vec{b}\)</span>在<span class="math inline">\(\vec{a}\)</span>的左边, 否则<span class="math inline">\(\vec{b}\)</span>在<span class="math inline">\(\vec{a}\)</span>​的右边.</p>
<h4 id="判断点是否在凸多边形内部">判断点是否在凸多边形内部</h4>
<p><img src="/.io//Github\hexo\source\_posts\GAMES101.assets\image-20220331103128802-16489936123257.png" alt="image-20220331103128802" style="zoom:33%;"></p>
<p>将凸多边形的点逆时针/顺时针排列, 将待判断的点与每条边进行叉乘, 若点均在边的左侧/右侧则该点在凸多边形内部. (注意这是<span class="math inline">\(O(n)\)</span>的,<span class="math inline">\(O(\log n)\)</span>​的做法右转计算几何板子).</p>
<h2 id="正交坐标系">正交坐标系</h2>
<p>假设向量<span class="math inline">\(\vec{x},\vec{y},\vec{z}\)</span>满足 <span class="math display">\[
\Vert \vec{x} \Vert = \Vert \vec{y} \Vert = \Vert \vec{z} \Vert = 1\\
\vec{x} \cdot \vec{y} = \vec{x} \cdot \vec{z} = \vec{y} \cdot \vec{z} = 0\\
\vec{x} \times \vec{y} = \vec{z}
\]</span> 那么<span class="math inline">\(\vec{x},\vec{y},\vec{z}\)</span>​组成一个正交坐标系, 且是右手系.</p>
<p>对于任意向量<span class="math inline">\(\vec p\)</span>, 可通过投影将其分解为三个基底的和: <span class="math display">\[
\vec p = (\vec p \cdot \vec x)\vec x + (\vec p \cdot \vec y )\vec y + (\vec p \cdot \vec z)\vec z
\]</span></p>
<h1 id="矩阵">矩阵</h1>
<h2 id="矩阵乘法">矩阵乘法</h2>
<p>设<span class="math inline">\(A\)</span>是一个<span class="math inline">\(n \times m\)</span>的矩阵, <span class="math inline">\(B\)</span>是一个<span class="math inline">\(m \times k\)</span>的矩阵, 那么<span class="math inline">\(A \times B\)</span>得到一个<span class="math inline">\(n \times k\)</span>的矩阵<span class="math inline">\(C\)</span>, 其中 <span class="math display">\[
C_{i,j} = \sum_{k = 1}^m A_{i,k} \cdot B_{k,j}
\]</span> <strong>矩阵乘法不存在交换律</strong> <span class="math display">\[
AB(C) = A(BC)\\
A(B+C) = AB + AC\\
(A+B)C = AC + BC
\]</span></p>
<h2 id="转置">转置</h2>
<p>将行和列互换. 例如 <span class="math display">\[
 \left(
\begin{array}{cccc} 
   1 &amp; 2 &amp; 3\\
   4 &amp; 5 &amp; 6
\end{array}
\right)^T =  \left(
\begin{array}{cccc} 
   1 &amp; 4\\
   2 &amp; 5\\
   3 &amp; 6
\end{array}
\right)
\]</span></p>
<p><span class="math display">\[
(AB)^T = B^TA^T
\]</span></p>
<h2 id="单位矩阵">单位矩阵</h2>
<p>主对角线为<span class="math inline">\(1\)</span>, 其余元素为<span class="math inline">\(0\)</span>的方阵, 记为<span class="math inline">\(I_n\)</span> 例如 <span class="math display">\[
I_3 =  \left(
\begin{array}{cccc} 
   1 &amp; 0 &amp; 0\\
   0 &amp; 1 &amp; 0\\
   0 &amp; 0 &amp; 1
\end{array}
\right)
\]</span></p>
<p><span class="math display">\[
AI_m = I_nA = A
\]</span></p>
<p>可以用来定义矩阵的逆: <span class="math display">\[
AA^{-1} = I
\]</span></p>
<p><span class="math display">\[
(AB)^{-1} = B^{-1}A^{-1}
\]</span></p>
<h1 id="平面">平面</h1>
<p>三维平面的一般式方程: <span class="math display">\[
Ax + By + Cz + D = 0
\]</span> 其中平面法线为<span class="math inline">\(\vec n = (A,B,C)^T\)</span></p>
<p>对于任意一点<span class="math inline">\(P(x_0,y_0,z_0)\)</span>, 其到平面的距离为<span class="math inline">\(d = Ax_0 + By_0 + Cz_0 + D\)</span>. 可见<span class="math inline">\(D\)</span>为原点到平面的距离. 当<span class="math inline">\(d &gt; 0\)</span>时说明点<span class="math inline">\(P\)</span>在平面法线所指一侧.</p>
<p>若两点<span class="math inline">\(P_1,P_2\)</span>分列于平面两侧, 且它们到平面的距离为<span class="math inline">\(d_1,d_2\)</span>, 则两点连线与平面的交点可以插值得到: <span class="math display">\[
\lambda = \frac{|d_1|}{|d_1 + d_2|} = \frac{d_1}{d_1 - d_2}
\]</span> <span class="math display">\[
P_{inter} = \lambda P_2 + (1 - \lambda)P_1
\]</span></p>
<h1 id="变换基础知识">变换基础知识</h1>
<h2 id="线性变换">线性变换</h2>
<p>可以表示为<span class="math inline">\(\vec{x&#39;} = A\vec{x}\)</span>的变换均为线性变换.</p>
<h3 id="缩放scale">缩放(Scale)</h3>
<p><img src="/.io//Github\hexo\source\_posts\GAMES101.assets\image-20220401171106621-16489936162318.png" alt="image-20220401171106621" style="zoom:33%;"></p>
<p>将横纵坐标按比例缩放: <span class="math display">\[
x&#39; = sx\\
y&#39; = sy
\]</span> 写为矩阵形式: <span class="math display">\[
\left[
\begin{array}{cccc} 
   x&#39;\\
   y&#39;
\end{array}
\right] = \left[
\begin{array}{cccc} 
   s &amp; 0\\
   0 &amp; s
\end{array}
\right]\left[
\begin{array}{cccc} 
   x\\
   y
\end{array}
\right]
\]</span> <img src="/.io//Github\hexo\source\_posts\GAMES101.assets\image-20220401171133617-16489936178929.png" alt="image-20220401171133617" style="zoom:33%;"></p>
<p>横纵坐标按不同比例缩放: <span class="math display">\[
\left[
\begin{array}{cccc} 
   x&#39;\\
   y&#39;
\end{array}
\right] = \left[
\begin{array}{cccc} 
   s_x &amp; 0\\
   0 &amp; s_y
\end{array}
\right]\left[
\begin{array}{cccc} 
   x\\
   y
\end{array}
\right]
\]</span></p>
<h3 id="反射reflection">反射(Reflection)</h3>
<p><img src="/.io//Github\hexo\source\_posts\GAMES101.assets\image-20220401171501411-164899361945310.png" alt="image-20220401171501411" style="zoom:33%;"> <span class="math display">\[
\left[
\begin{array}{cccc} 
   x&#39;\\
   y&#39;
\end{array}
\right] = \left[
\begin{array}{cccc} 
   -1 &amp; 0\\
   0 &amp; 1
\end{array}
\right]\left[
\begin{array}{cccc} 
   x\\
   y
\end{array}
\right]
\]</span></p>
<h3 id="切变shear">切变(Shear)</h3>
<p><img src="/.io//Github\hexo\source\_posts\GAMES101.assets\image-20220401171722621-164899362109911.png" alt="image-20220401171722621" style="zoom:33%;"> <span class="math display">\[
x&#39; = x + ay\\
y&#39; = y
\]</span></p>
<p><span class="math display">\[
\left[
\begin{array}{cccc} 
   x&#39;\\
   y&#39;
\end{array}
\right] = \left[
\begin{array}{cccc} 
   1 &amp; a\\
   0 &amp; 1
\end{array}
\right]\left[
\begin{array}{cccc} 
   x\\
   y
\end{array}
\right]
\]</span></p>
<h3 id="旋转rotate">旋转(Rotate)</h3>
<p>默认为以<span class="math inline">\((0,0)\)</span>为中心逆时针旋转.</p>
<p><img src="/.io//Github\hexo\source\_posts\GAMES101.assets\image-20220401174056239-164899362270712.png" alt="image-20220401174056239" style="zoom:33%;"> <span class="math display">\[
R_\theta  = \left[
\begin{array}{cccc} 
   \cos\theta &amp; -\sin\theta\\
   \sin\theta &amp; \cos\theta
\end{array}
\right]
\]</span></p>
<p><span class="math display">\[
R_{-\theta}  = \left[
\begin{array}{cccc} 
   \cos\theta &amp; \sin\theta\\
   -\sin\theta &amp; \cos\theta
\end{array}
\right] = R_\theta^T = R_\theta^{-1}
\]</span></p>
<p>说明旋转矩阵是一个正交矩阵.</p>
<p>如果旋转的中心不在原点<span class="math inline">\((0,0)\)</span>, 需要先将中心点平移至原点后旋转, 旋转后再将中心点平移至原位置.</p>
<h2 id="平移translation">平移(Translation)</h2>
<p><img src="/.io//Github\hexo\source\_posts\GAMES101.assets\image-20220401180755821-164899362481713.png" alt="image-20220401180755821" style="zoom:33%;"> <span class="math display">\[
x&#39; = x + t_x\\
y&#39; = y + t_y
\]</span> 我们无法把它写成矩阵相乘的形式, 因此平移不是线性变换.</p>
<p>使用齐次坐标表示后(见下文), 平移也可表示为矩阵形式: <span class="math display">\[
\left(
\begin{array}{cccc} 
   x&#39;\\
   y&#39;\\
   w&#39;
\end{array}
\right) = \left(
\begin{array}{cccc} 
   1 &amp; 0 &amp; t_x\\
   0 &amp; 1 &amp; t_y\\
   0 &amp; 0 &amp; 1
\end{array}
\right)\cdot \left(
\begin{array}{cccc} 
   x\\
   y\\
   1
\end{array}
\right) = \left(
\begin{array}{cccc} 
   x + t_x\\
   y + t_y\\
   1
\end{array}
\right)
\]</span></p>
<h2 id="齐次坐标homogeneous-coordinates">齐次坐标(Homogeneous Coordinates)</h2>
<p>我们把二维的点和向量添加一维, 变成齐次坐标<span class="math inline">\((x,y,w)^T\)</span>. <span class="math display">\[
\tt{point} = \left(
\begin{array}{cccc} 
   x\\
   y\\
   1
\end{array}
\right)\tt{,vector = }\left(
\begin{array}{cccc} 
   x\\
   y\\
   0
\end{array}
\right)
\]</span> 对于<span class="math inline">\(w \neq 0\)</span>, <span class="math display">\[
\left(
\begin{array}{cccc} 
   x\\
   y\\
   w
\end{array}
\right) 表示点\left(
\begin{array}{cccc} 
   \frac{x}{w} \\
   \frac{y}{w} \\
   1
\end{array}
\right)
\]</span> 根据<span class="math inline">\(w\)</span>的值可以轻易地判断两个齐次坐标相加后的结果:</p>
<ul>
<li>点 + 向量 = 点</li>
<li>向量 + 向量 = 向量</li>
<li>点 - 点 = 向量</li>
<li>点 + 点在齐次坐标下表示两点的中点</li>
</ul>
<h2 id="仿射变换affine-transformation">仿射变换(Affine Transformation)</h2>
<p>对一个向量空间进行一次线性变换后再进行平移, 称为仿射变换. <span class="math display">\[
\left(
\begin{array}{cccc} 
   x&#39;\\
   y&#39;\\
\end{array}
\right) = \left(
\begin{array}{cccc} 
   a &amp; b\\
   c &amp; d\\
\end{array}
\right) \cdot \left(
\begin{array}{cccc} 
   x\\
   y\\
\end{array}
\right) + \left(
\begin{array}{cccc} 
   t_x\\
   t_y\\
\end{array}
\right)
\]</span> 写成齐次坐标形式: <span class="math display">\[
\left(
\begin{array}{cccc} 
   x&#39;\\
   y&#39;\\
   1
\end{array}
\right) = 
\left(
\begin{array}{cccc} 
   a &amp; b &amp; t_x\\
   c &amp; d &amp; t_y\\
   0 &amp; 0 &amp; 1
\end{array}
\right) \cdot 
\left(
\begin{array}{cccc} 
   x\\
   y\\
   1
\end{array}
\right)
\]</span></p>
<p>其中, 左上的2x2矩阵为原线性变换矩阵, <span class="math inline">\(t_x\)</span>, <span class="math inline">\(t_y\)</span>表示平移. 三维与其类似. 注意: 这个矩阵表示先进行线性变换, 再进行平移.</p>
<h2 id="逆变换inverse-transform">逆变换(Inverse Transform)</h2>
<p>求逆即可</p>
<h2 id="变换的组合">变换的组合</h2>
<p>假设对<span class="math inline">\(\vec x\)</span>依次应用变换<span class="math inline">\(M_1,M_2,...,M_n\)</span>, 那么有 <span class="math display">\[
\vec{x&#39;} = M_n \cdot M_{n-1} \cdots M_2 \cdot M_1 \cdot \vec{x}
\]</span></p>
<h2 id="变换的分解">变换的分解</h2>
<h3 id="例按某点旋转">例:按某点旋转</h3>
<p><img src="/.io//Github\hexo\source\_posts\GAMES101.assets\image-20220401185309912-164899362872814.png" alt="image-20220401185309912" style="zoom: 50%;"></p>
<p>假设我们要按点<span class="math inline">\(C\)</span>旋转<span class="math inline">\(\alpha\)</span>度, 可以先将点<span class="math inline">\(C\)</span>平移回原点<span class="math inline">\(T(-c)\)</span>, 进行旋转<span class="math inline">\(R(\alpha)\)</span>, 再将点<span class="math inline">\(C\)</span>移动回原位. <span class="math display">\[
\vec{x&#39;} = T(c) \cdot R(\alpha) \cdot T(-c) \cdot \vec{x}
\]</span></p>
<h2 id="三维变换">三维变换</h2>
<p>此处仅列出和二维有较大不同的部分.</p>
<h3 id="旋转">旋转</h3>
<h4 id="按坐标轴旋转">按坐标轴旋转</h4>
<ul>
<li><p>按<span class="math inline">\(x\)</span>轴旋转<span class="math inline">\(\alpha\)</span>度 <span class="math display">\[
  R_x(\alpha) = \left(
  \begin{array}{cccc} 
     1 &amp; 0 &amp; 0 &amp; 0\\
     0 &amp; \cos \alpha &amp; -\sin\alpha &amp; 0\\
     0 &amp; \sin\alpha &amp; \cos\alpha &amp; 0\\
     0 &amp; 0 &amp; 0 &amp; 1
  \end{array}
  \right)
  \]</span></p></li>
<li><p>按<span class="math inline">\(y\)</span>轴(注意和其它两个的区别, $ x z = -y$) <span class="math display">\[
  R_y(\alpha) = \left(
  \begin{array}{cccc} 
     \cos\alpha &amp; 0 &amp; \sin\alpha &amp; 0\\
     0 &amp; 1 &amp; 0 &amp; 1\\
     -\sin\alpha &amp; 0 &amp; \cos\alpha &amp; 0\\
     0 &amp; 0 &amp; 0 &amp; 1
  \end{array}
  \right)
  \]</span></p></li>
<li><p>按<span class="math inline">\(z\)</span>轴 <span class="math display">\[
  R_z(\alpha) = \left(
  \begin{array}{cccc} 
     \cos\alpha &amp; -\sin\alpha &amp; 0 &amp; 0 \\
     \sin\alpha &amp; \cos\alpha &amp; 0 &amp; 0\\
     0 &amp; 0 &amp; 1 &amp; 0\\
     0 &amp; 0 &amp; 0 &amp; 1
  \end{array}
  \right)
  \]</span></p></li>
</ul>
<h4 id="一般性的旋转">一般性的旋转</h4>
<p>我们用<span class="math inline">\(R_{xyz}(\alpha, \beta, \gamma)\)</span>表示绕<span class="math inline">\(x\)</span>轴旋转<span class="math inline">\(\alpha\)</span>, 绕<span class="math inline">\(y\)</span>轴旋转<span class="math inline">\(\beta\)</span>, 绕<span class="math inline">\(z\)</span>轴旋转<span class="math inline">\(\gamma\)</span>. <span class="math inline">\(\alpha\beta\gamma\)</span>也被叫做欧拉角. <span class="math display">\[
R_{xyz}(\alpha, \beta, \gamma) = R_x(\alpha)R_y(\beta)R_z(\gamma)
\]</span></p>
<h4 id="rodrigues旋转公式">Rodrigues旋转公式</h4>
<p><span class="math inline">\(R(\vec n,\alpha)\)</span>表示绕轴<span class="math inline">\(\vec n\)</span>(起点在原点)按右手方 m 向旋转角度为<span class="math inline">\(\alpha\)</span>的变换. <span class="math display">\[
R(\vec n,\alpha) = \cos(\alpha)\vec I + (1 - \cos(\alpha))\vec n \vec n^T + \sin(\alpha)\left(
\begin{array}{cccc} 
   0 &amp; -\vec{n}_{z} &amp; \vec{n}_y\\
   \vec{n}_z &amp; 0 &amp; -\vec{n}_x\\
   -\vec{n}_y &amp; \vec{n}_x &amp; 0\\
\end{array}
\right)
\]</span></p>
<h4 id="欧拉角">欧拉角</h4>
<h4 id="待补充四元数quaternion">(待补充)四元数(Quaternion)</h4>
<p>四元数是一种有三个虚部的复数: <span class="math display">\[
q = a + b i + c j + d k
\]</span> 其中有 <span class="math display">\[
i^2 = j^2 = k^2 = ijk = -1
\]</span> 四元数的加法只需把对应系数相加. 乘法每个虚部遵从如下乘法表:</p>
<figure>
<img src="/.io//image-20230217144100518.png" alt="image-20230217144100518"><figcaption aria-hidden="true">image-20230217144100518</figcaption>
</figure>
<p>和虚数的共轭类似, 有四元数<span class="math inline">\(q\)</span>的共轭<span class="math inline">\(q^*\)</span>: <span class="math display">\[
q^* = a - bi - cj - dk
\]</span> 注意: <span class="math inline">\((pq)^* = q^*p^*\)</span></p>
<p>一个四元数的绝对值<span class="math inline">\(|q|\)</span>定义为: <span class="math display">\[
|q| = \sqrt{q\cdot q^*} = \sqrt{a^2 + b^2 + c^2 + d^2}
\]</span> 其中绝对值为1的四元数称为单位四元数.</p>
<p>四元数的逆(乘逆)<span class="math inline">\(q^{-1}\)</span>: <span class="math display">\[
q^{-1} = \frac{q^*}{|q|^2}
\]</span></p>
<p>实部为0(<span class="math inline">\(a = 0\)</span>)的四元数称为纯四元数. 一个三维空间的坐标<span class="math inline">\((x,y,z)\)</span>可以用纯四元数<span class="math inline">\(xi + yj +zk\)</span>来表示.</p>
<h1 id="渲染过程中的各种变换">渲染过程中的各种变换</h1>
<p>推荐阅读:http://www.codinglabs.net/article_world_view_projection_matrix.aspx</p>
<p>假设我们要拍一张照片，需要以下三个步骤:</p>
<ol type="1">
<li>安排好要拍的人或物. 对应模型变换(model transformation), 即将物体坐标转换为世界坐标.</li>
<li>寻找一个放置相机的位置和角度. 对应视图变换(view transformation).</li>
<li>拍照. 对应投影变换(projection transformation).</li>
</ol>
<h2 id="模型变换model-transformation">模型变换(Model Transformation)</h2>
<p>这一步是将模型坐标转换为世界坐标的过程, 转换矩阵记为<span class="math inline">\(M_{model}\)</span></p>
<h2 id="视图变换view-transformation">视图变换(View Transformation)</h2>
<p>要进行视图变换, 我们首先需要定义相机的摆放:</p>
<ul>
<li>位置(Position)<span class="math inline">\(\vec e\)</span></li>
<li>视角(Look-at direction/gaze direction)<span class="math inline">\(\hat g\)</span></li>
<li>向上方向(Up direction)<span class="math inline">\(\hat t\)</span></li>
</ul>
<p>因为我们写的是一个渲染引擎而不是在现实世界，所以完全可以搞一个以相机为中心的世界. 约定相机永远位于原点，向上方向是<span class="math inline">\(\text Y\)</span>轴, 指向<span class="math inline">\(\text Z\)</span>轴的反方向. 再次提醒坐标系是右手系, 且<span class="math inline">\(\text Y\)</span>是纵坐标轴:</p>
<p><img src="/.io//Github\hexo\source\_posts\GAMES101.assets\image-20220621095653583.png" alt="image-20220621095653583" style="zoom:50%;"></p>
<p>那么对于一个给定的相机位置，需要进行一系列变换将其变成标准的相机位置. 我们把这个变换矩阵记作<span class="math inline">\(M_{view}\)</span>, 具体需要进行如下变换:</p>
<ol type="1">
<li>将<span class="math inline">\(\vec e\)</span>平移到原点</li>
<li>将<span class="math inline">\(\vec g\)</span>旋转到<span class="math inline">\(-\vec Z\)</span></li>
<li>将<span class="math inline">\(\hat t\)</span>旋转到<span class="math inline">\(\vec Y\)</span></li>
<li>将<span class="math inline">\(\hat g \times \hat t\)</span>旋转到<span class="math inline">\(\vec X\)</span></li>
</ol>
<p>根据前面的内容, 我们需要先平移(<span class="math inline">\(T_{view}\)</span>)再旋转<span class="math inline">\((R_{view})\)</span>, 即<span class="math inline">\(M_{view} = R_{view}T_{view}\)</span> <span class="math display">\[
T_{view} = \left(
\begin{array}{cccc} 
   1 &amp; 0 &amp; 0 &amp; -x_e\\
   0 &amp; 1 &amp; 0 &amp; -y_e\\
   0 &amp; 0 &amp; 1 &amp; -z_e\\
   0 &amp; 0 &amp; 0 &amp; 1
\end{array}
\right)
\]</span> 同样根据前面的内容, 我们有<span class="math inline">\(R_{-\theta} = R_\theta^{-1} = R_\theta^T\)</span>. 因此与其正向进行旋转, 不如先把<span class="math inline">\(X\space Y\space-Z\)</span>轴旋转到<span class="math inline">\(etg\)</span>, 再求它的逆矩阵. 因为我们要旋转的向量都很简单(比如<span class="math inline">\((1,0,0)^T\)</span>), 所以这个矩阵可以直接构造出来: <span class="math display">\[
R_{view}^{-1} = \left(
\begin{array}{cccc} 
   x_{\hat g \times \hat t} &amp; x_\hat t &amp; x_{-\hat g} &amp; 0\\
   y_{\hat g \times \hat t} &amp; y_\hat t &amp; y_{-\hat g} &amp; 0\\
   z_{\hat g \times \hat t} &amp; z_\hat t &amp; z_{-\hat g} &amp; 0\\
   0 &amp; 0 &amp; 0 &amp; 1
\end{array}
\right)
\]</span> 于是有 <span class="math display">\[
R_{view} = (R_{view}^{-1})^T \left(
\begin{array}{cccc} 
   x_{\hat g \times \hat t} &amp; y_{\hat g \times \hat t} &amp; z_{\hat g \times \hat t} &amp; 0\\
   x_\hat t &amp; y_\hat t &amp; z_\hat t &amp; 0\\
   x_{-\hat g} &amp; y_{-\hat g} &amp; z_{-\hat g} &amp; 0\\
   0 &amp; 0 &amp; 0 &amp; 1
\end{array}
\right)
\]</span></p>
<p>在实现时, 我们通常不指定视角<span class="math inline">\(\vec g\)</span>, 而是通过视角所指向的点(设为<span class="math inline">\(C\)</span>)和相机位置(<span class="math inline">\(E\)</span>)来确定<span class="math inline">\(\vec g\)</span>. 这时有: <span class="math display">\[
\vec g = \vec{EC}\\
\]</span> 有了<span class="math inline">\(\vec g,\vec t\)</span>, 便可以计算出相机坐标系: <span class="math display">\[
\vec w = -\frac{\vec g}{|\vec g|}\\
\vec u = \frac{\vec t \times \vec w}{|\vec t \times \vec w|}\\
\vec v = \vec w \times \vec u
\]</span> 这时<span class="math inline">\(R_{view}\)</span>为 <span class="math display">\[
R_{view} = (R_{view}^{-1})^T \left(
\begin{array}{cccc} 
   x_{\vec u} &amp; y_{\vec u} &amp; z_{\vec u} &amp; 0\\
   x_{\vec v} &amp; y_{\vec v} &amp; z_{\vec v} &amp; 0\\
   x_{\vec w} &amp; y_{\vec w} &amp; z_{\vec w} &amp; 0\\
   0 &amp; 0 &amp; 0 &amp; 1
\end{array}
\right)
\]</span></p>
<h3 id="lookat">LookAt</h3>
<h2 id="投影变换projection-transformation">投影变换(Projection Transformation)</h2>
<p>投影变换将3D的图形转换到2D上，分为正交投影(Orthographic Projection)和透视投影(Perspective Projection)</p>
<figure>
<img src="/.io//Github\hexo\source_posts\GAMES101.assets\image-20220621164915132.png" alt="image-20220621164915132"><figcaption aria-hidden="true">image-20220621164915132</figcaption>
</figure>
<h3 id="正交投影orthographic-projection">正交投影(Orthographic Projection)</h3>
<p>其实直接将所有的<span class="math inline">\(z\)</span>值忽略掉就可以获得正交投影. 但一般采用如下方法:</p>
<p>我们先定义一个<span class="math inline">\([l,r] \times [b,t] \times [f,n]\)</span>的立方体(left,right,bottom,top,far,near). (注意, <span class="math inline">\(z\)</span>值越小离相机越远, 因为相机的视线是-Z) 然后我们将这个立方体先平移再缩放, 得到中心位于原点, <span class="math inline">\([-1,1] \times[-1,1] \times [-1,1]\)</span>的标准立方体(canonical cube).</p>
<figure>
<img src="/.io//Github\hexo\source_posts\GAMES101.assets\image-20220622075400700.png" alt="image-20220622075400700"><figcaption aria-hidden="true">image-20220622075400700</figcaption>
</figure>
<p>可以很简单地写出变换矩阵: <span class="math display">\[
M_{ortho} = \left(
\begin{array}{cccc} 
   \frac{2}{r - l} &amp; 0 &amp; 0 &amp; 0\\
   0 &amp; \frac{2}{t - b} &amp; 0 &amp; 0\\
   0 &amp; 0 &amp; \frac{2}{n - f} &amp; 0\\
   0 &amp; 0 &amp; 0 &amp; 1
\end{array}
\right)\left(
\begin{array}{cccc} 
   1 &amp; 0 &amp; 0 &amp; -\frac{l+r}{2} \\
   0 &amp; 1 &amp; 0 &amp; -\frac{b+t}{2} \\
   0 &amp; 0 &amp; 1 &amp; -\frac{f+n}{2} \\
   0 &amp; 0 &amp; 0 &amp; 1
\end{array}
\right)
\]</span></p>
<p>相乘之后的结果:</p>
<figure>
<img src="/.io//image-20230211094736858.png" alt="image-20230211094736858"><figcaption aria-hidden="true">image-20230211094736858</figcaption>
</figure>
<h3 id="透视投影perspective-projection">透视投影(Perspective Projection)</h3>
<p>进行透视投影时, 我们假设相机是一个点, 而所有光线都汇聚到这个点上(或者从这个点发出):</p>
<p><img src="/.io//Github\hexo\source\_posts\GAMES101.assets\image-20220622080539039.png" alt="image-20220622080539039" style="zoom:50%;"></p>
<p>在三维空间上我们的视野便形成了一个四棱锥(因为你的电脑屏幕是长方形而不是圆形). 如果以待渲染的画面所在平面为顶将这个四棱锥的头截去, 便得到了一个截头四棱锥(frustum). 将这个四棱锥挤压成一个立方体, 再进行正交投影, 便能得到想要的画面:</p>
<p><img src="/.io//Github\hexo\source\_posts\GAMES101.assets\image-20220622080748026.png" alt="image-20220622080748026" style="zoom:50%;"></p>
<p>考虑在挤压时Frustum中每个点的<span class="math inline">\(x,y\)</span>会如何变化.</p>
<p><img src="/.io//Github\hexo\source\_posts\GAMES101.assets\image-20220622082005810.png" alt="image-20220622082005810" style="zoom:50%;"></p>
<p>上图可以看作Frustum的一个侧视图. 一个点的<span class="math inline">\(y\)</span>在挤压后变成了<span class="math inline">\(y&#39;\)</span>. 根据相似三角形很容易得出 <span class="math display">\[
y&#39; = \frac{n}{z}y
\]</span> 同样 <span class="math display">\[
x&#39; = \frac{n}{z}x
\]</span> 假设挤压过程对应的矩阵是<span class="math inline">\(M_{persp\to ortho}\)</span>. 此时我们还不知道<span class="math inline">\(z\)</span>坐标会如何变化(注意它不是不变).</p>
<p>注意：可以利用矩阵的最后一行对<span class="math inline">\(x,y,z\)</span>进行除法运算.</p>
<figure>
<img src="/.io//image-20230213093551705.png" alt="image-20230213093551705"><figcaption aria-hidden="true">image-20230213093551705</figcaption>
</figure>
<figure>
<img src="/.io//image-20230213093601539.png" alt="image-20230213093601539"><figcaption aria-hidden="true">image-20230213093601539</figcaption>
</figure>
<p>举例:</p>
<figure>
<img src="/.io//image-20230213093729117.png" alt="image-20230213093729117"><figcaption aria-hidden="true">image-20230213093729117</figcaption>
</figure>
<p>根据 <span class="math display">\[
M_{persp \to ortho} \cdot \left(
\begin{array}{cccc} 
   x \\
   y \\
   z \\
   1 
\end{array}
\right) =  \left(
\begin{array}{cccc} 
   \frac{n}{z}x \\
   \frac{n}{z}y \\
   ? \\
   1 
\end{array}
\right) =  \left(
\begin{array}{cccc} 
   nx \\
   ny \\
   ? \\
   z 
\end{array}
\right)
\]</span> 可以先填出矩阵的部分内容: <span class="math display">\[
M_{persp \to ortho} = \left(
\begin{array}{cccc} 
   n &amp; 0 &amp; 0 &amp; 0\\
   0 &amp; n &amp; 0 &amp; 0\\
   ? &amp; ? &amp; ? &amp; ?\\
   0 &amp; 0 &amp; 1 &amp; 0
\end{array}
\right)
\]</span> 这个矩阵的第三行需要进行一点推导. 尽管我们不知道每个点的<span class="math inline">\(z\)</span>坐标如何变换, 但我们知道, 在最前面平面(<span class="math inline">\(z = n\)</span>)上的点, 其<span class="math inline">\(z\)</span>坐标永远等于<span class="math inline">\(n\)</span>, 即: <span class="math display">\[
\left(
\begin{array}{cccc} 
   n &amp; 0 &amp; 0 &amp; 0\\
   0 &amp; n &amp; 0 &amp; 0\\
   ? &amp; ? &amp; ? &amp; ?\\
   0 &amp; 0 &amp; 1 &amp; 0
\end{array}
\right) \cdot \left(
\begin{array}{cccc} 
   x \\
   y \\
   n \\
   1 
\end{array}
\right) = \left(
\begin{array}{cccc} 
   x \\
   y \\
   n \\
   1 
\end{array}
\right)
= \left(
\begin{array}{cccc} 
   nx \\
   ny \\
   n^2 \\
   n 
\end{array}
\right)
\]</span> 可知<span class="math inline">\(M[2][0] = M[2][1] = 0\)</span>. 设<span class="math inline">\(M[2][2]\)</span>为<span class="math inline">\(A\)</span>, <span class="math inline">\(M[2][3]\)</span>为<span class="math inline">\(B\)</span>, 则 <span class="math display">\[
(0,0,A,B) \cdot \left(
\begin{array}{cccc} 
   x \\
   y \\
   n \\
   1 
\end{array}
\right) = n^2
\]</span></p>
<p><span class="math display">\[
An + B = n^2
\]</span></p>
<p>同理有 <span class="math display">\[
Af + B = f^2
\]</span> 解得 <span class="math display">\[
A = n + f\\
B = -nf
\]</span> 于是我们求出了整个矩阵: <span class="math display">\[
M_{persp \to ortho} = \left(
\begin{array}{cccc} 
   n &amp; 0 &amp; 0 &amp; 0\\
   0 &amp; n &amp; 0 &amp; 0\\
   0 &amp; 0 &amp; n+f &amp; -nf\\
   0 &amp; 0 &amp; 1 &amp; 0
\end{array}
\right)
\]</span> 整个透视投影的过程便是先挤压再正交投影的过程, 即 <span class="math display">\[
M_{persp} = M_{ortho}M_{persp\to ortho}
\]</span></p>
<p>做一下矩阵乘法, 这个矩阵的结果是: <span class="math display">\[
M_{persp } = \left(
\begin{array}{cccc} 
\frac{2n}{r - l} &amp; 0 &amp; \frac{l + r}{l - r} &amp; 0 \\
0 &amp; \frac{2n}{t - b} &amp; \frac{b + t}{b - t} &amp; 0 \\
0 &amp; 0 &amp; \frac{f+n}{n - f} &amp; -\frac{2 f n}{n - f} \\
0 &amp; 0 &amp; 1 &amp; 0
\end{array}
\right)
\]</span> 可以看到, 这个矩阵的最后一行是<span class="math inline">\([0,0,1,0]\)</span>. 也就是说, 一个点在进行透视投影后, 它的深度信息<span class="math inline">\(z\)</span>就是齐次坐标的<span class="math inline">\(w\)</span>.</p>
<p>上述矩阵还可以进行优化. 一般情况下, 我们的视锥是对称的(即<span class="math inline">\(l = -r, t = -b\)</span>). 这种情况下有: <span class="math display">\[
M_{persp } = \left(
\begin{array}{cccc} 
\frac{n}{r} &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; \frac{n}{t} &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; \frac{f+n}{n - f} &amp; -\frac{2 f n}{n - f} \\
0 &amp; 0 &amp; 1 &amp; 0
\end{array}
\right)
\]</span> 注意: 如果在OpenGL下使用上述矩阵, 需要进行转置.</p>
<h4 id="构造投影矩阵">构造投影矩阵</h4>
<p>来自作业1. 参考资料: https://zhuanlan.zhihu.com/p/361156478</p>
<p>https://en.wikipedia.org/wiki/Field_of_view_in_video_games</p>
<p><img src="/.io//image-20221219152229743.png" alt="image-20221219152229743" style="zoom: 67%;"></p>
<p>有些时候, 我们没有<span class="math inline">\(l,r,b,t,n,f\)</span>六个参数, 而是需要用以下四个参数，构造投影矩阵:</p>
<p><code>float eyefov</code>: (垂直)可视角度</p>
<p><code>float aspect_ratio</code>: 宽高比</p>
<p><code>float zNear</code>: 近平面的<span class="math inline">\(z\)</span>轴坐标</p>
<p><code>float zFar</code>: 远平面的<span class="math inline">\(z\)</span>轴坐标</p>
<figure>
<img src="/.io//image-20221219152445852.png" alt="image-20221219152445852"><figcaption aria-hidden="true">image-20221219152445852</figcaption>
</figure>
<p><img src="/.io//480px-FOV_in_video_games.svg.png" alt="480px-FOV_in_video_games.svg" style="zoom: 50%;"></p>
<p>如图, 约定<span class="math inline">\(V\)</span>代表垂直视角, <span class="math inline">\(H\)</span>代表水平视角.<span class="math inline">\(w\)</span>和<span class="math inline">\(h\)</span>代表显示器的宽度和高度. <span class="math inline">\(l,r,b,t,n,f\)</span>见投影变换部分. 在此假设所有角已经转换成弧度制. 易得: <span class="math display">\[
t = \tan(\frac{V}{2}) \cdot \text{zNear}\\
b = -t
\]</span> 因为<span class="math inline">\(\text{aspect\_ratio} = \frac{w}{h} = \frac{r}{t}\)</span>, 所以有 <span class="math display">\[
r = \text{aspect\_ratio} \cdot t\\
l = -r
\]</span> 这样便可构建出投影变换矩阵.</p>
<h3 id="裁剪坐标系clip-coordinate-system">裁剪坐标系(clip coordinate system)</h3>
<p>在经过<span class="math inline">\(M_{persp\to ortho}\)</span>的变换后, 每个顶点均位于裁剪坐标系中. 此时每个点仍然是以齐次坐标系<span class="math inline">\((x_c,y_c,z_c,w_c)\)</span>的形式表示的. 对每个点进行透视除法(即将<span class="math inline">\(xyz\)</span>分量都除以<span class="math inline">\(w\)</span>), 便可将其转换为标准化设备坐标系(normalized device coordinates). 但在进行透视除法前, 我们需要对顶点进行裁剪. 对于任意<span class="math inline">\(xyz\)</span>坐标, 如果其绝对值大于<span class="math inline">\(|w|\)</span>, 则这个顶点需要被裁剪.</p>
<p>在裁剪后并执行透视除法后, 每个点便被变换到了<span class="math inline">\([-1,1]^3\)</span>的空间中. 且这里的每个点都曾位于透视投影定义的截头锥体内.</p>
<h2 id="视口变换viewport-transformation">视口变换(Viewport Transformation)</h2>
<figure>
<img src="/.io//image-20221219153149597.png" alt="image-20221219153149597"><figcaption aria-hidden="true">image-20221219153149597</figcaption>
</figure>
<p>屏幕像素有一些约定, 见下图</p>
<figure>
<img src="/.io//image-20221219153222638.png" alt="image-20221219153222638"><figcaption aria-hidden="true">image-20221219153222638</figcaption>
</figure>
<figure>
<img src="/.io//image-20221219153232165.png" alt="image-20221219153232165"><figcaption aria-hidden="true">image-20221219153232165</figcaption>
</figure>
<p>视口变换是这一系列变换的最后一步, 它的作用是将上一步正交投影得到的<span class="math inline">\([-1,1] \times [-1,1]\)</span>的画面转换到显示器<span class="math inline">\([0,width] \times [0,height]\)</span>的画面. 由于像素<span class="math inline">\((x,y)\)</span>在屏幕上的实际坐标是<span class="math inline">\((x+0.5,y+0.5)\)</span>, 最终我们要将正交投影的矩阵转化为<span class="math inline">\([-0.5,width - 0.5] \times [-0.5,height - 0.5]\)</span> 易得转移矩阵如下: <span class="math display">\[
M_{viewport} = \left(
\begin{array}{cccc} 
   \frac{width}{2} &amp; 0 &amp; 0 &amp; \frac{width-1}{2} \\
   0 &amp; \frac{height}{2} &amp; 0 &amp; \frac{height-1}{2}\\
   0 &amp; 0 &amp; 1 &amp; 0\\
   0 &amp; 0 &amp; 0 &amp; 1
\end{array}
\right)
\]</span> 注意在上面的变换中, 我们保留了<span class="math inline">\(z\)</span>的值供z-buffer使用.</p>
<p>综上所述, 一个完整的变换矩阵为: <span class="math display">\[
M = M_{viewport}M_{persp}M_{view}M_{model}
\]</span></p>
<h1 id="光栅化rasterizing">光栅化(Rasterizing)</h1>
<p>光栅化时处理的一般是三角形, 因为它有如下优秀的性质:</p>
<figure>
<img src="/.io//image-20221219160050824.png" alt="image-20221219160050824"><figcaption aria-hidden="true">image-20221219160050824</figcaption>
</figure>
<p>将一个三角形变为屏幕上的像素便为光栅化:</p>
<figure>
<img src="/.io//image-20221219161426802.png" alt="image-20221219161426802"><figcaption aria-hidden="true">image-20221219161426802</figcaption>
</figure>
<figure>
<img src="/.io//image-20221219161502656.png" alt="image-20221219161502656"><figcaption aria-hidden="true">image-20221219161502656</figcaption>
</figure>
<p>在光栅化时, 先求出三角形的边界, 再遍历边界里的每个像素, 判断其是否在三角形的内部(可以用叉积或者重心坐标), 绘制所有在三角形内部的像素即可.</p>
<h3 id="抗锯齿antialiasing理论知识">抗锯齿(Antialiasing)理论知识</h3>
<p>本节相当多的内容引用自Wikipedia.</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%B7%B7%E7%96%8A">混叠</a>（英语：<strong>Aliasing</strong>），在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/訊號">信号</a>频谱上可称作<strong>叠频</strong>；在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/影像">影像</a>上可称作<strong>叠影</strong>，主要来自于对连续时间信号作<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/取樣">取样</a>以<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/數位化">数字化</a>时，取样频率低于两倍<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/奈奎斯特频率">奈奎斯特频率</a>。</p>
<p>在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/統計">统计</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/訊號處理">信号处理</a>和相关领域中，<strong>混叠</strong>是指取样信号被还原成连续信号时产生彼此交叠而<strong>失真</strong>的现象。当混叠发生时，原始信号无法从取样信号还原。而混叠可能发生在时域上，称做<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=時間混疊&amp;action=edit&amp;redlink=1">时间混叠</a>，或是发生在频域上，被称作<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=空間混疊&amp;action=edit&amp;redlink=1">空间混叠</a>。</p>
<p>在视觉影像的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/類比數位轉換">模拟数字转换</a>或<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=音樂訊號&amp;action=edit&amp;redlink=1">音乐信号</a>领域，混叠都是相当重要的议题。因为在做模拟-数字转换时若取样频率选取不当将造成高频信号和低频信号混叠在一起，因此无法完美地重建出原始的信号。为了避免此情形发生，取样前必须先做<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/滤波">滤波</a>的操作。</p>
<p><img src="/.io//image-20221219164657871.png" alt="image-20221219164657871" style="zoom:50%;"></p>
<p>先对原图像进行模糊处理(滤波), 再进行采样, 可以得到较好的抗锯齿效果:</p>
<p><img src="/.io//image-20221219164733184.png" alt="image-20221219164733184" style="zoom:50%;"></p>
<p>但是如果先采样再进行模糊, 只会得到模糊的锯齿:</p>
<p><img src="/.io//image-20221219164822465.png" alt="image-20221219164822465" style="zoom:50%;"></p>
<p>下面解释原因.(日后再补)</p>
<h4 id="频域frequency-domain">频域(Frequency Domain)</h4>
<p><strong>频率</strong>（frequency）又称<strong>周率</strong>，是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/物理学">物理学</a>上描述某具规律周期性的现象或事件，在每单位<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/时间">时间</a>内（即每秒）重复发生的次数.</p>
<p>设<span class="math inline">\(\tau\)</span>时间内某事件重复发生<span class="math inline">\(n\)</span>次, 则该事件发生的频率<span class="math inline">\(f\)</span>为 <span class="math display">\[
f = \frac{n}{\tau} \text{Hz}
\]</span> 又因为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/週期">周期</a>定义为重复事件发生的最小时间间隔，故频率也可以表示为周期（<span class="math inline">\(T\)</span>）的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/倒数">倒数</a>： <span class="math display">\[
f = \frac{1}{T} \text{Hz}
\]</span></p>
<h3 id="msaa">MSAA</h3>
<figure>
<img src="/.io//image-20221221102839024.png" alt="image-20221221102839024"><figcaption aria-hidden="true">image-20221221102839024</figcaption>
</figure>
<figure>
<img src="/.io//image-20221221102907451.png" alt="image-20221221102907451"><figcaption aria-hidden="true">image-20221221102907451</figcaption>
</figure>
<figure>
<img src="/.io//image-20221221102920456.png" alt="image-20221221102920456"><figcaption aria-hidden="true">image-20221221102920456</figcaption>
</figure>
<p>MSAA先进行超采样, 即原来采样一次的单个像素, 现在采样<span class="math inline">\(n \times n\)</span>次得到<span class="math inline">\(n^2\)</span>个小像素. 超采样后, 将每个像素对应的在三角形内部的小像素进行平均(这一步相当于模糊操作), 即可得到最终的采样结果.</p>
<h3 id="z-buffer">Z-buffer</h3>
<h1 id="着色shading">着色(Shading)</h1>
<h2 id="bling-phong模型">Bling-Phong模型</h2>
<p><img src="/.io//image-20220628093826856.png" alt="image-20220628093826856" style="zoom:50%;"></p>
<p>如图, 现实世界中的光线可以分为三个部分:</p>
<ul>
<li>反射高光(Specular highlights)</li>
<li>漫反射(Diffuse reflection)</li>
<li>环境光(Ambient lighting)</li>
</ul>
<p>分别对这三种光进行模拟, 便可得到较为真实的效果.</p>
<p><img src="/.io//image-20220628102400032.png" alt="image-20220628102400032" style="zoom:67%;"></p>
<p>在计算光线反射时, 我们是对每个点(Shading point)进行单独计算的. 尽管待计算的点可能位于曲面上, 我们仍然认为极小的局部是一个平面. 待处理的输入参数有以下几个:</p>
<ul>
<li>观测方向<span class="math inline">\(\hat v\)</span>(Viewer direction)</li>
<li>平面法线<span class="math inline">\(\hat n\)</span>(Surface normal)</li>
<li>光线方向<span class="math inline">\(\hat l\)</span>(Light direction), 它从表面指向光源, 与光线的方向相反.</li>
<li>表面参数(Surface parameters), 包括颜色, 反射率等</li>
</ul>
<p>注意: 以上的向量均只表示方向, 为单位向量. 另外着色只考虑自身, 不会考虑其他物体的存在, 要将着色(Shading)和阴影(Shadow)进行区分.</p>
<h3 id="漫反射diffuse-reflection">漫反射(Diffuse reflection)</h3>
<p><img src="/.io//image-20220628103055157.png" alt="image-20220628103055157" style="zoom:50%;"></p>
<p>当一束光射向粗糙的物体表面时, 粗糙表面会把入射光向各个方向进行反射, 称为漫反射. 需要注意无论我们的视角角度如何, 漫反射的效果都是一样的. 因此漫反射的光照强度只和入射角、平面法线、平面距光源的距离有关.</p>
<p>首先来考虑入射角:</p>
<p><img src="/.io//image-20220630093119443.png" alt="image-20220630093119443" style="zoom:50%;"></p>
<p>设<span class="math inline">\(\theta\)</span>是<span class="math inline">\(\hat l\)</span>和<span class="math inline">\(\hat n\)</span>的夹角, 那么平面接收到的能量是与<span class="math inline">\(\cos \theta = \hat l \cdot \hat n\)</span>成正比的. 这被称为兰伯特余弦定律(Lambert's cosine law).</p>
<p>再考虑距离:</p>
<p><img src="/.io//image-20220630093855769.png" alt="image-20220630093855769" style="zoom:50%;"></p>
<p>能量与光源的距离成平方反比关系, 即距离光源<span class="math inline">\(r\)</span>的点接收到的光强是光源的<span class="math inline">\(\frac{1}{r^2}\)</span>. (半径为<span class="math inline">\(r\)</span>的球壳表面积为<span class="math inline">\(4\pi r^2\)</span>, 结合能量守恒即可推导出).</p>
<figure>
<img src="/.io//image-20220630094611616.png" alt="image-20220630094611616"><figcaption aria-hidden="true">image-20220630094611616</figcaption>
</figure>
<p>因此我们可以得出漫反射光强的计算公式, 其中<span class="math inline">\(k_d\)</span>为漫反射参数, 一般代表颜色, 可以定义成一个三维的RGB向量. <span class="math display">\[
L_d = k_d \cdot \frac{I}{r^2} \cdot \max(0,\hat n \cdot \hat l)
\]</span></p>
<h3 id="反射高光specular-highlights">反射高光(Specular highlights)</h3>
<figure>
<img src="/.io//image-20220630100922174.png" alt="image-20220630100922174"><figcaption aria-hidden="true">image-20220630100922174</figcaption>
</figure>
<p>反射高光的光强与我们的观察角度有很大关系. 对于一个比较光滑的物体, 它的反射高光只集中在反射向量(<span class="math inline">\(\hat R\)</span>)附近的一小块区域(图中黄色部分). 要进行计算, 我们就需要先计算出<span class="math inline">\(\hat R\)</span>. 而Bling-Phong模型使用半程向量(half vector)来进行近似计算, 避免了对<span class="math inline">\(\hat R\)</span>的计算:</p>
<p><img src="/.io//image-20220630101402464.png" alt="image-20220630101402464" style="zoom: 67%;"></p>
<p>半程向量<span class="math inline">\(\hat h\)</span>是位于<span class="math inline">\(\hat l\)</span>和<span class="math inline">\(\hat v\)</span>夹角的角平分线上的单位向量. <span class="math display">\[
\hat h = \frac{\hat v + \hat l}{|\hat v + \hat l|}
\]</span> 假设<span class="math inline">\(\hat h\)</span>与<span class="math inline">\(\hat n\)</span>的夹角<span class="math inline">\(\alpha\)</span>近似等于<span class="math inline">\(\hat R\)</span>与<span class="math inline">\(\hat v\)</span>的夹角, 便可以得出反射光的光强计算公式: <span class="math display">\[
L_s = k_s \cdot \frac{I}{r^2} \cdot \max(0,\hat n \cdot \hat h)^p
\]</span> 其中<span class="math inline">\(k_s\)</span>一般为白色, 也可取光源颜色. 指数<span class="math inline">\(p\)</span>可以加速高光的衰减, 让模型更加真实. 这个参数一般取<span class="math inline">\(100 \sim 200\)</span></p>
<figure>
<img src="/.io//image-20220630102119144.png" alt="image-20220630102119144"><figcaption aria-hidden="true">image-20220630102119144</figcaption>
</figure>
<figure>
<img src="/.io//image-20220630102229234.png" alt="image-20220630102229234"><figcaption aria-hidden="true">image-20220630102229234</figcaption>
</figure>
<h3 id="环境光ambient-lighting">环境光(Ambient lighting)</h3>
<p>环境光非常的简单粗暴: <span class="math display">\[
L_a = k_a \cdot I_a
\]</span> 把三种光全部加起来, 就能得到Bling-Phong模型的光照: <span class="math display">\[
L = L_d + L_s + L_a\\
= k_d \cdot \frac{I}{r^2} \cdot \max(0,\hat n \cdot \hat l) + k_s \cdot \frac{I}{r^2} \cdot \max(0,\hat n \cdot \hat h)^p + k_a \cdot I_a
\]</span></p>
<h2 id="着色频率待补全">着色频率(待补全)</h2>
<p>Bling-Phong模型只给出了着色方法, 但Shading Point是什么并没有给出定义. 本节便讨论不同着色频率的实现和效果.</p>
<p>着色频率可以分为平面着色(Flat shading), Gouraud shading和Phong shading.</p>
<p>在这里先看一下各种着色频率的区别:</p>
<p><img src="/.io//image-20220630104547245.png" alt="image-20220630104547245" style="zoom:50%;"></p>
<h3 id="平面着色flat-shading">平面着色(Flat Shading)</h3>
<p>平面着色对每个三角形面求出一个法线, 并据此求出整个三角形的shading结果.</p>
<figure>
<img src="/.io//image-20220630103725500.png" alt="image-20220630103725500"><figcaption aria-hidden="true">image-20220630103725500</figcaption>
</figure>
<h3 id="gouraud-shading">Gouraud Shading</h3>
<p>Gouraud着色先求出三角形每个顶点的法线, 计算出颜色, 再对三角形内部的每个点进行插值(interpolation).</p>
<figure>
<img src="/.io//image-20220630104005380.png" alt="image-20220630104005380"><figcaption aria-hidden="true">image-20220630104005380</figcaption>
</figure>
<p>在一般的obj模型中我们一般只能获得三角形的法线, 因而每个顶点的法线由与其相邻的三角形法线(加权)平均得来: <span class="math display">\[
\vec N_v =  \frac{\sum_{i}\vec N_i}{\sum_{i}|\vec N_i|}
\]</span> <img src="/.io//image-20220630105034275.png" alt="image-20220630105034275" style="zoom:33%;"></p>
<h3 id="phong-shading">Phong Shading</h3>
<p>Phong shading先插值计算出每个像素的法线, 再对每个像素进行shading.</p>
<p><img src="/.io//image-20221219091505338.png" alt="image-20221219091505338" style="zoom:50%;"></p>
<h2 id="渲染管线graphics-pipeline">渲染管线(Graphics Pipeline)</h2>
<figure>
<img src="/.io//image-20220630105709088.png" alt="image-20220630105709088"><figcaption aria-hidden="true">image-20220630105709088</figcaption>
</figure>
<h1 id="纹理映射texture-mapping">纹理映射(Texture Mapping)</h1>
<figure>
<img src="/.io//image-20221219095356275.png" alt="image-20221219095356275"><figcaption aria-hidden="true">image-20221219095356275</figcaption>
</figure>
<figure>
<img src="/.io//image-20221219095431898.png" alt="image-20221219095431898"><figcaption aria-hidden="true">image-20221219095431898</figcaption>
</figure>
<p>​ 一般默认<span class="math inline">\(u,v \in [0,1]\)</span></p>
<figure>
<img src="/.io//image-20221219095443482.png" alt="image-20221219095443482"><figcaption aria-hidden="true">image-20221219095443482</figcaption>
</figure>
<h2 id="重心坐标barycentric-coordinates">重心坐标(Barycentric coordinates)</h2>
<h3 id="一般定义">一般定义</h3>
<p>设<span class="math inline">\(V_1,...,V_n\)</span>是<span class="math inline">\(n\)</span>维向量空间<span class="math inline">\(V\)</span>中<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Simplex">单纯形</a>的顶点, 对于<span class="math inline">\(V\)</span>中任意一点<span class="math inline">\(P\)</span>, 有 <span class="math display">\[
(\sum_{i = 1}^n \lambda_i)\cdot P = \sum_{i = 1}^n \lambda_i \cdot V_i
\]</span> 则系数<span class="math inline">\(\lambda_1,...,\lambda_n\)</span>称为<span class="math inline">\(P\)</span>关于<span class="math inline">\(V_1,...V_n\)</span>的重心坐标. 一般规定<span class="math inline">\(\sum_{i = 1}^n \lambda_i = 1\)</span>, 此时称为<strong>正规化</strong>的重心坐标. 以下讨论的重心坐标均为正规化的.</p>
<h3 id="二维平面中的重心坐标系">二维平面中的重心坐标系</h3>
<h4 id="定义-1">定义</h4>
<p>二维平面上, 单纯形为三角形. 假设给出一三角形<span class="math inline">\(\Delta ABC\)</span>和三角形所在平面上的一点<span class="math inline">\(P\)</span>, 则<span class="math inline">\(P\)</span>可被如下重心坐标表示: <span class="math display">\[
P = \alpha A + \beta B + \gamma C
\]</span> <img src="/.io//image-20221219101132111.png" alt="image-20221219101132111" style="zoom:50%;"></p>
<p>考虑<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/144360079">下图(来源见链接)</a>:</p>
<p><img src="https://pic2.zhimg.com/80/v2-34f542500eb2b8b4679dc351609398ad_720w.jpg" alt="img" style="zoom: 50%;"></p>
<p>将<span class="math inline">\(\vec{AB},\vec{AC}\)</span>作为坐标系, 可以得到 <span class="math display">\[
\begin{align}
P =&amp; A + \beta(\vec{AB}) + \gamma(\vec{AC})\\
=&amp; A + \beta(B - A) + \gamma(C - A)\\
=&amp; (1 - \beta - \gamma)A + \beta B + \gamma C
\end{align}
\]</span> 这样便可以从坐标系的角度来解释重心坐标, 同时能得到 <span class="math display">\[
\alpha = 1 - \beta - \gamma
\]</span></p>
<h4 id="求解解方程组">求解:解方程组</h4>
<p>将点带入重心坐标的定义, 可以得到: <span class="math display">\[
\left \{
\begin{array}{cccc} 
   x_p = (1 - \beta - \gamma) x_a + \beta x_b + \gamma x_c \\
   y_p = (1 - \beta - \gamma) y_a + \beta y_b + \gamma y_c
\end{array}
\right.
\]</span> 提取出<span class="math inline">\(\beta \space \gamma\)</span>: <span class="math display">\[
\left \{
\begin{array}{cccc}
x_p - x_a = \beta(x_b - x_a) + \gamma (x_c - x_a)\\
y_p - y_a = \beta(y_b - y_a) + \gamma (y_c - y_a)
\end{array}
\right.
\]</span> 转化为矩阵形式: <span class="math display">\[
\left[
\begin{array}{}
    x_b - x_a &amp; x_c - x_a\\
    y_b - y_a &amp; y_c - y_a
\end{array}
\right]
\left[
\begin{array}{}
\beta \\
\gamma
\end{array}
\right]
=
\left[
\begin{array}{}
x_p - x_a\\
y_p - y_a
\end{array}
\right]
\]</span> 这样便可求解出<span class="math inline">\(\beta \space \gamma\)</span>进而求出<span class="math inline">\(\alpha\)</span></p>
<h4 id="求解向量叉积">求解:向量叉积</h4>
<p>把坐标系的表达式变换一下: <span class="math display">\[
\beta \vec{AB} + \gamma \vec{AC} + \vec{PA} = 0
\]</span> 拆开后: <span class="math display">\[
\left \{
\begin{array}{cccc} 
\beta\vec{AB}_x + \gamma \vec{AC}_x + \vec{PA}_x = 0\\
\beta\vec{AB}_y + \gamma \vec{AC}_y + \vec{PA}_y = 0
\end{array}
\right.
\]</span> 转化为矩阵形式: <span class="math display">\[
\left[
\begin{array}{}
\beta &amp; \gamma &amp; 1
\end{array}
\right]
\left[
\begin{array}{}
\vec{AB}_x\\
\vec{AC}_x\\
\vec{PA}_x
\end{array}
\right] = 0\\
\left[
\begin{array}{}
\beta &amp; \gamma &amp; 1
\end{array}
\right]
\left[
\begin{array}{}
\vec{AB}_y\\
\vec{AC}_y\\
\vec{PA}_y
\end{array}
\right] = 0\\
\]</span> 从几何意义考虑, 这相当于<span class="math inline">\([\beta ,\gamma,1]\)</span>这个向量和后两个向量分别垂直. 因而我们求出后两个向量的叉积(假设结果为<span class="math inline">\([x,y,z]\)</span>), 则<span class="math inline">\([\frac{x}{z}, \frac{y}{z},1]\)</span>等于<span class="math inline">\([\beta,\gamma,1]\)</span>​.</p>
<p>需要注意<span class="math inline">\(z = 0\)</span>的特殊情况, 根据叉乘的定义, 此时有<span class="math inline">\(\vec{AB}_x \cdot \vec{AC}_y - \vec{AB}_y \cdot \vec{AC}_x = 0\)</span>, 即<span class="math inline">\(\vec{AB} \cdot \vec{AC} = 0\)</span>, 说明<span class="math inline">\(ABC\)</span>三点共线. 这时返回一个任意的负重心坐标即可.</p>
<h4 id="求解三角形面积">求解:三角形面积</h4>
<p><img src="/.io//image-20221219101504847.png" alt="image-20221219101504847" style="zoom: 67%;"></p>
<p>如图, 假设三角形面积分别为<span class="math inline">\(A_A,A_B,A_C\)</span>. 则 <span class="math display">\[
\alpha = \frac{A_A}{A_A+A_B+A_C}\\
\beta = \frac{A_B}{A_A+A_B+A_C}\\
\gamma = \frac{A_C}{A_A+A_B+A_C}
\]</span></p>
<h3 id="应用">应用</h3>
<h4 id="判断点与三角形的关系">判断点与三角形的关系</h4>
<p>重心坐标有很多应用, 在这里我们能用到的结论是: 若<span class="math inline">\(\alpha,\beta,\gamma\)</span>均大于<span class="math inline">\(0\)</span>, 则点<span class="math inline">\(P\)</span>在三角形<span class="math inline">\(\Delta ABC\)</span>的内部; 若<span class="math inline">\(\alpha,\beta,\gamma\)</span>有一个等于<span class="math inline">\(0\)</span>, 则点<span class="math inline">\(P\)</span>在三角形的边上; 若<span class="math inline">\(\alpha,\beta,\gamma\)</span>有两个等于<span class="math inline">\(0\)</span>, 则点<span class="math inline">\(P\)</span>在三角形的顶点上.</p>
<p>下面的代码采用了向量叉积法:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">insideTriangle</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">const</span> Vector3f* _v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> inside = <span class="literal">true</span>;</span><br><span class="line">    Vector3f result =  <span class="comment">//cal cross</span></span><br><span class="line">            <span class="built_in">Vector3f</span>(_v[<span class="number">1</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>(),_v[<span class="number">2</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>(),_v[<span class="number">0</span>].<span class="built_in">x</span>() - x)</span><br><span class="line">            .<span class="built_in">cross</span>(<span class="built_in">Vector3f</span>(_v[<span class="number">1</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>(),_v[<span class="number">2</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>(),_v[<span class="number">0</span>].<span class="built_in">y</span>() - y));</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(result.<span class="built_in">z</span>()) &lt; eps)inside = <span class="literal">false</span>;<span class="comment">//z == 0</span></span><br><span class="line">    result.<span class="built_in">x</span>() /= result.<span class="built_in">z</span>(),result.<span class="built_in">y</span>() /= result.<span class="built_in">z</span>();</span><br><span class="line">    <span class="keyword">float</span> alpha = <span class="number">1</span> - result.<span class="built_in">x</span>() - result.<span class="built_in">y</span>(),beta = result.<span class="built_in">x</span>(),gamma = result.<span class="built_in">y</span>();</span><br><span class="line">    <span class="keyword">if</span>(alpha &lt; eps <span class="keyword">or</span> beta &lt; eps <span class="keyword">or</span> gamma &lt; eps)inside = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> inside;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重心">重心</h4>
<figure>
<img src="/.io//image-20221219101838190.png" alt="image-20221219101838190"><figcaption aria-hidden="true">image-20221219101838190</figcaption>
</figure>
<h4 id="根据顶点进行线性插值">根据顶点进行线性插值</h4>
<figure>
<img src="/.io//image-20221219102046013.png" alt="image-20221219102046013"><figcaption aria-hidden="true">image-20221219102046013</figcaption>
</figure>
<p>​ 求出重心坐标后, 只需计算 <span class="math display">\[
V = \alpha V_A + \beta V_B + \gamma V_C
\]</span> 其中<span class="math inline">\(V\)</span>可以是任何想要插值的值. (注意投影会改变重心坐标, 在插值时需要先在三维计算重心坐标再投影到二维)</p>
<figure>
<img src="/.io//image-20221219103020986.png" alt="image-20221219103020986"><figcaption aria-hidden="true">image-20221219103020986</figcaption>
</figure>
<h4 id="透视矫正插值">透视矫正插值</h4>
<p>阅读资料: https://zhuanlan.zhihu.com/p/403259571</p>
<p>令 <span class="math display">\[
Z_n = \frac{1}{\alpha + \beta + \gamma}
\]</span> 顶点的<span class="math inline">\(z\)</span>坐标和纹理坐标在经过重心插值后, 还需乘上这个系数进行矫正.</p>
<h2 id="纹理放大texture-magnification">纹理放大(Texture Magnification)</h2>
<figure>
<img src="/.io//image-20221219103436527.png" alt="image-20221219103436527"><figcaption aria-hidden="true">image-20221219103436527</figcaption>
</figure>
<p>通常情况下我们希望像素(pixel)和纹理元素(texel)是一一对应的关系, 但当pixel数量多于/少于texel时, 便需要一种方法来将纹理进行变换.</p>
<h3 id="双线性插值bilinear-interpolation">双线性插值(Bilinear Interpolation)</h3>
<p>如下图, 假设我们需要采样红点处的texel值<span class="math inline">\(f(x,y)\)</span></p>
<p><img src="/.io//image-20221219103701756.png" alt="image-20221219103701756" style="zoom:50%;"></p>
<p>按如下方法选取红点临近的四个texel并将其标号(<span class="math inline">\(u\)</span>即该texel的值, 如颜色值, 深度等等)</p>
<p><img src="/.io//image-20221219104000472.png" alt="image-20221219104000472" style="zoom:50%;"></p>
<p>并记红点到<span class="math inline">\(u_{00}\)</span>的中心点的距离为<span class="math inline">\(s,t\)</span>. 这里假设<span class="math inline">\(s,t \in [0,1]\)</span></p>
<figure>
<img src="/.io//image-20221219104123598.png" alt="image-20221219104123598"><figcaption aria-hidden="true">image-20221219104123598</figcaption>
</figure>
<p>我们按如下方法定义一维的线性插值: <span class="math display">\[
\text{lerp}(x,v_0,v_1) = v_0 + x (v_1 - v_0)
\]</span> <img src="/.io//image-20221219104952425.png" alt="image-20221219104952425"></p>
<p>首先从一个方向(这里是水平)进行插值: <span class="math display">\[
u_0 = \text{lerp}(s,u_{00},u_{10})\\
u_1 = \text{lerp}(s,u_{01},u_{11})
\]</span> 再从另一个方向(竖直)插值即可得到<span class="math inline">\(f(x,y)\)</span>: <span class="math display">\[
f(x,y) = lerp(t,u_0,u_1)
\]</span> 这样一个pixel便综合考虑了它临近的四个texel的值.</p>
<h3 id="当纹理过大时">当纹理过大时</h3>
<figure>
<img src="/.io//image-20221219112706797.png" alt="image-20221219112706797"><figcaption aria-hidden="true">image-20221219112706797</figcaption>
</figure>
<figure>
<img src="/.io//image-20221219112924865.png" alt="image-20221219112924865"><figcaption aria-hidden="true">image-20221219112924865</figcaption>
</figure>
<p>如图，当一个pixel覆盖了很多个texel时(地平线处的格子), 仍然直接进行插值便会出现很严重的问题. 在之前的反走样部分, 通过超采样(例如MSAA)可以解决这一问题. 但超采样对性能的消耗很高. 为了解决性能问题, 我们直接求每个pixel覆盖的texel的平均值.</p>
<h4 id="mipmap">Mipmap</h4>
<figure>
<img src="/.io//image-20221221163827485.png" alt="image-20221221163827485"><figcaption aria-hidden="true">image-20221221163827485</figcaption>
</figure>
<figure>
<img src="/.io//image-20221221164045467.png" alt="image-20221221164045467"><figcaption aria-hidden="true">image-20221221164045467</figcaption>
</figure>
<p>如上图, mipmap从第<span class="math inline">\(0\)</span>层(原图)开始, 每次将图像的边长缩小一半, 形成新的一层(记为<span class="math inline">\(D\)</span>), 直到不能缩小为止. 这样每一层都存储了一个方形区域texel平均值的近似值. 查询时, 只要根据pixel的坐标和覆盖大小, 在mipmap中找到对应位置, 便可快速求出平均值, 容易计算这样只会占用<span class="math inline">\(\frac{1}{3}\)</span>的额外存储空间.</p>
<figure>
<img src="/.io//image-20221221165133886.png" alt="image-20221221165133886"><figcaption aria-hidden="true">image-20221221165133886</figcaption>
</figure>
<p>在计算<span class="math inline">\(D\)</span>时, 我们取当前待求点所在的一个正方形(上图红色部分), 将其投影到纹理空间中. 令<span class="math inline">\(L\)</span>为当前点到相邻两个点在纹理空间中距离的最大值, 则<span class="math inline">\(D = \log_2L\)</span></p>
<figure>
<img src="/.io//image-20221221170102301.png" alt="image-20221221170102301"><figcaption aria-hidden="true">image-20221221170102301</figcaption>
</figure>
<p>用这样的方法求出来的<span class="math inline">\(D\)</span>将其取整到整数后, 有很大的问题: 不连续(图中的色块).</p>
<figure>
<img src="/.io//image-20221221170355687.png" alt="image-20221221170355687"><figcaption aria-hidden="true">image-20221221170355687</figcaption>
</figure>
<p>三线性插值(Trilinear Interpolation)可以解决这个问题. 我们先对<span class="math inline">\(D\)</span>和<span class="math inline">\(D+1\)</span>层分别做一次双线性插值, 再根据取整之前<span class="math inline">\(D\)</span>的值再做一次线性插值, 便能得到不错的结果:</p>
<figure>
<img src="/.io//image-20221221170533925.png" alt="image-20221221170533925"><figcaption aria-hidden="true">image-20221221170533925</figcaption>
</figure>
<h4 id="各项异性过滤anisotropic-filtering">各项异性过滤(Anisotropic Filtering)</h4>
<figure>
<img src="/.io//image-20221221170902803.png" alt="image-20221221170902803"><figcaption aria-hidden="true">image-20221221170902803</figcaption>
</figure>
<figure>
<img src="/.io//image-20221221170913408.png" alt="image-20221221170913408"><figcaption aria-hidden="true">image-20221221170913408</figcaption>
</figure>
<figure>
<img src="/.io//image-20221221171236905.png" alt="image-20221221171236905"><figcaption aria-hidden="true">image-20221221171236905</figcaption>
</figure>
<p>如上图.屏幕空间到纹理空间的映射过程中, 并不是每个像素都对应一个理想的正方形, 有的会被拉伸成细长的矩形. Mipmap在处理这样的像素时, 因为平均范围过大变得过度模糊而失去了细节.</p>
<figure>
<img src="/.io//image-20221221171522167.png" alt="image-20221221171522167"><figcaption aria-hidden="true">image-20221221171522167</figcaption>
</figure>
<p>各向异性过滤在Mipmap的基础上, 计算了不同长度宽度的组合(Mipmap只计算了上图中对角线部分). 这样在查询时, 对于细长的、近似水平或竖直的矩形可以得到更好的效果, 但仍然难处理细长的斜向矩形.</p>
<h2 id="立方体贴图cube-map">立方体贴图(Cube Map)</h2>
<figure>
<img src="/.io//image-20221230193850676.png" alt="image-20221230193850676"><figcaption aria-hidden="true">image-20221230193850676</figcaption>
</figure>
<figure>
<img src="/.io//image-20221230193903585.png" alt="image-20221230193903585"><figcaption aria-hidden="true">image-20221230193903585</figcaption>
</figure>
<p>在记录环境光时, 可以用一个光滑的金属球, 记录其表面的反射光, 再将其展开成一个平面. 但这样有一个问题: 展开图的上部和下部会发生比较严重的变形. 立方体贴图便是解决这种问题的方法.</p>
<figure>
<img src="/.io//image-20221230194258226.png" alt="image-20221230194258226"><figcaption aria-hidden="true">image-20221230194258226</figcaption>
</figure>
<figure>
<img src="/.io//image-20221230194504922.png" alt="image-20221230194504922"><figcaption aria-hidden="true">image-20221230194504922</figcaption>
</figure>
<p>如图, 我们用一个包围盒把球围起来. 从球心出发向外的每一条光线最终会打在这个包围盒上. 记录这些打在包围盒上的光线, 再将包围盒展开, 便得到了立方体贴图. 立方体贴图的变形明显更少, 但是需要计算一下每个方向对应的面.</p>
<h2 id="凹凸法线贴图bumpnormal-mapping">凹凸/法线贴图(Bump/Normal Mapping)</h2>
<p>推荐阅读: https://zhuanlan.zhihu.com/p/412555049</p>
<figure>
<img src="/.io//image-20221230201203530.png" alt="image-20221230201203530"><figcaption aria-hidden="true">image-20221230201203530</figcaption>
</figure>
<p>在之前的Bling Phong模型中, 我们利用了顶点的法线数据来插值得到每个像素的法线. 这种方式计算量大, 却不能在模型面数较少时取得较好的效果. 凹凸贴图/法线贴图也是材质的一种, 它让我们可以用贴图的信息来计算每个顶点的法线. 右图便是一个简单的球形应用了法线贴图后的效果. 可以看出,凹凸/法线贴图可以在不增加三角形面的前提下提升表现细节.</p>
<h3 id="凹凸贴图">凹凸贴图</h3>
<figure>
<img src="/.io//image-20221231100908188.png" alt="image-20221231100908188"><figcaption aria-hidden="true">image-20221231100908188</figcaption>
</figure>
<p>凹凸贴图是一张二维的黑白图片, 一般越白的部分表示高度越高. 它通过重新定义(或者说扰动)高度的方法, 来让我们能计算新的法线. 在上图中, 物体本身的法线为<span class="math inline">\(\vec{p}\)</span>, 经过凹凸贴图扰动后(橙色曲线)计算出的新法线为<span class="math inline">\(\vec{n}\)</span>.</p>
<figure>
<img src="/.io//image-20221231102657626.png" alt="image-20221231102657626"><figcaption aria-hidden="true">image-20221231102657626</figcaption>
</figure>
<p>先考虑如何在一维求扰动后的法线. 假设原物体是一条和<span class="math inline">\(x\)</span>轴平行的直线, 这样它的法线<span class="math inline">\(\vec{n} = (0,1)\)</span>. 蓝色曲线是被凹凸贴图扰动后的结果. 我们先近似求出蓝色点切线的斜率<span class="math inline">\(dp\)</span>. 因为凹凸贴图也是一种材质, 能细分的最小单位是一个像素, 所以<span class="math inline">\(dp\)</span>可以简单的用相邻两点间高度<span class="math inline">\(h\)</span>的差值得到(其中系数<span class="math inline">\(c\)</span>定义了凹凸贴图的影响有多大): <span class="math display">\[
dp = c(h(p+1) - h(p))
\]</span> 这样切线便是<span class="math inline">\((1,dp)\)</span>. 将其旋转90°可得法线<span class="math inline">\(\vec{n} = (-dp,1)\text{.normalized()}\)</span>. 时刻注意表示方向的向量必须归一化.</p>
<figure>
<img src="/.io//image-20221231104248459.png" alt="image-20221231104248459"><figcaption aria-hidden="true">image-20221231104248459</figcaption>
</figure>
<p>三维情况下, 我们假设最初的法线是<span class="math inline">\((0,0,1)\)</span>. 类比(这里有较为复杂的推导步骤, 在这里省略)一维情况, 分别求出<span class="math inline">\(u,v\)</span>两个方向上的斜率, 可得法线: <span class="math display">\[
\vec{n} = (-du,-dv,1)\text{.normalized()}
\]</span> 注意: 上述坐标是在假设法线为<span class="math inline">\((0,0,1)\)</span>, 且构成坐标系的一个轴的前提下计算的. 要真正使用凹凸贴图定义的法线, 还需将其变换回世界坐标.</p>
<h3 id="法线贴图">法线贴图</h3>
<p>凹凸贴图存储了每个像素扰动后的高度, 在使用时仍需进行计算来得到每个像素的法线. 而法线贴图则帮我们完成了这一步, 它直接将法线信息存储在材质中. 材质的<span class="math inline">\(R,G,B\)</span>三维便对应了法线的<span class="math inline">\(x,y,z\)</span>. 需要注意的是, RGB分量是无符号值, 而法线是有符号的. 因此我们在写入(<span class="math inline">\(\text{normal} \to \text{color}\)</span>)和读取(<span class="math inline">\(\text{color} \to \text{normal}\)</span>)时要进行一定的转换: <span class="math display">\[
\text{color} = \frac{\text{normal}}{2} + 0.5\\
\text{normal} = 2 \cdot (\text{color} - 0.5)
\]</span> 另外值得注意的一点是, 大多数法线贴图看上去都是蓝色的, 这是因为默认法线是<span class="math inline">\((0,0,1)\)</span>, 编码成颜色信息后是<span class="math inline">\(\text{RGB}(0.5,0.5,1)\)</span>. 蓝色部分说明对法线信息没有太大改动.</p>
<h3 id="tbn矩阵待补充">TBN矩阵(待补充)</h3>
<p>在使用凹凸贴图/法线贴图时, 我们均假设了法线指向<span class="math inline">\((0,0,1)\)</span></p>
<p>(等学到光线追踪再补)</p>
<h2 id="位移贴图displacement-mapping">位移贴图(Displacement Mapping)</h2>
<figure>
<img src="/.io//image-20221231163142098.png" alt="image-20221231163142098"><figcaption aria-hidden="true">image-20221231163142098</figcaption>
</figure>
<h2 id="阴影贴图shadow-mapping">阴影贴图(Shadow mapping)</h2>
<figure>
<img src="/.io//image-20230102162421668.png" alt="image-20230102162421668"><figcaption aria-hidden="true">image-20230102162421668</figcaption>
</figure>
<figure>
<img src="/.io//image-20230102162429547.png" alt="image-20230102162429547"><figcaption aria-hidden="true">image-20230102162429547</figcaption>
</figure>
<figure>
<img src="/.io//image-20230102162437931.png" alt="image-20230102162437931"><figcaption aria-hidden="true">image-20230102162437931</figcaption>
</figure>
<figure>
<img src="/.io//image-20230102162455204.png" alt="image-20230102162455204"><figcaption aria-hidden="true">image-20230102162455204</figcaption>
</figure>
<figure>
<img src="/.io//image-20230102162502379.png" alt="image-20230102162502379"><figcaption aria-hidden="true">image-20230102162502379</figcaption>
</figure>
<p>阴影贴图的工作流程如下:</p>
<ol type="1">
<li>从光源出发(将光源当作相机), 生成一张物体的深度图</li>
<li>从相机出发，对于看到的每一个点, 将其投影回上一步的深度图对应的位置. 如果该点的实际深度与深度图记录的相同, 那么这个点就是可见的, 否则不可见.</li>
</ol>
<p>Shadow Mapping也会存在一些问题:</p>
<ul>
<li>硬阴影，且只支持点光源</li>
<li>质量与深度图的分辨率有关</li>
<li>存在数值精度问题 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Z-fighting">Z-fighting</a></li>
</ul>
<h1 id="几何geometry">几何(Geometry)</h1>
<h2 id="基本表示方法">基本表示方法</h2>
<h3 id="隐式表述">隐式表述</h3>
<h4 id="普通方程">普通方程</h4>
<figure>
<img src="/.io//image-20230101085836806.png" alt="image-20230101085836806"><figcaption aria-hidden="true">image-20230101085836806</figcaption>
</figure>
<p>普通方程直接给出<span class="math inline">\(x,y,z\)</span>之间的关系, 例如<span class="math inline">\(f(x,y,z) = 0\)</span>. 观察上图的公式, 很难直接看出普通方程对应的图形是什么, 即普通方程的采样十分困难. 但判断某个点在普通方程定义的几何体的内部/外部非常简单: 将该点的坐标带入<span class="math inline">\(f\)</span>, 与等式右边的值比较即可. 同时, 隐式表述的几何体很容易做光线和几何的交.</p>
<h4 id="构造实体几何constructive-solid-geometry">构造实体几何(Constructive Solid Geometry)</h4>
<figure>
<img src="/.io//image-20230101090758941.png" alt="image-20230101090758941"><figcaption aria-hidden="true">image-20230101090758941</figcaption>
</figure>
<p>构造实体几何(CSG)使用逻辑运算来将简单的几何体组合成复杂的形体.</p>
<h4 id="距离函数distance-functions">距离函数(Distance Functions)</h4>
<figure>
<img src="/.io//image-20230101091219298.png" alt="image-20230101091219298"><figcaption aria-hidden="true">image-20230101091219298</figcaption>
</figure>
<figure>
<img src="/.io//image-20230101091901164.png" alt="image-20230101091901164"><figcaption aria-hidden="true">image-20230101091901164</figcaption>
</figure>
<figure>
<img src="/.io//image-20230101091907809.png" alt="image-20230101091907809"><figcaption aria-hidden="true">image-20230101091907809</figcaption>
</figure>
<figure>
<img src="/.io//image-20230101092000903.png" alt="image-20230101092000903"><figcaption aria-hidden="true">image-20230101092000903</figcaption>
</figure>
<h4 id="水平集方法level-set-methods">水平集方法(Level Set Methods)</h4>
<figure>
<img src="/.io//image-20230101093158811.png" alt="image-20230101093158811"><figcaption aria-hidden="true">image-20230101093158811</figcaption>
</figure>
<h4 id="分形fractals">分形(Fractals)</h4>
<figure>
<img src="/.io//image-20230101093458135.png" alt="image-20230101093458135"><figcaption aria-hidden="true">image-20230101093458135</figcaption>
</figure>
<h3 id="显式表述">显式表述</h3>
<h4 id="参数方程">参数方程</h4>
<figure>
<img src="/.io//image-20230101090125770.png" alt="image-20230101090125770"><figcaption aria-hidden="true">image-20230101090125770</figcaption>
</figure>
<figure>
<img src="/.io//image-20230101090228895.png" alt="image-20230101090228895"><figcaption aria-hidden="true">image-20230101090228895</figcaption>
</figure>
<p>显式表述的参数方程直接定义一个从一个坐标向另一个坐标转换的方式. 它采样起来十分简单: 只需将原坐标的值代入<span class="math inline">\(f\)</span>就能得到新坐标的值. 但它判断某个点在几何体的内部/外部十分困难.</p>
<h4 id="点云point-cloud">点云(Point Cloud)</h4>
<figure>
<img src="/.io//image-20230101161856992.png" alt="image-20230101161856992"><figcaption aria-hidden="true">image-20230101161856992</figcaption>
</figure>
<h4 id="多边形面polygon-mesh">多边形面(Polygon Mesh)</h4>
<figure>
<img src="/.io//image-20230101162104438.png" alt="image-20230101162104438"><figcaption aria-hidden="true">image-20230101162104438</figcaption>
</figure>
<h4 id="贝塞尔曲线">贝塞尔曲线</h4>
<p>见曲线章节</p>
<h2 id="曲线">曲线</h2>
<h3 id="贝塞尔曲线bézier-curves">贝塞尔曲线(Bézier Curves)</h3>
<p>贝塞尔曲线是一种由<strong>控制点</strong>来确定形状的曲线. <span class="math inline">\(n\)</span>个控制点描述了一个<span class="math inline">\(n-1\)</span>阶的贝塞尔曲线. 下面是正在绘制的不同阶贝塞尔曲线的一些例子:</p>
<figure>
<img src="/.io//image-20230101191607647.png" alt="image-20230101191607647"><figcaption aria-hidden="true">image-20230101191607647</figcaption>
</figure>
<p>注意图中的<span class="math inline">\(t = 0.49\)</span>. 遍历<span class="math inline">\(t \in[0,1]\)</span>, 计算并绘制某一点的运动轨迹(图中红点), 这条轨迹便是贝塞尔曲线. 从上图可以看出, <span class="math inline">\(k\)</span>阶贝塞尔曲线可以从<span class="math inline">\(k-1\)</span>阶递推得到. 这一递推算法称作德卡斯特里奥算法(De Casteljau's algorithm).</p>
<p>在解释这一算法之前, 我们先来看一下一阶贝塞尔曲线的表达式: <span class="math display">\[
B_1(t) = P_0 + (P_1 - P_0)t
\]</span> 很显然, 这是一个线性插值. 观察一阶贝塞尔曲线的图像, 可以看出它就是一条直线.</p>
<figure>
<img src="/.io//image-20230101192935349.png" alt="image-20230101192935349"><figcaption aria-hidden="true">image-20230101192935349</figcaption>
</figure>
<p>在时刻为<span class="math inline">\(t\)</span>时, 图中红色部分与整个线段的长度比为<span class="math inline">\(t:1\)</span>. 现在我们扩展到二阶贝塞尔曲线:</p>
<figure>
<img src="/.io//image-20230101193200797.png" alt="image-20230101193200797"><figcaption aria-hidden="true">image-20230101193200797</figcaption>
</figure>
<p>可以看到, 我们对<span class="math inline">\(\vec{b_0b_1}\)</span>和<span class="math inline">\(\vec{b_1b_2}\)</span>分别进行线性插值(简称lerp)得到了<span class="math inline">\(b_0^1\)</span>和<span class="math inline">\(b_0^2\)</span>两个点, 这两个点可以作为一个新的一阶贝塞尔曲线的控制点. 再对其进行线性插值, 便得到了要绘制的点<span class="math inline">\(b_0^2\)</span>.</p>
<figure>
<img src="/.io//image-20230101194348767.png" alt="image-20230101194348767"><figcaption aria-hidden="true">image-20230101194348767</figcaption>
</figure>
<p>三阶曲线也类似. 这样, 对于<span class="math inline">\(n\)</span>阶的贝塞尔曲线, 每插值一轮, 其阶数便减<span class="math inline">\(1\)</span>, 直到阶数等于<span class="math inline">\(1\)</span>. 这便是德卡斯特里奥算法的核心思想.</p>
<p>贝塞尔曲线也有非递推的公式(<span class="math inline">\(P_i\)</span>为控制点): <span class="math display">\[
b^n(t) = \sum_{i = 0}^nP_i \cdot B_i^n(t), t\in[0,1]
\]</span> 这个方法更快, 但数值稳定性不如递推算法高. 其中<span class="math inline">\(B_i^n(t)\)</span>称为伯恩施坦多项式 (Bernstein polynomial) <span class="math display">\[
B_i^n(t) = \binom{n}{i}t^i(1-t)^{n-i}
\]</span> <img src="/.io//image-20230101203944181.png" alt="image-20230101203944181"></p>
<p>伯恩施坦多项式有一个概率意义上的解释: 某独立事件发生一次的概率为<span class="math inline">\(p\)</span>, 那么进行<span class="math inline">\(n\)</span>次事件, 恰好发生<span class="math inline">\(i\)</span>次的概率为<span class="math inline">\(B_i^n(p)\)</span>. 既然我们能将其解释为概率, 那么同一阶伯恩施坦多项式在任何时间下的和必为<span class="math inline">\(1\)</span>, 即<span class="math inline">\(\sum_{i = 0}^nB_i^n(t) = 1\)</span>.</p>
<p>贝塞尔曲线有如下性质:</p>
<ul>
<li>一条贝塞尔曲线一定从第一个控制点开始, 在最后一个控制点结束. 需要注意的是贝塞尔曲线不必经过全部控制点.</li>
<li>对于三阶贝塞尔曲线, 其插值得到的两个二阶曲线为: <span class="math inline">\(b&#39;(0) = 3(P_1 - P_0),b&#39;(1) = 3(P_3 - P_2)\)</span>.</li>
<li>对控制点做仿射变换等价于对贝塞尔曲线做仿射变换, 但对投影变换不满足.</li>
<li>贝塞尔曲线一定位于控制点构成的凸包内.</li>
</ul>
<h4 id="分段贝塞尔曲线piecewise-bézier-curves">分段贝塞尔曲线(Piecewise Bézier Curves)</h4>
<figure>
<img src="/.io//image-20230101205249527.png" alt="image-20230101205249527"><figcaption aria-hidden="true">image-20230101205249527</figcaption>
</figure>
<p>高阶的贝塞尔曲线看上去很不直观, 也很难再用控制点来控制它的形状.</p>
<figure>
<img src="/.io//image-20230101205455090.png" alt="image-20230101205455090"><figcaption aria-hidden="true">image-20230101205455090</figcaption>
</figure>
<p>将控制点每<span class="math inline">\(k\)</span>个点(比如每四个)分段, 便是分段贝塞尔曲线. 但直接进行分段可能会出现尖锐的部分(如上图). 对贝塞尔曲线的连通性有如下定义:</p>
<figure>
<img src="/.io//image-20230101210542727.png" alt="image-20230101210542727"><figcaption aria-hidden="true">image-20230101210542727</figcaption>
</figure>
<figure>
<img src="/.io//image-20230101210843747.png" alt="image-20230101210843747"><figcaption aria-hidden="true">image-20230101210843747</figcaption>
</figure>
<figure>
<img src="/.io//image-20230101210935095.png" alt="image-20230101210935095"><figcaption aria-hidden="true">image-20230101210935095</figcaption>
</figure>
<p><span class="math inline">\(C^0\)</span>连续性: 第一段曲线的终点和第二段曲线的起点相同.</p>
<p><span class="math inline">\(C^1\)</span>连续性: 两曲线的交点及其相邻的左右两个点共线, 且交点是这一线段的中点.</p>
<h3 id="样条splines">样条(splines)</h3>
<h4 id="b样条待补充">B样条(待补充)</h4>
<h2 id="曲面">曲面</h2>
<h3 id="贝塞尔曲面bézier-surfaces">贝塞尔曲面(Bézier Surfaces)</h3>
<figure>
<img src="/.io//image-20230101212424816.png" alt="image-20230101212424816"><figcaption aria-hidden="true">image-20230101212424816</figcaption>
</figure>
<figure>
<img src="/.io//image-20230101212550919.png" alt="image-20230101212550919"><figcaption aria-hidden="true">image-20230101212550919</figcaption>
</figure>
<p>我们用类似双线性插值的思想, 将<span class="math inline">\(4\times 4\)</span>个控制点分成四组, 每组四个点, 求出每一组在时间<span class="math inline">\(t_1\)</span>时所绘制的点. 再将这四个点作为一条新的贝塞尔曲线的控制点, 遍历<span class="math inline">\(t_2\)</span>. 这样在<span class="math inline">\(t_1 \cdot t_2\)</span>时间内, 绘制的点便能形成一个贝塞尔曲面.</p>
<h2 id="对网格面的几何操作">对网格面的几何操作</h2>
<h3 id="曲面细分mesh-subdivision">曲面细分(Mesh subdivision)</h3>
<figure>
<img src="/.io//image-20230102102512465.png" alt="image-20230102102512465"><figcaption aria-hidden="true">image-20230102102512465</figcaption>
</figure>
<p>表面细分做了两件事: 1. 增加三角形数量 2. 调整三角形的位置</p>
<h4 id="loop细分loop-subdivision">Loop细分(Loop Subdivision)</h4>
<p>注意这里的Loop和循环没关系, Loop是发明者的姓.</p>
<figure>
<img src="/.io//image-20230102102743279.png" alt="image-20230102102743279"><figcaption aria-hidden="true">image-20230102102743279</figcaption>
</figure>
<p>Loop细分只能处理三角形网格. 它将一个三角形分成四个, 在划分的过程中会产生新的点. 我们需要将新生成的点和原先存在的点区分进行处理:</p>
<figure>
<img src="/.io//image-20230102103149087.png" alt="image-20230102103149087"><figcaption aria-hidden="true">image-20230102103149087</figcaption>
</figure>
<p>对于新生成的每个点, 记这个点所在的三角形边上两个顶点为<span class="math inline">\(A,B\)</span>. 这条边相对的顶点为<span class="math inline">\(C,D\)</span>. 则新生成的顶点<span class="math inline">\(P_{new}\)</span>位置调整到: <span class="math display">\[
P_{new} = \frac{3}{8} \cdot(A + B) + \frac{1}{8} \cdot (C + D)
\]</span> <img src="/.io//image-20230102103449651.png" alt="image-20230102103449651"></p>
<p>对于旧顶点, 按下式更新: <span class="math display">\[
P_{old} = (1 - n\cdot u) \cdot P_{origin} + u\cdot \sum P_{neighbor}
\]</span> 其中:</p>
<ul>
<li><span class="math inline">\(P_{origin}\)</span>: 该点原先的位置</li>
<li><span class="math inline">\(\sum P_{neighbor}\)</span>: 该点相邻点的和</li>
<li><span class="math inline">\(n\)</span>: 该点的度数(相邻点的数量)</li>
<li><span class="math inline">\(u = \frac{3}{8n}\)</span>. 若<span class="math inline">\(n = 3, u = \frac{3}{16}\)</span></li>
</ul>
<h4 id="catmull-clark-subdivision-general-mesh">Catmull-Clark Subdivision (General Mesh)</h4>
<figure>
<img src="/.io//image-20230102104257086.png" alt="image-20230102104257086"><figcaption aria-hidden="true">image-20230102104257086</figcaption>
</figure>
<p>Catmull-Clark Subdivision可以处理一般化的网格. 它将每个面分为四边形面和非四边形面两部分. 将点按度数分类: 所有度数不是<span class="math inline">\(4\)</span>的点为奇异点(Extraordinary vertex).</p>
<figure>
<img src="/.io//image-20230102104653238.png" alt="image-20230102104653238"><figcaption aria-hidden="true">image-20230102104653238</figcaption>
</figure>
<p>在细分时, 我们在每个面内选取一个点, 再将其和每条边的中点相连. 可以看出, 做了一次细分之后, 新增的奇异点个数等于原来非四边形面的个数, 且这些非四边形面都会变成四边形面. 也就是说, 奇异点个数仅可能在第一次细分时增加.</p>
<figure>
<img src="/.io//image-20230102104956880.png" alt="image-20230102104956880"><figcaption aria-hidden="true">image-20230102104956880</figcaption>
</figure>
<p>计算方式见上图(待详细补充).</p>
<figure>
<img src="/.io//image-20230102105202170.png" alt="image-20230102105202170"><figcaption aria-hidden="true">image-20230102105202170</figcaption>
</figure>
<h3 id="曲面简化mesh-simplification">曲面简化(Mesh Simplification)</h3>
<figure>
<img src="/.io//image-20230102110207321.png" alt="image-20230102110207321"><figcaption aria-hidden="true">image-20230102110207321</figcaption>
</figure>
<figure>
<img src="/.io//image-20230102160417599.png" alt="image-20230102160417599"><figcaption aria-hidden="true">image-20230102160417599</figcaption>
</figure>
<h4 id="二次误差度量quadric-error-metrics">二次误差度量(Quadric Error Metrics)</h4>
<p>(待补充)</p>
<figure>
<img src="/.io//image-20230102160632054.png" alt="image-20230102160632054"><figcaption aria-hidden="true">image-20230102160632054</figcaption>
</figure>
<p>我们在删掉一个顶点之后, 需要调整其他顶点的位置来让简化后的模型与原模型误差尽量的小. 这个误差可以用二次误差度量来表示.</p>
<figure>
<img src="/.io//image-20230102161104395.png" alt="image-20230102161104395"><figcaption aria-hidden="true">image-20230102161104395</figcaption>
</figure>
<figure>
<img src="/.io//image-20230102161115053.png" alt="image-20230102161115053"><figcaption aria-hidden="true">image-20230102161115053</figcaption>
</figure>
<h1 id="光线追踪ray-tracing">光线追踪(Ray Tracing)</h1>
<figure>
<img src="/.io//image-20230102165148477.png" alt="image-20230102165148477"><figcaption aria-hidden="true">image-20230102165148477</figcaption>
</figure>
<p>我们对光线做如下假设:</p>
<ul>
<li>光线沿直线传播</li>
<li>光线不会发生碰撞</li>
<li>光线从光源出发, 经过一系列折射反射等后, 进入观察者的眼睛, 这个过程可逆.(reciprocity)</li>
</ul>
<h2 id="光线投射算法ray-casting">光线投射算法(Ray Casting)</h2>
<p><img src="/.io//image-20230102172147726.png" alt="image-20230102172147726" style="zoom:50%;"></p>
<p><img src="/.io//image-20230103085159189.png" alt="image-20230103085159189" style="zoom: 67%;"></p>
<p><img src="/.io//image-20230103085207993.png" alt="image-20230103085207993" style="zoom: 67%;"></p>
<h2 id="recursive-whitted-style-ray-tracing">Recursive (Whitted-Style) Ray Tracing</h2>
<p><img src="/.io//image-20230103090059354.png" alt="image-20230103090059354" style="zoom: 67%;"></p>
<p>如上图. 对于每个像素, 从观测点发出一条光线. 这一条光线可以经过多次反射、折射、吸收, 在多个地方与多个物体有交点. 我们对这每一个交点将其与光源连线, 判断可见性并着色, 再将着色结果全部加回到像素中. 这便是Recursive (Whitted-Style) Ray Tracing的基本思想.</p>
<h2 id="光线与表面求交ray-surface-intersection">光线与表面求交(Ray-Surface Intersection)</h2>
<h3 id="光线定义">光线定义</h3>
<p><img src="/.io//image-20230103090856184.png" alt="image-20230103090856184" style="zoom:50%;"></p>
<h3 id="与隐式表面求交">与隐式表面求交</h3>
<p>先看如何与球求交</p>
<p>球的定义: <span class="math display">\[
\bold p : (\bold p - \bold c)^2 - R^2 = 0
\]</span> <img src="/.io//image-20230103091156776.png" alt="image-20230103091156776" style="zoom:50%;"></p>
<p>上图<span class="math inline">\(\bold o\)</span>为光源位置, <span class="math inline">\(\bold d\)</span>为光线方向. <span class="math inline">\(\bold p\)</span>为光线与球的交点, <span class="math inline">\(\bold c\)</span>为球心, <span class="math inline">\(R\)</span>为球的半径.</p>
<p>若光线与球相交, 则交点必须满足光线和球的表达式(即<span class="math inline">\(\bold p = \bold o + t\bold d\)</span>). 代入得: <span class="math display">\[
(\bold o + t \bold d - \bold c)^2 - R^2 = 0
\]</span> <img src="/.io//image-20230103091627336.png" alt="image-20230103091627336" style="zoom: 50%;"></p>
<p>直接展开求解即可. 注意<span class="math inline">\(t\)</span>必须为非负实数才有意义.</p>
<p>隐式表面: <span class="math display">\[
\bold p: f(\bold p) = 0
\]</span> 则光线与隐式表面求交: <span class="math display">\[
f(\bold o + t\bold d) = 0
\]</span> 求根即可.</p>
<h3 id="与三角面显式表面求交">与三角面(显式表面)求交</h3>
<p><img src="/.io//image-20230103092945358.png" alt="image-20230103092945358" style="zoom:67%;"></p>
<p><img src="/.io//image-20230103093000914.png" alt="image-20230103093000914" style="zoom: 67%;"></p>
<p>可以将光线与三角形求交拆成两步:</p>
<ol type="1">
<li>求光线与三角形所在平面的交点</li>
<li>判断交点是否在三角形内部</li>
</ol>
<p><img src="/.io//image-20230103093149661.png" alt="image-20230103093149661" style="zoom:67%;"></p>
<p>平面可以由一条法线<span class="math inline">\(\vec n\)</span>和屏幕上一点<span class="math inline">\(\bold{p&#39;}\)</span>来定义. <span class="math display">\[
\bold p : (\bold p - \bold p&#39;) \cdot \vec n = 0
\]</span> 展开为<span class="math inline">\(ax + by + cz + d = 0\)</span>的形式.</p>
<p>将光线定义代入:</p>
<p><img src="/.io//image-20230103093543226.png" alt="image-20230103093543226" style="zoom:50%;"></p>
<p>求出<span class="math inline">\(t\)</span>后判断是否在三角形内部即可.</p>
<h4 id="möller-trumbore-algorithm">Möller Trumbore Algorithm</h4>
<p>回忆一下我们用重心坐标判断点与三角形关系的过程: 若<span class="math inline">\(\alpha,\beta,\gamma\)</span>均大于<span class="math inline">\(0\)</span>, 则点<span class="math inline">\(P\)</span>在三角形<span class="math inline">\(\Delta ABC\)</span>的内部. 那么可以写出如下式子: <span class="math display">\[
\bold o + t\bold d = (1 - b_1 - b_2)\bold{P_0} + b_1 \bold{P_1} + b_2 \bold{P_2}
\]</span> <img src="/.io//image-20230103100315630.png" alt="image-20230103100315630" style="zoom:67%;"></p>
<p>这是一个有三个变量<span class="math inline">\((t,b_1,b_2)\)</span>三个方程的线性方程组. 很容易求解.</p>
<h5 id="作业5待补充">作业5(待补充)</h5>
<p>参考: https://zhuanlan.zhihu.com/p/431092843</p>
<ul>
<li>生成每个像素对应的光线</li>
</ul>
<h2 id="求交过程中的加速">求交过程中的加速</h2>
<h3 id="包围盒bounding-volumes">包围盒(Bounding Volumes)</h3>
<p><img src="/.io//image-20230103100829200.png" alt="image-20230103100829200" style="zoom:67%;"></p>
<p>在之前的算法中, 我们对每个像素发出的光线都要和全部三角形面求交. 使用包围盒后, 便可以先和包围盒求交. 如果二者不相交, 包围盒内的所有三角形都可以忽略不计.</p>
<p><img src="/.io//image-20230103101135974.png" alt="image-20230103101135974" style="zoom:67%;"></p>
<p>我们可以把包围盒理解为三对平面的交集. 这三对平面一般和坐标轴构成的平面平行. 下面主要讨论如何与轴对齐包围盒求交:</p>
<p><img src="/.io//image-20230103101759942.png" alt="image-20230103101759942" style="zoom:67%;"></p>
<p>先考虑二维的情况. 先将光线与<span class="math inline">\(x\)</span>面求交, 可以得到光线进入和射出的时间(这两个时间可以求出一条线段), <span class="math inline">\(y\)</span>面同理. 将这两个线段求交(即<span class="math inline">\(t_{min}\)</span>取<span class="math inline">\(\text{max}\)</span>,<span class="math inline">\(t_{max}\)</span>取<span class="math inline">\(\text{min}\)</span>), 即可求出光线在包围盒内的部分. 可以看出, 光线在包围盒内当且仅当光线进入矩形的所有对面(<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>). 光线离开包围盒只需满足离开任意对面.</p>
<p>现在推广到三维情况: 我们对三组对面分别求出它们的<span class="math inline">\(t_{min}\)</span>和<span class="math inline">\(t_{max}\)</span>.</p>
<p>可得进入时间: <span class="math inline">\(t_{enter} = \max(t_{min})\)</span></p>
<p>离开时间: <span class="math inline">\(t_{exit} = \min(t_{max})\)</span></p>
<p>当<span class="math inline">\(t_{enter} \leq t_{exit}\)</span>且<span class="math inline">\(t_{exit} \ge 0\)</span>时, 光线与包围盒相交.</p>
<p>对于AABB, 求交十分简单</p>
<h3 id="空间分割uniform-spatial-partitions-grids">空间分割(Uniform Spatial Partitions (Grids))</h3>
<p>在之前的优化中, 我们通过包围盒来避免了每条光线与每个三角面进行求交. 空间分割是对每个包围盒内部的判断进行进一步优化.</p>
<p><img src="/.io//image-20230103153852733.png" alt="image-20230103153852733" style="zoom:67%;"></p>
<p><img src="/.io//image-20230103154036499.png" alt="image-20230103154036499" style="zoom:67%;"></p>
<p>在一个包围盒内(图中最外层的边界即为包围盒), 将这个包围盒分成<span class="math inline">\(n \times n\)</span>个小格子. 如果一个格子包含了物体的表面, 就将其进行标记. 对于一条打进包围盒内部的光线, 我们首先计算它的行进路径上经过了哪些格子(Bresenham直线算法), 再对经过的格子中被标记的格子进行光线与物体的求交. 这样便避免了将光线与包围盒内的每个物体进行求交运算. 在三维空间中, 格子的个数一般取<span class="math inline">\(27 \times 物体个数\)</span></p>
<p>这种方法适合物体较均匀分布的场景.</p>
<h3 id="空间划分spatial-partitions">空间划分(Spatial Partitions)</h3>
<figure>
<img src="/.io//image-20230103154814447.png" alt="image-20230103154814447"><figcaption aria-hidden="true">image-20230103154814447</figcaption>
</figure>
<h4 id="k-d-tree">K-D Tree</h4>
<p>https://oi-wiki.org/ds/kdt/</p>
<p><img src="/.io//image-20230103160349287.png" alt="image-20230103160349287" style="zoom:67%;"></p>
<p><img src="/.io//image-20230103160356874.png" alt="image-20230103160356874" style="zoom:67%;"></p>
<p>K-D Tree有一些问题. 其一是物体与包围盒之间的关系很难进行判断(例如包围盒被三角形完全包围的情况). 其二是一个物体可能会同时存在于多个叶子节点中. 目前实践上已经很少使用K-D Tree, 而是改用BVH.</p>
<h3 id="物体划分与包围盒层次结构object-partitions-bounding-volume-hierarchy-bvh">物体划分与包围盒层次结构(Object Partitions &amp; Bounding Volume Hierarchy (BVH))</h3>
<p>PPT的信息已经足够充分, 这里不做过多解释. 详细实现留在作业6中.</p>
<p><img src="/.io//image-20230103161342545.png" alt="image-20230103161342545" style="zoom:67%;"></p>
<p><img src="/.io//image-20230103161405827.png" alt="image-20230103161405827" style="zoom:67%;"></p>
<p><img src="/.io//image-20230104092006753.png" alt="image-20230104092006753" style="zoom:67%;"></p>
<p><img src="/.io//image-20230104092638796.png" alt="image-20230104092638796" style="zoom:67%;"></p>
<p><img src="/.io//image-20230104093048787.png" alt="image-20230104093048787" style="zoom:67%;"></p>
<p><img src="/.io//image-20230104093112224.png" alt="image-20230104093112224" style="zoom:67%;"></p>
<h2 id="辐射度量学radiometry">辐射度量学(Radiometry)</h2>
<h3 id="基础-1">基础</h3>
<p><img src="/.io//image-20230104094036626.png" alt="image-20230104094036626" style="zoom:67%;"></p>
<p><img src="/.io//image-20230104094044139.png" alt="image-20230104094044139" style="zoom:67%;"></p>
<h4 id="辐射能和通量radiant-energy-and-flux-power">辐射能和通量(Radiant Energy and Flux (Power))</h4>
<p>辐射能即电磁辐射的能量, 用字母<span class="math inline">\(Q\)</span>表示. 单位是焦耳(<span class="math inline">\(J\)</span>,Joule). <span class="math display">\[
Q [\text J = \text{Joule}]
\]</span></p>
<p>辐射通量(Radiant flux), 也称作辐射功率(Radiant power), 是单位时间内发射/反射/传送/接受等等的能量. 用符号<span class="math inline">\(\Phi\)</span>表示. 单位是瓦或者流明. <span class="math display">\[
\Phi \equiv \frac{\text dQ}{\text d t}[\text{W = Watt}][\text{lm = lumen}]
\]</span></p>
<p><img src="/.io//image-20230119154805971.png" alt="image-20230119154805971" style="zoom:67%;"></p>
<p>上面是衡量光线的几种概念.</p>
<p>Radiant Intensity: 辐射强度</p>
<p>irradiance: 辐照度</p>
<p>radiance: 辐射</p>
<p>(中文译名不重要)</p>
<h4 id="辐射强度radiant-intensityi">辐射强度(Radiant Intensity,I)</h4>
<p><span class="math display">\[
I(\omega) = \frac{\text d \Phi}{\text d \omega} [\text{candela}]
\]</span></p>
<ul>
<li>立体角(Solid Angles)</li>
</ul>
<p><img src="/.io//image-20230105103912704.png" alt="image-20230105103912704" style="zoom:67%;"></p>
<p>在二维平面上, 角度<span class="math inline">\(\theta\)</span>被定义为扇形对应弧长<span class="math inline">\(l\)</span>与半径<span class="math inline">\(r\)</span>的比值. 在三维空间上, 令锥体所对的球面面积为<span class="math inline">\(A\)</span>, 则立体角: <span class="math display">\[
\Omega = \frac{A}{r^2}
\]</span> 单位是球面度(steradians). 注意立体角和角度一样, 也是无量纲量. 球的弧面度是<span class="math inline">\(4\pi\)</span></p>
<p><img src="/.io//image-20230105105000475.png" alt="image-20230105105000475" style="zoom:67%;"></p>
<p><img src="/.io//image-20230119155738314.png" alt="image-20230119155738314" style="zoom:67%;"></p>
<p><img src="/.io//image-20230119155039976.png" alt="image-20230119155039976" style="zoom:67%;"></p>
<p>如图, Radiant Intensity是单位立体角上的辐射通量(辐射功率), 单位是candela.</p>
<p><img src="/.io//image-20230119155946806.png" alt="image-20230119155946806" style="zoom:67%;"></p>
<p>约定使用<span class="math inline">\(\omega\)</span>来表示球坐标下的方向向量.</p>
<h4 id="辐照度irradiancee">辐照度(Irradiance,E)</h4>
<p><span class="math display">\[
E(\bold x) = \frac{\text d \Phi(\bold x)}{\text d A} [lux]
\]</span></p>
<p><img src="/.io//image-20230119163217212.png" alt="image-20230119163217212" style="zoom:67%;"></p>
<p>irradiance(辐照度)是入射到表面点上的单位面积的功率. 注意它和辐射强度(单位立体角上的功率)的区别. 注意这里需要入射光和平面垂直.</p>
<p><img src="/.io//image-20230119163932417.png" alt="image-20230119163932417" style="zoom:67%;"></p>
<p>回忆一下Bling-Phong模型里的兰伯特余弦定理. Irradiance的计算与它相同，计算的是投影面积.</p>
<p><img src="/.io//image-20230119164250275.png" alt="image-20230119164250275" style="zoom:67%;"></p>
<p>对于Bling-Phong模型中的能量衰减，这里也有更好的解释: irradiance随距离的平方反比衰减.</p>
<h4 id="辐亮度radiancel">辐亮度(Radiance,L)</h4>
<p><span class="math display">\[
L(p,\omega) = \frac{\text d ^2\Phi(\bold p,\omega)}{\text d \omega \text d A\cos\theta}
\]</span></p>
<p><img src="/.io//image-20230119164455940.png" alt="image-20230119164455940" style="zoom:67%;"></p>
<p><img src="/.io//image-20230119164653064.png" alt="image-20230119164653064" style="zoom:67%;"></p>
<p>Radiance(辐亮度)是在每单位立体角和单位投影面积上，表面接受/反射/发射的能量. 单位是尼特(nit).</p>
<p><img src="/.io//image-20230119165724982.png" alt="image-20230119165724982" style="zoom:67%;"></p>
<p><img src="/.io//image-20230119170732140.png" alt="image-20230119170732140" style="zoom:67%;"></p>
<p><img src="/.io//image-20230119170741047.png" alt="image-20230119170741047" style="zoom:67%;"></p>
<p><img src="/.io//image-20230119170751306.png" alt="image-20230119170751306" style="zoom:67%;"></p>
<h3 id="brdfbidirectional-reflectance-distribution-function">BRDF(Bidirectional Reflectance Distribution Function)</h3>
<p><img src="/.io//image-20230126134706238.png" alt="image-20230126134706238" style="zoom:67%;"></p>
<p><img src="/.io//image-20230126134715824.png" alt="image-20230126134715824" style="zoom:67%;"></p>
<p><img src="/.io//image-20230201081746064.png" alt="image-20230201081746064" style="zoom:80%;"></p>
<p><img src="/.io//image-20230201083352297.png" alt="image-20230201083352297" style="zoom:80%;"></p>
<h3 id="渲染方程">渲染方程</h3>
<figure>
<img src="/.io//image-20230201083709425.png" alt="image-20230201083709425"><figcaption aria-hidden="true">image-20230201083709425</figcaption>
</figure>
<p>其中<span class="math inline">\(\Omega ^ +\)</span>和<span class="math inline">\(H^2\)</span>都表示半球. 下半球的贡献为0, 不作计算. <span class="math inline">\(L_e\)</span>为物体的自发光.</p>
<figure>
<img src="/.io//image-20230201084514147.png" alt="image-20230201084514147"><figcaption aria-hidden="true">image-20230201084514147</figcaption>
</figure>
<figure>
<img src="/.io//image-20230201084542706.png" alt="image-20230201084542706"><figcaption aria-hidden="true">image-20230201084542706</figcaption>
</figure>
<figure>
<img src="/.io//image-20230201084559031.png" alt="image-20230201084559031"><figcaption aria-hidden="true">image-20230201084559031</figcaption>
</figure>
<figure>
<img src="/.io//image-20230201084817636.png" alt="image-20230201084817636"><figcaption aria-hidden="true">image-20230201084817636</figcaption>
</figure>
<figure>
<img src="/.io//image-20230201085404576.png" alt="image-20230201085404576"><figcaption aria-hidden="true">image-20230201085404576</figcaption>
</figure>
<figure>
<img src="/.io//image-20230201085409915.png" alt="image-20230201085409915"><figcaption aria-hidden="true">image-20230201085409915</figcaption>
</figure>
<figure>
<img src="/.io//image-20230201085821416.png" alt="image-20230201085821416"><figcaption aria-hidden="true">image-20230201085821416</figcaption>
</figure>
<h3 id="蒙特卡罗积分monte-carlo-integration">蒙特卡罗积分(Monte Carlo Integration)</h3>
<p><img src="/.io//image-20230203091155356.png" alt="image-20230203091155356" style="zoom:67%;"></p>
<p>均匀分布的情况下:</p>
<p><img src="/.io//image-20230203091631419.png" alt="image-20230203091631419" style="zoom:67%;"></p>
<p><img src="/.io//image-20230203091640676.png" alt="image-20230203091640676" style="zoom:67%;"></p>
<h2 id="路径追踪path-tracing">路径追踪(Path Tracing)</h2>
<p><img src="/.io//image-20230203095135065.png" alt="image-20230203095135065" style="zoom:67%;"></p>
<p><img src="/.io//image-20230203095152862.png" alt="image-20230203095152862" style="zoom:67%;"></p>
<p><img src="/.io//image-20230203095329690.png" alt="image-20230203095329690" style="zoom:80%;"></p>
<p>根据上面的公式，可以写出如下伪代码:</p>
<p><img src="/.io//image-20230203100854467.png" alt="image-20230203100854467" style="zoom:67%;"></p>
<p>但是这个做法有很大问题: 这个算法是递归的, 同时对于每根打到物体上的光线都需要重新做一次shade, 假设每次shade有<span class="math inline">\(n\)</span>条光线, 一共反射了<span class="math inline">\(k\)</span>次, 总光线数将是<span class="math inline">\(O(n^k)\)</span>级别. 要避免指数爆炸, 必须有<span class="math inline">\(n = 1\)</span>:</p>
<p><img src="/.io//image-20230203101046378.png" alt="image-20230203101046378" style="zoom:67%;"></p>
<p><span class="math inline">\(n = 1\)</span>又带来了另一个问题: 在蒙特卡洛方法里, 采样越少噪声越大. 路径追踪中只采样一次, 会产生十分巨大的噪声. 为此我们需要对一个像素做多次路径追踪并取均值.</p>
<p><img src="/.io//image-20230203101623438.png" alt="image-20230203101623438" style="zoom:67%;"></p>
<p>现在光线数量指数爆炸的问题解决了. 但这是一个递归算法, 我们还缺少一个终止条件. 如果简单地设置一个递归深度, 会导致能量损失, 我们需要一种更合理的解决方法, 设一个概率, 每条光线在继续采样时有概率终止:</p>
<p><img src="/.io//image-20230203101956422.png" alt="image-20230203101956422" style="zoom:67%;"></p>
<p><img src="/.io//image-20230203102510766.png" alt="image-20230203102510766" style="zoom:67%;"></p>
<p><img src="/.io//image-20230203103151011.png" alt="image-20230203103151011" style="zoom:67%;"></p>
<p>至此, 路径追踪的正确算法已经得出, 下面的内容是性能优化.</p>
<p><img src="/.io//image-20230203103629972.png" alt="image-20230203103629972" style="zoom:67%;"></p>
<p><img src="/.io//image-20230203103642748.png" alt="image-20230203103642748" style="zoom:67%;"></p>
<p>为了避免浪费，我们改为对光源采样. 为此我们需要得到<span class="math inline">\(\text d \omega\)</span>(立体角, 对像素点对应的半球采样)和<span class="math inline">\(\text d A\)</span>(面积, 对光源采样)之间的关系:</p>
<p><img src="/.io//image-20230206143614599.png" alt="image-20230206143614599" style="zoom:67%;"></p>
<p><img src="/.io//image-20230206143843085.png" alt="image-20230206143843085" style="zoom:67%;"></p>
<p>这样便可以重写渲染方程:</p>
<p><img src="/.io//image-20230206144106059.png" alt="image-20230206144106059" style="zoom:67%;"></p>
<p><img src="/.io//image-20230206144231758.png" alt="image-20230206144231758" style="zoom:67%;"></p>
<p><img src="/.io//image-20230206144359534.png" alt="image-20230206144359534" style="zoom:67%;"></p>
<p><img src="/.io//image-20230206144757574.png" alt="image-20230206144757574" style="zoom:67%;"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LinkinPony</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
